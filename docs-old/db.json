{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"src/images/components.png","path":"images/components.png","modified":0,"renderable":0},{"_id":"src/images/data.png","path":"images/data.png","modified":0,"renderable":0},{"_id":"src/images/devtools-storage-chrome.png","path":"images/devtools-storage-chrome.png","modified":0,"renderable":0},{"_id":"src/images/devtools-storage-edge.png","path":"images/devtools-storage-edge.png","modified":0,"renderable":0},{"_id":"src/images/dom-tree.png","path":"images/dom-tree.png","modified":0,"renderable":0},{"_id":"src/images/hn-architecture.png","path":"images/hn-architecture.png","modified":0,"renderable":0},{"_id":"src/images/hn.png","path":"images/hn.png","modified":0,"renderable":0},{"_id":"src/images/lifecycle.png","path":"images/lifecycle.png","modified":0,"renderable":0},{"_id":"src/images/logged-proxied-data.png","path":"images/logged-proxied-data.png","modified":0,"renderable":0},{"_id":"src/images/mvvm.png","path":"images/mvvm.png","modified":0,"renderable":0},{"_id":"src/images/props-events.png","path":"images/props-events.png","modified":0,"renderable":0},{"_id":"src/images/search-by-algolia.png","path":"images/search-by-algolia.png","modified":0,"renderable":0},{"_id":"src/images/state.png","path":"images/state.png","modified":0,"renderable":0},{"_id":"src/images/transition.png","path":"images/transition.png","modified":0,"renderable":0},{"_id":"src/images/typescript-type-error.png","path":"images/typescript-type-error.png","modified":0,"renderable":0},{"_id":"src/images/vue-component-with-preprocessors.png","path":"images/vue-component-with-preprocessors.png","modified":0,"renderable":0},{"_id":"src/images/vue-component.png","path":"images/vue-component.png","modified":0,"renderable":0},{"_id":"themes/vue/source/browserconfig.xml","path":"browserconfig.xml","modified":0,"renderable":1},{"_id":"themes/vue/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/vue/source/index.html","path":"index.html","modified":0,"renderable":1},{"_id":"themes/vue/source/manifest.json","path":"manifest.json","modified":0,"renderable":1},{"_id":"src/images/devtools-storage.png","path":"images/devtools-storage.png","modified":0,"renderable":0},{"_id":"themes/vue/source/compiled/Human.svg","path":"compiled/Human.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/compiled/favicon.ico","path":"compiled/favicon.ico","modified":0,"renderable":1},{"_id":"themes/vue/source/compiled/index.html","path":"compiled/index.html","modified":0,"renderable":1},{"_id":"themes/vue/source/css/app.css","path":"css/app.css","modified":0,"renderable":1},{"_id":"themes/vue/source/css/benchmark.styl","path":"css/benchmark.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/page.styl","path":"css/page.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/search.styl","path":"css/search.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/images/Monterail.png","path":"images/Monterail.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/aaha.png","path":"images/aaha.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/alligator_io.svg","path":"images/alligator_io.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/autocode.svg","path":"images/autocode.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/bestvpn_co.png","path":"images/bestvpn_co.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/bit.png","path":"images/bit.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/blokt_cryptocurrency_news.png","path":"images/blokt_cryptocurrency_news.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/chaitin.png","path":"images/chaitin.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/check.png","path":"images/check.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/cloudstudio.png","path":"images/cloudstudio.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coding.png","path":"images/coding.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-bch.png","path":"images/coin-bch.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-btc.png","path":"images/coin-btc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-eth.png","path":"images/coin-eth.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/coin-ltc.png","path":"images/coin-ltc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/daily.png","path":"images/daily.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/dcloud.gif","path":"images/dcloud.gif","modified":0,"renderable":1},{"_id":"themes/vue/source/images/derek_pollard.png","path":"images/derek_pollard.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/devexpress.png","path":"images/devexpress.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/devsquad.png","path":"images/devsquad.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/dopamine.png","path":"images/dopamine.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/down.png","path":"images/down.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/earthlink.png","path":"images/earthlink.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/energy_comparison.png","path":"images/energy_comparison.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/fastcoding_inc.png","path":"images/fastcoding_inc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/fastcoding_inc.svg","path":"images/fastcoding_inc.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/feed.png","path":"images/feed.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/firestick_tricks.png","path":"images/firestick_tricks.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/flatlogic_templates.svg","path":"images/flatlogic_templates.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/foo.png","path":"images/foo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/frontend_love.png","path":"images/frontend_love.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/frontendlove.png","path":"images/frontendlove.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/gitee.png","path":"images/gitee.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/gridsome.png","path":"images/gridsome.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/happy_programmer_llc.png","path":"images/happy_programmer_llc.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/html_burger.png","path":"images/html_burger.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons.png","path":"images/icons.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons_8.png","path":"images/icons_8.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/inkoop.png","path":"images/inkoop.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/intygrate.png","path":"images/intygrate.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/isle_of_code.png","path":"images/isle_of_code.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/isolutions_uk_limited.png","path":"images/isolutions_uk_limited.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/jqwidgets_.png","path":"images/jqwidgets_.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/jqwidgets_ltd.png","path":"images/jqwidgets_ltd.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/laravel.png","path":"images/laravel.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/marcus_hiles.png","path":"images/marcus_hiles.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/menu-blm.png","path":"images/menu-blm.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/menu.png","path":"images/menu.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/modus.png","path":"images/modus.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/moovweb.png","path":"images/moovweb.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/nativescript.png","path":"images/nativescript.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/neds.png","path":"images/neds.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/netflix_vpn.png","path":"images/netflix_vpn.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/okay.png","path":"images/okay.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/onsen_ui.png","path":"images/onsen_ui.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/opteo.png","path":"images/opteo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/passionate_people.png","path":"images/passionate_people.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/patreon.png","path":"images/patreon.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/paypal.png","path":"images/paypal.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/philip_john_basile.gif","path":"images/philip_john_basile.gif","modified":0,"renderable":1},{"_id":"themes/vue/source/images/piratebay_proxy.png","path":"images/piratebay_proxy.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/piratebayproxy.png","path":"images/piratebayproxy.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/primevue.png","path":"images/primevue.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/programmers_io.png","path":"images/programmers_io.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/pullrequest.svg","path":"images/pullrequest.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/retool.png","path":"images/retool.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/roadster.png","path":"images/roadster.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/search.png","path":"images/search.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/shopware_ag.png","path":"images/shopware_ag.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/shopware_ag.svg","path":"images/shopware_ag.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/staff_augmentation.png","path":"images/staff_augmentation.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/stdlib.png","path":"images/stdlib.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/storekit.png","path":"images/storekit.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/syncfusion.png","path":"images/syncfusion.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tee__.png","path":"images/tee__.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tendermint.png","path":"images/tendermint.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tidelift.png","path":"images/tidelift.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tighten_co.png","path":"images/tighten_co.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/tooltwist.png","path":"images/tooltwist.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/unicorn_io.png","path":"images/unicorn_io.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/valuecoders.png","path":"images/valuecoders.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vehikl.png","path":"images/vehikl.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vpn_review.png","path":"images/vpn_review.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vpnranks.png","path":"images/vpnranks.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vuejobs.png","path":"images/vuejobs.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vuemastery.png","path":"images/vuemastery.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vueschool.png","path":"images/vueschool.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vuetify.png","path":"images/vuetify.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vuetraining_net__note__since_i_m_not_sure_where_else_to_put_it____this_is_replacing_vuescreencasts___they_re_both_run_by_me__i_m_just_switching_where_i_want_my_sponsorship_to_point_.png","path":"images/vuetraining_net__note__since_i_m_not_sure_where_else_to_put_it____this_is_replacing_vuescreencasts___they_re_both_run_by_me__i_m_just_switching_where_i_want_my_sponsorship_to_point_.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/watchcartoononline.png","path":"images/watchcartoononline.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/webdock.png","path":"images/webdock.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/wilderminds.png","path":"images/wilderminds.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/x_team.png","path":"images/x_team.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/y8.png","path":"images/y8.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/yakaz.png","path":"images/yakaz.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/css.escape.js","path":"js/css.escape.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/smooth-scroll.min.js","path":"js/smooth-scroll.min.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/theme-data.js","path":"js/theme-data.js","modified":0,"renderable":1},{"_id":"src/images/memory-leak-example.png","path":"images/memory-leak-example.png","modified":0,"renderable":0},{"_id":"src/images/oxford-comma.jpg","path":"images/oxford-comma.jpg","modified":0,"renderable":0},{"_id":"themes/vue/source/images/accelebrate.png","path":"images/accelebrate.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/bacancy_technology.png","path":"images/bacancy_technology.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/storyblok.png","path":"images/storyblok.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/usave.png","path":"images/usave.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/webucator.png","path":"images/webucator.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/vue.min.js","path":"js/vue.min.js","modified":0,"renderable":1},{"_id":"themes/vue/source/compiled/img/Human.svg","path":"compiled/img/Human.svg","modified":0,"renderable":1},{"_id":"themes/vue/source/compiled/img/logo.png","path":"compiled/img/logo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-144x144.png","path":"images/icons/android-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-192x192.png","path":"images/icons/android-icon-192x192.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-36x36.png","path":"images/icons/android-icon-36x36.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-48x48.png","path":"images/icons/android-icon-48x48.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-72x72.png","path":"images/icons/android-icon-72x72.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-96x96.png","path":"images/icons/android-icon-96x96.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-114x114.png","path":"images/icons/apple-icon-114x114.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-120x120.png","path":"images/icons/apple-icon-120x120.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-144x144.png","path":"images/icons/apple-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-152x152.png","path":"images/icons/apple-icon-152x152.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-180x180.png","path":"images/icons/apple-icon-180x180.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-57x57.png","path":"images/icons/apple-icon-57x57.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-60x60.png","path":"images/icons/apple-icon-60x60.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-72x72.png","path":"images/icons/apple-icon-72x72.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-76x76.png","path":"images/icons/apple-icon-76x76.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-precomposed.png","path":"images/icons/apple-icon-precomposed.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon.png","path":"images/icons/apple-icon.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-96x96.png","path":"images/icons/favicon-96x96.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon.ico","path":"images/icons/favicon.ico","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-144x144.png","path":"images/icons/ms-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-150x150.png","path":"images/icons/ms-icon-150x150.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-310x310.png","path":"images/icons/ms-icon-310x310.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-70x70.png","path":"images/icons/ms-icon-70x70.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/writers_per_hour.jpg","path":"images/writers_per_hour.jpg","modified":0,"renderable":1},{"_id":"themes/vue/source/images/special-sponsor-spot.png","path":"images/special-sponsor-spot.png","modified":0,"renderable":1},{"_id":"src/images/devtools-timetravel.gif","path":"images/devtools-timetravel.gif","modified":0,"renderable":0},{"_id":"themes/vue/source/images/icons/bacancy_technology.png","path":"images/icons/bacancy_technology.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/vue.js","path":"js/vue.js","modified":0,"renderable":1},{"_id":"src/images/breakpoint_set.png","path":"images/breakpoint_set.png","modified":0,"renderable":0},{"_id":"src/images/config_add.png","path":"images/config_add.png","modified":0,"renderable":0},{"_id":"src/images/breakpoint_hit.png","path":"images/breakpoint_hit.png","modified":0,"renderable":0},{"_id":"themes/vue/source/compiled/js/app.js","path":"compiled/js/app.js","modified":0,"renderable":1},{"_id":"themes/vue/source/compiled/js/chunk-vendors.js","path":"compiled/js/chunk-vendors.js","modified":0,"renderable":1}],"Cache":[{"_id":"src/.DS_Store","hash":"7bba9151cf6ef60afeccd3f870ce438485f5b11d","modified":1601301125714},{"_id":"src/index.md","hash":"fd945de1e31344f0d8be59bcc87e3f5fda468e11","modified":1601078141095},{"_id":"themes/vue/.DS_Store","hash":"1f6450c8473595ac2d5104757d9753c04da9ca97","modified":1601301116395},{"_id":"themes/vue/_config.yml","hash":"a53f8f3af09462a9100313113e6115f476491434","modified":1601215072242},{"_id":"src/_posts/011-component.md","hash":"dc6bea9c00bb7e7c8b5009026e2ac78986c50312","modified":1601078141064},{"_id":"src/_posts/012-release.md","hash":"fa3d912b80c623e665eddc689d39f5feacc4f18c","modified":1601078141065},{"_id":"src/_posts/1.0.0-release.md","hash":"f530bc04b8a0635fdbc8f2659fb1129cf02c233b","modified":1601078141065},{"_id":"src/_posts/announcing-2.0.md","hash":"289e35fd375f2bb058acc157e77b2367b1bc4265","modified":1601078141065},{"_id":"src/_posts/common-gotchas.md","hash":"e410fbfb6717dfe4e090d983825f95408ba3071b","modified":1601078141065},{"_id":"src/_posts/march-update.md","hash":"35317ee656c5ff190db107fdb48f57c3761c0bb8","modified":1601078141066},{"_id":"src/_posts/vue-011-release.md","hash":"2be60f8115795ffb2047b6a2d4e18fe2477cd517","modified":1601078141066},{"_id":"src/_posts/vue-cli.md","hash":"20c913472a116c717f0a9d3d8fd174764fd5b417","modified":1601078141066},{"_id":"src/_posts/vue-next.md","hash":"a0ac9a662aece66b050544ac9467673811083a35","modified":1601078141066},{"_id":"src/_posts/why-no-template-url.md","hash":"b62a1f01eaa924cf3aa3d1bd5f7e721604fe8cca","modified":1601078141067},{"_id":"src/_posts/vuejs-010-release.md","hash":"d89462ea33e99c8869a7d1445a2c7a26c95146bb","modified":1601078141067},{"_id":"src/images/components.png","hash":"2f4056d9c0448a3204386ddefd84025ea8a58967","modified":1601078141075},{"_id":"src/images/data.png","hash":"7071337f9071f93ebf85639ede38b0f40fd75d98","modified":1601078141079},{"_id":"src/images/devtools-storage-chrome.png","hash":"4c6defcd7f965e743c5a9d9242766e67b7a79a38","modified":1601078141080},{"_id":"src/images/devtools-storage-edge.png","hash":"4550f8c408787ed427c5f6b07530533690be1a3c","modified":1601078141080},{"_id":"src/images/dom-tree.png","hash":"820025017bfcf319d411f6eb2a6f07d543132028","modified":1601078141085},{"_id":"src/images/hn-architecture.png","hash":"0b4adafb587478119e1fb5808f8f04481268a3ce","modified":1601078141085},{"_id":"src/images/hn.png","hash":"d0a6b7b011d305d62504cae3bbce54d111783e82","modified":1601078141086},{"_id":"src/images/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1601078141087},{"_id":"src/images/logged-proxied-data.png","hash":"0e875c2ded04180d9fc73785fbc91351b8159648","modified":1601078141087},{"_id":"src/images/mvvm.png","hash":"b83d7f54d5f2df09a662a7057cd521d23b67e451","modified":1601078141090},{"_id":"src/images/props-events.png","hash":"0f0328ec572bda3f864bb65eea5dbbf32b59504c","modified":1601078141092},{"_id":"src/images/search-by-algolia.png","hash":"b580b0eb3965b62ce9bb1bab1ed0577448f73075","modified":1601078141092},{"_id":"src/images/state.png","hash":"8d8033027c49fee1f795cdca0736c4315efc54fa","modified":1601078141093},{"_id":"src/images/transition.png","hash":"918faae8f4e8e8d0b02c7516ba3c9931b9161487","modified":1601078141093},{"_id":"src/images/typescript-type-error.png","hash":"f282f85d3fe94a7ebd2f741efad3d55a5469dcc5","modified":1601078141094},{"_id":"src/images/vue-component-with-preprocessors.png","hash":"daed0210c92685fd128bd5e8b9338700619b2442","modified":1601078141094},{"_id":"src/images/vue-component.png","hash":"a9155a78d17b79c5f8e28f4ccf48864fcf172efb","modified":1601078141095},{"_id":"src/coc/index.md","hash":"dd6cb88296917f08b0ee3694c5af244139317b62","modified":1601078141067},{"_id":"src/menu/index.md","hash":"189f0685b3420069e60d21599ace0e653ed99ecb","modified":1601078141095},{"_id":"src/resources/partners.md","hash":"22b131c77a3db61d066bb0066c56e7729eb780c2","modified":1601078141096},{"_id":"src/resources/themes.md","hash":"6218de9c9a80620f044a2f4583f52b55c5bd2438","modified":1601078141096},{"_id":"src/support-vuejs/index.md","hash":"6348a4b94c23a55e433d78c2283e9e5f6b16ea3e","modified":1601078141096},{"_id":"themes/vue/layout/.DS_Store","hash":"196dc8707f11c689a9ce41aedb9c659b940fa274","modified":1601048519202},{"_id":"themes/vue/layout/index.ejs","hash":"84f9f2426502fe92f40070104e72193cdc701674","modified":1601215040100},{"_id":"themes/vue/layout/layout.ejs","hash":"c4f2893e16c62214fc5fe0603b8149e53ca8080c","modified":1601078141144},{"_id":"themes/vue/layout/page.ejs","hash":"5c26b81b8ee7408f73e125378149080625c5cc06","modified":1601078141144},{"_id":"themes/vue/layout/partners-page.ejs","hash":"456b21d664191b007cb329c100c00e2e060a7334","modified":1601078141147},{"_id":"themes/vue/layout/post.ejs","hash":"c14db1616a9c9e3023e2b4dfb97a031a196e9475","modified":1601078141148},{"_id":"themes/vue/layout/search-page.ejs","hash":"fa2c6e6dd39a5b57c0a79e2d7860a71beb340fbf","modified":1601078141148},{"_id":"themes/vue/layout/sponsors-page.ejs","hash":"62997b7fd20229eb4a4d60725ff4818b70df5e50","modified":1601078141148},{"_id":"themes/vue/source/.DS_Store","hash":"d24d5d135f550a347ab3799501b7e639f81433ee","modified":1601052006965},{"_id":"themes/vue/source/browserconfig.xml","hash":"115f1a6d4b6a6ca0661f12b3d9a6123f213d78b7","modified":1601078141148},{"_id":"themes/vue/source/favicon.ico","hash":"c0605efed936ee2600284e6480521d06fa64f872","modified":1601078141162},{"_id":"themes/vue/source/index.html","hash":"5d959c9504566a86103719c3dc806e3427ef837e","modified":1601078141207},{"_id":"themes/vue/source/manifest.json","hash":"5918737209c849e5275b870ae4ff0c62350a7d74","modified":1601078141211},{"_id":"src/images/devtools-storage.png","hash":"edc4425d005028a30d2f2ae66183ecb65f0d988f","modified":1601078141082},{"_id":"src/v2/cookbook/adding-instance-properties.md","hash":"5cdfeec3f5df67b56953feacb2d971e91fefbabd","modified":1601078141104},{"_id":"src/v2/cookbook/avoiding-memory-leaks.md","hash":"2b8a6bf914493fb12691b3e2ecd669c5b161f96a","modified":1601078141104},{"_id":"src/v2/cookbook/client-side-storage.md","hash":"3549b3da4250f98ce26191b1ad6eca089c723ce5","modified":1601078141105},{"_id":"src/v2/cookbook/creating-custom-scroll-directives.md","hash":"ae07e9643a031c53a643de2fcda9e9b71b031f89","modified":1601078141105},{"_id":"src/v2/cookbook/debugging-in-vscode.md","hash":"43e0e619c923a84f963e93d17e3b34f76587bd05","modified":1601078141105},{"_id":"src/v2/cookbook/dockerize-vuejs-app.md","hash":"3b9e241236048d4c95083d13d4081efe460867e2","modified":1601078141105},{"_id":"src/v2/cookbook/editable-svg-icons.md","hash":"1ab5744519da3257e736c847147f2c97ad43d992","modified":1601078141106},{"_id":"src/v2/cookbook/form-validation.md","hash":"d015ccaf520e379d0706cdac7a8f605237a461f7","modified":1601078141106},{"_id":"src/v2/cookbook/index.md","hash":"f4b48d457ae36bfde3d08c2ddece666f46ec2239","modified":1601078141107},{"_id":"src/v2/cookbook/packaging-sfc-for-npm.md","hash":"2f686d219d730d0195102886d74e31b4e47b088f","modified":1601078141107},{"_id":"src/v2/cookbook/practical-use-of-scoped-slots.md","hash":"923b6b0debb9d75cbd3cb9a2359317620624c3f2","modified":1601078141107},{"_id":"src/v2/cookbook/serverless-blog.md","hash":"737f66577fd06638ba9202b2fcd2ffd6b2e003e3","modified":1601078141108},{"_id":"src/v2/cookbook/unit-testing-vue-components.md","hash":"63b1ac2c7ce11fb6ff8e5ccb1a4d4ca32d7be1db","modified":1601078141108},{"_id":"src/v2/cookbook/using-axios-to-consume-apis.md","hash":"105be93b008a7a4609c02d30c4c07b52e82636a2","modified":1601078141108},{"_id":"src/v2/bytepath/Tween Class.md","hash":"ee7afddee7c0884dac40fa1dc390fd91dd73ff1e","modified":1601293177022},{"_id":"src/v2/bytepath/animationreuse.md","hash":"6fa34578d755ab95dffd11fec32316ecf77a0d46","modified":1601293611516},{"_id":"src/v2/bytepath/assetcomposition.md","hash":"d6bbe47c2546dac66ffb81e41227c093c522a329","modified":1601214209068},{"_id":"src/v2/bytepath/assetreuse.md","hash":"b976e34a40382644d01c8a497cc1b4e3321ef5f3","modified":1601214390968},{"_id":"src/v2/bytepath/basicanimations.md","hash":"c7a64ee5ba3c121be30eba48bb9e519c1397bc0d","modified":1601213316780},{"_id":"src/v2/bytepath/basictransformations.md","hash":"70bf01c28f37f348dd3c9db31709f3040f39954e","modified":1601211202315},{"_id":"src/v2/bytepath/cameracontrol.md","hash":"a86b0d8cd7823288deb35f7928984505788c33c5","modified":1601214523898},{"_id":"src/v2/bytepath/domtransformations.md","hash":"93a304c033b51271870023b6a1f7219e1387e36a","modified":1601213685618},{"_id":"src/v2/bytepath/fastforwardandrewind.md","hash":"58b9cf77f87050512e144fac6ca4930070c58b65","modified":1601293401965},{"_id":"src/v2/bytepath/homeless.md","hash":"98ba3b930357fb6487abafa27a58b0cd8b3a65fb","modified":1601211259727},{"_id":"src/v2/bytepath/importingassets.md","hash":"9cd939820ed3dc702bfee921e02a1c3b3e96eff2","modified":1601293611513},{"_id":"src/v2/bytepath/index.md","hash":"28f727f1274e567a1b5fa74206442f289763923c","modified":1601078141101},{"_id":"src/v2/bytepath/introduction.md","hash":"398db9686a0404dd0c2512e279dd2a877dad7408","modified":1601210593655},{"_id":"src/v2/bytepath/keyboardinput.md","hash":"12db284ea4fcc17439ebf9602089f05afa8f1836","modified":1601214467414},{"_id":"src/v2/bytepath/keyframeanimations.md","hash":"d4e93505842669ae40511b8975173e6c7369a7ca","modified":1601293381600},{"_id":"src/v2/bytepath/matrixprop.md","hash":"7b992cbe0b0bf8f9e5db63f503b4d9a966cd33bb","modified":1601211496334},{"_id":"src/v2/bytepath/mouseinput.md","hash":"e3f892f615a01ca9d47afb3587ede76f9e9d7d5f","modified":1601214462091},{"_id":"src/v2/bytepath/positionclass.md","hash":"a0b5a7eb6df6952c5289dfb26033a7b05b4b6b86","modified":1601211447770},{"_id":"src/v2/bytepath/renderlessanimations.md","hash":"3d5fcd03b17bd3e08234febbb65886db9ebe14af","modified":1601213976310},{"_id":"src/v2/bytepath/sampleassets.md","hash":"3f1d3b78d3548828d86965856270a84ea7005abc","modified":1601211478137},{"_id":"src/v2/bytepath/transformationmutators.md","hash":"da20360596e546bf5257c572c310130889d4fbce","modified":1601211632371},{"_id":"src/v2/examples/commits.md","hash":"4a55618622da6212d16608487f05108539b41da9","modified":1601078141108},{"_id":"src/v2/examples/deepstream.md","hash":"1a4a8da5179a36150ee96c73e9e63b366b2bac64","modified":1601078141109},{"_id":"src/v2/examples/elastic-header.md","hash":"a68433cc37d4845553f78fd941910e319f22d8a5","modified":1601078141109},{"_id":"src/v2/examples/firebase.md","hash":"4ef7aa1073141f9dafab0461f0ec23da8e1b7298","modified":1601078141109},{"_id":"src/v2/examples/grid-component.md","hash":"f0fe767121105a376a0f1b0e47a8820778f3b3a0","modified":1601078141109},{"_id":"src/v2/examples/hackernews.md","hash":"361b243ad94dc95d3d94fbb3993ef58d4c65c7aa","modified":1601078141109},{"_id":"src/v2/examples/index.md","hash":"c2fd88ad978dc7afe53593521afd74f7ccf2f5fc","modified":1601078141110},{"_id":"src/v2/examples/modal.md","hash":"7fdcc0b05f38bb68617b67e2d963e3109bb0ce92","modified":1601078141110},{"_id":"src/v2/examples/select2.md","hash":"ff8018f0237b9efee7d082c9bb7243c6f7e2e608","modified":1601078141110},{"_id":"src/v2/examples/svg.md","hash":"954fbdd0aa2ea437ad711f1876bba25a1b2d7c5e","modified":1601078141110},{"_id":"src/v2/examples/todomvc.md","hash":"61466bbe6be6c7fd579abb90f950e191d1b6da7e","modified":1601078141110},{"_id":"src/v2/examples/tree-view.md","hash":"15e5c47a71815e7eaf8ef093fbb9fbf69180ae0d","modified":1601078141111},{"_id":"src/v2/search/index.md","hash":"7f76b8a040366f4d8e4b23d06d5e021fc45ce5c2","modified":1601078141141},{"_id":"src/v2/guide/class-and-style.md","hash":"38e7883029f6928cb110b8c6e3a005598b8b9030","modified":1601078141133},{"_id":"src/v2/guide/components-custom-events.md","hash":"98e8ef750b749f6efff19f14f19d76c38b593971","modified":1601078141133},{"_id":"src/v2/guide/components-dynamic-async.md","hash":"f1aeb54949959c5dc50fce7704574ef485c66a44","modified":1601078141133},{"_id":"src/v2/guide/components-edge-cases.md","hash":"a0f84e7e5745f3a567bdedb76fa1f1afc95e6e83","modified":1601078141134},{"_id":"src/v2/guide/components-props.md","hash":"66d7d503022b3debd23e546fbab83d70b571fd59","modified":1601078141134},{"_id":"src/v2/guide/components-registration.md","hash":"a00b220c7df6c7ebd5974e8bc931d95d76af1a18","modified":1601078141134},{"_id":"src/v2/guide/components-slots.md","hash":"f3b187264aaa98bc688167617bd5305c9da889a8","modified":1601078141135},{"_id":"src/v2/guide/components.md","hash":"0e99b9ad856d276862c3cd0a6a92e8b24fdfc970","modified":1601078141135},{"_id":"src/v2/guide/computed.md","hash":"8747c78361e0e07cfb84db0be3f012f2e7c4e97a","modified":1601078141135},{"_id":"src/v2/guide/conditional.md","hash":"238e0e5ea8e755555c9ed1fd9ffd55bac5c7b2ef","modified":1601078141135},{"_id":"src/v2/guide/custom-directive.md","hash":"48f7c3e06a08c2fd3a582c7cd10dcbbb0e06b1ae","modified":1601078141136},{"_id":"src/v2/guide/deployment.md","hash":"2283dcf0cbc53a54f6c02871c6697e1c708ff5a7","modified":1601078141136},{"_id":"src/v2/guide/events.md","hash":"0c07484ecd8277a4e974c75a3fc5440be825572b","modified":1601078141136},{"_id":"src/v2/guide/filters.md","hash":"5ad769672918c4b2bf7af27fcfa9960212d9a8f3","modified":1601078141137},{"_id":"src/v2/guide/forms.md","hash":"24259da607063f3e671c71d51fea14745a896eb9","modified":1601078141137},{"_id":"src/v2/guide/index.md","hash":"aebb7adac61419f77fdf8b6cc6186ea90cdf7cd9","modified":1601078141137},{"_id":"src/v2/guide/installation.md","hash":"5e8626ba56f5d92efd538f29c7002d55d2a9c19a","modified":1601215072539},{"_id":"src/v2/guide/instance.md","hash":"ac2c8f066f09fc9756d42a8515040441d5b12335","modified":1601078141138},{"_id":"src/v2/guide/join.md","hash":"df465d3619849dcd02ec7343dd93ba7496385fc8","modified":1601078141138},{"_id":"src/v2/guide/list.md","hash":"acddea36fe329ddb980471963f2bc2897664cf29","modified":1601078141138},{"_id":"src/v2/guide/mixins.md","hash":"8eb594c73aa565cf435ef384b5c98802ef3417da","modified":1601078141138},{"_id":"src/v2/guide/plugins.md","hash":"cbf65c29cbb9b5dbe7bff5434d025aba26ab7b8d","modified":1601078141139},{"_id":"src/v2/guide/reactivity.md","hash":"d9dfac364aba5f55b60206f93d66b1772186ca57","modified":1601078141139},{"_id":"src/v2/guide/render-function.md","hash":"ed4f9677e88cc13a56321255a8170da12937a164","modified":1601078141139},{"_id":"src/v2/guide/single-file-components.md","hash":"d154e7438d340cda10000193681756250cdfa5dc","modified":1601078141140},{"_id":"src/v2/guide/state-management.md","hash":"67ca24ca535c8aad13e1bf42f3871071a63f51b2","modified":1601078141140},{"_id":"src/v2/guide/syntax.md","hash":"748b8ea368405a2b03a673d8f986c43f65aeb23a","modified":1601078141140},{"_id":"src/v2/guide/testing.md","hash":"e1debe1732fb375d0d1d2cfc1da13e7a7bf73b68","modified":1601078141140},{"_id":"src/v2/guide/typescript.md","hash":"3c79af37ff9a5834c800c3ca2a77c2f5434e2382","modified":1601078141141},{"_id":"src/v2/style-guide/index.md","hash":"8734711dd2a27beb65bbb43bc4de4db6c043905f","modified":1601078141141},{"_id":"themes/vue/layout/icons/bch.ejs","hash":"d5d3f724738964e5ea4dcb5ca733c5a3ce6268ad","modified":1601078141142},{"_id":"themes/vue/layout/icons/btc.ejs","hash":"fed9b5d4b5e19813dc6dea1e58143d402b8692e0","modified":1601078141142},{"_id":"themes/vue/layout/icons/eth.ejs","hash":"36e176c7e64e56c0e2b5da03d6a297344862b550","modified":1601078141142},{"_id":"themes/vue/layout/icons/github-dark.ejs","hash":"a06780311d7f5ec2f962bd23ff8964befbbcdd93","modified":1601078141142},{"_id":"themes/vue/layout/icons/github.ejs","hash":"188ffb2152598973849360eafeb18d4f907cf32a","modified":1601078141143},{"_id":"themes/vue/layout/icons/ltc.ejs","hash":"6d74d8a03ae0729d84e58c5a776916d7fb217543","modified":1601078141143},{"_id":"themes/vue/layout/icons/medium.ejs","hash":"11850bc444cc7b966bc804930fb7aa9bb4790f8d","modified":1601078141143},{"_id":"themes/vue/layout/icons/play.ejs","hash":"af4cb73bbfdadd794e0fba125fdcd66fc3263f22","modified":1601078141143},{"_id":"themes/vue/layout/icons/twitter.ejs","hash":"4fc8410bd2bc266c81d87399c8b66c5cbae5ce69","modified":1601078141143},{"_id":"themes/vue/layout/partials/ad-text.ejs","hash":"37f6ad840c7f6e2450fc8c53880db7878f53baff","modified":1601078141144},{"_id":"themes/vue/layout/partials/ad.ejs","hash":"76684e3f2709e164b265492bc54aac24c65f848b","modified":1601078141145},{"_id":"themes/vue/layout/partials/conf.ejs","hash":"5c5cd81cb4025c9a8790be69ce0a702aac72f8a4","modified":1601078141145},{"_id":"themes/vue/layout/partials/ecosystem_dropdown.ejs","hash":"adfad32b0a6e7faed653fe2c247dd97a0c359253","modified":1601078141145},{"_id":"themes/vue/layout/partials/header.ejs","hash":"1d56620740db1a46c0e4133991e1eebbbb47699d","modified":1601078141145},{"_id":"themes/vue/layout/partials/language_dropdown.ejs","hash":"26a5ee549c51be6fc7da082a45b6d8ad567b3e23","modified":1601078141145},{"_id":"themes/vue/layout/partials/learn_dropdown.ejs","hash":"c7329eb3f84158bcb54df79f1051bb00de60f86e","modified":1601078141146},{"_id":"themes/vue/layout/partials/main_menu.ejs","hash":"982f161cd0ac06b4bf81c579e19f70fa731da8f5","modified":1601078141146},{"_id":"themes/vue/layout/partials/platinum_sponsors.ejs","hash":"a80ca4c4dd537b27f4d13929023562a09e3be279","modified":1601078141146},{"_id":"themes/vue/layout/partials/resources_dropdown.ejs","hash":"ec85635ecf31fe54aef2d412939238bcd0731ed8","modified":1601078141146},{"_id":"themes/vue/layout/partials/sidebar.ejs","hash":"a6a4962ec0e768935ae4531b5dde0ec3714f623c","modified":1601078141146},{"_id":"themes/vue/layout/partials/sponsors.ejs","hash":"c20f1f00a430a75665bf4d13dd60d6f21181cf82","modified":1601078141147},{"_id":"themes/vue/layout/partials/sponsors_sidebar.ejs","hash":"bfe4519887f122beb9b242fdcff83d382ad7ab6a","modified":1601078141147},{"_id":"themes/vue/layout/partials/support_vue_dropdown.ejs","hash":"12ab9595fadc63de20980c8001dbcebe1ffdbf94","modified":1601078141147},{"_id":"themes/vue/layout/partials/toc.ejs","hash":"525880ba96f31b9600dc3ddc5108403c37744990","modified":1601214314022},{"_id":"themes/vue/source/compiled/Human.svg","hash":"db77c146f4bfb2346b766520a36f21dcbc6c9423","modified":1601148995099},{"_id":"themes/vue/source/compiled/favicon.ico","hash":"c0605efed936ee2600284e6480521d06fa64f872","modified":1601148995099},{"_id":"themes/vue/source/compiled/index.html","hash":"ff9c0e002afa9243a8b0195126652f6188fafe1a","modified":1601148995098},{"_id":"themes/vue/source/css/_ad.styl","hash":"05aeb9ed010a1c5767d9f09a0533385602032033","modified":1601078141156},{"_id":"themes/vue/source/css/_animations.styl","hash":"709eff86f230249ea35a7d6374d21b81e870cb1c","modified":1601078141156},{"_id":"themes/vue/source/css/_api.styl","hash":"d1d041953b75246d6733324ea0073bc5491468b1","modified":1601078141156},{"_id":"themes/vue/source/css/_common.styl","hash":"05351f866f9064e535ddada555ed32c5d7494f58","modified":1601078141156},{"_id":"themes/vue/source/css/_demo.styl","hash":"587c26bdedf0bcbaed841fe4222431439ed7d16e","modified":1601078141157},{"_id":"themes/vue/source/css/_header.styl","hash":"964e057d5cf840c522fbac6766f7ad5df111aa27","modified":1601078141157},{"_id":"themes/vue/source/css/_migration.styl","hash":"6c95c614220e0318913282fe793f84b0e99ab7a6","modified":1601078141157},{"_id":"themes/vue/source/css/_modal.styl","hash":"19f7e22f56ba3852ac765dd0297dee34c0e2e449","modified":1601078141157},{"_id":"themes/vue/source/css/_offline-menu.styl","hash":"bdd13f1a8814197cd629fc433ca8874b5af929ec","modified":1601078141157},{"_id":"themes/vue/source/css/_partners.styl","hash":"4e98cd0683722b1139a100197552107c8c454f52","modified":1601078141158},{"_id":"themes/vue/source/css/_scrimba.styl","hash":"5d0cee1b347bbc5b47e973fb76bf7fa782e087d7","modified":1601078141158},{"_id":"themes/vue/source/css/_search-page.styl","hash":"b836d30b5fa0366ea1308b2e1d8e5fa987e0ccd2","modified":1601078141158},{"_id":"themes/vue/source/css/_settings.styl","hash":"16ed461c4801b606541e9623e7c751e3be2d9edf","modified":1601078141158},{"_id":"themes/vue/source/css/_sidebar.styl","hash":"e52d4e26544e1d7bcd0ded68513fa6c475fec816","modified":1601078141159},{"_id":"themes/vue/source/css/_sponsors-index.styl","hash":"821a79fb1c8ac5e968524ce3fd53bf0b959828f4","modified":1601078141159},{"_id":"themes/vue/source/css/_sponsors-page.styl","hash":"6a4d63b0fd2dac24ca105d15b34d65d4cbc11e34","modified":1601078141159},{"_id":"themes/vue/source/css/_sponsors-sidebar.styl","hash":"713bb877d4ab005d568edcaa4cb7ad0173dd8bb3","modified":1601078141160},{"_id":"themes/vue/source/css/_style-guide.styl","hash":"bdf64ffc2e6c67d2e752953de93c63566cbb483b","modified":1601078141160},{"_id":"themes/vue/source/css/_syntax.styl","hash":"0e7423aab803b9e3f4006cfd28eb668c4fa3a6e4","modified":1601078141160},{"_id":"themes/vue/source/css/_team.styl","hash":"d6e2de47ad3d2bbcc1f11ae4b3f9566378f6a372","modified":1601078141160},{"_id":"themes/vue/source/css/_themes.styl","hash":"7899e87c3c04fd004d81e3c16e13aa38f900db1d","modified":1601078141160},{"_id":"themes/vue/source/css/_vue-mastery.styl","hash":"484c4a000116e51f2c15f74980d48925a8398a31","modified":1601078141161},{"_id":"themes/vue/source/css/app.css","hash":"8cb2749cb6da882651245e22cf5361ca0a6fdc86","modified":1601078141161},{"_id":"themes/vue/source/css/benchmark.styl","hash":"f676e3d142530aef8a4f29a22360f4516047a1ff","modified":1601078141161},{"_id":"themes/vue/source/css/index.styl","hash":"b083727e3c582a9d2e64b4423bb1e658f8cb3126","modified":1601078141161},{"_id":"themes/vue/source/css/page.styl","hash":"5450d7e06ad1c02dfd2108709e6000424f07ead0","modified":1601078141161},{"_id":"themes/vue/source/css/search.styl","hash":"006d48944e9513d569ba68ed054755a5aa42c338","modified":1601078141161},{"_id":"themes/vue/source/images/Monterail.png","hash":"5f347b6677637054908e4599709134f4606285cd","modified":1601078141162},{"_id":"themes/vue/source/images/aaha.png","hash":"081c1d01fd9d611e6270d45d87c15b41fbc1aaed","modified":1601078141162},{"_id":"themes/vue/source/images/alligator_io.svg","hash":"95f65bec674298d1fe49b46768034dbf64b4adbf","modified":1601078141163},{"_id":"themes/vue/source/images/autocode.svg","hash":"191612d16cc8342550747fbc1b2480507855fca3","modified":1601078141163},{"_id":"themes/vue/source/images/bestvpn_co.png","hash":"499990e72cb49b3c53316d376c787ff1c5f17a7f","modified":1601078141165},{"_id":"themes/vue/source/images/bit.png","hash":"c017f11268e43727a12aa40885ea1f18056233b1","modified":1601078141165},{"_id":"themes/vue/source/images/blokt_cryptocurrency_news.png","hash":"fa2ac30a25830e9ef383fdb8c4efc5cc98aaff8f","modified":1601078141166},{"_id":"themes/vue/source/images/chaitin.png","hash":"a61b1ec393b9600d173255fed72fd873a72b8225","modified":1601078141166},{"_id":"themes/vue/source/images/check.png","hash":"b22174f8a966abf7a46eba7991be7a7ae5e16637","modified":1601078141166},{"_id":"themes/vue/source/images/cloudstudio.png","hash":"a0cb4e3d6a3f8f06e0c0416c71427dd01f3af52b","modified":1601078141166},{"_id":"themes/vue/source/images/coding.png","hash":"42d13e784d11c72f8bb40042b2d99761ddbe8559","modified":1601078141167},{"_id":"themes/vue/source/images/coin-bch.png","hash":"783293c8b782e7772e61f62e1168ae175a0a1456","modified":1601078141167},{"_id":"themes/vue/source/images/coin-btc.png","hash":"4dc6d5b671dba33b3e293180ccc9ec2f0b480a6b","modified":1601078141167},{"_id":"themes/vue/source/images/coin-eth.png","hash":"aadb0a7d299f9a2baf2bf2d281f70d1e26e15a48","modified":1601078141168},{"_id":"themes/vue/source/images/coin-ltc.png","hash":"2bf87f92612990bc609dcc8826a344be05166717","modified":1601078141168},{"_id":"themes/vue/source/images/daily.png","hash":"0671abb13bb622f27b85e14eb5341813219c3548","modified":1601078141168},{"_id":"themes/vue/source/images/dcloud.gif","hash":"abb83784b95fdb175e8ffefb2ab6eb17984f6af4","modified":1601078141168},{"_id":"themes/vue/source/images/derek_pollard.png","hash":"a09bcb5d8fe8a712b31591aa2169f751ea7591ba","modified":1601078141168},{"_id":"themes/vue/source/images/devexpress.png","hash":"8b39711fba0756c8407e27de46f2641ac651f30b","modified":1601078141169},{"_id":"themes/vue/source/images/devsquad.png","hash":"f96551ba232f1b005512892334e912b45cc37374","modified":1601078141169},{"_id":"themes/vue/source/images/dopamine.png","hash":"2ea0928227dd6cb44ceeca4ed877feb2be741ff1","modified":1601078141169},{"_id":"themes/vue/source/images/down.png","hash":"6ded74a98bb128e76bfd45cffede2679fd0598f0","modified":1601078141170},{"_id":"themes/vue/source/images/earthlink.png","hash":"b47c30f0093a0e8c48c5d0ae1feff24d6ef64de4","modified":1601078141170},{"_id":"themes/vue/source/images/energy_comparison.png","hash":"eb8657097242bd990585ddae38ad72e8388917ca","modified":1601078141170},{"_id":"themes/vue/source/images/fastcoding_inc.png","hash":"91d2a1c0d7b5eaf71051341a2c3b718bd8770ad1","modified":1601078141170},{"_id":"themes/vue/source/images/fastcoding_inc.svg","hash":"12cfd6800f3b3b37999001eb41f9ff515888bc8c","modified":1601078141171},{"_id":"themes/vue/source/images/feed.png","hash":"eba32c4f87e5ea1f89dce9c68d8603c8f82a8cd9","modified":1601078141171},{"_id":"themes/vue/source/images/firestick_tricks.png","hash":"b43bc723f029191685f77fb573b5c0aadbc2a12d","modified":1601078141171},{"_id":"themes/vue/source/images/flatlogic_templates.svg","hash":"4f69bad6ed18c96049efa438a9d2f333301e11c2","modified":1601078141172},{"_id":"themes/vue/source/images/foo.png","hash":"30b0400c2bc6ed05e056c9b1171878b3510967ef","modified":1601078141172},{"_id":"themes/vue/source/images/frontend_love.png","hash":"ef3695d6a19646599211f886e3a27cd75a374ef6","modified":1601078141172},{"_id":"themes/vue/source/images/frontendlove.png","hash":"ef3695d6a19646599211f886e3a27cd75a374ef6","modified":1601078141173},{"_id":"themes/vue/source/images/gitee.png","hash":"29fbe638ec4e24faad12f345399eac7f426b2772","modified":1601078141173},{"_id":"themes/vue/source/images/gridsome.png","hash":"85adec48d683c206a5ccfaaf2de39c8b12ce09fb","modified":1601078141174},{"_id":"themes/vue/source/images/happy_programmer_llc.png","hash":"bd82c4e12cffa604e3e2d1688b333fba1eaa7113","modified":1601078141174},{"_id":"themes/vue/source/images/html_burger.png","hash":"a6c54ce4ae3ad4b5f1b02a3bb1ca7da838eee8f5","modified":1601078141174},{"_id":"themes/vue/source/images/icons.png","hash":"50aa19eac3a7bf6acb435838b7a890050a4a6d8d","modified":1601078141175},{"_id":"themes/vue/source/images/icons_8.png","hash":"4d44e5b251f72dffe37ac7007042fc0b7beb34fb","modified":1601078141182},{"_id":"themes/vue/source/images/inkoop.png","hash":"fb568c6e466a6c19e5ee40bf92cf2527c58a6db2","modified":1601078141182},{"_id":"themes/vue/source/images/intygrate.png","hash":"f55e418bdf6b1a9fc72fee3d86ec02cc51c6d83b","modified":1601078141182},{"_id":"themes/vue/source/images/isle_of_code.png","hash":"ff273db09eb5ca17d047c73256ee311a9a04d911","modified":1601078141183},{"_id":"themes/vue/source/images/isolutions_uk_limited.png","hash":"067c63b7e2da8667e49f1c63a398094814657742","modified":1601078141183},{"_id":"themes/vue/source/images/jqwidgets_.png","hash":"6ffa378d97190dc88d4d54fa0051c36c6088e03d","modified":1601078141184},{"_id":"themes/vue/source/images/jqwidgets_ltd.png","hash":"eb4da2aec072a3f2a6c3cd322e1a44528f737177","modified":1601078141184},{"_id":"themes/vue/source/images/laravel.png","hash":"010281d898830dbb8c848f6a272ba46ddc95e800","modified":1601078141185},{"_id":"themes/vue/source/images/logo.png","hash":"555257b8c5e7ecf34ce4f9b952eeaf006adfa339","modified":1601078141185},{"_id":"themes/vue/source/images/marcus_hiles.png","hash":"08a36fa5f6bd0156a8b7ccd86ff74baf56776536","modified":1601078141185},{"_id":"themes/vue/source/images/menu-blm.png","hash":"5214de2eac1df19a9b3854c60e99ec43a5945657","modified":1601078141186},{"_id":"themes/vue/source/images/menu.png","hash":"45d62574f2a22017c2aa2001964eaf560f1f70c6","modified":1601078141186},{"_id":"themes/vue/source/images/modus.png","hash":"d4f2c2f7292b26ce11d88d2b08ff299f4e8eb2d4","modified":1601078141186},{"_id":"themes/vue/source/images/moovweb.png","hash":"5f8ec63939c9991eb3deff29a7c69221e07ebf88","modified":1601078141187},{"_id":"themes/vue/source/images/nativescript.png","hash":"ce3751738de68182c1e9ebab7d345227753cc5dc","modified":1601078141187},{"_id":"themes/vue/source/images/neds.png","hash":"675a3f7997063c12a48946219db52948732b71b2","modified":1601078141188},{"_id":"themes/vue/source/images/netflix_vpn.png","hash":"54c1e9c816588a0f9d0b5619d62f953707e77dba","modified":1601078141188},{"_id":"themes/vue/source/images/okay.png","hash":"afc75fb9af3c59c7b2ed5411ab7e90f677935d30","modified":1601078141188},{"_id":"themes/vue/source/images/onsen_ui.png","hash":"0dc98d72d447a8f4d3b8c43cb0890362597de194","modified":1601078141189},{"_id":"themes/vue/source/images/opteo.png","hash":"1915a34af45592878eacc3764dc603a81491f4ae","modified":1601078141189},{"_id":"themes/vue/source/images/passionate_people.png","hash":"c637a4f55fe9d8f469a20796fe159b18fe54b327","modified":1601078141190},{"_id":"themes/vue/source/images/patreon.png","hash":"bb0d0dd23c4058d8be63cdf0ccba1e6a13b05acf","modified":1601078141190},{"_id":"themes/vue/source/images/paypal.png","hash":"b1c3741633ff0c0f8f8a0e80d68202c14a524009","modified":1601078141190},{"_id":"themes/vue/source/images/philip_john_basile.gif","hash":"33e8f13ef9678b8ecaa146fb45acda0057b2e090","modified":1601078141190},{"_id":"themes/vue/source/images/piratebay_proxy.png","hash":"98588ad87fc245df67b26bd5ada2b3b506a61f86","modified":1601078141191},{"_id":"themes/vue/source/images/piratebayproxy.png","hash":"98588ad87fc245df67b26bd5ada2b3b506a61f86","modified":1601078141191},{"_id":"themes/vue/source/images/primevue.png","hash":"636a57faddf5950b8e47319456ae1d7a0f88fd29","modified":1601078141192},{"_id":"themes/vue/source/images/programmers_io.png","hash":"97990feb9b226ad06f55e7dd8e7432d3cf39cc63","modified":1601078141192},{"_id":"themes/vue/source/images/pullrequest.svg","hash":"335566b90d53b7f844c9c41812952042fdf55225","modified":1601078141192},{"_id":"themes/vue/source/images/retool.png","hash":"08c4cbd16f45b2fe1cdc8e095982f07e959a82dc","modified":1601078141192},{"_id":"themes/vue/source/images/roadster.png","hash":"5581867231c0f4059c0ea63f20717886a6e7ac9d","modified":1601078141193},{"_id":"themes/vue/source/images/search.png","hash":"7f519d31bc3c6ca005b6ca5d8ff5ded172df627a","modified":1601078141193},{"_id":"themes/vue/source/images/shopware_ag.png","hash":"c440385ade9c0f9c66104bd1b1b7d41d32c0251a","modified":1601078141193},{"_id":"themes/vue/source/images/shopware_ag.svg","hash":"658c483629cfce8eed7221d1f8463b532abaab02","modified":1601078141193},{"_id":"themes/vue/source/images/staff_augmentation.png","hash":"4d9475570c70eac3c3ada6ee8614b2e4a30f7d80","modified":1601078141196},{"_id":"themes/vue/source/images/stdlib.png","hash":"7adff740e3c1a55e243dff2fb903250d1ba3f559","modified":1601078141196},{"_id":"themes/vue/source/images/storekit.png","hash":"47774422bb1bd1ed985ea3bb2f2ecb7754bb9983","modified":1601078141196},{"_id":"themes/vue/source/images/syncfusion.png","hash":"688285b2ae526c27aaa5cd081a95c881750c59cc","modified":1601078141197},{"_id":"themes/vue/source/images/tee__.png","hash":"e9fc652b1ed66c56be035c1a4607ade5724efc1f","modified":1601078141198},{"_id":"themes/vue/source/images/tendermint.png","hash":"b4c01640076893d035414016b0ee2f90994bd361","modified":1601078141198},{"_id":"themes/vue/source/images/tidelift.png","hash":"63c60abbab4bcc37340f29e0db8290383fb35631","modified":1601078141198},{"_id":"themes/vue/source/images/tighten_co.png","hash":"a0f3f8614ad7f9a4e0eaa0793cf24519b5b25e45","modified":1601078141199},{"_id":"themes/vue/source/images/tooltwist.png","hash":"e625a481e2eb3f7194273d58b250d0fafd42e462","modified":1601078141199},{"_id":"themes/vue/source/images/unicorn_io.png","hash":"c93b60e72d38a6bb313a805d2d276d224fd591e8","modified":1601078141199},{"_id":"themes/vue/source/images/valuecoders.png","hash":"ae72f75eea4e7864c06b7641d0a4d426bdc59f18","modified":1601078141200},{"_id":"themes/vue/source/images/vehikl.png","hash":"e5f045088e79ac5d3aedd2d4efc5b37d15431df0","modified":1601078141201},{"_id":"themes/vue/source/images/vpn_review.png","hash":"8d936036f5272a1d59e148355658290b2b7612c5","modified":1601078141201},{"_id":"themes/vue/source/images/vpnranks.png","hash":"249546e6076846f8fbc7d772a6f51badd20f45af","modified":1601078141201},{"_id":"themes/vue/source/images/vuejobs.png","hash":"149231804a4686f1ec890f7d984207ea83cf8190","modified":1601078141202},{"_id":"themes/vue/source/images/vuemastery.png","hash":"a783b81f0d9ded6e8d46991cc8d18ff878e17656","modified":1601078141202},{"_id":"themes/vue/source/images/vueschool.png","hash":"a4ae5d18c97b8cb5a5d8fcd4c80a6230bf2fc3d9","modified":1601078141202},{"_id":"themes/vue/source/images/vuetify.png","hash":"66254951f82e0639fb588b362f72b80839d9f411","modified":1601078141203},{"_id":"themes/vue/source/images/vuetraining_net__note__since_i_m_not_sure_where_else_to_put_it____this_is_replacing_vuescreencasts___they_re_both_run_by_me__i_m_just_switching_where_i_want_my_sponsorship_to_point_.png","hash":"727650000264f4cce681f796d915efb6577302f5","modified":1601078141203},{"_id":"themes/vue/source/images/watchcartoononline.png","hash":"caacc07c694704a981e6555afe1d94015ceb0505","modified":1601078141204},{"_id":"themes/vue/source/images/webdock.png","hash":"c32ce7cafbc31378c592226dac6ab8e0a8d9b124","modified":1601078141204},{"_id":"themes/vue/source/images/wilderminds.png","hash":"a9e87eda70ad75a6148e1a980cb4e4ddb085e3ca","modified":1601078141205},{"_id":"themes/vue/source/images/x_team.png","hash":"c2d996ec0a802ce39d695266fbc142dd7dad45c0","modified":1601078141207},{"_id":"themes/vue/source/images/y8.png","hash":"9b584ce4cc6a0724d1dd01ce694411e54f790425","modified":1601078141207},{"_id":"themes/vue/source/images/yakaz.png","hash":"8287ea4beca210e44cde508247c09b930e48d01a","modified":1601078141207},{"_id":"themes/vue/source/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1601050480193},{"_id":"themes/vue/source/js/common.js","hash":"b2573998fa99c7767537f4ec6f066eeafc20e721","modified":1601078141208},{"_id":"themes/vue/source/js/css.escape.js","hash":"1d0e28a08261de3955b0ee18432e304c1f468441","modified":1601078141208},{"_id":"themes/vue/source/js/smooth-scroll.min.js","hash":"90cdfb5d91db8cce21ab705335d591768555f474","modified":1601078141208},{"_id":"themes/vue/source/js/theme-data.js","hash":"4732a5b951d43b814aa903b74114a733a88f358b","modified":1601078141209},{"_id":"src/images/memory-leak-example.png","hash":"7c2df66d99f06df266d294aa7c923fe5e8af7657","modified":1601078141089},{"_id":"src/images/oxford-comma.jpg","hash":"8c315f549b52fe61222d237ea8375a5b64a4737c","modified":1601078141092},{"_id":"src/v2/api/index.md","hash":"c394f0d7bc8afdbcd3e7090d5111b8c066e44031","modified":1601078141097},{"_id":"themes/vue/source/images/accelebrate.png","hash":"c20a58507563546c91813caa2d7751420a1d6cf3","modified":1601078141163},{"_id":"themes/vue/source/images/bacancy_technology.png","hash":"920b3e48d4b18d454ecaeffd4e2895ceff06d1ec","modified":1601078141164},{"_id":"themes/vue/source/images/storyblok.png","hash":"733685fbd16245c42a9a0b2e36010c86a9549dcd","modified":1601078141197},{"_id":"themes/vue/source/images/usave.png","hash":"d9de7e9a012a636cdb323a62faa62d05fca33141","modified":1601078141200},{"_id":"themes/vue/source/images/webucator.png","hash":"940bdf955efcea9471ebcc586d371fa839496c09","modified":1601078141205},{"_id":"themes/vue/source/js/vue.min.js","hash":"e55df1f7d6c288ee73d439bab26dd006ffee7af3","modified":1601215072476},{"_id":"src/v2/examples/vue-10-two-way-currency-filter/index.html","hash":"f5d30eaef94a74065e902dbfbd0a88d4581cd170","modified":1601078141112},{"_id":"src/v2/examples/vue-10-two-way-currency-filter/package.json","hash":"4a153508ad0f4fbfe425b71e52f387c9198daa5b","modified":1601078141112},{"_id":"src/v2/examples/vue-10-two-way-currency-filter/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141113},{"_id":"src/v2/examples/vue-10-two-way-currency-filter-v2/index.html","hash":"4f366dd9c29d3558047cbfa071ba8beb302fd2c6","modified":1601078141111},{"_id":"src/v2/examples/vue-10-two-way-currency-filter-v2/package.json","hash":"a2fa7ebd6d232f3e7b4e45d0f4b500bb7afc9f7d","modified":1601078141111},{"_id":"src/v2/examples/vue-10-two-way-currency-filter-v2/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141111},{"_id":"src/v2/examples/vue-10-two-way-currency-filter-v3/currency-validator.js","hash":"5359fbc4b91c63c5fef2b105a3c4d15ef055c9a4","modified":1601078141111},{"_id":"src/v2/examples/vue-10-two-way-currency-filter-v3/index.html","hash":"edba196bd43f3ff632b9374cff81c352d61756d1","modified":1601078141112},{"_id":"src/v2/examples/vue-10-two-way-currency-filter-v3/package.json","hash":"b6016d428a0de963c74860d63fbe41fc8bad9c18","modified":1601078141112},{"_id":"src/v2/examples/vue-10-two-way-currency-filter-v3/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141112},{"_id":"src/v2/examples/vue-20-accessing-parent-component-instance/index.html","hash":"f958ac25d93963ceeaa545dcd54158d68a2d92f6","modified":1601078141113},{"_id":"src/v2/examples/vue-20-accessing-parent-component-instance/package.json","hash":"a0e34b371f744e4ecc857f3f64bb8499ff814839","modified":1601078141113},{"_id":"src/v2/examples/vue-20-accessing-parent-component-instance/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141113},{"_id":"src/v2/examples/vue-20-component-blog-post-example/index.html","hash":"919030c241c3e3cd30b01f4ad5ae91f5a0eff71c","modified":1601078141113},{"_id":"src/v2/examples/vue-20-component-blog-post-example/package.json","hash":"cece2378609b2f2698d78ea6fea36924271a9e1b","modified":1601078141114},{"_id":"src/v2/examples/vue-20-component-blog-post-example/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141114},{"_id":"src/v2/examples/vue-20-dependency-injection/index.html","hash":"bc6ab5fe22a90b32081c0a37de54fdb890f400a2","modified":1601078141114},{"_id":"src/v2/examples/vue-20-dependency-injection/package.json","hash":"619d5fd815c5f9152b05752aa8d6b5b2d1639424","modified":1601078141114},{"_id":"src/v2/examples/vue-20-dependency-injection/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141114},{"_id":"src/v2/examples/vue-20-dynamic-components/index.html","hash":"7320b3aebbc60da4f80e93b8542d50ec0f1932d3","modified":1601078141115},{"_id":"src/v2/examples/vue-20-dynamic-components/package.json","hash":"dd98c223806e94d9ea20c12ce4679cf877c9c448","modified":1601078141116},{"_id":"src/v2/examples/vue-20-dynamic-components/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141116},{"_id":"src/v2/examples/vue-20-dynamic-components-with-binding/index.html","hash":"c768dc162857a92df16045b69a5d57d3f77bdaf4","modified":1601078141115},{"_id":"src/v2/examples/vue-20-dynamic-components-with-binding/package.json","hash":"2ec7786b608ff5a66e12f4e44b761bee044d197e","modified":1601078141115},{"_id":"src/v2/examples/vue-20-dynamic-components-with-binding/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141115},{"_id":"src/v2/examples/vue-20-dynamic-state-transitions/index.html","hash":"5312a2e840ad55b32b4c0495dd3ff5e1f002d9fd","modified":1601078141116},{"_id":"src/v2/examples/vue-20-dynamic-state-transitions/package.json","hash":"b5bfd433e8dba7de434203abd2c435851d0f4734","modified":1601078141116},{"_id":"src/v2/examples/vue-20-dynamic-state-transitions/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141116},{"_id":"src/v2/examples/vue-20-elastic-header/index.html","hash":"414fa6a58ee4f0c92ff27513928f858186d82e87","modified":1601078141117},{"_id":"src/v2/examples/vue-20-elastic-header/package.json","hash":"169455ffa7af736d75eac5facb736ba119815e5e","modified":1601078141117},{"_id":"src/v2/examples/vue-20-elastic-header/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141117},{"_id":"src/v2/examples/vue-20-elastic-header/style.css","hash":"3da0957241c1f9167974ea6d1f215562824d3b9c","modified":1601078141117},{"_id":"src/v2/examples/vue-20-firebase-validation/index.html","hash":"52b900b3bdec2909fb2106113dda8153c2e2e261","modified":1601078141117},{"_id":"src/v2/examples/vue-20-firebase-validation/package.json","hash":"0cd6f354e7a948db8977c37add9390cf64db0ac8","modified":1601078141118},{"_id":"src/v2/examples/vue-20-firebase-validation/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141118},{"_id":"src/v2/examples/vue-20-firebase-validation/style.css","hash":"b487f23dea94a1331dcb3a23359b7007eb5ffe29","modified":1601078141118},{"_id":"src/v2/examples/vue-20-github-commits/index.html","hash":"05f47baaafa10a158e7c55ca32a3c8257f10811d","modified":1601078141118},{"_id":"src/v2/examples/vue-20-github-commits/package.json","hash":"61b5fad47737ba47600e82229328f2b748e6ef59","modified":1601078141118},{"_id":"src/v2/examples/vue-20-github-commits/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141118},{"_id":"src/v2/examples/vue-20-github-commits/style.css","hash":"5c1d972a2996148db544597872643d5930af0cd3","modified":1601078141119},{"_id":"src/v2/examples/vue-20-grid-component/index.html","hash":"5479e99a9619b60cb1f24843998424acf4c812a6","modified":1601078141119},{"_id":"src/v2/examples/vue-20-grid-component/package.json","hash":"e60c82ae9a158c6ac152ec9390e4ecc72e016df4","modified":1601078141119},{"_id":"src/v2/examples/vue-20-grid-component/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141119},{"_id":"src/v2/examples/vue-20-grid-component/style.css","hash":"5107d2d1f1fde40bfa7e6ec179cf4d8773ced23e","modified":1601078141119},{"_id":"src/v2/examples/vue-20-hello-world/index.html","hash":"1c1712b8b3f1b0747ccc12ed229d4d8efd8207da","modified":1601078141120},{"_id":"src/v2/examples/vue-20-hello-world/package.json","hash":"3b16b82b046f704dfaf3510aaa037903f1e5d5ec","modified":1601078141120},{"_id":"src/v2/examples/vue-20-hello-world/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141120},{"_id":"src/v2/examples/vue-20-keep-alive-with-dynamic-components/index.html","hash":"18e5332475c287922e0b19cc0881adad5ff1d17e","modified":1601078141120},{"_id":"src/v2/examples/vue-20-keep-alive-with-dynamic-components/package.json","hash":"33a5bcda9a2a6d0d79aa3bbd108f89e3d32c3d71","modified":1601078141120},{"_id":"src/v2/examples/vue-20-keep-alive-with-dynamic-components/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141121},{"_id":"src/v2/examples/vue-20-keep-alive-with-dynamic-components/style.css","hash":"b2c0f2211ef4ba8bfd1bea9f003a7e8c5cb7e199","modified":1601078141121},{"_id":"src/v2/examples/vue-20-list-move-transitions/index.html","hash":"1cf94348f082922c442b6abe1cab9c0634cef286","modified":1601078141121},{"_id":"src/v2/examples/vue-20-list-move-transitions/package.json","hash":"dadd0ad2130064b84c3cb42570d1d4665cbe77ad","modified":1601078141121},{"_id":"src/v2/examples/vue-20-list-move-transitions/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141121},{"_id":"src/v2/examples/vue-20-list-move-transitions/style.css","hash":"3bc91c4df1d6e768c72d568cc5a61cc4c50bee23","modified":1601078141122},{"_id":"src/v2/examples/vue-20-markdown-editor/index.html","hash":"274bc7013f894191fbbc33436bb07dcac7187ba5","modified":1601078141122},{"_id":"src/v2/examples/vue-20-markdown-editor/package.json","hash":"a8b2b2ddf685e1f955cd8193f6d1d90030a86869","modified":1601078141122},{"_id":"src/v2/examples/vue-20-markdown-editor/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141122},{"_id":"src/v2/examples/vue-20-markdown-editor/style.css","hash":"4fd48425960737dc5f386c9135a74625099d9e55","modified":1601078141123},{"_id":"src/v2/examples/vue-20-modal-component/index.html","hash":"f60d9315e1f4f5c00120d102dd25db35b65d54aa","modified":1601078141123},{"_id":"src/v2/examples/vue-20-modal-component/package.json","hash":"1508c0e6609e6355a5706bda2f2aa0b222da35de","modified":1601078141123},{"_id":"src/v2/examples/vue-20-modal-component/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141123},{"_id":"src/v2/examples/vue-20-modal-component/style.css","hash":"bb987198f3101748b6c182ddb603d74afea4de7e","modified":1601078141124},{"_id":"src/v2/examples/vue-20-priority-d-rules-correct-example/index.html","hash":"9e8293d8cc1a2d9ca7434527a244854896bde7ec","modified":1601078141124},{"_id":"src/v2/examples/vue-20-priority-d-rules-correct-example/package.json","hash":"a1bf459bb64ba4d459cd5b5ee640f6ee5bfc52f2","modified":1601078141124},{"_id":"src/v2/examples/vue-20-priority-d-rules-correct-example/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141125},{"_id":"src/v2/examples/vue-20-priority-d-rules-unintended-consequences/index.html","hash":"ffa3404abbcd694eae25e0c278089971aa8ebb1d","modified":1601078141125},{"_id":"src/v2/examples/vue-20-priority-d-rules-unintended-consequences/package.json","hash":"ba133d9f5a9da5c66a80fa428b3d5fc0c6af0d69","modified":1601078141125},{"_id":"src/v2/examples/vue-20-priority-d-rules-unintended-consequences/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141125},{"_id":"src/v2/examples/vue-20-programmatic-event-listeners/index.html","hash":"bfe54f8c278751984d0876d3125191bc33367d24","modified":1601078141126},{"_id":"src/v2/examples/vue-20-programmatic-event-listeners/package.json","hash":"c95af5f6881ba462c163cdb14020758c6bcf9cfa","modified":1601078141126},{"_id":"src/v2/examples/vue-20-programmatic-event-listeners/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141126},{"_id":"src/v2/examples/vue-20-realtime-with-deepstreamhub/index.html","hash":"669c6793341afcca10f03dfc9072757f70f49b77","modified":1601078141126},{"_id":"src/v2/examples/vue-20-realtime-with-deepstreamhub/package.json","hash":"00fceddf315f859aaa070cb638582203d90fc42f","modified":1601078141126},{"_id":"src/v2/examples/vue-20-realtime-with-deepstreamhub/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141127},{"_id":"src/v2/examples/vue-20-realtime-with-deepstreamhub/style.css","hash":"a36c30bfc096b21511e876e2892d3ac7364c089e","modified":1601078141127},{"_id":"src/v2/examples/vue-20-single-file-components/Hello.vue","hash":"7e77ad1f5b1fbf2ff2b7395cd85f9559c5eb8190","modified":1601078141127},{"_id":"src/v2/examples/vue-20-single-file-components/index.html","hash":"1b433f33b806b0ddfe84c13b41b6b68881ee49ec","modified":1601078141127},{"_id":"src/v2/examples/vue-20-single-file-components/index.js","hash":"897ab6260ce938e4e1bfd5a7053b94055604d225","modified":1601078141127},{"_id":"src/v2/examples/vue-20-single-file-components/package.json","hash":"d6fd17683a78b483296b64ef1057ed05078d418d","modified":1601078141128},{"_id":"src/v2/examples/vue-20-svg-graph/index.html","hash":"61f5e84cf613ff6a035096458ccb9b8ae04e56f1","modified":1601078141128},{"_id":"src/v2/examples/vue-20-svg-graph/package.json","hash":"26e76fcc22499865472a6fb92ac047b0a790cd20","modified":1601078141128},{"_id":"src/v2/examples/vue-20-svg-graph/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141128},{"_id":"src/v2/examples/vue-20-svg-graph/style.css","hash":"6a65e6cea183f04f431698983f09160cfdbb7e87","modified":1601078141129},{"_id":"src/v2/examples/vue-20-template-compilation/index.html","hash":"ed04a5e3067e727a521da9563931bbabace6e137","modified":1601078141129},{"_id":"src/v2/examples/vue-20-template-compilation/package.json","hash":"d42f57b2b1559da4ebb0e7673230b84789e3220b","modified":1601078141129},{"_id":"src/v2/examples/vue-20-template-compilation/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141129},{"_id":"src/v2/examples/vue-20-template-compilation/style.css","hash":"e54a84504d0a79bb59f7243ee98700bdd24ed144","modified":1601078141130},{"_id":"src/v2/examples/vue-20-todomvc/index.html","hash":"01807c009abc1e0c34dc87f60b00b4a91997c7df","modified":1601078141130},{"_id":"src/v2/examples/vue-20-todomvc/package.json","hash":"f6f4f54451b279559610af435d72f4bc261d7233","modified":1601078141130},{"_id":"src/v2/examples/vue-20-todomvc/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141130},{"_id":"src/v2/examples/vue-20-tree-view/index.html","hash":"728f46229e9f3ee26e842ecfd3fb58effa5d9370","modified":1601078141130},{"_id":"src/v2/examples/vue-20-tree-view/package.json","hash":"9f44b5d67b228c162c66c4920bd6f9960b603e2c","modified":1601078141131},{"_id":"src/v2/examples/vue-20-tree-view/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141131},{"_id":"src/v2/examples/vue-20-tree-view/style.css","hash":"6e40d312e77cf35cecd478d0b0502a6a1ff541e9","modified":1601078141131},{"_id":"src/v2/examples/vue-20-two-way-currency-filter/currency-validator.js","hash":"5359fbc4b91c63c5fef2b105a3c4d15ef055c9a4","modified":1601078141131},{"_id":"src/v2/examples/vue-20-two-way-currency-filter/index.html","hash":"25bf2109787390e0a22caaa5885d2437b491493c","modified":1601078141131},{"_id":"src/v2/examples/vue-20-two-way-currency-filter/package.json","hash":"07bde381b3476d4cb2fcf3d831e6d08e9fda1a46","modified":1601078141132},{"_id":"src/v2/examples/vue-20-two-way-currency-filter/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141132},{"_id":"src/v2/examples/vue-20-wrapper-component/index.html","hash":"831061745f0caffc8a38e64e2ba6995b239d432b","modified":1601078141132},{"_id":"src/v2/examples/vue-20-wrapper-component/package.json","hash":"4354ba8ce3b094b6cf5078d12df0e6da5141c5b4","modified":1601078141132},{"_id":"src/v2/examples/vue-20-wrapper-component/sandbox.config.json","hash":"a98497b886ddad2de80abf9b3237f67d003a439e","modified":1601078141132},{"_id":"themes/vue/source/compiled/img/Human.svg","hash":"d072e8f88b38a9590c06b68bb4771d6c19e69e91","modified":1601148995099},{"_id":"themes/vue/source/compiled/img/logo.png","hash":"1a6ace377133f14a2b2cd7c48f10369a6bc54b2e","modified":1601148995099},{"_id":"themes/vue/source/images/icons/android-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1601078141175},{"_id":"themes/vue/source/images/icons/android-icon-192x192.png","hash":"b35d14364fce39e54f3896ddee44f970b7487b2c","modified":1601078141175},{"_id":"themes/vue/source/images/icons/android-icon-36x36.png","hash":"ea99e8a2db010e40c71fd254d3709c5fd551610d","modified":1601078141175},{"_id":"themes/vue/source/images/icons/android-icon-48x48.png","hash":"05c04b9833c99ddcab596fe99250a88a3e6df583","modified":1601078141175},{"_id":"themes/vue/source/images/icons/android-icon-72x72.png","hash":"66a36856e9d0af7902abcf9f24401f68d429d0d6","modified":1601078141176},{"_id":"themes/vue/source/images/icons/android-icon-96x96.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1601078141176},{"_id":"themes/vue/source/images/icons/apple-icon-114x114.png","hash":"07fce47fddaae024a74f027c3a8c98b385096060","modified":1601078141176},{"_id":"themes/vue/source/images/icons/apple-icon-120x120.png","hash":"0c55163aeba24ccf0508e49cd4ee08ba9c9757a6","modified":1601078141176},{"_id":"themes/vue/source/images/icons/apple-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1601078141176},{"_id":"themes/vue/source/images/icons/apple-icon-152x152.png","hash":"52f7579762a3dc955a9ad67a6918a049e2720164","modified":1601078141177},{"_id":"themes/vue/source/images/icons/apple-icon-180x180.png","hash":"5e828e492672efd0d9e6ac2b5ff46ae45ff34ab9","modified":1601078141177},{"_id":"themes/vue/source/images/icons/apple-icon-57x57.png","hash":"cf8ac1abcb1c53cb9b201ef082ba29a9591844d6","modified":1601078141177},{"_id":"themes/vue/source/images/icons/apple-icon-60x60.png","hash":"c1905c7bf23fe3f08dcecc45b1638e6a2da60f42","modified":1601078141177},{"_id":"themes/vue/source/images/icons/apple-icon-72x72.png","hash":"66a36856e9d0af7902abcf9f24401f68d429d0d6","modified":1601078141177},{"_id":"themes/vue/source/images/icons/apple-icon-76x76.png","hash":"c7ad68677d2647033a60911731cf82db37784cf3","modified":1601078141178},{"_id":"themes/vue/source/images/icons/apple-icon-precomposed.png","hash":"d07baf1d7200a145c15bb2b7abc9c1c864e0cdf9","modified":1601078141178},{"_id":"themes/vue/source/images/icons/apple-icon.png","hash":"d07baf1d7200a145c15bb2b7abc9c1c864e0cdf9","modified":1601078141178},{"_id":"themes/vue/source/images/icons/favicon-16x16.png","hash":"03f5391b57618b4b868ad3addec3375ec03db088","modified":1601078141180},{"_id":"themes/vue/source/images/icons/favicon-32x32.png","hash":"fd0ea145dddf84c510317b7320b2c53efd850260","modified":1601078141180},{"_id":"themes/vue/source/images/icons/favicon-96x96.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1601078141180},{"_id":"themes/vue/source/images/icons/favicon.ico","hash":"3c5aa0ae13d561379ea8ce15f4d7e02163ef3273","modified":1601078141180},{"_id":"themes/vue/source/images/icons/ms-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1601078141181},{"_id":"themes/vue/source/images/icons/ms-icon-150x150.png","hash":"52c635f52bb7b91382a2f8d61f64a4ff25ae11aa","modified":1601078141181},{"_id":"themes/vue/source/images/icons/ms-icon-310x310.png","hash":"58f800960bae4c97a0d14bdd42f98db20c2e2bc8","modified":1601078141181},{"_id":"themes/vue/source/images/icons/ms-icon-70x70.png","hash":"8b326124c52e9b2e6c2826232a7627cdadbd3c0b","modified":1601078141181},{"_id":"themes/vue/source/images/writers_per_hour.jpg","hash":"e4d91e160e2a34c4f2180fb0ec4e3f014f08edd1","modified":1601078141206},{"_id":"themes/vue/source/images/special-sponsor-spot.png","hash":"f635521496f2f8a4c35c67160b088c1756b7d948","modified":1601078141195},{"_id":"src/images/devtools-timetravel.gif","hash":"43ddab8e7869a513c2058d2892b54d0c556ef5e2","modified":1601078141084},{"_id":"themes/vue/source/images/icons/bacancy_technology.png","hash":"900c58a849862758c7062030f5a3aa09fd785a21","modified":1601078141180},{"_id":"themes/vue/source/js/vue.js","hash":"5c39dfc37fc42400e4b4557db956f3f218a90ca7","modified":1601215072525},{"_id":"src/images/breakpoint_set.png","hash":"db3c2527261d19c83424b69d789fca4a85dbec07","modified":1601078141075},{"_id":"src/images/config_add.png","hash":"ef17eaeb40ca00f9c66d813c569c1b54160db1a9","modified":1601078141078},{"_id":"src/images/breakpoint_hit.png","hash":"56c93842cb88a37df7dd327507c5c44f94459e72","modified":1601078141071},{"_id":"themes/vue/source/compiled/js/app.js","hash":"34077a5a129a8dab5411f5710d62d2657a5c567f","modified":1601148995099},{"_id":"themes/vue/source/compiled/js/chunk-vendors.js","hash":"0a296151a5da7315bc3bd31d9b14dedfbd4842b2","modified":1601148995099},{"_id":"public/v2/examples/vue-10-two-way-currency-filter/package.json","hash":"97ed080a13d7aa1f44be9f96d966901902aa6ad3","modified":1601215187545},{"_id":"public/v2/examples/vue-10-two-way-currency-filter/sandbox.config.json","hash":"5a7630aa4fc1ec5ee3e49db6a6c4a9b1bbc851d6","modified":1601215187545},{"_id":"public/v2/examples/vue-10-two-way-currency-filter-v2/package.json","hash":"7cd2755efbda6ad098bdbb6708391a7698f1bdb0","modified":1601215188147},{"_id":"public/v2/examples/vue-10-two-way-currency-filter-v2/sandbox.config.json","hash":"5a7630aa4fc1ec5ee3e49db6a6c4a9b1bbc851d6","modified":1601215188147},{"_id":"public/v2/examples/vue-10-two-way-currency-filter-v3/currency-validator.js","hash":"5359fbc4b91c63c5fef2b105a3c4d15ef055c9a4","modified":1601215188181},{"_id":"public/v2/examples/vue-10-two-way-currency-filter-v3/package.json","hash":"a18d982c8968d6cd43afe5116fa93eef09c32d26","modified":1601215188181},{"_id":"public/v2/examples/vue-10-two-way-currency-filter-v3/sandbox.config.json","hash":"5a7630aa4fc1ec5ee3e49db6a6c4a9b1bbc851d6","modified":1601215188181},{"_id":"public/api/index.html","hash":"c9f0675039fb57c59b92b18474eb4f9140732fe5","modified":1601215188181},{"_id":"public/guide/class-and-style.html","hash":"970d4f993423e3d86413d315fe8fab5bad5aae0b","modified":1601215188181},{"_id":"public/guide/comparison.html","hash":"25850f1a4700c5305be71224f7a5cd3686e71e98","modified":1601215188182},{"_id":"public/guide/components.html","hash":"ac958e3d99e1b93df5fde31e95bb4ee2cb903af4","modified":1601215188182},{"_id":"public/guide/computed.html","hash":"96e3f4afeda86496a9078df974419c0a1d37e1c1","modified":1601215188182},{"_id":"public/guide/conditional.html","hash":"c6311d6806399fcfeebb3d38db377000f0ba20bf","modified":1601215188182},{"_id":"public/guide/custom-directive.html","hash":"d44daebd462e74d838560b80855b20084f673f88","modified":1601215188182},{"_id":"public/guide/deployment.html","hash":"c5b31d7025c5749f3f49cc1eef8ef4643239aab8","modified":1601215188182},{"_id":"public/guide/events.html","hash":"8b247e0b17642e6f2d94b39a9c5a30ffce35654b","modified":1601215188182},{"_id":"public/guide/forms.html","hash":"5a11591db0b014ae607fa7926fcb039ab56b66fc","modified":1601215188182},{"_id":"public/guide/index.html","hash":"e2b3d8b93afe5e766d9131ed574e0540d935b641","modified":1601215188182},{"_id":"public/guide/installation.html","hash":"1b0ef502e9b94e6e600eecbd198a73ba7e22d6af","modified":1601215188182},{"_id":"public/guide/instance.html","hash":"5edcf2972c13eee9e5deaf4936bc26268e834a25","modified":1601215188182},{"_id":"public/guide/join.html","hash":"f31da6e98e785258938fed5b13b02b776a8f0098","modified":1601215188182},{"_id":"public/guide/list.html","hash":"5c42ddd4f0c24c277cbb01be24404690d09a8a9b","modified":1601215188182},{"_id":"public/guide/migration-vue-router.html","hash":"146720fedd3855128fe39e8d9855c7cead9dc14d","modified":1601215188182},{"_id":"public/guide/migration-vuex.html","hash":"98193c186c31c9f82e4ef9d15eda478d6334d168","modified":1601215188182},{"_id":"public/guide/migration.html","hash":"02d5dd7fb011b540ac6b2ebd54c6aeb1a68a4327","modified":1601215188182},{"_id":"public/guide/mixins.html","hash":"4cbab0c07672782b6d42678ffec17873fcd0eb45","modified":1601215188182},{"_id":"public/guide/plugins.html","hash":"ef61f5d30721719cadd935718871b757465435eb","modified":1601215188182},{"_id":"public/guide/reactivity.html","hash":"6416a919fa2cea085484a090f7e05a2b44c2bab6","modified":1601215188182},{"_id":"public/guide/render-function.html","hash":"a29c7cba96378e3c8521eed1950fa32a6f77a189","modified":1601215188182},{"_id":"public/guide/routing.html","hash":"8945e59bf128ec03dd5040407c017f5596ed796d","modified":1601215188182},{"_id":"public/guide/single-file-components.html","hash":"f948a1559acb573f62b2593d5c60968978ed3161","modified":1601215188182},{"_id":"public/guide/ssr.html","hash":"efc8457a72454695edba3386e71653eb19bee86c","modified":1601215188182},{"_id":"public/guide/state-management.html","hash":"f7712e9d5875a243badc5f5a2425b104b0bb626e","modified":1601215188182},{"_id":"public/guide/syntax.html","hash":"75e4af69b22c8ec64b8c391f1b94dd64d5163aad","modified":1601215188182},{"_id":"public/guide/transitioning-state.html","hash":"1f5cabe1606bfdd3aa999cc2982d93f46e319c1b","modified":1601215188182},{"_id":"public/guide/transitions.html","hash":"ead910e781daf4430d4ac1c52570e194543ca015","modified":1601215188182},{"_id":"public/guide/unit-testing.html","hash":"9747699833d0356a5917ae4cc0068833847da2dd","modified":1601215188183},{"_id":"public/examples/commits.html","hash":"d7448d159ad4dad3eb4c3f63cb5971330e62e82d","modified":1601215188183},{"_id":"public/examples/elastic-header.html","hash":"6b445fee8ad128496b592e928ef297eeb7be1ec4","modified":1601215188183},{"_id":"public/examples/firebase.html","hash":"f00b36c0efc07818424eaecbb296e82dcc426ce0","modified":1601215188183},{"_id":"public/examples/grid-component.html","hash":"c2b990091a2977fc8446a19b438cbbe76d9bc5d0","modified":1601215188183},{"_id":"public/examples/hackernews.html","hash":"a51131e06269681c38cb1cbdfa359339f53143cc","modified":1601215188183},{"_id":"public/examples/index.html","hash":"a6ffd730fde22ef518953b62e12f79a3472c958c","modified":1601215188183},{"_id":"public/examples/modal.html","hash":"d5474beb09b1399f7aba07d04d335ccca1a6d1f6","modified":1601215188183},{"_id":"public/examples/select2.html","hash":"d3d6ae69df79ea8025a1893b11169a4c6a933631","modified":1601215188183},{"_id":"public/examples/svg.html","hash":"5b1fa13f3f832fe334c06175cca67c227152385b","modified":1601215188183},{"_id":"public/examples/todomvc.html","hash":"fb57cee2468f6c9c5424069f3923e2138ddb7b31","modified":1601215188183},{"_id":"public/examples/tree-view.html","hash":"0c09ebb15415a6bc3fcc3749bbe5fd9229110de4","modified":1601215188183},{"_id":"public/atom.xml","hash":"a369668d8cc948a3db1c776f9213ec65c1631bf8","modified":1601215188183},{"_id":"public/index.html","hash":"dedae1746927f10b4469d48dc293343fa8b7a12d","modified":1601215188201},{"_id":"public/coc/index.html","hash":"d2b63762926cca4678d753e1baad49f159b3dba1","modified":1601215188201},{"_id":"public/menu/index.html","hash":"f76e45ce019e5d09803c6bae2bcc2307d0b8ec78","modified":1601215188201},{"_id":"public/resources/partners.html","hash":"ca08544795dfc94cbb80a219cbf8f4fe6aa0002b","modified":1601215188201},{"_id":"public/resources/themes.html","hash":"2e2416a621b696d07fbfdc9724eda2fe62d67268","modified":1601215188201},{"_id":"public/support-vuejs/index.html","hash":"01816ccea399cb721c776ec4636c103027d50508","modified":1601215188201},{"_id":"public/v2/cookbook/avoiding-memory-leaks.html","hash":"c76d649f409192953238eab2bbc2363db669453d","modified":1601215188201},{"_id":"public/v2/cookbook/adding-instance-properties.html","hash":"6b68090622975c39da1ebd79b4fad5e6ef5756b5","modified":1601215188201},{"_id":"public/v2/cookbook/client-side-storage.html","hash":"d734179a75222015b325cfb0956f361b1bb644ec","modified":1601215188201},{"_id":"public/v2/cookbook/creating-custom-scroll-directives.html","hash":"af98cde85ac48a33b2676cb8ca91f6077416d5d3","modified":1601215188201},{"_id":"public/v2/cookbook/debugging-in-vscode.html","hash":"22ade14466ca3065a59fd0014e2edb03d9e67200","modified":1601215188201},{"_id":"public/v2/cookbook/dockerize-vuejs-app.html","hash":"d8a60e39ac5a7ee1e72309d64de410daa677c988","modified":1601215188201},{"_id":"public/v2/cookbook/editable-svg-icons.html","hash":"bf2597bba377811ab920e1aba6c64613a4cddbf2","modified":1601215188201},{"_id":"public/v2/cookbook/form-validation.html","hash":"dc4e6b0e3ace31449792f7ef5cb3300956ebfb81","modified":1601215188201},{"_id":"public/v2/cookbook/index.html","hash":"38d0874a0346871878cf21aaa607cb5343876866","modified":1601215188201},{"_id":"public/v2/cookbook/practical-use-of-scoped-slots.html","hash":"570cfcc473227eca5f048f2e423dca8e1e39950a","modified":1601215188201},{"_id":"public/v2/cookbook/serverless-blog.html","hash":"de1c6fa38dacf19ee61c48569b2686b0fe8ab6eb","modified":1601215188201},{"_id":"public/v2/cookbook/packaging-sfc-for-npm.html","hash":"ffd43392fd101f5bc3614039551f1df99fb697ec","modified":1601215188202},{"_id":"public/v2/cookbook/unit-testing-vue-components.html","hash":"f90c4bc34c09feef06c037bdd4bf110912ed1945","modified":1601215188202},{"_id":"public/v2/cookbook/using-axios-to-consume-apis.html","hash":"1430156ca42c69dd8bd70d8785233d62790dd17a","modified":1601215188202},{"_id":"public/v2/bytepath/Tween Class.html","hash":"b760d9b7b7ba1c5099498fc76bef84d04936928b","modified":1601215188202},{"_id":"public/v2/bytepath/animationreuse.html","hash":"cbdf77adc546aa44e9f5521edee77a818bc04f12","modified":1601215188202},{"_id":"public/v2/bytepath/assetcomposition.html","hash":"2d67c2213eea7d6d1acc044b0f314bfa15dd042d","modified":1601215188202},{"_id":"public/v2/bytepath/assetreuse.html","hash":"5c064f4c1d563f43bb033eeeb121c1e70e2735ba","modified":1601215188202},{"_id":"public/v2/bytepath/basicanimations.html","hash":"41324868579edd8f1835999e2743fff9b22e3363","modified":1601215188202},{"_id":"public/v2/bytepath/basictransformations.html","hash":"70a86ee1cf407ff75a76fa631556b8d80bc26e3a","modified":1601215188202},{"_id":"public/v2/bytepath/fastforwardandrewind.html","hash":"14bc2140cb06bf3af575459fe09bed397deb09cc","modified":1601215188202},{"_id":"public/v2/bytepath/homeless.html","hash":"5605326dc34af0eac13d063f95251f53b042b4af","modified":1601215188202},{"_id":"public/v2/bytepath/cameracontrol.html","hash":"33476dc0067d5c7b416ea920395d2c8288b8e971","modified":1601215188202},{"_id":"public/v2/bytepath/domtransformations.html","hash":"ca446e19d3c02826b8980026f0d6abce53bd6174","modified":1601215188202},{"_id":"public/v2/bytepath/importingassets.html","hash":"6f075c296b8de23a274a54344fb06d5e99fde113","modified":1601215188202},{"_id":"public/v2/bytepath/index.html","hash":"f4a6b9f1da6295b14b99afe9b9ec3630097886fc","modified":1601215188202},{"_id":"public/v2/bytepath/introduction.html","hash":"d1589955fa1c0911fec8e49d97bb25932323279e","modified":1601215188202},{"_id":"public/v2/bytepath/keyboardinput.html","hash":"477e6eeb7a004e29711362e8f0566ef9a51b0f09","modified":1601215188202},{"_id":"public/v2/bytepath/keyframeanimations.html","hash":"45eea6c0495c9aa7e1acbbe240975f3c27b2b865","modified":1601215188202},{"_id":"public/v2/bytepath/matrixprop.html","hash":"e0cd643d75254cfd6efa090c517d0b5280dfcd2e","modified":1601215188202},{"_id":"public/v2/bytepath/positionclass.html","hash":"5b63545fd4043398b5109f32b7cebac14970099c","modified":1601215188202},{"_id":"public/v2/bytepath/transformationmutators.html","hash":"265ac61d1aa6d0981e27eb237e5e441e123948de","modified":1601215188202},{"_id":"public/v2/bytepath/mouseinput.html","hash":"1fbc566bcca8b34aa12d3ed0e745662dbc64e35b","modified":1601215188203},{"_id":"public/v2/bytepath/sampleassets.html","hash":"7b1e1878d41febfff40d812a0783bb01648647bf","modified":1601215188203},{"_id":"public/v2/bytepath/renderlessanimations.html","hash":"d53cdddd0dddf2a33ee76d35eb2a79351e4f6344","modified":1601215188203},{"_id":"public/v2/examples/deepstream.html","hash":"7f8fe84c44d4da24f384f97a33619e19d4cfeac3","modified":1601215188203},{"_id":"public/v2/examples/firebase.html","hash":"d8ca1c6300e2df3c96e5f969eb34a5924f5899cd","modified":1601215188203},{"_id":"public/v2/examples/elastic-header.html","hash":"dbcbbc5ed87022f79db027aa4ef8595ae7bad8e9","modified":1601215188203},{"_id":"public/v2/examples/commits.html","hash":"fb83c90c222a09d30c29d53c330809315828cd68","modified":1601215188203},{"_id":"public/v2/examples/grid-component.html","hash":"25e4142d647c4342ae2a317609f34494c2a4e5fd","modified":1601215188203},{"_id":"public/v2/examples/hackernews.html","hash":"5639115484ab50c52a16c524a1a6efd09bf50046","modified":1601215188203},{"_id":"public/v2/examples/index.html","hash":"8158ca45b76af72cbf695e1710b5241c7ec5def8","modified":1601215188203},{"_id":"public/v2/examples/modal.html","hash":"369f8f620a60e0f386008ee36fe3c81cb9310133","modified":1601215188203},{"_id":"public/v2/examples/select2.html","hash":"733f86ede505ad1a0e2dcac82f2a2de382a87c74","modified":1601215188203},{"_id":"public/v2/examples/todomvc.html","hash":"416160c59612a7b592c72095a0f632241b40a82b","modified":1601215188203},{"_id":"public/v2/examples/svg.html","hash":"d98c7a1915895e8d7f5dcd36d714e318ca93af5b","modified":1601215188203},{"_id":"public/v2/examples/tree-view.html","hash":"ef1cc6108e90a41033ae7fba3a8c485d1c109d9e","modified":1601215188203},{"_id":"public/v2/search/index.html","hash":"0a608e19d99d8df6c186bf1921a64df0e62890aa","modified":1601215188203},{"_id":"public/v2/guide/class-and-style.html","hash":"8e7efc8f97cc248cd9e39cdd3f121a91ee928858","modified":1601215188203},{"_id":"public/v2/guide/components-custom-events.html","hash":"e2cc19db886e36a27aa7bbcd83e32de37c2a56a1","modified":1601215188203},{"_id":"public/v2/guide/components-dynamic-async.html","hash":"258ba610d2a09b1f8d825cf6a6e485469e037e34","modified":1601215188203},{"_id":"public/v2/guide/components-edge-cases.html","hash":"e40ca231ff739c6ba2630dd2eb5eef0ac411d48b","modified":1601215188203},{"_id":"public/v2/guide/components-props.html","hash":"480c098f091175f8841339922917af872bba09e4","modified":1601215188203},{"_id":"public/v2/guide/components-registration.html","hash":"e91f1b0bec4c0e003560c0ae65dba63716e554da","modified":1601215188204},{"_id":"public/v2/guide/components-slots.html","hash":"239fa7d67cbac7b50a3d7ce5aa0c9594df355882","modified":1601215188204},{"_id":"public/v2/guide/conditional.html","hash":"e76f059d1d82accefd7033bfa49d254f4bd4867e","modified":1601215188204},{"_id":"public/v2/guide/custom-directive.html","hash":"9831d1cd87eb497b2c65e9fee73f13ccbed4ccb3","modified":1601215188204},{"_id":"public/v2/guide/computed.html","hash":"bebe9e6e552976dddd59db908801af88b5e7d29d","modified":1601215188204},{"_id":"public/v2/guide/components.html","hash":"5f73791602d2f72ab1eafd32fa7de6d4b3deb7b1","modified":1601215188204},{"_id":"public/v2/guide/events.html","hash":"38c9a7b752382ce31b4e68d4f2f5b428fcf2fe69","modified":1601215188204},{"_id":"public/v2/guide/forms.html","hash":"ecd8366757c133037643bf6cc1d6f2d9f08fd463","modified":1601215188204},{"_id":"public/v2/guide/index.html","hash":"fb14cd6f0311d4489d5f887ff75f0f1ae764f440","modified":1601215188205},{"_id":"public/v2/guide/deployment.html","hash":"a00cf6d13fbad7d9a299e53e80eaa3e4d9c98026","modified":1601215188205},{"_id":"public/v2/guide/filters.html","hash":"65195a2eb490e1b4c6668f1145bc455eb56fdfcb","modified":1601215188205},{"_id":"public/v2/guide/instance.html","hash":"9fc6a853db79891263d386db7a57497d4f01093e","modified":1601215188205},{"_id":"public/v2/guide/installation.html","hash":"b3a0e6ddf1f8e4b6b7f936bd31916e6bc7711ef3","modified":1601215188205},{"_id":"public/v2/guide/join.html","hash":"17c050c5339b84929948541b53fcc46b59b75cf3","modified":1601215188205},{"_id":"public/v2/guide/list.html","hash":"8c68d36aa78c88155ea286f10f9c9ddf83a945c6","modified":1601215188205},{"_id":"public/v2/guide/mixins.html","hash":"c35971a243cae0159a91b83cd6928c8d04008a25","modified":1601215188205},{"_id":"public/v2/guide/plugins.html","hash":"27f981fe39da626a06707847d55f5f896e14f5f2","modified":1601215188205},{"_id":"public/v2/guide/reactivity.html","hash":"ae1f8bb995cfc8cb4a3c08d06fd52ee322a8e0ff","modified":1601215188205},{"_id":"public/v2/guide/render-function.html","hash":"42799b7bcc028c83c48196d5ddf64455483d3f8b","modified":1601215188205},{"_id":"public/v2/guide/single-file-components.html","hash":"0983d0bf75ad724c0d0e7779ac4b7de529fd12bf","modified":1601215188205},{"_id":"public/v2/guide/state-management.html","hash":"b19f5bcea3b5ace1d80deb225ac1241b3b6ecc46","modified":1601215188205},{"_id":"public/v2/guide/syntax.html","hash":"f50b5fee35af7979d1bb776d3031c7e93fe8ea38","modified":1601215188205},{"_id":"public/v2/guide/testing.html","hash":"e7867a6b6b7fb3e4ae2720461bac63e361440827","modified":1601215188205},{"_id":"public/v2/guide/typescript.html","hash":"b21e5bdd43fec9d75ad3e183a50c90efd7d4b5ce","modified":1601215188205},{"_id":"public/v2/style-guide/index.html","hash":"5f5781a492becbbb23de63118ffd2f9bee7c843e","modified":1601215188206},{"_id":"public/v2/api/index.html","hash":"6c9f872b8af3e52b40eb4098077ba2f59c71943f","modified":1601215188206},{"_id":"public/v2/examples/vue-10-two-way-currency-filter/index.html","hash":"02ab4599c78610ddfdcbb128d014c9328f275ea1","modified":1601215188206},{"_id":"public/v2/examples/vue-10-two-way-currency-filter-v2/index.html","hash":"c87b66c02c79a1bfbc4aec494743505453173beb","modified":1601215188206},{"_id":"public/v2/examples/vue-10-two-way-currency-filter-v3/index.html","hash":"83e8ad8433e531547b8cb9d77703da5fd95149da","modified":1601215188206},{"_id":"public/2016/04/27/announcing-2.0/index.html","hash":"cd4417768ff7729eeadc565233d4de116e23dbe7","modified":1601215188206},{"_id":"public/2016/03/14/march-update/index.html","hash":"b23d4730ccf06a3f6ae0ee85b00c415cd4fe848c","modified":1601215188206},{"_id":"public/2016/02/06/common-gotchas/index.html","hash":"e516e57e0c7ec42de5d547626e8594f995c53ab7","modified":1601215188206},{"_id":"public/2015/12/28/vue-cli/index.html","hash":"0858c569edb3f8932abe427c5a96354e995d06d1","modified":1601215188206},{"_id":"public/2015/10/28/why-no-template-url/index.html","hash":"91d07742afe3dc90bc9226b46703f10cee7ddcf3","modified":1601215188206},{"_id":"public/2015/10/26/1.0.0-release/index.html","hash":"ca183ac0a6919768865c120bafbdf48f00a0ce5e","modified":1601215188206},{"_id":"public/2015/06/11/012-release/index.html","hash":"71b72fae013d6f457b15683d2d63cefb4eb3f91c","modified":1601215188206},{"_id":"public/2014/12/08/011-component/index.html","hash":"ee571ab47cb36caaa3bd24c816a9675f870d0039","modified":1601215188206},{"_id":"public/2014/11/09/vue-011-release/index.html","hash":"12e607b7cc7b2c9214e0007dfdaba5634dc8bd50","modified":1601215188206},{"_id":"public/2014/07/29/vue-next/index.html","hash":"6261373bc5993c482cc8abb1a41bb208e310417a","modified":1601215188206},{"_id":"public/2014/03/22/vuejs-010-release/index.html","hash":"342b7dc739ff3823d5ad7f946f1cfc9bfd6de354","modified":1601215188206},{"_id":"public/page/2/index.html","hash":"942ba8675c964d6026c1e19602512857b6d9d8e4","modified":1601215188206},{"_id":"public/archives/index.html","hash":"a2677aa12b76b541ed012036e461f66b158ad55a","modified":1601215188206},{"_id":"public/archives/page/2/index.html","hash":"5a14e6477710a2a1c22be7d2b93a6916299caceb","modified":1601215188206},{"_id":"public/archives/2014/index.html","hash":"f83f044d12de7d1e30b82c8dfc749d420605ba01","modified":1601215188206},{"_id":"public/archives/2014/03/index.html","hash":"4ec754cc3b449a1e40da1862bbc183e36dc74184","modified":1601215188206},{"_id":"public/archives/2014/07/index.html","hash":"ad20a274368a2b0acf466b819f859e9caf264efa","modified":1601215188207},{"_id":"public/archives/2014/11/index.html","hash":"23460be0d971d06a9f947886045d2636afeab0ae","modified":1601215188207},{"_id":"public/archives/2014/12/index.html","hash":"2d4ce64439f5ca3eb0ba9cba8566554db062acc9","modified":1601215188207},{"_id":"public/archives/2015/index.html","hash":"a72f1ebdf1ec297b5afc7d6bea4be6ed66365d88","modified":1601215188207},{"_id":"public/archives/2015/06/index.html","hash":"0bf3b92843f5fe6250db9902dcb0f94308bca59e","modified":1601215188207},{"_id":"public/archives/2015/10/index.html","hash":"37043e751ca460574e2466a3b8ea88c18ad4cc12","modified":1601215188207},{"_id":"public/archives/2015/12/index.html","hash":"67798af3100deb8d8393acc791a392c4a97e2f0c","modified":1601215188207},{"_id":"public/archives/2016/index.html","hash":"082b9f6b1916bc9ab1ae4e8009b064c29f04cda9","modified":1601215188207},{"_id":"public/archives/2016/02/index.html","hash":"a03353c59361c4d321d8315d4ff878e087d7999e","modified":1601215188207},{"_id":"public/archives/2016/03/index.html","hash":"f2a7476aa8e3d0268205daf6de9fc661120d2b46","modified":1601215188207},{"_id":"public/archives/2016/04/index.html","hash":"7de9d99490ad18dc7901890fda5317a216309ea2","modified":1601215188207},{"_id":"public/images/components.png","hash":"2f4056d9c0448a3204386ddefd84025ea8a58967","modified":1601215188216},{"_id":"public/images/data.png","hash":"7071337f9071f93ebf85639ede38b0f40fd75d98","modified":1601215188216},{"_id":"public/images/dom-tree.png","hash":"820025017bfcf319d411f6eb2a6f07d543132028","modified":1601215188217},{"_id":"public/images/lifecycle.png","hash":"53345be1363e09b3e43e34d27c030c4f376b060a","modified":1601215188217},{"_id":"public/images/devtools-storage-chrome.png","hash":"4c6defcd7f965e743c5a9d9242766e67b7a79a38","modified":1601215188217},{"_id":"public/images/devtools-storage-edge.png","hash":"4550f8c408787ed427c5f6b07530533690be1a3c","modified":1601215188217},{"_id":"public/images/hn-architecture.png","hash":"0b4adafb587478119e1fb5808f8f04481268a3ce","modified":1601215188217},{"_id":"public/images/mvvm.png","hash":"b83d7f54d5f2df09a662a7057cd521d23b67e451","modified":1601215188217},{"_id":"public/images/search-by-algolia.png","hash":"b580b0eb3965b62ce9bb1bab1ed0577448f73075","modified":1601215188217},{"_id":"public/images/props-events.png","hash":"0f0328ec572bda3f864bb65eea5dbbf32b59504c","modified":1601215188217},{"_id":"public/images/logged-proxied-data.png","hash":"0e875c2ded04180d9fc73785fbc91351b8159648","modified":1601215188217},{"_id":"public/images/state.png","hash":"8d8033027c49fee1f795cdca0736c4315efc54fa","modified":1601215188217},{"_id":"public/images/transition.png","hash":"918faae8f4e8e8d0b02c7516ba3c9931b9161487","modified":1601215188217},{"_id":"public/browserconfig.xml","hash":"115f1a6d4b6a6ca0661f12b3d9a6123f213d78b7","modified":1601215188217},{"_id":"public/images/hn.png","hash":"d0a6b7b011d305d62504cae3bbce54d111783e82","modified":1601215188217},{"_id":"public/favicon.ico","hash":"c0605efed936ee2600284e6480521d06fa64f872","modified":1601215188217},{"_id":"public/images/typescript-type-error.png","hash":"f282f85d3fe94a7ebd2f741efad3d55a5469dcc5","modified":1601215188217},{"_id":"public/compiled/Human.svg","hash":"db77c146f4bfb2346b766520a36f21dcbc6c9423","modified":1601215188217},{"_id":"public/images/vue-component.png","hash":"a9155a78d17b79c5f8e28f4ccf48864fcf172efb","modified":1601215188217},{"_id":"public/compiled/favicon.ico","hash":"c0605efed936ee2600284e6480521d06fa64f872","modified":1601215188217},{"_id":"public/images/vue-component-with-preprocessors.png","hash":"daed0210c92685fd128bd5e8b9338700619b2442","modified":1601215188217},{"_id":"public/images/aaha.png","hash":"081c1d01fd9d611e6270d45d87c15b41fbc1aaed","modified":1601215188217},{"_id":"public/images/Monterail.png","hash":"5f347b6677637054908e4599709134f4606285cd","modified":1601215188218},{"_id":"public/images/alligator_io.svg","hash":"95f65bec674298d1fe49b46768034dbf64b4adbf","modified":1601215188218},{"_id":"public/images/autocode.svg","hash":"191612d16cc8342550747fbc1b2480507855fca3","modified":1601215188218},{"_id":"public/images/blokt_cryptocurrency_news.png","hash":"fa2ac30a25830e9ef383fdb8c4efc5cc98aaff8f","modified":1601215188218},{"_id":"public/images/chaitin.png","hash":"a61b1ec393b9600d173255fed72fd873a72b8225","modified":1601215188218},{"_id":"public/images/check.png","hash":"b22174f8a966abf7a46eba7991be7a7ae5e16637","modified":1601215188218},{"_id":"public/images/cloudstudio.png","hash":"a0cb4e3d6a3f8f06e0c0416c71427dd01f3af52b","modified":1601215188218},{"_id":"public/images/bestvpn_co.png","hash":"499990e72cb49b3c53316d376c787ff1c5f17a7f","modified":1601215188218},{"_id":"public/images/coin-bch.png","hash":"783293c8b782e7772e61f62e1168ae175a0a1456","modified":1601215188218},{"_id":"public/images/coin-btc.png","hash":"4dc6d5b671dba33b3e293180ccc9ec2f0b480a6b","modified":1601215188218},{"_id":"public/images/coin-eth.png","hash":"aadb0a7d299f9a2baf2bf2d281f70d1e26e15a48","modified":1601215188218},{"_id":"public/images/bit.png","hash":"c017f11268e43727a12aa40885ea1f18056233b1","modified":1601215188218},{"_id":"public/images/coin-ltc.png","hash":"2bf87f92612990bc609dcc8826a344be05166717","modified":1601215188218},{"_id":"public/images/coding.png","hash":"42d13e784d11c72f8bb40042b2d99761ddbe8559","modified":1601215188218},{"_id":"public/images/daily.png","hash":"0671abb13bb622f27b85e14eb5341813219c3548","modified":1601215188218},{"_id":"public/images/derek_pollard.png","hash":"a09bcb5d8fe8a712b31591aa2169f751ea7591ba","modified":1601215188218},{"_id":"public/images/dcloud.gif","hash":"abb83784b95fdb175e8ffefb2ab6eb17984f6af4","modified":1601215188218},{"_id":"public/images/devsquad.png","hash":"f96551ba232f1b005512892334e912b45cc37374","modified":1601215188218},{"_id":"public/images/down.png","hash":"6ded74a98bb128e76bfd45cffede2679fd0598f0","modified":1601215188218},{"_id":"public/images/dopamine.png","hash":"2ea0928227dd6cb44ceeca4ed877feb2be741ff1","modified":1601215188218},{"_id":"public/images/devexpress.png","hash":"8b39711fba0756c8407e27de46f2641ac651f30b","modified":1601215188218},{"_id":"public/images/earthlink.png","hash":"b47c30f0093a0e8c48c5d0ae1feff24d6ef64de4","modified":1601215188218},{"_id":"public/images/fastcoding_inc.png","hash":"91d2a1c0d7b5eaf71051341a2c3b718bd8770ad1","modified":1601215188218},{"_id":"public/images/feed.png","hash":"eba32c4f87e5ea1f89dce9c68d8603c8f82a8cd9","modified":1601215188218},{"_id":"public/images/energy_comparison.png","hash":"eb8657097242bd990585ddae38ad72e8388917ca","modified":1601215188218},{"_id":"public/images/fastcoding_inc.svg","hash":"12cfd6800f3b3b37999001eb41f9ff515888bc8c","modified":1601215188218},{"_id":"public/images/frontend_love.png","hash":"ef3695d6a19646599211f886e3a27cd75a374ef6","modified":1601215188218},{"_id":"public/images/firestick_tricks.png","hash":"b43bc723f029191685f77fb573b5c0aadbc2a12d","modified":1601215188218},{"_id":"public/images/flatlogic_templates.svg","hash":"4f69bad6ed18c96049efa438a9d2f333301e11c2","modified":1601215188218},{"_id":"public/images/foo.png","hash":"30b0400c2bc6ed05e056c9b1171878b3510967ef","modified":1601215188218},{"_id":"public/images/frontendlove.png","hash":"ef3695d6a19646599211f886e3a27cd75a374ef6","modified":1601215188218},{"_id":"public/images/gitee.png","hash":"29fbe638ec4e24faad12f345399eac7f426b2772","modified":1601215188219},{"_id":"public/images/icons.png","hash":"50aa19eac3a7bf6acb435838b7a890050a4a6d8d","modified":1601215188219},{"_id":"public/images/html_burger.png","hash":"a6c54ce4ae3ad4b5f1b02a3bb1ca7da838eee8f5","modified":1601215188219},{"_id":"public/images/isle_of_code.png","hash":"ff273db09eb5ca17d047c73256ee311a9a04d911","modified":1601215188219},{"_id":"public/images/happy_programmer_llc.png","hash":"bd82c4e12cffa604e3e2d1688b333fba1eaa7113","modified":1601215188219},{"_id":"public/images/inkoop.png","hash":"fb568c6e466a6c19e5ee40bf92cf2527c58a6db2","modified":1601215188219},{"_id":"public/images/jqwidgets_ltd.png","hash":"eb4da2aec072a3f2a6c3cd322e1a44528f737177","modified":1601215188219},{"_id":"public/images/icons_8.png","hash":"4d44e5b251f72dffe37ac7007042fc0b7beb34fb","modified":1601215188219},{"_id":"public/images/logo.png","hash":"555257b8c5e7ecf34ce4f9b952eeaf006adfa339","modified":1601215188219},{"_id":"public/images/laravel.png","hash":"010281d898830dbb8c848f6a272ba46ddc95e800","modified":1601215188219},{"_id":"public/images/menu-blm.png","hash":"5214de2eac1df19a9b3854c60e99ec43a5945657","modified":1601215188219},{"_id":"public/images/menu.png","hash":"45d62574f2a22017c2aa2001964eaf560f1f70c6","modified":1601215188219},{"_id":"public/images/nativescript.png","hash":"ce3751738de68182c1e9ebab7d345227753cc5dc","modified":1601215188219},{"_id":"public/images/modus.png","hash":"d4f2c2f7292b26ce11d88d2b08ff299f4e8eb2d4","modified":1601215188219},{"_id":"public/images/neds.png","hash":"675a3f7997063c12a48946219db52948732b71b2","modified":1601215188219},{"_id":"public/images/marcus_hiles.png","hash":"08a36fa5f6bd0156a8b7ccd86ff74baf56776536","modified":1601215188219},{"_id":"public/images/moovweb.png","hash":"5f8ec63939c9991eb3deff29a7c69221e07ebf88","modified":1601215188219},{"_id":"public/images/netflix_vpn.png","hash":"54c1e9c816588a0f9d0b5619d62f953707e77dba","modified":1601215188219},{"_id":"public/images/onsen_ui.png","hash":"0dc98d72d447a8f4d3b8c43cb0890362597de194","modified":1601215188219},{"_id":"public/images/okay.png","hash":"afc75fb9af3c59c7b2ed5411ab7e90f677935d30","modified":1601215188219},{"_id":"public/images/patreon.png","hash":"bb0d0dd23c4058d8be63cdf0ccba1e6a13b05acf","modified":1601215188219},{"_id":"public/images/passionate_people.png","hash":"c637a4f55fe9d8f469a20796fe159b18fe54b327","modified":1601215188219},{"_id":"public/images/opteo.png","hash":"1915a34af45592878eacc3764dc603a81491f4ae","modified":1601215188219},{"_id":"public/images/paypal.png","hash":"b1c3741633ff0c0f8f8a0e80d68202c14a524009","modified":1601215188219},{"_id":"public/images/philip_john_basile.gif","hash":"33e8f13ef9678b8ecaa146fb45acda0057b2e090","modified":1601215188219},{"_id":"public/images/piratebay_proxy.png","hash":"98588ad87fc245df67b26bd5ada2b3b506a61f86","modified":1601215188219},{"_id":"public/images/piratebayproxy.png","hash":"98588ad87fc245df67b26bd5ada2b3b506a61f86","modified":1601215188219},{"_id":"public/images/programmers_io.png","hash":"97990feb9b226ad06f55e7dd8e7432d3cf39cc63","modified":1601215188219},{"_id":"public/images/primevue.png","hash":"636a57faddf5950b8e47319456ae1d7a0f88fd29","modified":1601215188219},{"_id":"public/images/pullrequest.svg","hash":"335566b90d53b7f844c9c41812952042fdf55225","modified":1601215188220},{"_id":"public/images/search.png","hash":"7f519d31bc3c6ca005b6ca5d8ff5ded172df627a","modified":1601215188220},{"_id":"public/images/roadster.png","hash":"5581867231c0f4059c0ea63f20717886a6e7ac9d","modified":1601215188220},{"_id":"public/images/shopware_ag.png","hash":"c440385ade9c0f9c66104bd1b1b7d41d32c0251a","modified":1601215188220},{"_id":"public/images/staff_augmentation.png","hash":"4d9475570c70eac3c3ada6ee8614b2e4a30f7d80","modified":1601215188220},{"_id":"public/images/shopware_ag.svg","hash":"658c483629cfce8eed7221d1f8463b532abaab02","modified":1601215188220},{"_id":"public/images/retool.png","hash":"08c4cbd16f45b2fe1cdc8e095982f07e959a82dc","modified":1601215188220},{"_id":"public/images/stdlib.png","hash":"7adff740e3c1a55e243dff2fb903250d1ba3f559","modified":1601215188220},{"_id":"public/images/storekit.png","hash":"47774422bb1bd1ed985ea3bb2f2ecb7754bb9983","modified":1601215188220},{"_id":"public/images/syncfusion.png","hash":"688285b2ae526c27aaa5cd081a95c881750c59cc","modified":1601215188220},{"_id":"public/images/tee__.png","hash":"e9fc652b1ed66c56be035c1a4607ade5724efc1f","modified":1601215188220},{"_id":"public/images/tendermint.png","hash":"b4c01640076893d035414016b0ee2f90994bd361","modified":1601215188220},{"_id":"public/images/tidelift.png","hash":"63c60abbab4bcc37340f29e0db8290383fb35631","modified":1601215188220},{"_id":"public/images/tighten_co.png","hash":"a0f3f8614ad7f9a4e0eaa0793cf24519b5b25e45","modified":1601215188220},{"_id":"public/images/unicorn_io.png","hash":"c93b60e72d38a6bb313a805d2d276d224fd591e8","modified":1601215188220},{"_id":"public/images/valuecoders.png","hash":"ae72f75eea4e7864c06b7641d0a4d426bdc59f18","modified":1601215188220},{"_id":"public/images/vehikl.png","hash":"e5f045088e79ac5d3aedd2d4efc5b37d15431df0","modified":1601215188220},{"_id":"public/images/tooltwist.png","hash":"e625a481e2eb3f7194273d58b250d0fafd42e462","modified":1601215188220},{"_id":"public/images/vpnranks.png","hash":"249546e6076846f8fbc7d772a6f51badd20f45af","modified":1601215188220},{"_id":"public/images/vuejobs.png","hash":"149231804a4686f1ec890f7d984207ea83cf8190","modified":1601215188220},{"_id":"public/images/vuemastery.png","hash":"a783b81f0d9ded6e8d46991cc8d18ff878e17656","modified":1601215188220},{"_id":"public/images/vpn_review.png","hash":"8d936036f5272a1d59e148355658290b2b7612c5","modified":1601215188220},{"_id":"public/images/vuetify.png","hash":"66254951f82e0639fb588b362f72b80839d9f411","modified":1601215188220},{"_id":"public/images/webdock.png","hash":"c32ce7cafbc31378c592226dac6ab8e0a8d9b124","modified":1601215188220},{"_id":"public/images/wilderminds.png","hash":"a9e87eda70ad75a6148e1a980cb4e4ddb085e3ca","modified":1601215188220},{"_id":"public/images/vueschool.png","hash":"a4ae5d18c97b8cb5a5d8fcd4c80a6230bf2fc3d9","modified":1601215188220},{"_id":"public/images/y8.png","hash":"9b584ce4cc6a0724d1dd01ce694411e54f790425","modified":1601215188220},{"_id":"public/images/watchcartoononline.png","hash":"caacc07c694704a981e6555afe1d94015ceb0505","modified":1601215188221},{"_id":"public/images/vuetraining_net__note__since_i_m_not_sure_where_else_to_put_it____this_is_replacing_vuescreencasts___they_re_both_run_by_me__i_m_just_switching_where_i_want_my_sponsorship_to_point_.png","hash":"727650000264f4cce681f796d915efb6577302f5","modified":1601215188221},{"_id":"public/images/yakaz.png","hash":"8287ea4beca210e44cde508247c09b930e48d01a","modified":1601215188221},{"_id":"public/images/x_team.png","hash":"c2d996ec0a802ce39d695266fbc142dd7dad45c0","modified":1601215188221},{"_id":"public/compiled/img/Human.svg","hash":"d072e8f88b38a9590c06b68bb4771d6c19e69e91","modified":1601215188221},{"_id":"public/compiled/img/logo.png","hash":"1a6ace377133f14a2b2cd7c48f10369a6bc54b2e","modified":1601215188221},{"_id":"public/images/icons/android-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1601215188221},{"_id":"public/images/icons/android-icon-192x192.png","hash":"b35d14364fce39e54f3896ddee44f970b7487b2c","modified":1601215188221},{"_id":"public/images/icons/android-icon-36x36.png","hash":"ea99e8a2db010e40c71fd254d3709c5fd551610d","modified":1601215188221},{"_id":"public/images/icons/android-icon-48x48.png","hash":"05c04b9833c99ddcab596fe99250a88a3e6df583","modified":1601215188221},{"_id":"public/images/icons/android-icon-96x96.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1601215188221},{"_id":"public/images/icons/apple-icon-114x114.png","hash":"07fce47fddaae024a74f027c3a8c98b385096060","modified":1601215188221},{"_id":"public/images/icons/android-icon-72x72.png","hash":"66a36856e9d0af7902abcf9f24401f68d429d0d6","modified":1601215188221},{"_id":"public/images/icons/apple-icon-120x120.png","hash":"0c55163aeba24ccf0508e49cd4ee08ba9c9757a6","modified":1601215188221},{"_id":"public/images/icons/apple-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1601215188221},{"_id":"public/images/icons/apple-icon-152x152.png","hash":"52f7579762a3dc955a9ad67a6918a049e2720164","modified":1601215188221},{"_id":"public/images/icons/apple-icon-180x180.png","hash":"5e828e492672efd0d9e6ac2b5ff46ae45ff34ab9","modified":1601215188221},{"_id":"public/images/icons/apple-icon-60x60.png","hash":"c1905c7bf23fe3f08dcecc45b1638e6a2da60f42","modified":1601215188221},{"_id":"public/images/icons/apple-icon-57x57.png","hash":"cf8ac1abcb1c53cb9b201ef082ba29a9591844d6","modified":1601215188221},{"_id":"public/images/icons/apple-icon-76x76.png","hash":"c7ad68677d2647033a60911731cf82db37784cf3","modified":1601215188221},{"_id":"public/images/icons/apple-icon-72x72.png","hash":"66a36856e9d0af7902abcf9f24401f68d429d0d6","modified":1601215188221},{"_id":"public/images/icons/apple-icon-precomposed.png","hash":"d07baf1d7200a145c15bb2b7abc9c1c864e0cdf9","modified":1601215188221},{"_id":"public/images/icons/favicon-16x16.png","hash":"03f5391b57618b4b868ad3addec3375ec03db088","modified":1601215188221},{"_id":"public/images/icons/apple-icon.png","hash":"d07baf1d7200a145c15bb2b7abc9c1c864e0cdf9","modified":1601215188221},{"_id":"public/images/icons/favicon.ico","hash":"3c5aa0ae13d561379ea8ce15f4d7e02163ef3273","modified":1601215188221},{"_id":"public/images/icons/favicon-96x96.png","hash":"7192dfc87e31d5ff5490f0be38a0a3c85584f6ac","modified":1601215188221},{"_id":"public/images/icons/favicon-32x32.png","hash":"fd0ea145dddf84c510317b7320b2c53efd850260","modified":1601215188221},{"_id":"public/images/icons/ms-icon-144x144.png","hash":"49a38f2187ebb43a2b332791fe45bddd01afbc9d","modified":1601215188221},{"_id":"public/images/icons/ms-icon-150x150.png","hash":"52c635f52bb7b91382a2f8d61f64a4ff25ae11aa","modified":1601215188221},{"_id":"public/images/icons/ms-icon-310x310.png","hash":"58f800960bae4c97a0d14bdd42f98db20c2e2bc8","modified":1601215188221},{"_id":"public/images/icons/ms-icon-70x70.png","hash":"8b326124c52e9b2e6c2826232a7627cdadbd3c0b","modified":1601215188221},{"_id":"public/images/gridsome.png","hash":"85adec48d683c206a5ccfaaf2de39c8b12ce09fb","modified":1601215188529},{"_id":"public/images/intygrate.png","hash":"f55e418bdf6b1a9fc72fee3d86ec02cc51c6d83b","modified":1601215188531},{"_id":"public/images/isolutions_uk_limited.png","hash":"067c63b7e2da8667e49f1c63a398094814657742","modified":1601215188532},{"_id":"public/images/jqwidgets_.png","hash":"6ffa378d97190dc88d4d54fa0051c36c6088e03d","modified":1601215188532},{"_id":"public/images/accelebrate.png","hash":"c20a58507563546c91813caa2d7751420a1d6cf3","modified":1601215188532},{"_id":"public/images/storyblok.png","hash":"733685fbd16245c42a9a0b2e36010c86a9549dcd","modified":1601215188532},{"_id":"public/images/usave.png","hash":"d9de7e9a012a636cdb323a62faa62d05fca33141","modified":1601215188533},{"_id":"public/images/webucator.png","hash":"940bdf955efcea9471ebcc586d371fa839496c09","modified":1601215188533},{"_id":"public/manifest.json","hash":"bf0e26610e6713f1c43af7264562605051724b43","modified":1601215188539},{"_id":"public/css/app.css","hash":"8cb2749cb6da882651245e22cf5361ca0a6fdc86","modified":1601215188539},{"_id":"public/css/search.css","hash":"cd794bd9629c33d38c76e31e8ba773ad7643f95c","modified":1601215188541},{"_id":"public/css/benchmark.css","hash":"3424ee8c27052da2ab9f544027f49e1550385e9d","modified":1601215188541},{"_id":"public/js/css.escape.js","hash":"1d0e28a08261de3955b0ee18432e304c1f468441","modified":1601215188541},{"_id":"public/js/smooth-scroll.min.js","hash":"90cdfb5d91db8cce21ab705335d591768555f474","modified":1601215188541},{"_id":"public/js/theme-data.js","hash":"4732a5b951d43b814aa903b74114a733a88f358b","modified":1601215188541},{"_id":"public/compiled/index.html","hash":"a366b4928dc6359ed87a2b06afe93bdec6da66ae","modified":1601215188542},{"_id":"public/css/index.css","hash":"f465ef579426051b689aa48f5e1b713c37c5783e","modified":1601215188542},{"_id":"public/css/page.css","hash":"7d9f420b4e307df5a363079bd0f5354fd6032e82","modified":1601215188542},{"_id":"public/js/common.js","hash":"b2573998fa99c7767537f4ec6f066eeafc20e721","modified":1601215188542},{"_id":"public/js/vue.min.js","hash":"e55df1f7d6c288ee73d439bab26dd006ffee7af3","modified":1601215188542},{"_id":"public/js/vue.js","hash":"5c39dfc37fc42400e4b4557db956f3f218a90ca7","modified":1601215188542},{"_id":"public/images/devtools-storage.png","hash":"edc4425d005028a30d2f2ae66183ecb65f0d988f","modified":1601215188542},{"_id":"public/images/bacancy_technology.png","hash":"920b3e48d4b18d454ecaeffd4e2895ceff06d1ec","modified":1601215188542},{"_id":"public/images/writers_per_hour.jpg","hash":"e4d91e160e2a34c4f2180fb0ec4e3f014f08edd1","modified":1601215188542},{"_id":"public/compiled/js/app.js","hash":"34077a5a129a8dab5411f5710d62d2657a5c567f","modified":1601215188547},{"_id":"public/compiled/js/chunk-vendors.js","hash":"0a296151a5da7315bc3bd31d9b14dedfbd4842b2","modified":1601215188547},{"_id":"public/images/memory-leak-example.png","hash":"7c2df66d99f06df266d294aa7c923fe5e8af7657","modified":1601215188555},{"_id":"public/images/icons/bacancy_technology.png","hash":"900c58a849862758c7062030f5a3aa09fd785a21","modified":1601215188555},{"_id":"public/images/oxford-comma.jpg","hash":"8c315f549b52fe61222d237ea8375a5b64a4737c","modified":1601215188559},{"_id":"public/images/special-sponsor-spot.png","hash":"f635521496f2f8a4c35c67160b088c1756b7d948","modified":1601215188559},{"_id":"public/images/devtools-timetravel.gif","hash":"43ddab8e7869a513c2058d2892b54d0c556ef5e2","modified":1601215188577},{"_id":"public/images/config_add.png","hash":"ef17eaeb40ca00f9c66d813c569c1b54160db1a9","modified":1601215188586},{"_id":"public/images/breakpoint_set.png","hash":"db3c2527261d19c83424b69d789fca4a85dbec07","modified":1601215188587},{"_id":"public/images/breakpoint_hit.png","hash":"56c93842cb88a37df7dd327507c5c44f94459e72","modified":1601215188589}],"Category":[],"Data":[],"Page":[{"index":true,"_content":"","source":"index.md","raw":"index: true\n---\n","date":"2020-09-25T23:55:41.095Z","updated":"2020-09-25T23:55:41.095Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gue0000c2v5kgw6ovq0","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# Code Of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n- Using welcoming and inclusive language\n- Being respectful of differing viewpoints and experiences\n- Gracefully accepting constructive criticism\n- Focusing on what is best for the community\n- Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n- The use of sexualized language or imagery and unwelcome sexual attention or advances\n- Trolling, insulting/derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or electronic address, without explicit permission\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at community@vuejs.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n","source":"coc/index.md","raw":"# Code Of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n- Using welcoming and inclusive language\n- Being respectful of differing viewpoints and experiences\n- Gracefully accepting constructive criticism\n- Focusing on what is best for the community\n- Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n- The use of sexualized language or imagery and unwelcome sexual attention or advances\n- Trolling, insulting/derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or electronic address, without explicit permission\n- Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at community@vuejs.org. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\n\n[homepage]: https://www.contributor-covenant.org\n","date":"2020-09-25T23:55:41.067Z","updated":"2020-09-25T23:55:41.067Z","path":"coc/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gwj0002c2v5e6p9d4t6","content":"<h1 id=\"Code-Of-Conduct\"><a href=\"#Code-Of-Conduct\" class=\"headerlink\" title=\"Code Of Conduct\"></a>Code Of Conduct</h1><h2 id=\"Our-Pledge\"><a href=\"#Our-Pledge\" class=\"headerlink\" title=\"Our Pledge\"></a>Our Pledge</h2><p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.</p>\n<h2 id=\"Our-Standards\"><a href=\"#Our-Standards\" class=\"headerlink\" title=\"Our Standards\"></a>Our Standards</h2><p>Examples of behavior that contributes to creating a positive environment include:</p>\n<ul>\n<li>Using welcoming and inclusive language</li>\n<li>Being respectful of differing viewpoints and experiences</li>\n<li>Gracefully accepting constructive criticism</li>\n<li>Focusing on what is best for the community</li>\n<li>Showing empathy towards other community members</li>\n</ul>\n<p>Examples of unacceptable behavior by participants include:</p>\n<ul>\n<li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li>\n<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>\n<li>Public or private harassment</li>\n<li>Publishing others’ private information, such as a physical or electronic address, without explicit permission</li>\n<li>Other conduct which could reasonably be considered inappropriate in a professional setting</li>\n</ul>\n<h2 id=\"Our-Responsibilities\"><a href=\"#Our-Responsibilities\" class=\"headerlink\" title=\"Our Responsibilities\"></a>Our Responsibilities</h2><p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>\n<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>\n<h2 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"Scope\"></a>Scope</h2><p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>\n<h2 id=\"Enforcement\"><a href=\"#Enforcement\" class=\"headerlink\" title=\"Enforcement\"></a>Enforcement</h2><p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <a href=\"mailto:community@vuejs.org\">community@vuejs.org</a>. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>\n<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.</p>\n<h2 id=\"Attribution\"><a href=\"#Attribution\" class=\"headerlink\" title=\"Attribution\"></a>Attribution</h2><p>This Code of Conduct is adapted from the <a href=\"https://www.contributor-covenant.org\" target=\"_blank\" rel=\"noopener\">Contributor Covenant</a>, version 1.4, available at <a href=\"https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\" target=\"_blank\" rel=\"noopener\">https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Code-Of-Conduct\"><a href=\"#Code-Of-Conduct\" class=\"headerlink\" title=\"Code Of Conduct\"></a>Code Of Conduct</h1><h2 id=\"Our-Pledge\"><a href=\"#Our-Pledge\" class=\"headerlink\" title=\"Our Pledge\"></a>Our Pledge</h2><p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, political party, or sexual identity and orientation. Note, however, that religion, political party, or other ideological affiliation provide no exemptions for the behavior we outline as unacceptable in this Code of Conduct.</p>\n<h2 id=\"Our-Standards\"><a href=\"#Our-Standards\" class=\"headerlink\" title=\"Our Standards\"></a>Our Standards</h2><p>Examples of behavior that contributes to creating a positive environment include:</p>\n<ul>\n<li>Using welcoming and inclusive language</li>\n<li>Being respectful of differing viewpoints and experiences</li>\n<li>Gracefully accepting constructive criticism</li>\n<li>Focusing on what is best for the community</li>\n<li>Showing empathy towards other community members</li>\n</ul>\n<p>Examples of unacceptable behavior by participants include:</p>\n<ul>\n<li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li>\n<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>\n<li>Public or private harassment</li>\n<li>Publishing others’ private information, such as a physical or electronic address, without explicit permission</li>\n<li>Other conduct which could reasonably be considered inappropriate in a professional setting</li>\n</ul>\n<h2 id=\"Our-Responsibilities\"><a href=\"#Our-Responsibilities\" class=\"headerlink\" title=\"Our Responsibilities\"></a>Our Responsibilities</h2><p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>\n<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>\n<h2 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"Scope\"></a>Scope</h2><p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>\n<h2 id=\"Enforcement\"><a href=\"#Enforcement\" class=\"headerlink\" title=\"Enforcement\"></a>Enforcement</h2><p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at <a href=\"mailto:community@vuejs.org\">community@vuejs.org</a>. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>\n<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project’s leadership.</p>\n<h2 id=\"Attribution\"><a href=\"#Attribution\" class=\"headerlink\" title=\"Attribution\"></a>Attribution</h2><p>This Code of Conduct is adapted from the <a href=\"https://www.contributor-covenant.org\" target=\"_blank\" rel=\"noopener\">Contributor Covenant</a>, version 1.4, available at <a href=\"https://www.contributor-covenant.org/version/1/4/code-of-conduct.html\" target=\"_blank\" rel=\"noopener\">https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</a></p>\n"},{"type":"menu","_content":"","source":"menu/index.md","raw":"---\ntype: menu\n---\n","date":"2020-09-25T23:55:41.095Z","updated":"2020-09-25T23:55:41.095Z","path":"menu/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gwm0004c2v5dxa1e03e","content":"","site":{"data":{}},"excerpt":"","more":""},{"type":"partners","partners":true,"title":"Vue Partners","proficiencies_urls":{"VueJs":"https://vuejs.org","Laravel":"https://laravel.com","Node":"https://nodejs.org"},"partners_list":[{"name":"Vehikl","logo":"vehikl.png","description":"Vehikl is a software consultancy specialising in PHP and JavaScript. We build best-in-class web applications written with popular frameworks such as Laravel, Express, NestJS, Vue, and React. Think of us as an extension of your team.","proficiencies":["VueJs","Laravel","Node","Team Augmentation"],"location":"Ontario, Canada","languages":["English"],"url_text":"www.vehikl.com","url_link":"www.vehikl.com?utm_source=vue_partners_page","hire_url":"www.vehikl.com/contact/?utm_source=vue_partners_page","email":"go+partner@vehikl.com","social_links":[{"name":"Github","class":"github","url":"https://github.com/vehikl"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/vehikl"},{"name":"Instagram","class":"instagram","url":"https://www.instagram.com/vehiklteam/"}]},{"name":"Modus Create","logo":"https://res.cloudinary.com/modus-labs/image/upload/v1533109874/modus/logo-vertical-black.svg","description":"Modus Create is a disruptive consulting firm that helps companies transform for success in the digital future.\nClients work with Modus to effect transformational change through a unique collaborative engagement model that focuses on strategy, product design/build, user experience, company culture, and process change to accelerate their response to digital disruption.\nModus is uniquely expert at executing within the new reality of global talent sourcing and globally distributed teams. Modus culture is based on recruiting only top talent regardless of their location. Modus delivers time zone-aligned, highly productive, English-speaking teams, accessibility, and a totally collaborative environment regardless of individual location. ","proficiencies":[{"name":"Vue.js","url":"https://moduscreate.com/partners/vue/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"AWS","url":"https://moduscreate.com/partners/aws/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Atlassian","url":"https://moduscreate.com/partners/atlassian/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Ionic","url":"https://moduscreate.com/partners/ionic/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Product Management","url":"https://moduscreate.com/what-we-do/product-management/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Customer Experience","url":"https://moduscreate.com/what-we-do/customer-experience/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Agile Transformation","url":"https://moduscreate.com/what-we-do/agile-transformation/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"},{"name":"Cloud Migration","url":"https://moduscreate.com/what-we-do/cloud-migration/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage"}],"location":"Reston, VA, USA / Los Angeles, CA, USA / Cluj, Romania / San José, Costa Rica","languages":["English","Global"],"url_text":"moduscreate.com","url_link":"moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage","hire_url":"moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage","email":"contact@moduscreate.com","social_links":[{"name":"Github","class":"github","url":"https://github.com/ModusCreateOrg"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/ModusCreate"},{"name":"LinkedIn","class":"linkedin","url":"https://www.linkedin.com/company/modus-create-inc"},{"name":"YouTube","class":"youtube","url":"https://www.youtube.com/moduscreate"}]},{"name":"Monterail","logo":"Monterail.png","description":"Monterail is a full-service software development company with 110+ experts on board delivering meaningful software for start-ups, SMBs and enterprises. We are organizers of the first official Vue-related conference in the world and authors of the State of Vue.js report (2017&2019). Our experts delivered 30 Vue.js-based projects so far.","proficiencies":[{"name":"VueJs","url":"https://hi.monterail.co/2NqPUa6"},{"name":"Ruby on Rails","url":"https://hi.monterail.co/31RvfBm"},{"name":"Javascript","url":"https://hi.monterail.co/34cWQhR"},{"name":"Python","url":"https://hi.monterail.co/2MXHLeb"},{"name":"Services","url":"https://www.monterail.com/services?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js"},{"name":"Projects","url":"https://www.monterail.com/projects?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js"}],"location":"Wrocław, Poland","languages":["English","Polish"],"url_text":"www.monterail.com","url_link":"www.monterail.com/services/vue-development?utm_campaign=Vue.js&utm_source=partner-list","hire_url":"www.monterail.com/contact","email":"hello@monterail.com","social_links":[{"name":"Github","class":"github","url":"https://github.com/monterail"},{"name":"Linkedin","class":"linkedin","url":"https://www.linkedin.com/company/monterail"},{"name":"Facebook","class":"facebook","url":"https://www.facebook.com/monterail/"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/monterail"},{"name":"Instagram","class":"instagram","url":"https://www.instagram.com/monterail/"}]},{"name":"Rangle","logo":"https://res.cloudinary.com/rangle/image/upload/q_auto,f_auto/vuejs.org/rangle_black_lockup_n6q48z.png","description":"Rangle is a global digital consultancy that helps ambitious organizations outperform the competition in the most demanding markets. We work closely with our clients as one team to imagine, design, and deliver human-centered digital experiences that create lasting results and real business value. Anchored in innovation and lean startup best-practices, our unique delivery and partnership model is purposed-built to this task.","proficiencies":[{"name":"Building Products","url":"https://rangle.io/#build-a-product/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Improving Experiences","url":"https://rangle.io/#improve-an-experience/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Training & Coaching","url":"https://rangle.io/#level-up-your-team/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Agile Transformation","url":"https://rangle.io/#adopt-agile-delivery/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"},{"name":"Business Transformation","url":"https://rangle.io/#transform-your-business/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners"}],"location":"Toronto, ON, CA　Atlanta, GA, USA　Amsterdam, Netherlands　Tokyo, Japan","languages":["English","French","Dutch"],"url_text":"rangle.io","url_link":"rangle.io/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners","hire_url":"rangle.io/contact-us/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners","email":"info@rangle.io","social_links":[{"name":"GitHub","class":"github","url":"https://github.com/rangle"},{"name":"LinkedIn","class":"linkedin","url":"https://www.linkedin.com/company/rangle/"},{"name":"Twitter","class":"twitter","url":"https://twitter.com/rangleio"},{"name":"Instagram","class":"instagram","url":"https://www.instagram.com/rangleio/?hl=en"}]}],"_content":"","source":"resources/partners.md","raw":"---\ntype: partners\npartners: true\ntitle: Vue Partners\nproficiencies_urls:\n  VueJs: https://vuejs.org\n  Laravel: https://laravel.com\n  Node: https://nodejs.org\npartners_list:\n    -\n        name: Vehikl\n        logo: vehikl.png\n        description:\n            Vehikl is a software consultancy specialising in PHP and JavaScript. We build best-in-class web applications written with popular frameworks such as Laravel, Express, NestJS, Vue, and React. Think of us as an extension of your team.\n        proficiencies:\n            - VueJs\n            - Laravel\n            - Node\n            - Team Augmentation\n        location: Ontario, Canada\n        languages:\n            - English\n        url_text: www.vehikl.com\n        url_link: www.vehikl.com?utm_source=vue_partners_page\n        hire_url: www.vehikl.com/contact/?utm_source=vue_partners_page\n        email: go+partner@vehikl.com\n        social_links:\n            -\n                name: Github\n                class: github\n                url: 'https://github.com/vehikl'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/vehikl'\n            -\n                name: Instagram\n                class: instagram\n                url: 'https://www.instagram.com/vehiklteam/'\n\n    -\n        name: Modus Create\n        logo: https://res.cloudinary.com/modus-labs/image/upload/v1533109874/modus/logo-vertical-black.svg\n        description:\n            \"Modus Create is a disruptive consulting firm that helps companies transform for success in the digital future.\n\n            Clients work with Modus to effect transformational change through a unique collaborative engagement model that focuses on strategy, product design/build, user experience, company culture, and process change to accelerate their response to digital disruption.\n\n            Modus is uniquely expert at executing within the new reality of global talent sourcing and globally distributed teams. Modus culture is based on recruiting only top talent regardless of their location. Modus delivers time zone-aligned, highly productive, English-speaking teams, accessibility, and a totally collaborative environment regardless of individual location.\n\"\n        proficiencies:\n            - name: Vue.js\n              url: https://moduscreate.com/partners/vue/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: AWS\n              url: https://moduscreate.com/partners/aws/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Atlassian\n              url: https://moduscreate.com/partners/atlassian/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Ionic\n              url: https://moduscreate.com/partners/ionic/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Product Management\n              url: https://moduscreate.com/what-we-do/product-management/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Customer Experience\n              url: https://moduscreate.com/what-we-do/customer-experience/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Agile Transformation\n              url: https://moduscreate.com/what-we-do/agile-transformation/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n            - name: Cloud Migration\n              url: https://moduscreate.com/what-we-do/cloud-migration/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n        location: Reston, VA, USA / Los Angeles, CA, USA / Cluj, Romania / San José, Costa Rica\n        languages:\n            - English\n            - Global\n        url_text: moduscreate.com\n        url_link: moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n        hire_url: moduscreate.com/?utm_source=Vue&utm_medium=Partner-Page&utm_campaign=Vue_partnerpage\n        email: contact@moduscreate.com\n        social_links:\n            -\n                name: Github\n                class: github\n                url: 'https://github.com/ModusCreateOrg'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/ModusCreate'\n            -\n                name: LinkedIn\n                class: linkedin\n                url: 'https://www.linkedin.com/company/modus-create-inc'\n            -\n                name: YouTube\n                class: youtube\n                url: 'https://www.youtube.com/moduscreate'\n    -\n        name: Monterail\n        logo: Monterail.png\n        description:\n            \"Monterail is a full-service software development company with 110+ experts on board delivering meaningful software for start-ups, SMBs and enterprises. We are organizers of the first official Vue-related conference in the world and authors of the State of Vue.js report (2017&2019). Our experts delivered 30 Vue.js-based projects so far.\"\n        proficiencies:\n            - name: VueJs\n              url: https://hi.monterail.co/2NqPUa6\n            - name: Ruby on Rails\n              url: https://hi.monterail.co/31RvfBm\n            - name: Javascript\n              url: https://hi.monterail.co/34cWQhR\n            - name: Python\n              url: https://hi.monterail.co/2MXHLeb\n            - name: Services\n              url:  https://www.monterail.com/services?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js\n            - name: Projects\n              url:  https://www.monterail.com/projects?utm_medium=referral&utm_source=partner-list&utm_campaign=vue.js\n        location: Wrocław, Poland\n        languages:\n            - English\n            - Polish\n        url_text: www.monterail.com\n        url_link: www.monterail.com/services/vue-development?utm_campaign=Vue.js&utm_source=partner-list\n        hire_url: www.monterail.com/contact\n        email: hello@monterail.com\n        social_links:\n            -\n                name: Github\n                class: github\n                url: 'https://github.com/monterail'\n            -\n                name: Linkedin\n                class: linkedin\n                url: 'https://www.linkedin.com/company/monterail'\n            -\n                name: Facebook\n                class: facebook\n                url: 'https://www.facebook.com/monterail/'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/monterail'\n            -\n                name: Instagram\n                class: instagram\n                url: 'https://www.instagram.com/monterail/'\n    -\n        name: Rangle\n        logo: https://res.cloudinary.com/rangle/image/upload/q_auto,f_auto/vuejs.org/rangle_black_lockup_n6q48z.png\n        description:\n            \"Rangle is a global digital consultancy that helps ambitious organizations outperform the competition in the most demanding markets. We work closely with our clients as one team to imagine, design, and deliver human-centered digital experiences that create lasting results and real business value. Anchored in innovation and lean startup best-practices, our unique delivery and partnership model is purposed-built to this task.\"\n        proficiencies:\n            - name: Building Products\n              url: https://rangle.io/#build-a-product/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Improving Experiences\n              url: https://rangle.io/#improve-an-experience/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Training & Coaching\n              url: https://rangle.io/#level-up-your-team/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Agile Transformation\n              url: https://rangle.io/#adopt-agile-delivery/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n            - name: Business Transformation\n              url: https://rangle.io/#transform-your-business/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n        location: Toronto, ON, CA　Atlanta, GA, USA　Amsterdam, Netherlands　Tokyo, Japan\n        languages:\n            - English\n            - French\n            - Dutch\n        url_text: rangle.io\n        url_link: rangle.io/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n        hire_url: rangle.io/contact-us/?utm_source=referral&utm_medium=partner&utm_campaign=vue-partners\n        email: info@rangle.io\n        social_links:\n            -\n                name: GitHub\n                class: github\n                url: 'https://github.com/rangle'\n            -\n                name: LinkedIn\n                class: linkedin\n                url: 'https://www.linkedin.com/company/rangle/'\n            -\n                name: Twitter\n                class: twitter\n                url: 'https://twitter.com/rangleio'\n            -\n                name: Instagram\n                class: instagram\n                url: 'https://www.instagram.com/rangleio/?hl=en'\n---\n","date":"2020-09-25T23:55:41.096Z","updated":"2020-09-25T23:55:41.096Z","path":"resources/partners.html","comments":1,"layout":"page","_id":"ckfl66gwn0006c2v5svd0yk8j","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Themes","type":"resources","order":804,"_content":"{% raw %}\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n{% endraw %}\n","source":"resources/themes.md","raw":"---\ntitle: Themes\ntype: resources\norder: 804\n---\n{% raw %}\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n{% endraw %}\n","date":"2020-09-25T23:55:41.096Z","updated":"2020-09-25T23:55:41.096Z","path":"resources/themes.html","comments":1,"layout":"page","_id":"ckfl66gwq0008c2v5lx4ks9em","content":"\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n\n","site":{"data":{}},"excerpt":"","more":"\n<div id=\"themes\">\n  <section v-for=\"partner in partners\" :key=\"partner.name\" class=\"partner-wrapper\">\n    <partner-component :partner=\"partner\"></partner-component>\n  </section>\n\n  <p>\n    Want to feature your themes here?\n    <a href=\"mailto:evan@vuejs.org?subject=Theme+affiliation\">Contact us</a>!\n  </p>\n</div>\n\n<script type=\"text/template\" id=\"partnerTemplate\">\n  <div>\n    <h2 :id=\"partner.name\">{{partner.name}}</h2>\n    <blockquote class=\"theme-partner-description\" v-html=\"partnerDescription\"></blockquote>\n    <div class=\"themes-grid\">\n      <div v-for=\"product in partner.products\" :key=\"product.url\" class=\"item-preview\">\n        <a class=\"item-preview-img\" :href=\"product.url\" rel=\"sponsored\">\n          <img :src=\"product.image\" :alt=\"`${product.name} - ${product.description}`\" loading=\"lazy\">\n        </a>\n        <div class=\"item-preview-name-container\">\n          <h3 class=\"item-preview-name\" :class=\"{'free': product.price === 0}\">\n            {{product.name}}\n          </h3>\n          <b v-if=\"product.price\" class=\"item-preview-price\">${{product.price}}</b>\n        </div>\n        <div class=\"item-preview-description\">{{product.description}}</div>\n      </div>\n      <div class=\"see-more-container\">\n        <a :href=\"partner.seeMoreUrl\" class=\"button white see-more-link\">See More Themes from {{partner.name}}</a>\n      </div>\n    </div>\n  </div>\n</script>\n\n<script>\nvar mdConverter = new showdown.Converter()\n\nVue.component('partner-component', {\n  template: document.getElementById('partnerTemplate').innerHTML,\n  props: {\n    partner: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    partnerDescription: function () {\n      return mdConverter.makeHtml(this.partner.description)\n    }\n  }\n})\n\nconst app = new Vue({\n  el: '#themes',\n  data: function () {\n    return {\n      partners: themeData\n    }\n  }\n})\n</script>\n\n"},{"sponsors":true,"type":"sponsors","_content":"","source":"support-vuejs/index.md","raw":"---\nsponsors: true\ntype: sponsors\n---\n","date":"2020-09-25T23:55:41.096Z","updated":"2020-09-25T23:55:41.096Z","path":"support-vuejs/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gx8000gc2v5zng00w9p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Avoiding Memory Leaks","type":"cookbook","order":10,"_content":"\n## Introduction\n\nIf you are developing applications with Vue, then you need to watch out for memory leaks. This issue is especially important in Single Page Applications (SPAs) because by design, users should not have to refresh their browser when using an SPA, so it is up to the JavaScript application to clean up components and make sure that garbage collection takes place as expected.\n\nMemory leaks in Vue applications do not typically come from Vue itself, rather they can happen when incorporating other libraries into an application.\n\n## Simple Example\n\nThe following example shows a memory leak caused by using the [Choices.js](https://github.com/jshjohnson/Choices) library in a Vue component and not properly cleaning it up. Later, we will show how to remove the Choices.js footprint and avoid the memory leak.\n\nIn the example below, we load up a select with a lot of options and then we use a show/hide button with a [v-if](/v2/guide/conditional.html) directive to add it and remove it from the virtual DOM. The problem with this example is that the `v-if` directive removes the parent element from the DOM, but we did not clean up the additional DOM pieces created by Choices.js, causing a memory leak.\n\n```html\n<link rel='stylesheet prefetch' href='https://joshuajohnson.co.uk/Choices/assets/styles/css/choices.min.css?version=3.0.3'>\n<script src='https://joshuajohnson.co.uk/Choices/assets/scripts/dist/choices.min.js?version=3.0.3'></script>\n\n<div id=\"app\">\n  <button\n    v-if=\"showChoices\"\n    @click=\"hide\"\n  >Hide</button>\n  <button\n    v-if=\"!showChoices\"\n    @click=\"show\"\n  >Show</button>\n  <div v-if=\"showChoices\">\n    <select id=\"choices-single-default\"></select>\n  </div>\n</div>\n```\n\n```js\nnew Vue({\n  el: \"#app\",\n  data: function () {\n    return {\n      showChoices: true\n    }\n  },\n  mounted: function () {\n    this.initializeChoices()\n  },\n  methods: {\n    initializeChoices: function () {\n      let list = []\n      // lets load up our select with many choices\n      // so it will use a lot of memory\n      for (let i = 0; i < 1000; i++) {\n        list.push({\n          label: \"Item \" + i,\n          value: i\n        })\n      }\n      new Choices(\"#choices-single-default\", {\n        searchEnabled: true,\n        removeItemButton: true,\n        choices: list\n      })\n    },\n    show: function () {\n      this.showChoices = true\n      this.$nextTick(() => {\n        this.initializeChoices()\n      })\n    },\n    hide: function () {\n      this.showChoices = false\n    }\n  }\n})\n```\n\nTo see this memory leak in action, open this [CodePen example](https://codepen.io/freeman-g/pen/qobpxo) using Chrome and then open the Chrome Task Manager. To open the Chrome Task Manager on Mac, choose Chrome Top Navigation > Window > Task Manager or on Windows, use the Shift+Esc shortcut. Now, click the show/hide button 50 or so times. You should see the memory usage in the Chrome Task Manager increase and never be reclaimed.\n\n![Memory Leak Example](/images/memory-leak-example.png)\n\n## Resolving the Memory Leak\n\nIn the above example, we can use our `hide()` method to do some clean up and solve the memory leak prior to removing the select from the DOM. To accomplish this, we will keep a property in our Vue instance’s data object and we will use the [Choices API’s](https://github.com/jshjohnson/Choices) `destroy()` method to perform the clean up.\n\nCheck the memory usage again with this [updated CodePen example](https://codepen.io/freeman-g/pen/mxWMor).\n\n```js\nnew Vue({\n  el: \"#app\",\n  data: function () {\n    return {\n      showChoices: true,\n      choicesSelect: null\n    }\n  },\n  mounted: function () {\n    this.initializeChoices()\n  },\n  methods: {\n    initializeChoices: function () {\n      let list = []\n      for (let i = 0; i < 1000; i++) {\n        list.push({\n          label: \"Item \" + i,\n          value: i\n        })\n      }\n      // Set a reference to our choicesSelect in our Vue instance's data object\n      this.choicesSelect = new Choices(\"#choices-single-default\", {\n        searchEnabled: true,\n        removeItemButton: true,\n        choices: list\n      })\n    },\n    show: function () {\n      this.showChoices = true\n      this.$nextTick(() => {\n        this.initializeChoices()\n      })\n    },\n    hide: function () {\n      // now we can use the reference to Choices to perform clean up here\n      // prior to removing the elements from the DOM\n      this.choicesSelect.destroy()\n      this.showChoices = false\n    }\n  }\n})\n```\n\n## Details about the Value\n\nMemory management and performance testing can easily be neglected in the excitement of shipping quickly, however, keeping a small memory footprint is still important to your overall user experience.\n\nConsider the types of devices your users may be using and what their normal flow will be. Could they use memory constrained laptops or mobile devices? Do your users typically do lots of in-application navigation? If either of these are true, then good memory management practices can help you avoid the worst case scenario of crashing a user’s browser. Even if neither of these are true, you can still potentially have degradation of performance over extended usage of your app if you are not careful.\n\n## Real-World Example\n\nIn the above example, we used a `v-if` directive to illustrate the memory leak, but a more common real-world scenario happens when using [vue-router](https://router.vuejs.org/en/) to route to components in a Single Page Application.\n\nJust like the `v-if` directive, `vue-router` removes elements from the virtual DOM and replaces those with new elements when a user navigates around your application. The Vue `beforeDestroy()` [lifecycle hook](/v2/guide/instance.html#Lifecycle-Diagram) is a good place to solve the same sort of issue in a `vue-router` based application.\n\nWe could move our clean up into the `beforeDestroy()` hook like this:\n\n```js\nbeforeDestroy: function () {\n    this.choicesSelect.destroy()\n}\n```\n\n## Alternative Patterns\n\nWe have discussed managing memory when removing elements, but what if you intentionally want to preserve state and keep elements in memory? In this case, you can use the built-in component [keep-alive](/v2/api/#keep-alive).\n\nWhen you wrap a component with `keep-alive`, its state will be preserved and therefore kept in memory.\n\n```html\n<button @click=\"show = false\">Hide</button>\n<keep-alive>\n  <!-- my-component will be intentionally kept in memory even when removed -->\n  <my-component v-if=\"show\"></my-component>\n</keep-alive>\n```\nThis technique can be useful to improve user experience. For example, imagine a user starts entering comments into a text input and then decides to navigate away. If the user then navigated back, their comments would still be preserved.\n\nOnce you use keep-alive, then you have access to two more lifecycle hooks: `activated` and `deactivated`. If you do want to clean up or change data when a keep-alive component is removed, you can do so in the `deactivated` hook.\n\n```js\ndeactivated: function () {\n  // remove any data you do not want to keep alive\n}\n```\n\n## Wrapping Up\n\nVue makes it very easy to develop amazing, reactive JavaScript applications, but you still need to be careful about memory leaks. These leaks will often occur when using additional 3rd Party libraries that manipulate the DOM outside of Vue. Make sure to test your application for memory leaks and take appropriate steps to clean up components where necessary.","source":"v2/cookbook/avoiding-memory-leaks.md","raw":"---\ntitle: Avoiding Memory Leaks\ntype: cookbook\norder: 10\n---\n\n## Introduction\n\nIf you are developing applications with Vue, then you need to watch out for memory leaks. This issue is especially important in Single Page Applications (SPAs) because by design, users should not have to refresh their browser when using an SPA, so it is up to the JavaScript application to clean up components and make sure that garbage collection takes place as expected.\n\nMemory leaks in Vue applications do not typically come from Vue itself, rather they can happen when incorporating other libraries into an application.\n\n## Simple Example\n\nThe following example shows a memory leak caused by using the [Choices.js](https://github.com/jshjohnson/Choices) library in a Vue component and not properly cleaning it up. Later, we will show how to remove the Choices.js footprint and avoid the memory leak.\n\nIn the example below, we load up a select with a lot of options and then we use a show/hide button with a [v-if](/v2/guide/conditional.html) directive to add it and remove it from the virtual DOM. The problem with this example is that the `v-if` directive removes the parent element from the DOM, but we did not clean up the additional DOM pieces created by Choices.js, causing a memory leak.\n\n```html\n<link rel='stylesheet prefetch' href='https://joshuajohnson.co.uk/Choices/assets/styles/css/choices.min.css?version=3.0.3'>\n<script src='https://joshuajohnson.co.uk/Choices/assets/scripts/dist/choices.min.js?version=3.0.3'></script>\n\n<div id=\"app\">\n  <button\n    v-if=\"showChoices\"\n    @click=\"hide\"\n  >Hide</button>\n  <button\n    v-if=\"!showChoices\"\n    @click=\"show\"\n  >Show</button>\n  <div v-if=\"showChoices\">\n    <select id=\"choices-single-default\"></select>\n  </div>\n</div>\n```\n\n```js\nnew Vue({\n  el: \"#app\",\n  data: function () {\n    return {\n      showChoices: true\n    }\n  },\n  mounted: function () {\n    this.initializeChoices()\n  },\n  methods: {\n    initializeChoices: function () {\n      let list = []\n      // lets load up our select with many choices\n      // so it will use a lot of memory\n      for (let i = 0; i < 1000; i++) {\n        list.push({\n          label: \"Item \" + i,\n          value: i\n        })\n      }\n      new Choices(\"#choices-single-default\", {\n        searchEnabled: true,\n        removeItemButton: true,\n        choices: list\n      })\n    },\n    show: function () {\n      this.showChoices = true\n      this.$nextTick(() => {\n        this.initializeChoices()\n      })\n    },\n    hide: function () {\n      this.showChoices = false\n    }\n  }\n})\n```\n\nTo see this memory leak in action, open this [CodePen example](https://codepen.io/freeman-g/pen/qobpxo) using Chrome and then open the Chrome Task Manager. To open the Chrome Task Manager on Mac, choose Chrome Top Navigation > Window > Task Manager or on Windows, use the Shift+Esc shortcut. Now, click the show/hide button 50 or so times. You should see the memory usage in the Chrome Task Manager increase and never be reclaimed.\n\n![Memory Leak Example](/images/memory-leak-example.png)\n\n## Resolving the Memory Leak\n\nIn the above example, we can use our `hide()` method to do some clean up and solve the memory leak prior to removing the select from the DOM. To accomplish this, we will keep a property in our Vue instance’s data object and we will use the [Choices API’s](https://github.com/jshjohnson/Choices) `destroy()` method to perform the clean up.\n\nCheck the memory usage again with this [updated CodePen example](https://codepen.io/freeman-g/pen/mxWMor).\n\n```js\nnew Vue({\n  el: \"#app\",\n  data: function () {\n    return {\n      showChoices: true,\n      choicesSelect: null\n    }\n  },\n  mounted: function () {\n    this.initializeChoices()\n  },\n  methods: {\n    initializeChoices: function () {\n      let list = []\n      for (let i = 0; i < 1000; i++) {\n        list.push({\n          label: \"Item \" + i,\n          value: i\n        })\n      }\n      // Set a reference to our choicesSelect in our Vue instance's data object\n      this.choicesSelect = new Choices(\"#choices-single-default\", {\n        searchEnabled: true,\n        removeItemButton: true,\n        choices: list\n      })\n    },\n    show: function () {\n      this.showChoices = true\n      this.$nextTick(() => {\n        this.initializeChoices()\n      })\n    },\n    hide: function () {\n      // now we can use the reference to Choices to perform clean up here\n      // prior to removing the elements from the DOM\n      this.choicesSelect.destroy()\n      this.showChoices = false\n    }\n  }\n})\n```\n\n## Details about the Value\n\nMemory management and performance testing can easily be neglected in the excitement of shipping quickly, however, keeping a small memory footprint is still important to your overall user experience.\n\nConsider the types of devices your users may be using and what their normal flow will be. Could they use memory constrained laptops or mobile devices? Do your users typically do lots of in-application navigation? If either of these are true, then good memory management practices can help you avoid the worst case scenario of crashing a user’s browser. Even if neither of these are true, you can still potentially have degradation of performance over extended usage of your app if you are not careful.\n\n## Real-World Example\n\nIn the above example, we used a `v-if` directive to illustrate the memory leak, but a more common real-world scenario happens when using [vue-router](https://router.vuejs.org/en/) to route to components in a Single Page Application.\n\nJust like the `v-if` directive, `vue-router` removes elements from the virtual DOM and replaces those with new elements when a user navigates around your application. The Vue `beforeDestroy()` [lifecycle hook](/v2/guide/instance.html#Lifecycle-Diagram) is a good place to solve the same sort of issue in a `vue-router` based application.\n\nWe could move our clean up into the `beforeDestroy()` hook like this:\n\n```js\nbeforeDestroy: function () {\n    this.choicesSelect.destroy()\n}\n```\n\n## Alternative Patterns\n\nWe have discussed managing memory when removing elements, but what if you intentionally want to preserve state and keep elements in memory? In this case, you can use the built-in component [keep-alive](/v2/api/#keep-alive).\n\nWhen you wrap a component with `keep-alive`, its state will be preserved and therefore kept in memory.\n\n```html\n<button @click=\"show = false\">Hide</button>\n<keep-alive>\n  <!-- my-component will be intentionally kept in memory even when removed -->\n  <my-component v-if=\"show\"></my-component>\n</keep-alive>\n```\nThis technique can be useful to improve user experience. For example, imagine a user starts entering comments into a text input and then decides to navigate away. If the user then navigated back, their comments would still be preserved.\n\nOnce you use keep-alive, then you have access to two more lifecycle hooks: `activated` and `deactivated`. If you do want to clean up or change data when a keep-alive component is removed, you can do so in the `deactivated` hook.\n\n```js\ndeactivated: function () {\n  // remove any data you do not want to keep alive\n}\n```\n\n## Wrapping Up\n\nVue makes it very easy to develop amazing, reactive JavaScript applications, but you still need to be careful about memory leaks. These leaks will often occur when using additional 3rd Party libraries that manipulate the DOM outside of Vue. Make sure to test your application for memory leaks and take appropriate steps to clean up components where necessary.","date":"2020-09-25T23:55:41.104Z","updated":"2020-09-25T23:55:41.104Z","path":"v2/cookbook/avoiding-memory-leaks.html","comments":1,"layout":"page","_id":"ckfl66gy0000hc2v5zh0gitgm","content":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>If you are developing applications with Vue, then you need to watch out for memory leaks. This issue is especially important in Single Page Applications (SPAs) because by design, users should not have to refresh their browser when using an SPA, so it is up to the JavaScript application to clean up components and make sure that garbage collection takes place as expected.</p>\n<p>Memory leaks in Vue applications do not typically come from Vue itself, rather they can happen when incorporating other libraries into an application.</p>\n<h2 id=\"Simple-Example\"><a href=\"#Simple-Example\" class=\"headerlink\" title=\"Simple Example\"></a>Simple Example</h2><p>The following example shows a memory leak caused by using the <a href=\"https://github.com/jshjohnson/Choices\" target=\"_blank\" rel=\"noopener\">Choices.js</a> library in a Vue component and not properly cleaning it up. Later, we will show how to remove the Choices.js footprint and avoid the memory leak.</p>\n<p>In the example below, we load up a select with a lot of options and then we use a show/hide button with a <a href=\"/v2/guide/conditional.html\">v-if</a> directive to add it and remove it from the virtual DOM. The problem with this example is that the <code>v-if</code> directive removes the parent element from the DOM, but we did not clean up the additional DOM pieces created by Choices.js, causing a memory leak.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">'stylesheet prefetch'</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">'https://joshuajohnson.co.uk/Choices/assets/styles/css/choices.min.css?version=3.0.3'</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">'https://joshuajohnson.co.uk/Choices/assets/scripts/dist/choices.min.js?version=3.0.3'</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"showChoices\"</span>\n    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"hide\"</span>\n  &gt;</span>Hide<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"!showChoices\"</span>\n    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"show\"</span>\n  &gt;</span>Show<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"showChoices\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"choices-single-default\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\"#app\"</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">showChoices</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initializeChoices()\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">initializeChoices</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">let</span> list = []\n      <span class=\"hljs-comment\">// lets load up our select with many choices</span>\n      <span class=\"hljs-comment\">// so it will use a lot of memory</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++) &#123;\n        list.push(&#123;\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">\"Item \"</span> + i,\n          <span class=\"hljs-attr\">value</span>: i\n        &#125;)\n      &#125;\n      <span class=\"hljs-keyword\">new</span> Choices(<span class=\"hljs-string\">\"#choices-single-default\"</span>, &#123;\n        <span class=\"hljs-attr\">searchEnabled</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">removeItemButton</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">choices</span>: list\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">show</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.initializeChoices()\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">hide</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">false</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>To see this memory leak in action, open this <a href=\"https://codepen.io/freeman-g/pen/qobpxo\" target=\"_blank\" rel=\"noopener\">CodePen example</a> using Chrome and then open the Chrome Task Manager. To open the Chrome Task Manager on Mac, choose Chrome Top Navigation &gt; Window &gt; Task Manager or on Windows, use the Shift+Esc shortcut. Now, click the show/hide button 50 or so times. You should see the memory usage in the Chrome Task Manager increase and never be reclaimed.</p>\n<p><img src=\"/images/memory-leak-example.png\" alt=\"Memory Leak Example\"></p>\n<h2 id=\"Resolving-the-Memory-Leak\"><a href=\"#Resolving-the-Memory-Leak\" class=\"headerlink\" title=\"Resolving the Memory Leak\"></a>Resolving the Memory Leak</h2><p>In the above example, we can use our <code>hide()</code> method to do some clean up and solve the memory leak prior to removing the select from the DOM. To accomplish this, we will keep a property in our Vue instance’s data object and we will use the <a href=\"https://github.com/jshjohnson/Choices\" target=\"_blank\" rel=\"noopener\">Choices API’s</a> <code>destroy()</code> method to perform the clean up.</p>\n<p>Check the memory usage again with this <a href=\"https://codepen.io/freeman-g/pen/mxWMor\" target=\"_blank\" rel=\"noopener\">updated CodePen example</a>.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\"#app\"</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">showChoices</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">choicesSelect</span>: <span class=\"hljs-literal\">null</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initializeChoices()\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">initializeChoices</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">let</span> list = []\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++) &#123;\n        list.push(&#123;\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">\"Item \"</span> + i,\n          <span class=\"hljs-attr\">value</span>: i\n        &#125;)\n      &#125;\n      <span class=\"hljs-comment\">// Set a reference to our choicesSelect in our Vue instance's data object</span>\n      <span class=\"hljs-keyword\">this</span>.choicesSelect = <span class=\"hljs-keyword\">new</span> Choices(<span class=\"hljs-string\">\"#choices-single-default\"</span>, &#123;\n        <span class=\"hljs-attr\">searchEnabled</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">removeItemButton</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">choices</span>: list\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">show</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.initializeChoices()\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">hide</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// now we can use the reference to Choices to perform clean up here</span>\n      <span class=\"hljs-comment\">// prior to removing the elements from the DOM</span>\n      <span class=\"hljs-keyword\">this</span>.choicesSelect.destroy()\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">false</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<h2 id=\"Details-about-the-Value\"><a href=\"#Details-about-the-Value\" class=\"headerlink\" title=\"Details about the Value\"></a>Details about the Value</h2><p>Memory management and performance testing can easily be neglected in the excitement of shipping quickly, however, keeping a small memory footprint is still important to your overall user experience.</p>\n<p>Consider the types of devices your users may be using and what their normal flow will be. Could they use memory constrained laptops or mobile devices? Do your users typically do lots of in-application navigation? If either of these are true, then good memory management practices can help you avoid the worst case scenario of crashing a user’s browser. Even if neither of these are true, you can still potentially have degradation of performance over extended usage of your app if you are not careful.</p>\n<h2 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h2><p>In the above example, we used a <code>v-if</code> directive to illustrate the memory leak, but a more common real-world scenario happens when using <a href=\"https://router.vuejs.org/en/\" target=\"_blank\" rel=\"noopener\">vue-router</a> to route to components in a Single Page Application.</p>\n<p>Just like the <code>v-if</code> directive, <code>vue-router</code> removes elements from the virtual DOM and replaces those with new elements when a user navigates around your application. The Vue <code>beforeDestroy()</code> <a href=\"/v2/guide/instance.html#Lifecycle-Diagram\">lifecycle hook</a> is a good place to solve the same sort of issue in a <code>vue-router</code> based application.</p>\n<p>We could move our clean up into the <code>beforeDestroy()</code> hook like this:</p>\n<pre><code class=\"hljs js\">beforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.choicesSelect.destroy()\n&#125;</code></pre>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>We have discussed managing memory when removing elements, but what if you intentionally want to preserve state and keep elements in memory? In this case, you can use the built-in component <a href=\"/v2/api/#keep-alive\">keep-alive</a>.</p>\n<p>When you wrap a component with <code>keep-alive</code>, its state will be preserved and therefore kept in memory.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"show = false\"</span>&gt;</span>Hide<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- my-component will be intentionally kept in memory even when removed --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"show\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>This technique can be useful to improve user experience. For example, imagine a user starts entering comments into a text input and then decides to navigate away. If the user then navigated back, their comments would still be preserved.</p>\n<p>Once you use keep-alive, then you have access to two more lifecycle hooks: <code>activated</code> and <code>deactivated</code>. If you do want to clean up or change data when a keep-alive component is removed, you can do so in the <code>deactivated</code> hook.</p>\n<pre><code class=\"hljs js\">deactivated: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// remove any data you do not want to keep alive</span>\n&#125;</code></pre>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>Vue makes it very easy to develop amazing, reactive JavaScript applications, but you still need to be careful about memory leaks. These leaks will often occur when using additional 3rd Party libraries that manipulate the DOM outside of Vue. Make sure to test your application for memory leaks and take appropriate steps to clean up components where necessary.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>If you are developing applications with Vue, then you need to watch out for memory leaks. This issue is especially important in Single Page Applications (SPAs) because by design, users should not have to refresh their browser when using an SPA, so it is up to the JavaScript application to clean up components and make sure that garbage collection takes place as expected.</p>\n<p>Memory leaks in Vue applications do not typically come from Vue itself, rather they can happen when incorporating other libraries into an application.</p>\n<h2 id=\"Simple-Example\"><a href=\"#Simple-Example\" class=\"headerlink\" title=\"Simple Example\"></a>Simple Example</h2><p>The following example shows a memory leak caused by using the <a href=\"https://github.com/jshjohnson/Choices\" target=\"_blank\" rel=\"noopener\">Choices.js</a> library in a Vue component and not properly cleaning it up. Later, we will show how to remove the Choices.js footprint and avoid the memory leak.</p>\n<p>In the example below, we load up a select with a lot of options and then we use a show/hide button with a <a href=\"/v2/guide/conditional.html\">v-if</a> directive to add it and remove it from the virtual DOM. The problem with this example is that the <code>v-if</code> directive removes the parent element from the DOM, but we did not clean up the additional DOM pieces created by Choices.js, causing a memory leak.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">link</span> <span class=\"hljs-attr\">rel</span>=<span class=\"hljs-string\">'stylesheet prefetch'</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">'https://joshuajohnson.co.uk/Choices/assets/styles/css/choices.min.css?version=3.0.3'</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">'https://joshuajohnson.co.uk/Choices/assets/scripts/dist/choices.min.js?version=3.0.3'</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"showChoices\"</span>\n    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"hide\"</span>\n  &gt;</span>Hide<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"!showChoices\"</span>\n    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"show\"</span>\n  &gt;</span>Show<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"showChoices\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"choices-single-default\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\"#app\"</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">showChoices</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initializeChoices()\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">initializeChoices</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">let</span> list = []\n      <span class=\"hljs-comment\">// lets load up our select with many choices</span>\n      <span class=\"hljs-comment\">// so it will use a lot of memory</span>\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++) &#123;\n        list.push(&#123;\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">\"Item \"</span> + i,\n          <span class=\"hljs-attr\">value</span>: i\n        &#125;)\n      &#125;\n      <span class=\"hljs-keyword\">new</span> Choices(<span class=\"hljs-string\">\"#choices-single-default\"</span>, &#123;\n        <span class=\"hljs-attr\">searchEnabled</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">removeItemButton</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">choices</span>: list\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">show</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.initializeChoices()\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">hide</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">false</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>To see this memory leak in action, open this <a href=\"https://codepen.io/freeman-g/pen/qobpxo\" target=\"_blank\" rel=\"noopener\">CodePen example</a> using Chrome and then open the Chrome Task Manager. To open the Chrome Task Manager on Mac, choose Chrome Top Navigation &gt; Window &gt; Task Manager or on Windows, use the Shift+Esc shortcut. Now, click the show/hide button 50 or so times. You should see the memory usage in the Chrome Task Manager increase and never be reclaimed.</p>\n<p><img src=\"/images/memory-leak-example.png\" alt=\"Memory Leak Example\"></p>\n<h2 id=\"Resolving-the-Memory-Leak\"><a href=\"#Resolving-the-Memory-Leak\" class=\"headerlink\" title=\"Resolving the Memory Leak\"></a>Resolving the Memory Leak</h2><p>In the above example, we can use our <code>hide()</code> method to do some clean up and solve the memory leak prior to removing the select from the DOM. To accomplish this, we will keep a property in our Vue instance’s data object and we will use the <a href=\"https://github.com/jshjohnson/Choices\" target=\"_blank\" rel=\"noopener\">Choices API’s</a> <code>destroy()</code> method to perform the clean up.</p>\n<p>Check the memory usage again with this <a href=\"https://codepen.io/freeman-g/pen/mxWMor\" target=\"_blank\" rel=\"noopener\">updated CodePen example</a>.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">\"#app\"</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">showChoices</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">choicesSelect</span>: <span class=\"hljs-literal\">null</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.initializeChoices()\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">initializeChoices</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">let</span> list = []\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++) &#123;\n        list.push(&#123;\n          <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">\"Item \"</span> + i,\n          <span class=\"hljs-attr\">value</span>: i\n        &#125;)\n      &#125;\n      <span class=\"hljs-comment\">// Set a reference to our choicesSelect in our Vue instance's data object</span>\n      <span class=\"hljs-keyword\">this</span>.choicesSelect = <span class=\"hljs-keyword\">new</span> Choices(<span class=\"hljs-string\">\"#choices-single-default\"</span>, &#123;\n        <span class=\"hljs-attr\">searchEnabled</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">removeItemButton</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">choices</span>: list\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">show</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">true</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.initializeChoices()\n      &#125;)\n    &#125;,\n    <span class=\"hljs-attr\">hide</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// now we can use the reference to Choices to perform clean up here</span>\n      <span class=\"hljs-comment\">// prior to removing the elements from the DOM</span>\n      <span class=\"hljs-keyword\">this</span>.choicesSelect.destroy()\n      <span class=\"hljs-keyword\">this</span>.showChoices = <span class=\"hljs-literal\">false</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<h2 id=\"Details-about-the-Value\"><a href=\"#Details-about-the-Value\" class=\"headerlink\" title=\"Details about the Value\"></a>Details about the Value</h2><p>Memory management and performance testing can easily be neglected in the excitement of shipping quickly, however, keeping a small memory footprint is still important to your overall user experience.</p>\n<p>Consider the types of devices your users may be using and what their normal flow will be. Could they use memory constrained laptops or mobile devices? Do your users typically do lots of in-application navigation? If either of these are true, then good memory management practices can help you avoid the worst case scenario of crashing a user’s browser. Even if neither of these are true, you can still potentially have degradation of performance over extended usage of your app if you are not careful.</p>\n<h2 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h2><p>In the above example, we used a <code>v-if</code> directive to illustrate the memory leak, but a more common real-world scenario happens when using <a href=\"https://router.vuejs.org/en/\" target=\"_blank\" rel=\"noopener\">vue-router</a> to route to components in a Single Page Application.</p>\n<p>Just like the <code>v-if</code> directive, <code>vue-router</code> removes elements from the virtual DOM and replaces those with new elements when a user navigates around your application. The Vue <code>beforeDestroy()</code> <a href=\"/v2/guide/instance.html#Lifecycle-Diagram\">lifecycle hook</a> is a good place to solve the same sort of issue in a <code>vue-router</code> based application.</p>\n<p>We could move our clean up into the <code>beforeDestroy()</code> hook like this:</p>\n<pre><code class=\"hljs js\">beforeDestroy: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.choicesSelect.destroy()\n&#125;</code></pre>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>We have discussed managing memory when removing elements, but what if you intentionally want to preserve state and keep elements in memory? In this case, you can use the built-in component <a href=\"/v2/api/#keep-alive\">keep-alive</a>.</p>\n<p>When you wrap a component with <code>keep-alive</code>, its state will be preserved and therefore kept in memory.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"show = false\"</span>&gt;</span>Hide<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- my-component will be intentionally kept in memory even when removed --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"show\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>This technique can be useful to improve user experience. For example, imagine a user starts entering comments into a text input and then decides to navigate away. If the user then navigated back, their comments would still be preserved.</p>\n<p>Once you use keep-alive, then you have access to two more lifecycle hooks: <code>activated</code> and <code>deactivated</code>. If you do want to clean up or change data when a keep-alive component is removed, you can do so in the <code>deactivated</code> hook.</p>\n<pre><code class=\"hljs js\">deactivated: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// remove any data you do not want to keep alive</span>\n&#125;</code></pre>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>Vue makes it very easy to develop amazing, reactive JavaScript applications, but you still need to be careful about memory leaks. These leaks will often occur when using additional 3rd Party libraries that manipulate the DOM outside of Vue. Make sure to test your application for memory leaks and take appropriate steps to clean up components where necessary.</p>\n"},{"title":"Adding Instance Properties","type":"cookbook","order":2,"_content":"\n## Base Example\n\nThere may be data/utilities you'd like to use in many components, but you don't want to [pollute the global scope](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md). In these cases, you can make them available to each Vue instance by defining them on the prototype:\n\n```js\nVue.prototype.$appName = 'My App'\n```\n\nNow `$appName` is available on all Vue instances, even before creation. If we run:\n\n```js\nnew Vue({\n  beforeCreate: function() {\n    console.log(this.$appName)\n  }\n})\n```\n\nThen `\"My App\"` will be logged to the console!\n\n## The Importance of Scoping Instance Properties\n\nYou may be wondering:\n\n> \"Why does `appName` start with `$`? Is that important? What does it do?\n\nNo magic is happening here. `$` is a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.\n\n> \"Conflicts? What do you mean?\"\n\nAnother great question! If you set:\n\n```js\nVue.prototype.appName = 'My App'\n```\n\nThen what would you expect to be logged below?\n\n```js\nnew Vue({\n  data: {\n    // Uh oh - appName is *also* the name of the\n    // instance property we defined!\n    appName: 'The name of some other app'\n  },\n  beforeCreate: function() {\n    console.log(this.appName)\n  },\n  created: function() {\n    console.log(this.appName)\n  }\n})\n```\n\nIt would be `\"My App\"`, then `\"The name of some other app\"`, because `this.appName` is overwritten ([sort of](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch5.md)) by `data` when the instance is created. We scope instance properties with `$` to avoid this. You can even use your own convention if you'd like, such as `$_appName` or `ΩappName`, to prevent even conflicts with plugins or future features.\n\n## Real-World Example: Replacing Vue Resource with Axios\n\nLet's say you're replacing the [now-retired Vue Resource](https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4). You really enjoyed accessing request methods through `this.$http` and you want to do the same thing with Axios instead.\n\nAll you have to do is include axios in your project:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"></script>\n\n<div id=\"app\">\n  <ul>\n    <li v-for=\"user in users\">{{ user.name }}</li>\n  </ul>\n</div>\n```\n\nAlias `axios` to `Vue.prototype.$http`:\n\n```js\nVue.prototype.$http = axios\n```\n\nThen you'll be able to use methods like `this.$http.get` in any Vue instance:\n\n```js\nnew Vue({\n  el: '#app',\n  data: {\n    users: []\n  },\n  created() {\n    var vm = this\n    this.$http\n      .get('https://jsonplaceholder.typicode.com/users')\n      .then(function(response) {\n        vm.users = response.data\n      })\n  }\n})\n```\n\n## The Context of Prototype Methods\n\nIn case you're not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use `this` to access data, computed properties, methods, or anything else defined on the instance.\n\nLet's take advantage of this in a `$reverseText` method:\n\n```js\nVue.prototype.$reverseText = function(propertyName) {\n  this[propertyName] = this[propertyName]\n    .split('')\n    .reverse()\n    .join('')\n}\n\nnew Vue({\n  data: {\n    message: 'Hello'\n  },\n  created: function() {\n    console.log(this.message) // => \"Hello\"\n    this.$reverseText('message')\n    console.log(this.message) // => \"olleH\"\n  }\n})\n```\n\nNote that the context binding will **not** work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:\n\n```js\nVue.prototype.$reverseText = propertyName => {\n  this[propertyName] = this[propertyName]\n    .split('')\n    .reverse()\n    .join('')\n}\n```\n\nWould throw an error:\n\n```log\nUncaught TypeError: Cannot read property 'split' of undefined\n```\n\n## When To Avoid This Pattern\n\nAs long as you're vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.\n\nHowever, it can sometimes cause confusion with other developers. They might see `this.$http`, for example, and think, \"Oh, I didn't know about this Vue feature!\" Then they move to a different project and are confused when `this.$http` is undefined. Or, maybe they want to Google how to do something, but can't find results because they don't realize they're actually using Axios under an alias.\n\n**The convenience comes at the cost of explicitness.** When looking at a component, it's impossible to tell where `$http` came from. Vue itself? A plugin? A coworker?\n\nSo what are the alternatives?\n\n## Alternative Patterns\n\n### When Not Using a Module System\n\nIn applications with **no** module system (e.g. via Webpack or Browserify), there's a pattern that's often used with _any_ JavaScript-enhanced frontend: a global `App` object.\n\nIf what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here's an example:\n\n```js\nvar App = Object.freeze({\n  name: 'My App',\n  version: '2.1.4',\n  helpers: {\n    // This is a purely functional version of\n    // the $reverseText method we saw earlier\n    reverseText: function(text) {\n      return text\n        .split('')\n        .reverse()\n        .join('')\n    }\n  }\n})\n```\n\n<p class=\"tip\">If you raised an eyebrow at `Object.freeze`, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\nNow the source of these shared properties is more obvious: there's an `App` object defined somewhere in the app. To find it, developers can run a project-wide search.\n\nAnother advantage is that `App` can now be used _anywhere_ in your code, whether it's Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on `this`:\n\n```js\nnew Vue({\n  data: {\n    appVersion: App.version\n  },\n  methods: {\n    reverseText: App.helpers.reverseText\n  }\n})\n```\n\n### When Using a Module System\n\nWhen you have access to a module system, you can easily organize shared code into modules, then `require`/`import` those modules wherever they're needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know _exactly_ where each one came from.\n\nWhile certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.\n","source":"v2/cookbook/adding-instance-properties.md","raw":"---\ntitle: Adding Instance Properties\ntype: cookbook\norder: 2\n---\n\n## Base Example\n\nThere may be data/utilities you'd like to use in many components, but you don't want to [pollute the global scope](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md). In these cases, you can make them available to each Vue instance by defining them on the prototype:\n\n```js\nVue.prototype.$appName = 'My App'\n```\n\nNow `$appName` is available on all Vue instances, even before creation. If we run:\n\n```js\nnew Vue({\n  beforeCreate: function() {\n    console.log(this.$appName)\n  }\n})\n```\n\nThen `\"My App\"` will be logged to the console!\n\n## The Importance of Scoping Instance Properties\n\nYou may be wondering:\n\n> \"Why does `appName` start with `$`? Is that important? What does it do?\n\nNo magic is happening here. `$` is a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.\n\n> \"Conflicts? What do you mean?\"\n\nAnother great question! If you set:\n\n```js\nVue.prototype.appName = 'My App'\n```\n\nThen what would you expect to be logged below?\n\n```js\nnew Vue({\n  data: {\n    // Uh oh - appName is *also* the name of the\n    // instance property we defined!\n    appName: 'The name of some other app'\n  },\n  beforeCreate: function() {\n    console.log(this.appName)\n  },\n  created: function() {\n    console.log(this.appName)\n  }\n})\n```\n\nIt would be `\"My App\"`, then `\"The name of some other app\"`, because `this.appName` is overwritten ([sort of](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch5.md)) by `data` when the instance is created. We scope instance properties with `$` to avoid this. You can even use your own convention if you'd like, such as `$_appName` or `ΩappName`, to prevent even conflicts with plugins or future features.\n\n## Real-World Example: Replacing Vue Resource with Axios\n\nLet's say you're replacing the [now-retired Vue Resource](https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4). You really enjoyed accessing request methods through `this.$http` and you want to do the same thing with Axios instead.\n\nAll you have to do is include axios in your project:\n\n```html\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"></script>\n\n<div id=\"app\">\n  <ul>\n    <li v-for=\"user in users\">{{ user.name }}</li>\n  </ul>\n</div>\n```\n\nAlias `axios` to `Vue.prototype.$http`:\n\n```js\nVue.prototype.$http = axios\n```\n\nThen you'll be able to use methods like `this.$http.get` in any Vue instance:\n\n```js\nnew Vue({\n  el: '#app',\n  data: {\n    users: []\n  },\n  created() {\n    var vm = this\n    this.$http\n      .get('https://jsonplaceholder.typicode.com/users')\n      .then(function(response) {\n        vm.users = response.data\n      })\n  }\n})\n```\n\n## The Context of Prototype Methods\n\nIn case you're not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use `this` to access data, computed properties, methods, or anything else defined on the instance.\n\nLet's take advantage of this in a `$reverseText` method:\n\n```js\nVue.prototype.$reverseText = function(propertyName) {\n  this[propertyName] = this[propertyName]\n    .split('')\n    .reverse()\n    .join('')\n}\n\nnew Vue({\n  data: {\n    message: 'Hello'\n  },\n  created: function() {\n    console.log(this.message) // => \"Hello\"\n    this.$reverseText('message')\n    console.log(this.message) // => \"olleH\"\n  }\n})\n```\n\nNote that the context binding will **not** work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:\n\n```js\nVue.prototype.$reverseText = propertyName => {\n  this[propertyName] = this[propertyName]\n    .split('')\n    .reverse()\n    .join('')\n}\n```\n\nWould throw an error:\n\n```log\nUncaught TypeError: Cannot read property 'split' of undefined\n```\n\n## When To Avoid This Pattern\n\nAs long as you're vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.\n\nHowever, it can sometimes cause confusion with other developers. They might see `this.$http`, for example, and think, \"Oh, I didn't know about this Vue feature!\" Then they move to a different project and are confused when `this.$http` is undefined. Or, maybe they want to Google how to do something, but can't find results because they don't realize they're actually using Axios under an alias.\n\n**The convenience comes at the cost of explicitness.** When looking at a component, it's impossible to tell where `$http` came from. Vue itself? A plugin? A coworker?\n\nSo what are the alternatives?\n\n## Alternative Patterns\n\n### When Not Using a Module System\n\nIn applications with **no** module system (e.g. via Webpack or Browserify), there's a pattern that's often used with _any_ JavaScript-enhanced frontend: a global `App` object.\n\nIf what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here's an example:\n\n```js\nvar App = Object.freeze({\n  name: 'My App',\n  version: '2.1.4',\n  helpers: {\n    // This is a purely functional version of\n    // the $reverseText method we saw earlier\n    reverseText: function(text) {\n      return text\n        .split('')\n        .reverse()\n        .join('')\n    }\n  }\n})\n```\n\n<p class=\"tip\">If you raised an eyebrow at `Object.freeze`, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\nNow the source of these shared properties is more obvious: there's an `App` object defined somewhere in the app. To find it, developers can run a project-wide search.\n\nAnother advantage is that `App` can now be used _anywhere_ in your code, whether it's Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on `this`:\n\n```js\nnew Vue({\n  data: {\n    appVersion: App.version\n  },\n  methods: {\n    reverseText: App.helpers.reverseText\n  }\n})\n```\n\n### When Using a Module System\n\nWhen you have access to a module system, you can easily organize shared code into modules, then `require`/`import` those modules wherever they're needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know _exactly_ where each one came from.\n\nWhile certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.\n","date":"2020-09-25T23:55:41.104Z","updated":"2020-09-25T23:55:41.104Z","path":"v2/cookbook/adding-instance-properties.html","comments":1,"layout":"page","_id":"ckfl66gy0000ic2v516zxc5q1","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There may be data/utilities you’d like to use in many components, but you don’t want to <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md\" target=\"_blank\" rel=\"noopener\">pollute the global scope</a>. In these cases, you can make them available to each Vue instance by defining them on the prototype:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$appName = <span class=\"hljs-string\">'My App'</span></code></pre>\n<p>Now <code>$appName</code> is available on all Vue instances, even before creation. If we run:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">beforeCreate</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$appName)\n  &#125;\n&#125;)</code></pre>\n<p>Then <code>&quot;My App&quot;</code> will be logged to the console!</p>\n<h2 id=\"The-Importance-of-Scoping-Instance-Properties\"><a href=\"#The-Importance-of-Scoping-Instance-Properties\" class=\"headerlink\" title=\"The Importance of Scoping Instance Properties\"></a>The Importance of Scoping Instance Properties</h2><p>You may be wondering:</p>\n<blockquote>\n<p>“Why does <code>appName</code> start with <code>$</code>? Is that important? What does it do?</p>\n</blockquote>\n<p>No magic is happening here. <code>$</code> is a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.</p>\n<blockquote>\n<p>“Conflicts? What do you mean?”</p>\n</blockquote>\n<p>Another great question! If you set:</p>\n<pre><code class=\"hljs js\">Vue.prototype.appName = <span class=\"hljs-string\">'My App'</span></code></pre>\n<p>Then what would you expect to be logged below?</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-comment\">// Uh oh - appName is *also* the name of the</span>\n    <span class=\"hljs-comment\">// instance property we defined!</span>\n    <span class=\"hljs-attr\">appName</span>: <span class=\"hljs-string\">'The name of some other app'</span>\n  &#125;,\n  <span class=\"hljs-attr\">beforeCreate</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.appName)\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.appName)\n  &#125;\n&#125;)</code></pre>\n<p>It would be <code>&quot;My App&quot;</code>, then <code>&quot;The name of some other app&quot;</code>, because <code>this.appName</code> is overwritten (<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch5.md\" target=\"_blank\" rel=\"noopener\">sort of</a>) by <code>data</code> when the instance is created. We scope instance properties with <code>$</code> to avoid this. You can even use your own convention if you’d like, such as <code>$_appName</code> or <code>ΩappName</code>, to prevent even conflicts with plugins or future features.</p>\n<h2 id=\"Real-World-Example-Replacing-Vue-Resource-with-Axios\"><a href=\"#Real-World-Example-Replacing-Vue-Resource-with-Axios\" class=\"headerlink\" title=\"Real-World Example: Replacing Vue Resource with Axios\"></a>Real-World Example: Replacing Vue Resource with Axios</h2><p>Let’s say you’re replacing the <a href=\"https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4\" target=\"_blank\" rel=\"noopener\">now-retired Vue Resource</a>. You really enjoyed accessing request methods through <code>this.$http</code> and you want to do the same thing with Axios instead.</p>\n<p>All you have to do is include axios in your project:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Alias <code>axios</code> to <code>Vue.prototype.$http</code>:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$http = axios</code></pre>\n<p>Then you’ll be able to use methods like <code>this.$http.get</code> in any Vue instance:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">users</span>: []\n  &#125;,\n  created() &#123;\n    <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">this</span>.$http\n      .get(<span class=\"hljs-string\">'https://jsonplaceholder.typicode.com/users'</span>)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">response</span>) </span>&#123;\n        vm.users = response.data\n      &#125;)\n  &#125;\n&#125;)</code></pre>\n<h2 id=\"The-Context-of-Prototype-Methods\"><a href=\"#The-Context-of-Prototype-Methods\" class=\"headerlink\" title=\"The Context of Prototype Methods\"></a>The Context of Prototype Methods</h2><p>In case you’re not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use <code>this</code> to access data, computed properties, methods, or anything else defined on the instance.</p>\n<p>Let’s take advantage of this in a <code>$reverseText</code> method:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$reverseText = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">propertyName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>[propertyName] = <span class=\"hljs-keyword\">this</span>[propertyName]\n    .split(<span class=\"hljs-string\">''</span>)\n    .reverse()\n    .join(<span class=\"hljs-string\">''</span>)\n&#125;\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.message) <span class=\"hljs-comment\">// =&gt; \"Hello\"</span>\n    <span class=\"hljs-keyword\">this</span>.$reverseText(<span class=\"hljs-string\">'message'</span>)\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.message) <span class=\"hljs-comment\">// =&gt; \"olleH\"</span>\n  &#125;\n&#125;)</code></pre>\n<p>Note that the context binding will <strong>not</strong> work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$reverseText = <span class=\"hljs-function\"><span class=\"hljs-params\">propertyName</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">this</span>[propertyName] = <span class=\"hljs-keyword\">this</span>[propertyName]\n    .split(<span class=\"hljs-string\">''</span>)\n    .reverse()\n    .join(<span class=\"hljs-string\">''</span>)\n&#125;</code></pre>\n<p>Would throw an error:</p>\n<pre><code class=\"hljs log\">Uncaught TypeError: Cannot read property &apos;split&apos; of undefined</code></pre>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>As long as you’re vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.</p>\n<p>However, it can sometimes cause confusion with other developers. They might see <code>this.$http</code>, for example, and think, “Oh, I didn’t know about this Vue feature!” Then they move to a different project and are confused when <code>this.$http</code> is undefined. Or, maybe they want to Google how to do something, but can’t find results because they don’t realize they’re actually using Axios under an alias.</p>\n<p><strong>The convenience comes at the cost of explicitness.</strong> When looking at a component, it’s impossible to tell where <code>$http</code> came from. Vue itself? A plugin? A coworker?</p>\n<p>So what are the alternatives?</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"When-Not-Using-a-Module-System\"><a href=\"#When-Not-Using-a-Module-System\" class=\"headerlink\" title=\"When Not Using a Module System\"></a>When Not Using a Module System</h3><p>In applications with <strong>no</strong> module system (e.g. via Webpack or Browserify), there’s a pattern that’s often used with <em>any</em> JavaScript-enhanced frontend: a global <code>App</code> object.</p>\n<p>If what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here’s an example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> App = <span class=\"hljs-built_in\">Object</span>.freeze(&#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'My App'</span>,\n  <span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">'2.1.4'</span>,\n  <span class=\"hljs-attr\">helpers</span>: &#123;\n    <span class=\"hljs-comment\">// This is a purely functional version of</span>\n    <span class=\"hljs-comment\">// the $reverseText method we saw earlier</span>\n    <span class=\"hljs-attr\">reverseText</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">text</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> text\n        .split(<span class=\"hljs-string\">''</span>)\n        .reverse()\n        .join(<span class=\"hljs-string\">''</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p class=\"tip\">If you raised an eyebrow at <code>Object.freeze</code>, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\n<p>Now the source of these shared properties is more obvious: there’s an <code>App</code> object defined somewhere in the app. To find it, developers can run a project-wide search.</p>\n<p>Another advantage is that <code>App</code> can now be used <em>anywhere</em> in your code, whether it’s Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on <code>this</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">appVersion</span>: App.version\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">reverseText</span>: App.helpers.reverseText\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"When-Using-a-Module-System\"><a href=\"#When-Using-a-Module-System\" class=\"headerlink\" title=\"When Using a Module System\"></a>When Using a Module System</h3><p>When you have access to a module system, you can easily organize shared code into modules, then <code>require</code>/<code>import</code> those modules wherever they’re needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know <em>exactly</em> where each one came from.</p>\n<p>While certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There may be data/utilities you’d like to use in many components, but you don’t want to <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md\" target=\"_blank\" rel=\"noopener\">pollute the global scope</a>. In these cases, you can make them available to each Vue instance by defining them on the prototype:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$appName = <span class=\"hljs-string\">'My App'</span></code></pre>\n<p>Now <code>$appName</code> is available on all Vue instances, even before creation. If we run:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">beforeCreate</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$appName)\n  &#125;\n&#125;)</code></pre>\n<p>Then <code>&quot;My App&quot;</code> will be logged to the console!</p>\n<h2 id=\"The-Importance-of-Scoping-Instance-Properties\"><a href=\"#The-Importance-of-Scoping-Instance-Properties\" class=\"headerlink\" title=\"The Importance of Scoping Instance Properties\"></a>The Importance of Scoping Instance Properties</h2><p>You may be wondering:</p>\n<blockquote>\n<p>“Why does <code>appName</code> start with <code>$</code>? Is that important? What does it do?</p>\n</blockquote>\n<p>No magic is happening here. <code>$</code> is a convention Vue uses for properties that are available to all instances. This avoids conflicts with any defined data, computed properties, or methods.</p>\n<blockquote>\n<p>“Conflicts? What do you mean?”</p>\n</blockquote>\n<p>Another great question! If you set:</p>\n<pre><code class=\"hljs js\">Vue.prototype.appName = <span class=\"hljs-string\">'My App'</span></code></pre>\n<p>Then what would you expect to be logged below?</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-comment\">// Uh oh - appName is *also* the name of the</span>\n    <span class=\"hljs-comment\">// instance property we defined!</span>\n    <span class=\"hljs-attr\">appName</span>: <span class=\"hljs-string\">'The name of some other app'</span>\n  &#125;,\n  <span class=\"hljs-attr\">beforeCreate</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.appName)\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.appName)\n  &#125;\n&#125;)</code></pre>\n<p>It would be <code>&quot;My App&quot;</code>, then <code>&quot;The name of some other app&quot;</code>, because <code>this.appName</code> is overwritten (<a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/objects-classes/ch5.md\" target=\"_blank\" rel=\"noopener\">sort of</a>) by <code>data</code> when the instance is created. We scope instance properties with <code>$</code> to avoid this. You can even use your own convention if you’d like, such as <code>$_appName</code> or <code>ΩappName</code>, to prevent even conflicts with plugins or future features.</p>\n<h2 id=\"Real-World-Example-Replacing-Vue-Resource-with-Axios\"><a href=\"#Real-World-Example-Replacing-Vue-Resource-with-Axios\" class=\"headerlink\" title=\"Real-World Example: Replacing Vue Resource with Axios\"></a>Real-World Example: Replacing Vue Resource with Axios</h2><p>Let’s say you’re replacing the <a href=\"https://medium.com/the-vue-point/retiring-vue-resource-871a82880af4\" target=\"_blank\" rel=\"noopener\">now-retired Vue Resource</a>. You really enjoyed accessing request methods through <code>this.$http</code> and you want to do the same thing with Axios instead.</p>\n<p>All you have to do is include axios in your project:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.15.2/axios.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>&gt;</span>&#123;&#123; user.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Alias <code>axios</code> to <code>Vue.prototype.$http</code>:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$http = axios</code></pre>\n<p>Then you’ll be able to use methods like <code>this.$http.get</code> in any Vue instance:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">users</span>: []\n  &#125;,\n  created() &#123;\n    <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n    <span class=\"hljs-keyword\">this</span>.$http\n      .get(<span class=\"hljs-string\">'https://jsonplaceholder.typicode.com/users'</span>)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">response</span>) </span>&#123;\n        vm.users = response.data\n      &#125;)\n  &#125;\n&#125;)</code></pre>\n<h2 id=\"The-Context-of-Prototype-Methods\"><a href=\"#The-Context-of-Prototype-Methods\" class=\"headerlink\" title=\"The Context of Prototype Methods\"></a>The Context of Prototype Methods</h2><p>In case you’re not aware, methods added to a prototype in JavaScript gain the context of the instance. That means they can use <code>this</code> to access data, computed properties, methods, or anything else defined on the instance.</p>\n<p>Let’s take advantage of this in a <code>$reverseText</code> method:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$reverseText = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">propertyName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>[propertyName] = <span class=\"hljs-keyword\">this</span>[propertyName]\n    .split(<span class=\"hljs-string\">''</span>)\n    .reverse()\n    .join(<span class=\"hljs-string\">''</span>)\n&#125;\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.message) <span class=\"hljs-comment\">// =&gt; \"Hello\"</span>\n    <span class=\"hljs-keyword\">this</span>.$reverseText(<span class=\"hljs-string\">'message'</span>)\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.message) <span class=\"hljs-comment\">// =&gt; \"olleH\"</span>\n  &#125;\n&#125;)</code></pre>\n<p>Note that the context binding will <strong>not</strong> work if you use an ES6/2015 arrow function, as they implicitly bind to their parent scope. That means the arrow function version:</p>\n<pre><code class=\"hljs js\">Vue.prototype.$reverseText = <span class=\"hljs-function\"><span class=\"hljs-params\">propertyName</span> =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">this</span>[propertyName] = <span class=\"hljs-keyword\">this</span>[propertyName]\n    .split(<span class=\"hljs-string\">''</span>)\n    .reverse()\n    .join(<span class=\"hljs-string\">''</span>)\n&#125;</code></pre>\n<p>Would throw an error:</p>\n<pre><code class=\"hljs log\">Uncaught TypeError: Cannot read property &apos;split&apos; of undefined</code></pre>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>As long as you’re vigilant in scoping prototype properties, using this pattern is quite safe - as in, unlikely to produce bugs.</p>\n<p>However, it can sometimes cause confusion with other developers. They might see <code>this.$http</code>, for example, and think, “Oh, I didn’t know about this Vue feature!” Then they move to a different project and are confused when <code>this.$http</code> is undefined. Or, maybe they want to Google how to do something, but can’t find results because they don’t realize they’re actually using Axios under an alias.</p>\n<p><strong>The convenience comes at the cost of explicitness.</strong> When looking at a component, it’s impossible to tell where <code>$http</code> came from. Vue itself? A plugin? A coworker?</p>\n<p>So what are the alternatives?</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"When-Not-Using-a-Module-System\"><a href=\"#When-Not-Using-a-Module-System\" class=\"headerlink\" title=\"When Not Using a Module System\"></a>When Not Using a Module System</h3><p>In applications with <strong>no</strong> module system (e.g. via Webpack or Browserify), there’s a pattern that’s often used with <em>any</em> JavaScript-enhanced frontend: a global <code>App</code> object.</p>\n<p>If what you want to add has nothing to do with Vue specifically, this may be a good alternative to reach for. Here’s an example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> App = <span class=\"hljs-built_in\">Object</span>.freeze(&#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'My App'</span>,\n  <span class=\"hljs-attr\">version</span>: <span class=\"hljs-string\">'2.1.4'</span>,\n  <span class=\"hljs-attr\">helpers</span>: &#123;\n    <span class=\"hljs-comment\">// This is a purely functional version of</span>\n    <span class=\"hljs-comment\">// the $reverseText method we saw earlier</span>\n    <span class=\"hljs-attr\">reverseText</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">text</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> text\n        .split(<span class=\"hljs-string\">''</span>)\n        .reverse()\n        .join(<span class=\"hljs-string\">''</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p class=\"tip\">If you raised an eyebrow at <code>Object.freeze</code>, what it does is prevent the object from being changed in the future. This essentially makes all its properties constants, protecting you from future state bugs.</p>\n\n<p>Now the source of these shared properties is more obvious: there’s an <code>App</code> object defined somewhere in the app. To find it, developers can run a project-wide search.</p>\n<p>Another advantage is that <code>App</code> can now be used <em>anywhere</em> in your code, whether it’s Vue-related or not. That includes attaching values directly to instance options, rather than having to enter a function to access properties on <code>this</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">appVersion</span>: App.version\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">reverseText</span>: App.helpers.reverseText\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"When-Using-a-Module-System\"><a href=\"#When-Using-a-Module-System\" class=\"headerlink\" title=\"When Using a Module System\"></a>When Using a Module System</h3><p>When you have access to a module system, you can easily organize shared code into modules, then <code>require</code>/<code>import</code> those modules wherever they’re needed. This is the epitome of explicitness, because in each file you gain a list of dependencies. You know <em>exactly</em> where each one came from.</p>\n<p>While certainly more verbose, this approach is definitely the most maintainable, especially when working with other developers and/or building a large app.</p>\n"},{"title":"Client-Side Storage","type":"cookbook","order":11,"_content":"\n## Base Example\n\nClient-side storage is an excellent way to quickly add performance gains to an application. By storing data on the browser itself, you can skip fetching information from the server every time the user needs it. While especially useful when offline, even online users will benefit from using data locally versus a remote server. Client-side storage can be done with [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies), [Local Storage](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API) (technically \"Web Storage\"), [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), and [WebSQL](https://www.w3.org/TR/webdatabase/) (a deprecated method that should not be used in new projects).\n\nIn this cookbook entry we'll focus on Local Storage, the simplest of the storage mechanisms. Local Storage uses a key/value system for storing data. It is limited to storing only simple values but complex data can be stored if you are willing to encode and decode the values with JSON. In general, Local Storage is appropriate for smaller sets of data you would want to persist, things like user preferences or form data. Larger data with more complex storage needs would be better stored typically in IndexedDB.\n\nLet's begin with a simple form based example:\n\n``` html\n<div id=\"app\">\n  My name is <input v-model=\"name\">\n</div>\n```\n\nThis example has one form field bound to a Vue value called `name`. Here's the JavaScript:\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    name: ''\n  },\n  mounted() {\n    if (localStorage.name) {\n      this.name = localStorage.name;\n    }\n  },\n  watch: {\n    name(newName) {\n      localStorage.name = newName;\n    }\n  }\n});\n```\n\nFocus on the `mounted` and `watch` parts. We use `mounted` to handle loading the value from localStorage. To handle writing the data base, we watch the `name` value and on change, immediately write it.\n\nYou can run this yourself here:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"KodaKb\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/KodaKb/\">testing localstorage</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nType something in the form and then reload this page. You'll note that the value you typed previously will show up automatically. Don't forget that your browser provides excellent developer tools for inspecting client-side storage. Here's an example in Firefox:\n\n![Storage devtools in Firefox](/images/devtools-storage.png)\n\nAnd here it is in Chrome:\n\n![Storage devtools in Chrome](/images/devtools-storage-chrome.png)\n\nAnd then finally, an example in Microsoft Edge. Note that you can find application storage values under the Debugger tab.\n\n![Storage devtools in Edge](/images/devtools-storage-edge.png)\n\n<p class=\"tip\">As a quick aside, these dev tools also offer you a way to remove storage values. This can be very useful when testing.</p>\n\nImmediately writing the value may not be advisable. Let's consider a slightly more advanced example. First, the updated form.\n\n``` html\n<div id=\"app\">\n  <p>\n    My name is <input v-model=\"name\">\n    and I am <input v-model=\"age\"> years old.\n  </p>\n  <p>\n    <button @click=\"persist\">Save</button>\n  </p>\n</div>\n```\n\nNow we've got two fields (again, bound to a Vue instance) but now there is the addition of a button that runs a `persist` method. Let's look at the JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    name: '',\n    age: 0\n  },\n  mounted() {\n    if (localStorage.name) {\n      this.name = localStorage.name;\n    }\n    if (localStorage.age) {\n      this.age = localStorage.age;\n    }\n  },\n  methods: {\n    persist() {\n      localStorage.name = this.name;\n      localStorage.age = this.age;\n      console.log('now pretend I did more stuff...');\n    }\n  }\n})\n```\n\nAs before, `mounted` is used to load persisted data, if it exists. This time, though, data is only persisted when the button is clicked. We could also do any validations or transformations here before storing the value. You could also store a date representing when the values were stored. With that metadata, the `mounted` method could make a logical call on whether or not to store the values again. You can try this version below.\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"rdOjLN\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/rdOjLN/\">testing localstorage 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n## Working with Complex Values\n\nAs mentioned above, Local Storage only works with simple values. To store more complex values, like objects or arrays, you must serialize and deserialize the values with JSON. Here is a more advanced example that persists an array of cats (the best kind of array possible).\n\n``` html\n<div id=\"app\">\n  <h2>Cats</h2>\n  <div v-for=\"(cat, n) in cats\">\n    <p>\n      <span class=\"cat\">{{ cat }}</span>\n      <button @click=\"removeCat(n)\">Remove</button>\n    </p>\n  </div>\n\n  <p>\n    <input v-model=\"newCat\">\n    <button @click=\"addCat\">Add Cat</button>\n  </p>\n</div>\n```\n\nThis \"app\" consists of a simple list on top (with a button to remove a cat) and a small form at the bottom to add a new cat. Now let's look at the JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    cats: [],\n    newCat: null\n  },\n  mounted() {\n    if (localStorage.getItem('cats')) {\n      try {\n        this.cats = JSON.parse(localStorage.getItem('cats'));\n      } catch(e) {\n        localStorage.removeItem('cats');\n      }\n    }\n  },\n  methods: {\n    addCat() {\n      // ensure they actually typed something\n      if (!this.newCat) {\n        return;\n      }\n\n      this.cats.push(this.newCat);\n      this.newCat = '';\n      this.saveCats();\n    },\n    removeCat(x) {\n      this.cats.splice(x, 1);\n      this.saveCats();\n    },\n    saveCats() {\n      const parsed = JSON.stringify(this.cats);\n      localStorage.setItem('cats', parsed);\n    }\n  }\n})\n```\n\nIn this application, we've switched to use the Local Storage APIs versus \"direct\" access. Both work but the API method is generally preferred. `mounted` now has to grab the value and parse the JSON value. If anything goes wrong here we assume the data is corrupt and delete it. (Remember, any time your web application uses client-side storage, the user has access to it and can modify it at will.)\n\nWe have three methods now to handle working with cats. Both `addCat` and `removeCat` handle updating the \"live\" Vue data stored in `this.cats`. They then run `saveCats` which handles serializing and persisting the data. You can play with this version below:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"qoYbyW\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"localstorage, complex\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/qoYbyW/\">localstorage, complex</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n## Alternative Patterns\n\nWhile the Local Storage API is relatively simple, it is missing some basic features that would be useful in many applications. The following plugins wrap Local Storage access and make it easier to use, while also adding functionality like default values.\n\n* [vue-local-storage](https://github.com/pinguinjkeke/vue-local-storage)\n* [vue-reactive-storage](https://github.com/ropbla9/vue-reactive-storage)\n* [vue2-storage](https://github.com/yarkovaleksei/vue2-storage)\n\n## Wrapping Up\n\nWhile the browser will never replace a server persistence system, having multiple ways to cache data locally can be a huge performance boost for your application, and working with it in Vue.js makes it even more powerful.\n","source":"v2/cookbook/client-side-storage.md","raw":"---\ntitle: Client-Side Storage\ntype: cookbook\norder: 11\n---\n\n## Base Example\n\nClient-side storage is an excellent way to quickly add performance gains to an application. By storing data on the browser itself, you can skip fetching information from the server every time the user needs it. While especially useful when offline, even online users will benefit from using data locally versus a remote server. Client-side storage can be done with [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies), [Local Storage](https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API) (technically \"Web Storage\"), [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API), and [WebSQL](https://www.w3.org/TR/webdatabase/) (a deprecated method that should not be used in new projects).\n\nIn this cookbook entry we'll focus on Local Storage, the simplest of the storage mechanisms. Local Storage uses a key/value system for storing data. It is limited to storing only simple values but complex data can be stored if you are willing to encode and decode the values with JSON. In general, Local Storage is appropriate for smaller sets of data you would want to persist, things like user preferences or form data. Larger data with more complex storage needs would be better stored typically in IndexedDB.\n\nLet's begin with a simple form based example:\n\n``` html\n<div id=\"app\">\n  My name is <input v-model=\"name\">\n</div>\n```\n\nThis example has one form field bound to a Vue value called `name`. Here's the JavaScript:\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    name: ''\n  },\n  mounted() {\n    if (localStorage.name) {\n      this.name = localStorage.name;\n    }\n  },\n  watch: {\n    name(newName) {\n      localStorage.name = newName;\n    }\n  }\n});\n```\n\nFocus on the `mounted` and `watch` parts. We use `mounted` to handle loading the value from localStorage. To handle writing the data base, we watch the `name` value and on change, immediately write it.\n\nYou can run this yourself here:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"KodaKb\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/KodaKb/\">testing localstorage</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nType something in the form and then reload this page. You'll note that the value you typed previously will show up automatically. Don't forget that your browser provides excellent developer tools for inspecting client-side storage. Here's an example in Firefox:\n\n![Storage devtools in Firefox](/images/devtools-storage.png)\n\nAnd here it is in Chrome:\n\n![Storage devtools in Chrome](/images/devtools-storage-chrome.png)\n\nAnd then finally, an example in Microsoft Edge. Note that you can find application storage values under the Debugger tab.\n\n![Storage devtools in Edge](/images/devtools-storage-edge.png)\n\n<p class=\"tip\">As a quick aside, these dev tools also offer you a way to remove storage values. This can be very useful when testing.</p>\n\nImmediately writing the value may not be advisable. Let's consider a slightly more advanced example. First, the updated form.\n\n``` html\n<div id=\"app\">\n  <p>\n    My name is <input v-model=\"name\">\n    and I am <input v-model=\"age\"> years old.\n  </p>\n  <p>\n    <button @click=\"persist\">Save</button>\n  </p>\n</div>\n```\n\nNow we've got two fields (again, bound to a Vue instance) but now there is the addition of a button that runs a `persist` method. Let's look at the JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    name: '',\n    age: 0\n  },\n  mounted() {\n    if (localStorage.name) {\n      this.name = localStorage.name;\n    }\n    if (localStorage.age) {\n      this.age = localStorage.age;\n    }\n  },\n  methods: {\n    persist() {\n      localStorage.name = this.name;\n      localStorage.age = this.age;\n      console.log('now pretend I did more stuff...');\n    }\n  }\n})\n```\n\nAs before, `mounted` is used to load persisted data, if it exists. This time, though, data is only persisted when the button is clicked. We could also do any validations or transformations here before storing the value. You could also store a date representing when the values were stored. With that metadata, the `mounted` method could make a logical call on whether or not to store the values again. You can try this version below.\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"rdOjLN\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/rdOjLN/\">testing localstorage 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n## Working with Complex Values\n\nAs mentioned above, Local Storage only works with simple values. To store more complex values, like objects or arrays, you must serialize and deserialize the values with JSON. Here is a more advanced example that persists an array of cats (the best kind of array possible).\n\n``` html\n<div id=\"app\">\n  <h2>Cats</h2>\n  <div v-for=\"(cat, n) in cats\">\n    <p>\n      <span class=\"cat\">{{ cat }}</span>\n      <button @click=\"removeCat(n)\">Remove</button>\n    </p>\n  </div>\n\n  <p>\n    <input v-model=\"newCat\">\n    <button @click=\"addCat\">Add Cat</button>\n  </p>\n</div>\n```\n\nThis \"app\" consists of a simple list on top (with a button to remove a cat) and a small form at the bottom to add a new cat. Now let's look at the JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    cats: [],\n    newCat: null\n  },\n  mounted() {\n    if (localStorage.getItem('cats')) {\n      try {\n        this.cats = JSON.parse(localStorage.getItem('cats'));\n      } catch(e) {\n        localStorage.removeItem('cats');\n      }\n    }\n  },\n  methods: {\n    addCat() {\n      // ensure they actually typed something\n      if (!this.newCat) {\n        return;\n      }\n\n      this.cats.push(this.newCat);\n      this.newCat = '';\n      this.saveCats();\n    },\n    removeCat(x) {\n      this.cats.splice(x, 1);\n      this.saveCats();\n    },\n    saveCats() {\n      const parsed = JSON.stringify(this.cats);\n      localStorage.setItem('cats', parsed);\n    }\n  }\n})\n```\n\nIn this application, we've switched to use the Local Storage APIs versus \"direct\" access. Both work but the API method is generally preferred. `mounted` now has to grab the value and parse the JSON value. If anything goes wrong here we assume the data is corrupt and delete it. (Remember, any time your web application uses client-side storage, the user has access to it and can modify it at will.)\n\nWe have three methods now to handle working with cats. Both `addCat` and `removeCat` handle updating the \"live\" Vue data stored in `this.cats`. They then run `saveCats` which handles serializing and persisting the data. You can play with this version below:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"qoYbyW\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"localstorage, complex\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/qoYbyW/\">localstorage, complex</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n## Alternative Patterns\n\nWhile the Local Storage API is relatively simple, it is missing some basic features that would be useful in many applications. The following plugins wrap Local Storage access and make it easier to use, while also adding functionality like default values.\n\n* [vue-local-storage](https://github.com/pinguinjkeke/vue-local-storage)\n* [vue-reactive-storage](https://github.com/ropbla9/vue-reactive-storage)\n* [vue2-storage](https://github.com/yarkovaleksei/vue2-storage)\n\n## Wrapping Up\n\nWhile the browser will never replace a server persistence system, having multiple ways to cache data locally can be a huge performance boost for your application, and working with it in Vue.js makes it even more powerful.\n","date":"2020-09-25T23:55:41.105Z","updated":"2020-09-25T23:55:41.105Z","path":"v2/cookbook/client-side-storage.html","comments":1,"layout":"page","_id":"ckfl66gy3000jc2v5pnf6rjki","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Client-side storage is an excellent way to quickly add performance gains to an application. By storing data on the browser itself, you can skip fetching information from the server every time the user needs it. While especially useful when offline, even online users will benefit from using data locally versus a remote server. Client-side storage can be done with <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">cookies</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API\" target=\"_blank\" rel=\"noopener\">Local Storage</a> (technically “Web Storage”), <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\" target=\"_blank\" rel=\"noopener\">IndexedDB</a>, and <a href=\"https://www.w3.org/TR/webdatabase/\" target=\"_blank\" rel=\"noopener\">WebSQL</a> (a deprecated method that should not be used in new projects).</p>\n<p>In this cookbook entry we’ll focus on Local Storage, the simplest of the storage mechanisms. Local Storage uses a key/value system for storing data. It is limited to storing only simple values but complex data can be stored if you are willing to encode and decode the values with JSON. In general, Local Storage is appropriate for smaller sets of data you would want to persist, things like user preferences or form data. Larger data with more complex storage needs would be better stored typically in IndexedDB.</p>\n<p>Let’s begin with a simple form based example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  My name is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This example has one form field bound to a Vue value called <code>name</code>. Here’s the JavaScript:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">if</span> (localStorage.name) &#123;\n      <span class=\"hljs-keyword\">this</span>.name = localStorage.name;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    name(newName) &#123;\n      localStorage.name = newName;\n    &#125;\n  &#125;\n&#125;);</code></pre>\n<p>Focus on the <code>mounted</code> and <code>watch</code> parts. We use <code>mounted</code> to handle loading the value from localStorage. To handle writing the data base, we watch the <code>name</code> value and on change, immediately write it.</p>\n<p>You can run this yourself here:</p>\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"KodaKb\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/KodaKb/\" target=\"_blank\" rel=\"noopener\">testing localstorage</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><br><script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script><br><br>Type something in the form and then reload this page. You’ll note that the value you typed previously will show up automatically. Don’t forget that your browser provides excellent developer tools for inspecting client-side storage. Here’s an example in Firefox:<br><br><img src=\"/images/devtools-storage.png\" alt=\"Storage devtools in Firefox\"><br><br>And here it is in Chrome:<br><br><img src=\"/images/devtools-storage-chrome.png\" alt=\"Storage devtools in Chrome\"><br><br>And then finally, an example in Microsoft Edge. Note that you can find application storage values under the Debugger tab.<br><br><img src=\"/images/devtools-storage-edge.png\" alt=\"Storage devtools in Edge\"><br><br><p class=\"tip\">As a quick aside, these dev tools also offer you a way to remove storage values. This can be very useful when testing.</p>\n\n<p>Immediately writing the value may not be advisable. Let’s consider a slightly more advanced example. First, the updated form.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    My name is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>\n    and I am <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"age\"</span>&gt;</span> years old.\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"persist\"</span>&gt;</span>Save<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Now we’ve got two fields (again, bound to a Vue instance) but now there is the addition of a button that runs a <code>persist</code> method. Let’s look at the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">0</span>\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">if</span> (localStorage.name) &#123;\n      <span class=\"hljs-keyword\">this</span>.name = localStorage.name;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (localStorage.age) &#123;\n      <span class=\"hljs-keyword\">this</span>.age = localStorage.age;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    persist() &#123;\n      localStorage.name = <span class=\"hljs-keyword\">this</span>.name;\n      localStorage.age = <span class=\"hljs-keyword\">this</span>.age;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'now pretend I did more stuff...'</span>);\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>As before, <code>mounted</code> is used to load persisted data, if it exists. This time, though, data is only persisted when the button is clicked. We could also do any validations or transformations here before storing the value. You could also store a date representing when the values were stored. With that metadata, the <code>mounted</code> method could make a logical call on whether or not to store the values again. You can try this version below.</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"rdOjLN\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/rdOjLN/\" target=\"_blank\" rel=\"noopener\">testing localstorage 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Working-with-Complex-Values\"><a href=\"#Working-with-Complex-Values\" class=\"headerlink\" title=\"Working with Complex Values\"></a>Working with Complex Values</h2><p>As mentioned above, Local Storage only works with simple values. To store more complex values, like objects or arrays, you must serialize and deserialize the values with JSON. Here is a more advanced example that persists an array of cats (the best kind of array possible).</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>Cats<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(cat, n) in cats\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"cat\"</span>&gt;</span>&#123;&#123; cat &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"removeCat(n)\"</span>&gt;</span>Remove<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"newCat\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"addCat\"</span>&gt;</span>Add Cat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This “app” consists of a simple list on top (with a button to remove a cat) and a small form at the bottom to add a new cat. Now let’s look at the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">cats</span>: [],\n    <span class=\"hljs-attr\">newCat</span>: <span class=\"hljs-literal\">null</span>\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">if</span> (localStorage.getItem(<span class=\"hljs-string\">'cats'</span>)) &#123;\n      <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.cats = <span class=\"hljs-built_in\">JSON</span>.parse(localStorage.getItem(<span class=\"hljs-string\">'cats'</span>));\n      &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;\n        localStorage.removeItem(<span class=\"hljs-string\">'cats'</span>);\n      &#125;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    addCat() &#123;\n      <span class=\"hljs-comment\">// ensure they actually typed something</span>\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.newCat) &#123;\n        <span class=\"hljs-keyword\">return</span>;\n      &#125;\n\n      <span class=\"hljs-keyword\">this</span>.cats.push(<span class=\"hljs-keyword\">this</span>.newCat);\n      <span class=\"hljs-keyword\">this</span>.newCat = <span class=\"hljs-string\">''</span>;\n      <span class=\"hljs-keyword\">this</span>.saveCats();\n    &#125;,\n    removeCat(x) &#123;\n      <span class=\"hljs-keyword\">this</span>.cats.splice(x, <span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-keyword\">this</span>.saveCats();\n    &#125;,\n    saveCats() &#123;\n      <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-keyword\">this</span>.cats);\n      localStorage.setItem(<span class=\"hljs-string\">'cats'</span>, parsed);\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>In this application, we’ve switched to use the Local Storage APIs versus “direct” access. Both work but the API method is generally preferred. <code>mounted</code> now has to grab the value and parse the JSON value. If anything goes wrong here we assume the data is corrupt and delete it. (Remember, any time your web application uses client-side storage, the user has access to it and can modify it at will.)</p>\n<p>We have three methods now to handle working with cats. Both <code>addCat</code> and <code>removeCat</code> handle updating the “live” Vue data stored in <code>this.cats</code>. They then run <code>saveCats</code> which handles serializing and persisting the data. You can play with this version below:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"qoYbyW\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"localstorage, complex\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/qoYbyW/\" target=\"_blank\" rel=\"noopener\">localstorage, complex</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>While the Local Storage API is relatively simple, it is missing some basic features that would be useful in many applications. The following plugins wrap Local Storage access and make it easier to use, while also adding functionality like default values.</p>\n<ul>\n<li><a href=\"https://github.com/pinguinjkeke/vue-local-storage\" target=\"_blank\" rel=\"noopener\">vue-local-storage</a></li>\n<li><a href=\"https://github.com/ropbla9/vue-reactive-storage\" target=\"_blank\" rel=\"noopener\">vue-reactive-storage</a></li>\n<li><a href=\"https://github.com/yarkovaleksei/vue2-storage\" target=\"_blank\" rel=\"noopener\">vue2-storage</a></li>\n</ul>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>While the browser will never replace a server persistence system, having multiple ways to cache data locally can be a huge performance boost for your application, and working with it in Vue.js makes it even more powerful.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Client-side storage is an excellent way to quickly add performance gains to an application. By storing data on the browser itself, you can skip fetching information from the server every time the user needs it. While especially useful when offline, even online users will benefit from using data locally versus a remote server. Client-side storage can be done with <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies\" target=\"_blank\" rel=\"noopener\">cookies</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API\" target=\"_blank\" rel=\"noopener\">Local Storage</a> (technically “Web Storage”), <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\" target=\"_blank\" rel=\"noopener\">IndexedDB</a>, and <a href=\"https://www.w3.org/TR/webdatabase/\" target=\"_blank\" rel=\"noopener\">WebSQL</a> (a deprecated method that should not be used in new projects).</p>\n<p>In this cookbook entry we’ll focus on Local Storage, the simplest of the storage mechanisms. Local Storage uses a key/value system for storing data. It is limited to storing only simple values but complex data can be stored if you are willing to encode and decode the values with JSON. In general, Local Storage is appropriate for smaller sets of data you would want to persist, things like user preferences or form data. Larger data with more complex storage needs would be better stored typically in IndexedDB.</p>\n<p>Let’s begin with a simple form based example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  My name is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This example has one form field bound to a Vue value called <code>name</code>. Here’s the JavaScript:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">if</span> (localStorage.name) &#123;\n      <span class=\"hljs-keyword\">this</span>.name = localStorage.name;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    name(newName) &#123;\n      localStorage.name = newName;\n    &#125;\n  &#125;\n&#125;);</code></pre>\n<p>Focus on the <code>mounted</code> and <code>watch</code> parts. We use <code>mounted</code> to handle loading the value from localStorage. To handle writing the data base, we watch the <code>name</code> value and on change, immediately write it.</p>\n<p>You can run this yourself here:</p>\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"KodaKb\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/KodaKb/\" target=\"_blank\" rel=\"noopener\">testing localstorage</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><br><script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script><br><br>Type something in the form and then reload this page. You’ll note that the value you typed previously will show up automatically. Don’t forget that your browser provides excellent developer tools for inspecting client-side storage. Here’s an example in Firefox:<br><br><img src=\"/images/devtools-storage.png\" alt=\"Storage devtools in Firefox\"><br><br>And here it is in Chrome:<br><br><img src=\"/images/devtools-storage-chrome.png\" alt=\"Storage devtools in Chrome\"><br><br>And then finally, an example in Microsoft Edge. Note that you can find application storage values under the Debugger tab.<br><br><img src=\"/images/devtools-storage-edge.png\" alt=\"Storage devtools in Edge\"><br><br><p class=\"tip\">As a quick aside, these dev tools also offer you a way to remove storage values. This can be very useful when testing.</p>\n\n<p>Immediately writing the value may not be advisable. Let’s consider a slightly more advanced example. First, the updated form.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    My name is <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>\n    and I am <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"age\"</span>&gt;</span> years old.\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"persist\"</span>&gt;</span>Save<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Now we’ve got two fields (again, bound to a Vue instance) but now there is the addition of a button that runs a <code>persist</code> method. Let’s look at the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">0</span>\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">if</span> (localStorage.name) &#123;\n      <span class=\"hljs-keyword\">this</span>.name = localStorage.name;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (localStorage.age) &#123;\n      <span class=\"hljs-keyword\">this</span>.age = localStorage.age;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    persist() &#123;\n      localStorage.name = <span class=\"hljs-keyword\">this</span>.name;\n      localStorage.age = <span class=\"hljs-keyword\">this</span>.age;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'now pretend I did more stuff...'</span>);\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>As before, <code>mounted</code> is used to load persisted data, if it exists. This time, though, data is only persisted when the button is clicked. We could also do any validations or transformations here before storing the value. You could also store a date representing when the values were stored. With that metadata, the <code>mounted</code> method could make a logical call on whether or not to store the values again. You can try this version below.</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"rdOjLN\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"testing localstorage 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/rdOjLN/\" target=\"_blank\" rel=\"noopener\">testing localstorage 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Working-with-Complex-Values\"><a href=\"#Working-with-Complex-Values\" class=\"headerlink\" title=\"Working with Complex Values\"></a>Working with Complex Values</h2><p>As mentioned above, Local Storage only works with simple values. To store more complex values, like objects or arrays, you must serialize and deserialize the values with JSON. Here is a more advanced example that persists an array of cats (the best kind of array possible).</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>Cats<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(cat, n) in cats\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"cat\"</span>&gt;</span>&#123;&#123; cat &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"removeCat(n)\"</span>&gt;</span>Remove<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"newCat\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"addCat\"</span>&gt;</span>Add Cat<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This “app” consists of a simple list on top (with a button to remove a cat) and a small form at the bottom to add a new cat. Now let’s look at the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">cats</span>: [],\n    <span class=\"hljs-attr\">newCat</span>: <span class=\"hljs-literal\">null</span>\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">if</span> (localStorage.getItem(<span class=\"hljs-string\">'cats'</span>)) &#123;\n      <span class=\"hljs-keyword\">try</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.cats = <span class=\"hljs-built_in\">JSON</span>.parse(localStorage.getItem(<span class=\"hljs-string\">'cats'</span>));\n      &#125; <span class=\"hljs-keyword\">catch</span>(e) &#123;\n        localStorage.removeItem(<span class=\"hljs-string\">'cats'</span>);\n      &#125;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    addCat() &#123;\n      <span class=\"hljs-comment\">// ensure they actually typed something</span>\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.newCat) &#123;\n        <span class=\"hljs-keyword\">return</span>;\n      &#125;\n\n      <span class=\"hljs-keyword\">this</span>.cats.push(<span class=\"hljs-keyword\">this</span>.newCat);\n      <span class=\"hljs-keyword\">this</span>.newCat = <span class=\"hljs-string\">''</span>;\n      <span class=\"hljs-keyword\">this</span>.saveCats();\n    &#125;,\n    removeCat(x) &#123;\n      <span class=\"hljs-keyword\">this</span>.cats.splice(x, <span class=\"hljs-number\">1</span>);\n      <span class=\"hljs-keyword\">this</span>.saveCats();\n    &#125;,\n    saveCats() &#123;\n      <span class=\"hljs-keyword\">const</span> parsed = <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-keyword\">this</span>.cats);\n      localStorage.setItem(<span class=\"hljs-string\">'cats'</span>, parsed);\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>In this application, we’ve switched to use the Local Storage APIs versus “direct” access. Both work but the API method is generally preferred. <code>mounted</code> now has to grab the value and parse the JSON value. If anything goes wrong here we assume the data is corrupt and delete it. (Remember, any time your web application uses client-side storage, the user has access to it and can modify it at will.)</p>\n<p>We have three methods now to handle working with cats. Both <code>addCat</code> and <code>removeCat</code> handle updating the “live” Vue data stored in <code>this.cats</code>. They then run <code>saveCats</code> which handles serializing and persisting the data. You can play with this version below:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"qoYbyW\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"localstorage, complex\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/qoYbyW/\" target=\"_blank\" rel=\"noopener\">localstorage, complex</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>While the Local Storage API is relatively simple, it is missing some basic features that would be useful in many applications. The following plugins wrap Local Storage access and make it easier to use, while also adding functionality like default values.</p>\n<ul>\n<li><a href=\"https://github.com/pinguinjkeke/vue-local-storage\" target=\"_blank\" rel=\"noopener\">vue-local-storage</a></li>\n<li><a href=\"https://github.com/ropbla9/vue-reactive-storage\" target=\"_blank\" rel=\"noopener\">vue-reactive-storage</a></li>\n<li><a href=\"https://github.com/yarkovaleksei/vue2-storage\" target=\"_blank\" rel=\"noopener\">vue2-storage</a></li>\n</ul>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>While the browser will never replace a server persistence system, having multiple ways to cache data locally can be a huge performance boost for your application, and working with it in Vue.js makes it even more powerful.</p>\n"},{"title":"Creating Custom Scroll Directives","type":"cookbook","order":7,"_content":"\n## Base Example\n\nThere are many times that we might want to add a bit of behavior, especially animation, to a scroll event on a site. There are many ways to do so, but the path with the least amount of code and dependencies is perhaps to use a [custom directive](https://vuejs.org/v2/guide/custom-directive.html) to create a hook for anything that fires off a particular scroll event.\n\n```js\nVue.directive('scroll', {\n  inserted: function (el, binding) {\n    let f = function (evt) {\n      if (binding.value(evt, el)) {\n        window.removeEventListener('scroll', f)\n      }\n    }\n    window.addEventListener('scroll', f)\n  }\n})\n\n// main app\nnew Vue({\n  el: '#app',\n  methods: {\n    handleScroll: function (evt, el) {\n      if (window.scrollY > 50) {\n        el.setAttribute(\n          'style',\n          'opacity: 1; transform: translate3d(0, -10px, 0)'\n        )\n      }\n      return window.scrollY > 100\n    }\n  }\n})\n```\n\n```html\n<div id=\"app\">\n  <h1 class=\"centered\">Scroll me</h1>\n  <div\n    v-scroll=\"handleScroll\"\n    class=\"box\"\n  >\n    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. A atque amet harum aut ab veritatis earum porro praesentium ut corporis. Quasi provident dolorem officia iure fugiat, eius mollitia sequi quisquam.</p>\n  </div>\n</div>\n```\n\n<p class=\"tip\">Remember! The directive must be registered before the Vue instance.</p>\n\nWe'd also need a style property that will transition the intermediary values here, in this case:\n\n```css\n.box {\n  transition: 1.5s all cubic-bezier(0.39, 0.575, 0.565, 1);\n}\n```\n\n<p data-height=\"450\" data-theme-id=\"5162\" data-slug-hash=\"983220ed949ac670dff96bdcaf9d3338\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Custom Scroll Directive- CSS Transition\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/983220ed949ac670dff96bdcaf9d3338/\">Custom Scroll Directive- CSS Transition</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\">@sdras</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nOr, with GreenSock(GSAP) or any other JavaScript animation library, the code becomes even more simple:\n\n```js\nVue.directive('scroll', {\n  inserted: function (el, binding) {\n    let f = function (evt) {\n      if (binding.value(evt, el)) {\n        window.removeEventListener('scroll', f)\n      }\n    }\n    window.addEventListener('scroll', f)\n  }\n})\n\n// main app\nnew Vue({\n  el: '#app',\n  methods: {\n    handleScroll: function (evt, el) {\n      if (window.scrollY > 50) {\n        TweenMax.to(el, 1.5, {\n          y: -10,\n          opacity: 1,\n          ease: Sine.easeOut\n        })\n      }\n      return window.scrollY > 100\n    }\n  }\n})\n```\n\nThough we would remove the previous CSS transition from this implementation because it's now handled with JavaScript.\n\n## The Benefit of Using Custom Directives\n\nVue is rich with options for directives, most of which cover very common use-cases, which can create a very productive developer experience. But even if you have an edge case not covered by the framework, it's got you covered in this case as well, because you can quite easily create a custom directive to fit your needs.\n\nAttaching and removing scroll events to elements is a really good use case for this technique because just like other directives we use, they are necessarily tied to the element and otherwise, we'd have to find the reference for it in the DOM. This pattern avoids the need for traversal, and keeps the event logic paired with the node that it's in reference to.\n\n## Real-World Example: Using a Custom Scroll Directive for Cascading Animations\n\nIn the course of creating a cohesive site, you may find that you're reusing the same type of animation logic in several areas. It seems simple, we would then create a very specific custom directive, right? Well, typically if you're reusing it, you will need to change it _just_ slightly for each use.\n\nTo help keep our code concise and legible, we would want to pass in some predefined arguments such as the beginning point and ending of the animation as we scroll down the page.\n\n**This example is better viewed in the [full screen version](https://s.codepen.io/sdras/debug/078c19f5b3ed7f7d28584da450296cd0).**\n\n<p data-height=\"500\" data-theme-id=\"5162\" data-slug-hash=\"c8c55e3e0bba997350551dd747119100\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Scrolling Example- Using Custom Directives in Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/c8c55e3e0bba997350551dd747119100/\">Scrolling Example- Using Custom Directives in Vue</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\">@sdras</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nIn the demo above, each of the sections has two different types of animation triggered from the scroll: a morphing animation, and a drawing animation that animates the individual paths in the SVG. We reuse those two animations, so we can create a custom directive for each. The arguments we'll pass in will help keep everything simple and reusable.\n\nTo show how we do this, we'll take a look at the morphing shape example, where we'll need to state the start and finish, as well as pass in a path value that we'll create a morph to. These arguments are each defined as `binding.value.foo`:\n\n```js\nVue.directive('clipscroll', {\n  inserted: function (el, binding) {\n    let f = function (evt) {\n      var hasRun = false\n      if (!hasRun && window.scrollY > binding.value.start) {\n        hasRun = true\n        TweenMax.to(el, 2, {\n          morphSVG: binding.value.toPath,\n          ease: Sine.easeIn\n        })\n      }\n      if (window.scrollY > binding.value.end) {\n        window.removeEventListener('scroll', f)\n      }\n    }\n    window.addEventListener('scroll', f)\n  }\n})\n```\n\nWe can then use this animation in our template, in this case we're attaching the directive to the `clipPath` element, and pass all of our arguments to the directives in an object.\n\n```html\n<clipPath id=\"clip-path\">\n  <path\n    v-clipscroll=\"{ start: '50', end: '100', toPath: 'M0.39 0.34H15.99V22.44H0.39z' }\"\n    id=\"poly-shapemorph\"\n    d=\"M12.46 20.76L7.34 22.04 3.67 18.25 5.12 13.18 10.24 11.9 13.91 15.69 12.46 20.76z\"\n  />\n</clipPath>\n```\n\n## Alternative Patterns\n\nCustom directives are extremely useful, but you may find some situations where you need something very specific that already exists in scrolling libraries that you don't wish to rebuild from scratch yourself.\n\n[Scrollmagic](http://scrollmagic.io/) has a very rich ecosystem of offerings to work with, as well as good documentation and demos to explore. This includes, but is not limited to things like [parallax](http://scrollmagic.io/examples/advanced/parallax_scrolling.html), [cascading pinning](http://scrollmagic.io/examples/expert/cascading_pins.html), [section wipes](http://scrollmagic.io/examples/basic/section_wipes_natural.html), and [responsive duration](http://scrollmagic.io/examples/basic/responsive_duration.html).\n","source":"v2/cookbook/creating-custom-scroll-directives.md","raw":"---\ntitle: Creating Custom Scroll Directives\ntype: cookbook\norder: 7\n---\n\n## Base Example\n\nThere are many times that we might want to add a bit of behavior, especially animation, to a scroll event on a site. There are many ways to do so, but the path with the least amount of code and dependencies is perhaps to use a [custom directive](https://vuejs.org/v2/guide/custom-directive.html) to create a hook for anything that fires off a particular scroll event.\n\n```js\nVue.directive('scroll', {\n  inserted: function (el, binding) {\n    let f = function (evt) {\n      if (binding.value(evt, el)) {\n        window.removeEventListener('scroll', f)\n      }\n    }\n    window.addEventListener('scroll', f)\n  }\n})\n\n// main app\nnew Vue({\n  el: '#app',\n  methods: {\n    handleScroll: function (evt, el) {\n      if (window.scrollY > 50) {\n        el.setAttribute(\n          'style',\n          'opacity: 1; transform: translate3d(0, -10px, 0)'\n        )\n      }\n      return window.scrollY > 100\n    }\n  }\n})\n```\n\n```html\n<div id=\"app\">\n  <h1 class=\"centered\">Scroll me</h1>\n  <div\n    v-scroll=\"handleScroll\"\n    class=\"box\"\n  >\n    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. A atque amet harum aut ab veritatis earum porro praesentium ut corporis. Quasi provident dolorem officia iure fugiat, eius mollitia sequi quisquam.</p>\n  </div>\n</div>\n```\n\n<p class=\"tip\">Remember! The directive must be registered before the Vue instance.</p>\n\nWe'd also need a style property that will transition the intermediary values here, in this case:\n\n```css\n.box {\n  transition: 1.5s all cubic-bezier(0.39, 0.575, 0.565, 1);\n}\n```\n\n<p data-height=\"450\" data-theme-id=\"5162\" data-slug-hash=\"983220ed949ac670dff96bdcaf9d3338\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Custom Scroll Directive- CSS Transition\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/983220ed949ac670dff96bdcaf9d3338/\">Custom Scroll Directive- CSS Transition</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\">@sdras</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nOr, with GreenSock(GSAP) or any other JavaScript animation library, the code becomes even more simple:\n\n```js\nVue.directive('scroll', {\n  inserted: function (el, binding) {\n    let f = function (evt) {\n      if (binding.value(evt, el)) {\n        window.removeEventListener('scroll', f)\n      }\n    }\n    window.addEventListener('scroll', f)\n  }\n})\n\n// main app\nnew Vue({\n  el: '#app',\n  methods: {\n    handleScroll: function (evt, el) {\n      if (window.scrollY > 50) {\n        TweenMax.to(el, 1.5, {\n          y: -10,\n          opacity: 1,\n          ease: Sine.easeOut\n        })\n      }\n      return window.scrollY > 100\n    }\n  }\n})\n```\n\nThough we would remove the previous CSS transition from this implementation because it's now handled with JavaScript.\n\n## The Benefit of Using Custom Directives\n\nVue is rich with options for directives, most of which cover very common use-cases, which can create a very productive developer experience. But even if you have an edge case not covered by the framework, it's got you covered in this case as well, because you can quite easily create a custom directive to fit your needs.\n\nAttaching and removing scroll events to elements is a really good use case for this technique because just like other directives we use, they are necessarily tied to the element and otherwise, we'd have to find the reference for it in the DOM. This pattern avoids the need for traversal, and keeps the event logic paired with the node that it's in reference to.\n\n## Real-World Example: Using a Custom Scroll Directive for Cascading Animations\n\nIn the course of creating a cohesive site, you may find that you're reusing the same type of animation logic in several areas. It seems simple, we would then create a very specific custom directive, right? Well, typically if you're reusing it, you will need to change it _just_ slightly for each use.\n\nTo help keep our code concise and legible, we would want to pass in some predefined arguments such as the beginning point and ending of the animation as we scroll down the page.\n\n**This example is better viewed in the [full screen version](https://s.codepen.io/sdras/debug/078c19f5b3ed7f7d28584da450296cd0).**\n\n<p data-height=\"500\" data-theme-id=\"5162\" data-slug-hash=\"c8c55e3e0bba997350551dd747119100\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Scrolling Example- Using Custom Directives in Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/c8c55e3e0bba997350551dd747119100/\">Scrolling Example- Using Custom Directives in Vue</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\">@sdras</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nIn the demo above, each of the sections has two different types of animation triggered from the scroll: a morphing animation, and a drawing animation that animates the individual paths in the SVG. We reuse those two animations, so we can create a custom directive for each. The arguments we'll pass in will help keep everything simple and reusable.\n\nTo show how we do this, we'll take a look at the morphing shape example, where we'll need to state the start and finish, as well as pass in a path value that we'll create a morph to. These arguments are each defined as `binding.value.foo`:\n\n```js\nVue.directive('clipscroll', {\n  inserted: function (el, binding) {\n    let f = function (evt) {\n      var hasRun = false\n      if (!hasRun && window.scrollY > binding.value.start) {\n        hasRun = true\n        TweenMax.to(el, 2, {\n          morphSVG: binding.value.toPath,\n          ease: Sine.easeIn\n        })\n      }\n      if (window.scrollY > binding.value.end) {\n        window.removeEventListener('scroll', f)\n      }\n    }\n    window.addEventListener('scroll', f)\n  }\n})\n```\n\nWe can then use this animation in our template, in this case we're attaching the directive to the `clipPath` element, and pass all of our arguments to the directives in an object.\n\n```html\n<clipPath id=\"clip-path\">\n  <path\n    v-clipscroll=\"{ start: '50', end: '100', toPath: 'M0.39 0.34H15.99V22.44H0.39z' }\"\n    id=\"poly-shapemorph\"\n    d=\"M12.46 20.76L7.34 22.04 3.67 18.25 5.12 13.18 10.24 11.9 13.91 15.69 12.46 20.76z\"\n  />\n</clipPath>\n```\n\n## Alternative Patterns\n\nCustom directives are extremely useful, but you may find some situations where you need something very specific that already exists in scrolling libraries that you don't wish to rebuild from scratch yourself.\n\n[Scrollmagic](http://scrollmagic.io/) has a very rich ecosystem of offerings to work with, as well as good documentation and demos to explore. This includes, but is not limited to things like [parallax](http://scrollmagic.io/examples/advanced/parallax_scrolling.html), [cascading pinning](http://scrollmagic.io/examples/expert/cascading_pins.html), [section wipes](http://scrollmagic.io/examples/basic/section_wipes_natural.html), and [responsive duration](http://scrollmagic.io/examples/basic/responsive_duration.html).\n","date":"2020-09-25T23:55:41.105Z","updated":"2020-09-25T23:55:41.105Z","path":"v2/cookbook/creating-custom-scroll-directives.html","comments":1,"layout":"page","_id":"ckfl66gy3000kc2v56slb4gh1","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are many times that we might want to add a bit of behavior, especially animation, to a scroll event on a site. There are many ways to do so, but the path with the least amount of code and dependencies is perhaps to use a <a href=\"https://vuejs.org/v2/guide/custom-directive.html\">custom directive</a> to create a hook for anything that fires off a particular scroll event.</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'scroll'</span>, &#123;\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> f = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (binding.value(evt, el)) &#123;\n        <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n      &#125;\n    &#125;\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// main app</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">handleScroll</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt, el</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">50</span>) &#123;\n        el.setAttribute(\n          <span class=\"hljs-string\">'style'</span>,\n          <span class=\"hljs-string\">'opacity: 1; transform: translate3d(0, -10px, 0)'</span>\n        )\n      &#125;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">100</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"centered\"</span>&gt;</span>Scroll me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n    <span class=\"hljs-attr\">v-scroll</span>=<span class=\"hljs-string\">\"handleScroll\"</span>\n    <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"box\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. A atque amet harum aut ab veritatis earum porro praesentium ut corporis. Quasi provident dolorem officia iure fugiat, eius mollitia sequi quisquam.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Remember! The directive must be registered before the Vue instance.</p>\n\n<p>We’d also need a style property that will transition the intermediary values here, in this case:</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.box</span> &#123;\n  <span class=\"hljs-attribute\">transition</span>: <span class=\"hljs-number\">1.5s</span> all <span class=\"hljs-built_in\">cubic-bezier</span>(<span class=\"hljs-number\">0.39</span>, <span class=\"hljs-number\">0.575</span>, <span class=\"hljs-number\">0.565</span>, <span class=\"hljs-number\">1</span>);\n&#125;</code></pre>\n<p></p><p data-height=\"450\" data-theme-id=\"5162\" data-slug-hash=\"983220ed949ac670dff96bdcaf9d3338\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Custom Scroll Directive- CSS Transition\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/983220ed949ac670dff96bdcaf9d3338/\" target=\"_blank\" rel=\"noopener\">Custom Scroll Directive- CSS Transition</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\" target=\"_blank\" rel=\"noopener\">@sdras</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>Or, with GreenSock(GSAP) or any other JavaScript animation library, the code becomes even more simple:</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'scroll'</span>, &#123;\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> f = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (binding.value(evt, el)) &#123;\n        <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n      &#125;\n    &#125;\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// main app</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">handleScroll</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt, el</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">50</span>) &#123;\n        TweenMax.to(el, <span class=\"hljs-number\">1.5</span>, &#123;\n          <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">-10</span>,\n          <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">1</span>,\n          <span class=\"hljs-attr\">ease</span>: Sine.easeOut\n        &#125;)\n      &#125;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">100</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Though we would remove the previous CSS transition from this implementation because it’s now handled with JavaScript.</p>\n<h2 id=\"The-Benefit-of-Using-Custom-Directives\"><a href=\"#The-Benefit-of-Using-Custom-Directives\" class=\"headerlink\" title=\"The Benefit of Using Custom Directives\"></a>The Benefit of Using Custom Directives</h2><p>Vue is rich with options for directives, most of which cover very common use-cases, which can create a very productive developer experience. But even if you have an edge case not covered by the framework, it’s got you covered in this case as well, because you can quite easily create a custom directive to fit your needs.</p>\n<p>Attaching and removing scroll events to elements is a really good use case for this technique because just like other directives we use, they are necessarily tied to the element and otherwise, we’d have to find the reference for it in the DOM. This pattern avoids the need for traversal, and keeps the event logic paired with the node that it’s in reference to.</p>\n<h2 id=\"Real-World-Example-Using-a-Custom-Scroll-Directive-for-Cascading-Animations\"><a href=\"#Real-World-Example-Using-a-Custom-Scroll-Directive-for-Cascading-Animations\" class=\"headerlink\" title=\"Real-World Example: Using a Custom Scroll Directive for Cascading Animations\"></a>Real-World Example: Using a Custom Scroll Directive for Cascading Animations</h2><p>In the course of creating a cohesive site, you may find that you’re reusing the same type of animation logic in several areas. It seems simple, we would then create a very specific custom directive, right? Well, typically if you’re reusing it, you will need to change it <em>just</em> slightly for each use.</p>\n<p>To help keep our code concise and legible, we would want to pass in some predefined arguments such as the beginning point and ending of the animation as we scroll down the page.</p>\n<p><strong>This example is better viewed in the <a href=\"https://s.codepen.io/sdras/debug/078c19f5b3ed7f7d28584da450296cd0\" target=\"_blank\" rel=\"noopener\">full screen version</a>.</strong></p>\n<p></p><p data-height=\"500\" data-theme-id=\"5162\" data-slug-hash=\"c8c55e3e0bba997350551dd747119100\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Scrolling Example- Using Custom Directives in Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/c8c55e3e0bba997350551dd747119100/\" target=\"_blank\" rel=\"noopener\">Scrolling Example- Using Custom Directives in Vue</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\" target=\"_blank\" rel=\"noopener\">@sdras</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>In the demo above, each of the sections has two different types of animation triggered from the scroll: a morphing animation, and a drawing animation that animates the individual paths in the SVG. We reuse those two animations, so we can create a custom directive for each. The arguments we’ll pass in will help keep everything simple and reusable.</p>\n<p>To show how we do this, we’ll take a look at the morphing shape example, where we’ll need to state the start and finish, as well as pass in a path value that we’ll create a morph to. These arguments are each defined as <code>binding.value.foo</code>:</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'clipscroll'</span>, &#123;\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> f = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> hasRun = <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">if</span> (!hasRun &amp;&amp; <span class=\"hljs-built_in\">window</span>.scrollY &gt; binding.value.start) &#123;\n        hasRun = <span class=\"hljs-literal\">true</span>\n        TweenMax.to(el, <span class=\"hljs-number\">2</span>, &#123;\n          <span class=\"hljs-attr\">morphSVG</span>: binding.value.toPath,\n          <span class=\"hljs-attr\">ease</span>: Sine.easeIn\n        &#125;)\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.scrollY &gt; binding.value.end) &#123;\n        <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n      &#125;\n    &#125;\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n  &#125;\n&#125;)</code></pre>\n<p>We can then use this animation in our template, in this case we’re attaching the directive to the <code>clipPath</code> element, and pass all of our arguments to the directives in an object.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"clip-path\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n    <span class=\"hljs-attr\">v-clipscroll</span>=<span class=\"hljs-string\">\"&#123; start: '50', end: '100', toPath: 'M0.39 0.34H15.99V22.44H0.39z' &#125;\"</span>\n    <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"poly-shapemorph\"</span>\n    <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M12.46 20.76L7.34 22.04 3.67 18.25 5.12 13.18 10.24 11.9 13.91 15.69 12.46 20.76z\"</span>\n  /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span></code></pre>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>Custom directives are extremely useful, but you may find some situations where you need something very specific that already exists in scrolling libraries that you don’t wish to rebuild from scratch yourself.</p>\n<p><a href=\"http://scrollmagic.io/\" target=\"_blank\" rel=\"noopener\">Scrollmagic</a> has a very rich ecosystem of offerings to work with, as well as good documentation and demos to explore. This includes, but is not limited to things like <a href=\"http://scrollmagic.io/examples/advanced/parallax_scrolling.html\" target=\"_blank\" rel=\"noopener\">parallax</a>, <a href=\"http://scrollmagic.io/examples/expert/cascading_pins.html\" target=\"_blank\" rel=\"noopener\">cascading pinning</a>, <a href=\"http://scrollmagic.io/examples/basic/section_wipes_natural.html\" target=\"_blank\" rel=\"noopener\">section wipes</a>, and <a href=\"http://scrollmagic.io/examples/basic/responsive_duration.html\" target=\"_blank\" rel=\"noopener\">responsive duration</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are many times that we might want to add a bit of behavior, especially animation, to a scroll event on a site. There are many ways to do so, but the path with the least amount of code and dependencies is perhaps to use a <a href=\"https://vuejs.org/v2/guide/custom-directive.html\">custom directive</a> to create a hook for anything that fires off a particular scroll event.</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'scroll'</span>, &#123;\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> f = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (binding.value(evt, el)) &#123;\n        <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n      &#125;\n    &#125;\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// main app</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">handleScroll</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt, el</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">50</span>) &#123;\n        el.setAttribute(\n          <span class=\"hljs-string\">'style'</span>,\n          <span class=\"hljs-string\">'opacity: 1; transform: translate3d(0, -10px, 0)'</span>\n        )\n      &#125;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">100</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"centered\"</span>&gt;</span>Scroll me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n    <span class=\"hljs-attr\">v-scroll</span>=<span class=\"hljs-string\">\"handleScroll\"</span>\n    <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"box\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Lorem ipsum dolor sit amet, consectetur adipisicing elit. A atque amet harum aut ab veritatis earum porro praesentium ut corporis. Quasi provident dolorem officia iure fugiat, eius mollitia sequi quisquam.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Remember! The directive must be registered before the Vue instance.</p>\n\n<p>We’d also need a style property that will transition the intermediary values here, in this case:</p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.box</span> &#123;\n  <span class=\"hljs-attribute\">transition</span>: <span class=\"hljs-number\">1.5s</span> all <span class=\"hljs-built_in\">cubic-bezier</span>(<span class=\"hljs-number\">0.39</span>, <span class=\"hljs-number\">0.575</span>, <span class=\"hljs-number\">0.565</span>, <span class=\"hljs-number\">1</span>);\n&#125;</code></pre>\n<p></p><p data-height=\"450\" data-theme-id=\"5162\" data-slug-hash=\"983220ed949ac670dff96bdcaf9d3338\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Custom Scroll Directive- CSS Transition\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/983220ed949ac670dff96bdcaf9d3338/\" target=\"_blank\" rel=\"noopener\">Custom Scroll Directive- CSS Transition</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\" target=\"_blank\" rel=\"noopener\">@sdras</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>Or, with GreenSock(GSAP) or any other JavaScript animation library, the code becomes even more simple:</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'scroll'</span>, &#123;\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> f = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (binding.value(evt, el)) &#123;\n        <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n      &#125;\n    &#125;\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// main app</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">handleScroll</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt, el</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">50</span>) &#123;\n        TweenMax.to(el, <span class=\"hljs-number\">1.5</span>, &#123;\n          <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">-10</span>,\n          <span class=\"hljs-attr\">opacity</span>: <span class=\"hljs-number\">1</span>,\n          <span class=\"hljs-attr\">ease</span>: Sine.easeOut\n        &#125;)\n      &#125;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">window</span>.scrollY &gt; <span class=\"hljs-number\">100</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Though we would remove the previous CSS transition from this implementation because it’s now handled with JavaScript.</p>\n<h2 id=\"The-Benefit-of-Using-Custom-Directives\"><a href=\"#The-Benefit-of-Using-Custom-Directives\" class=\"headerlink\" title=\"The Benefit of Using Custom Directives\"></a>The Benefit of Using Custom Directives</h2><p>Vue is rich with options for directives, most of which cover very common use-cases, which can create a very productive developer experience. But even if you have an edge case not covered by the framework, it’s got you covered in this case as well, because you can quite easily create a custom directive to fit your needs.</p>\n<p>Attaching and removing scroll events to elements is a really good use case for this technique because just like other directives we use, they are necessarily tied to the element and otherwise, we’d have to find the reference for it in the DOM. This pattern avoids the need for traversal, and keeps the event logic paired with the node that it’s in reference to.</p>\n<h2 id=\"Real-World-Example-Using-a-Custom-Scroll-Directive-for-Cascading-Animations\"><a href=\"#Real-World-Example-Using-a-Custom-Scroll-Directive-for-Cascading-Animations\" class=\"headerlink\" title=\"Real-World Example: Using a Custom Scroll Directive for Cascading Animations\"></a>Real-World Example: Using a Custom Scroll Directive for Cascading Animations</h2><p>In the course of creating a cohesive site, you may find that you’re reusing the same type of animation logic in several areas. It seems simple, we would then create a very specific custom directive, right? Well, typically if you’re reusing it, you will need to change it <em>just</em> slightly for each use.</p>\n<p>To help keep our code concise and legible, we would want to pass in some predefined arguments such as the beginning point and ending of the animation as we scroll down the page.</p>\n<p><strong>This example is better viewed in the <a href=\"https://s.codepen.io/sdras/debug/078c19f5b3ed7f7d28584da450296cd0\" target=\"_blank\" rel=\"noopener\">full screen version</a>.</strong></p>\n<p></p><p data-height=\"500\" data-theme-id=\"5162\" data-slug-hash=\"c8c55e3e0bba997350551dd747119100\" data-default-tab=\"result\" data-user=\"sdras\" data-embed-version=\"2\" data-pen-title=\"Scrolling Example- Using Custom Directives in Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/sdras/pen/c8c55e3e0bba997350551dd747119100/\" target=\"_blank\" rel=\"noopener\">Scrolling Example- Using Custom Directives in Vue</a> by Sarah Drasner (<a href=\"https://codepen.io/sdras\" target=\"_blank\" rel=\"noopener\">@sdras</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>In the demo above, each of the sections has two different types of animation triggered from the scroll: a morphing animation, and a drawing animation that animates the individual paths in the SVG. We reuse those two animations, so we can create a custom directive for each. The arguments we’ll pass in will help keep everything simple and reusable.</p>\n<p>To show how we do this, we’ll take a look at the morphing shape example, where we’ll need to state the start and finish, as well as pass in a path value that we’ll create a morph to. These arguments are each defined as <code>binding.value.foo</code>:</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'clipscroll'</span>, &#123;\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n    <span class=\"hljs-keyword\">let</span> f = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">evt</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> hasRun = <span class=\"hljs-literal\">false</span>\n      <span class=\"hljs-keyword\">if</span> (!hasRun &amp;&amp; <span class=\"hljs-built_in\">window</span>.scrollY &gt; binding.value.start) &#123;\n        hasRun = <span class=\"hljs-literal\">true</span>\n        TweenMax.to(el, <span class=\"hljs-number\">2</span>, &#123;\n          <span class=\"hljs-attr\">morphSVG</span>: binding.value.toPath,\n          <span class=\"hljs-attr\">ease</span>: Sine.easeIn\n        &#125;)\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">window</span>.scrollY &gt; binding.value.end) &#123;\n        <span class=\"hljs-built_in\">window</span>.removeEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n      &#125;\n    &#125;\n    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">'scroll'</span>, f)\n  &#125;\n&#125;)</code></pre>\n<p>We can then use this animation in our template, in this case we’re attaching the directive to the <code>clipPath</code> element, and pass all of our arguments to the directives in an object.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clipPath</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"clip-path\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n    <span class=\"hljs-attr\">v-clipscroll</span>=<span class=\"hljs-string\">\"&#123; start: '50', end: '100', toPath: 'M0.39 0.34H15.99V22.44H0.39z' &#125;\"</span>\n    <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"poly-shapemorph\"</span>\n    <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M12.46 20.76L7.34 22.04 3.67 18.25 5.12 13.18 10.24 11.9 13.91 15.69 12.46 20.76z\"</span>\n  /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clipPath</span>&gt;</span></code></pre>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>Custom directives are extremely useful, but you may find some situations where you need something very specific that already exists in scrolling libraries that you don’t wish to rebuild from scratch yourself.</p>\n<p><a href=\"http://scrollmagic.io/\" target=\"_blank\" rel=\"noopener\">Scrollmagic</a> has a very rich ecosystem of offerings to work with, as well as good documentation and demos to explore. This includes, but is not limited to things like <a href=\"http://scrollmagic.io/examples/advanced/parallax_scrolling.html\" target=\"_blank\" rel=\"noopener\">parallax</a>, <a href=\"http://scrollmagic.io/examples/expert/cascading_pins.html\" target=\"_blank\" rel=\"noopener\">cascading pinning</a>, <a href=\"http://scrollmagic.io/examples/basic/section_wipes_natural.html\" target=\"_blank\" rel=\"noopener\">section wipes</a>, and <a href=\"http://scrollmagic.io/examples/basic/responsive_duration.html\" target=\"_blank\" rel=\"noopener\">responsive duration</a>.</p>\n"},{"title":"Debugging in VS Code","type":"cookbook","order":8,"_content":"\nEvery application reaches a point where it's necessary to understand failures, small to large. In this recipe, we explore a few workflows for VS Code users who would like to debug their application in the browser.\n\nThis recipe shows how to debug [Vue CLI](https://github.com/vuejs/vue-cli) applications in VS Code as they run in the browser.\n\n<p class=\"tip\">Note: This recipe covers Chrome and Firefox. If you know how to setup VS Code debugging with other browsers, please consider sharing your insights (see bottom of the page).</p>\n\n## Prerequisites\n\nMake sure you have VS Code and the browser of your choice installed, and the latest version of the corresponding Debugger extension installed and enabled:\n\n* [Debugger for Chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome)\n* [Debugger for Firefox](https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-firefox-debug)\n\nInstall and create a project with the [vue-cli](https://github.com/vuejs/vue-cli), following the instructions in the [Vue CLI Guide](https://cli.vuejs.org/). Change into the newly created application directory and open VS Code.\n\n### Displaying Source Code in the Browser\n\nBefore you can debug your Vue components from VS Code, you need to update the generated Webpack config to build sourcemaps. We do this so that our debugger has a way to map the code within a compressed file back to its position in the original file. This ensures that you can debug an application even after your assets have been optimized by Webpack.\n\nIf you use Vue CLI 2, set or update the `devtool` property inside `config/index.js`:\n\n```json\ndevtool: 'source-map',\n```\n\nIf you use Vue CLI 3, set or update the `devtool` property inside `vue.config.js`:\n\n```js\nmodule.exports = {\n  configureWebpack: {\n    devtool: 'source-map'\n  }\n}\n```\n\n### Launching the Application from VS Code\n\n<p class=\"tip\">We're assuming the port to be `8080` here. If it's not the case (for instance, if `8080` has been taken and Vue CLI automatically picks another port for you), just modify the configuration accordingly.</p>\n\nClick on the Debugging icon in the Activity Bar to bring up the Debug view, then click on the gear icon to configure a launch.json file, selecting **Chrome/Firefox: Launch** as the environment. Replace content of the generated launch.json with the corresponding configuration:\n\n![Add Chrome Configuration](/images/config_add.png)\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"name\": \"vuejs: chrome\",\n      \"url\": \"http://localhost:8080\",\n      \"webRoot\": \"${workspaceFolder}/src\",\n      \"breakOnLoad\": true,\n      \"sourceMapPathOverrides\": {\n        \"webpack:///src/*\": \"${webRoot}/*\"\n      }\n    },\n    {\n      \"type\": \"firefox\",\n      \"request\": \"launch\",\n      \"name\": \"vuejs: firefox\",\n      \"url\": \"http://localhost:8080\",\n      \"webRoot\": \"${workspaceFolder}/src\",\n      \"pathMappings\": [{ \"url\": \"webpack:///src/\", \"path\": \"${webRoot}/\" }]\n    }\n  ]\n}\n```\n\n## Setting a Breakpoint\n\n1.  Set a breakpoint in **src/components/HelloWorld.vue** on `line 90` where the `data` function returns a string.\n\n  ![Breakpoint Renderer](/images/breakpoint_set.png)\n\n2.  Open your favorite terminal at the root folder and serve the app using Vue CLI:\n\n  ```\n  npm run serve\n  ```\n\n3.  Go to the Debug view, select the **'vuejs: chrome/firefox'** configuration, then press F5 or click the green play button.\n\n4.  Your breakpoint should now be hit as a new browser instance opens `http://localhost:8080`.\n\n  ![Breakpoint Hit](/images/breakpoint_hit.png)\n\n## Alternative Patterns\n\n### Vue Devtools\n\nThere are other methods of debugging, varying in complexity. The most popular and simple of which is to use the excellent Vue.js devtools [for Chrome](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd) and [for Firefox](https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/). Some of the benefits of working with the devtools are that they enable you to live-edit data properties and see the changes reflected immediately. The other major benefit is the ability to do time travel debugging for Vuex.\n\n![Devtools Timetravel Debugger](/images/devtools-timetravel.gif)\n\n<p class=\"tip\">Please note that if the page uses a production/minified build of Vue.js (such as the standard link from a CDN), devtools inspection is disabled by default so the Vue pane won't show up. If you switch to an unminified version, you may have to give the page a hard refresh to see them.</p>\n\n### Simple Debugger Statement\n\nThe example above has a great workflow. However, there is an alternative option where you can use the [native debugger statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) directly in your code. If you choose to work this way, it's important that you remember to remove the statements when you're done.\n\n```js\n<script>\nexport default {\n  data() {\n    return {\n      message: ''\n    }\n  },\n  mounted() {\n    const hello = 'Hello World!'\n    debugger\n    this.message = hello\n  }\n};\n</script>\n```\n\n## Acknowledgements\n\nThis recipe was based on a contribution from [Kenneth Auchenberg](https://twitter.com/auchenberg), [available here](https://github.com/Microsoft/VSCode-recipes/tree/master/vuejs-cli).\n","source":"v2/cookbook/debugging-in-vscode.md","raw":"---\ntitle: Debugging in VS Code\ntype: cookbook\norder: 8\n---\n\nEvery application reaches a point where it's necessary to understand failures, small to large. In this recipe, we explore a few workflows for VS Code users who would like to debug their application in the browser.\n\nThis recipe shows how to debug [Vue CLI](https://github.com/vuejs/vue-cli) applications in VS Code as they run in the browser.\n\n<p class=\"tip\">Note: This recipe covers Chrome and Firefox. If you know how to setup VS Code debugging with other browsers, please consider sharing your insights (see bottom of the page).</p>\n\n## Prerequisites\n\nMake sure you have VS Code and the browser of your choice installed, and the latest version of the corresponding Debugger extension installed and enabled:\n\n* [Debugger for Chrome](https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome)\n* [Debugger for Firefox](https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-firefox-debug)\n\nInstall and create a project with the [vue-cli](https://github.com/vuejs/vue-cli), following the instructions in the [Vue CLI Guide](https://cli.vuejs.org/). Change into the newly created application directory and open VS Code.\n\n### Displaying Source Code in the Browser\n\nBefore you can debug your Vue components from VS Code, you need to update the generated Webpack config to build sourcemaps. We do this so that our debugger has a way to map the code within a compressed file back to its position in the original file. This ensures that you can debug an application even after your assets have been optimized by Webpack.\n\nIf you use Vue CLI 2, set or update the `devtool` property inside `config/index.js`:\n\n```json\ndevtool: 'source-map',\n```\n\nIf you use Vue CLI 3, set or update the `devtool` property inside `vue.config.js`:\n\n```js\nmodule.exports = {\n  configureWebpack: {\n    devtool: 'source-map'\n  }\n}\n```\n\n### Launching the Application from VS Code\n\n<p class=\"tip\">We're assuming the port to be `8080` here. If it's not the case (for instance, if `8080` has been taken and Vue CLI automatically picks another port for you), just modify the configuration accordingly.</p>\n\nClick on the Debugging icon in the Activity Bar to bring up the Debug view, then click on the gear icon to configure a launch.json file, selecting **Chrome/Firefox: Launch** as the environment. Replace content of the generated launch.json with the corresponding configuration:\n\n![Add Chrome Configuration](/images/config_add.png)\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"chrome\",\n      \"request\": \"launch\",\n      \"name\": \"vuejs: chrome\",\n      \"url\": \"http://localhost:8080\",\n      \"webRoot\": \"${workspaceFolder}/src\",\n      \"breakOnLoad\": true,\n      \"sourceMapPathOverrides\": {\n        \"webpack:///src/*\": \"${webRoot}/*\"\n      }\n    },\n    {\n      \"type\": \"firefox\",\n      \"request\": \"launch\",\n      \"name\": \"vuejs: firefox\",\n      \"url\": \"http://localhost:8080\",\n      \"webRoot\": \"${workspaceFolder}/src\",\n      \"pathMappings\": [{ \"url\": \"webpack:///src/\", \"path\": \"${webRoot}/\" }]\n    }\n  ]\n}\n```\n\n## Setting a Breakpoint\n\n1.  Set a breakpoint in **src/components/HelloWorld.vue** on `line 90` where the `data` function returns a string.\n\n  ![Breakpoint Renderer](/images/breakpoint_set.png)\n\n2.  Open your favorite terminal at the root folder and serve the app using Vue CLI:\n\n  ```\n  npm run serve\n  ```\n\n3.  Go to the Debug view, select the **'vuejs: chrome/firefox'** configuration, then press F5 or click the green play button.\n\n4.  Your breakpoint should now be hit as a new browser instance opens `http://localhost:8080`.\n\n  ![Breakpoint Hit](/images/breakpoint_hit.png)\n\n## Alternative Patterns\n\n### Vue Devtools\n\nThere are other methods of debugging, varying in complexity. The most popular and simple of which is to use the excellent Vue.js devtools [for Chrome](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd) and [for Firefox](https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/). Some of the benefits of working with the devtools are that they enable you to live-edit data properties and see the changes reflected immediately. The other major benefit is the ability to do time travel debugging for Vuex.\n\n![Devtools Timetravel Debugger](/images/devtools-timetravel.gif)\n\n<p class=\"tip\">Please note that if the page uses a production/minified build of Vue.js (such as the standard link from a CDN), devtools inspection is disabled by default so the Vue pane won't show up. If you switch to an unminified version, you may have to give the page a hard refresh to see them.</p>\n\n### Simple Debugger Statement\n\nThe example above has a great workflow. However, there is an alternative option where you can use the [native debugger statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger) directly in your code. If you choose to work this way, it's important that you remember to remove the statements when you're done.\n\n```js\n<script>\nexport default {\n  data() {\n    return {\n      message: ''\n    }\n  },\n  mounted() {\n    const hello = 'Hello World!'\n    debugger\n    this.message = hello\n  }\n};\n</script>\n```\n\n## Acknowledgements\n\nThis recipe was based on a contribution from [Kenneth Auchenberg](https://twitter.com/auchenberg), [available here](https://github.com/Microsoft/VSCode-recipes/tree/master/vuejs-cli).\n","date":"2020-09-25T23:55:41.105Z","updated":"2020-09-25T23:55:41.105Z","path":"v2/cookbook/debugging-in-vscode.html","comments":1,"layout":"page","_id":"ckfl66gy3000lc2v5q6uwbvnm","content":"<p>Every application reaches a point where it’s necessary to understand failures, small to large. In this recipe, we explore a few workflows for VS Code users who would like to debug their application in the browser.</p>\n<p>This recipe shows how to debug <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">Vue CLI</a> applications in VS Code as they run in the browser.</p>\n<p class=\"tip\">Note: This recipe covers Chrome and Firefox. If you know how to setup VS Code debugging with other browsers, please consider sharing your insights (see bottom of the page).</p>\n\n<h2 id=\"Prerequisites\"><a href=\"#Prerequisites\" class=\"headerlink\" title=\"Prerequisites\"></a>Prerequisites</h2><p>Make sure you have VS Code and the browser of your choice installed, and the latest version of the corresponding Debugger extension installed and enabled:</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome\" target=\"_blank\" rel=\"noopener\">Debugger for Chrome</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-firefox-debug\" target=\"_blank\" rel=\"noopener\">Debugger for Firefox</a></li>\n</ul>\n<p>Install and create a project with the <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">vue-cli</a>, following the instructions in the <a href=\"https://cli.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue CLI Guide</a>. Change into the newly created application directory and open VS Code.</p>\n<h3 id=\"Displaying-Source-Code-in-the-Browser\"><a href=\"#Displaying-Source-Code-in-the-Browser\" class=\"headerlink\" title=\"Displaying Source Code in the Browser\"></a>Displaying Source Code in the Browser</h3><p>Before you can debug your Vue components from VS Code, you need to update the generated Webpack config to build sourcemaps. We do this so that our debugger has a way to map the code within a compressed file back to its position in the original file. This ensures that you can debug an application even after your assets have been optimized by Webpack.</p>\n<p>If you use Vue CLI 2, set or update the <code>devtool</code> property inside <code>config/index.js</code>:</p>\n<pre><code class=\"hljs json\">devtool: 'source-map',</code></pre>\n<p>If you use Vue CLI 3, set or update the <code>devtool</code> property inside <code>vue.config.js</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-attr\">configureWebpack</span>: &#123;\n    <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">'source-map'</span>\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Launching-the-Application-from-VS-Code\"><a href=\"#Launching-the-Application-from-VS-Code\" class=\"headerlink\" title=\"Launching the Application from VS Code\"></a>Launching the Application from VS Code</h3><p class=\"tip\">We’re assuming the port to be <code>8080</code> here. If it’s not the case (for instance, if <code>8080</code> has been taken and Vue CLI automatically picks another port for you), just modify the configuration accordingly.</p>\n\n<p>Click on the Debugging icon in the Activity Bar to bring up the Debug view, then click on the gear icon to configure a launch.json file, selecting <strong>Chrome/Firefox: Launch</strong> as the environment. Replace content of the generated launch.json with the corresponding configuration:</p>\n<p><img src=\"/images/config_add.png\" alt=\"Add Chrome Configuration\"></p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.2.0\"</span>,\n  <span class=\"hljs-attr\">\"configurations\"</span>: [\n    &#123;\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"chrome\"</span>,\n      <span class=\"hljs-attr\">\"request\"</span>: <span class=\"hljs-string\">\"launch\"</span>,\n      <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"vuejs: chrome\"</span>,\n      <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"http://localhost:8080\"</span>,\n      <span class=\"hljs-attr\">\"webRoot\"</span>: <span class=\"hljs-string\">\"$&#123;workspaceFolder&#125;/src\"</span>,\n      <span class=\"hljs-attr\">\"breakOnLoad\"</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">\"sourceMapPathOverrides\"</span>: &#123;\n        <span class=\"hljs-attr\">\"webpack:///src/*\"</span>: <span class=\"hljs-string\">\"$&#123;webRoot&#125;/*\"</span>\n      &#125;\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"firefox\"</span>,\n      <span class=\"hljs-attr\">\"request\"</span>: <span class=\"hljs-string\">\"launch\"</span>,\n      <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"vuejs: firefox\"</span>,\n      <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"http://localhost:8080\"</span>,\n      <span class=\"hljs-attr\">\"webRoot\"</span>: <span class=\"hljs-string\">\"$&#123;workspaceFolder&#125;/src\"</span>,\n      <span class=\"hljs-attr\">\"pathMappings\"</span>: [&#123; <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"webpack:///src/\"</span>, <span class=\"hljs-attr\">\"path\"</span>: <span class=\"hljs-string\">\"$&#123;webRoot&#125;/\"</span> &#125;]\n    &#125;\n  ]\n&#125;</code></pre>\n<h2 id=\"Setting-a-Breakpoint\"><a href=\"#Setting-a-Breakpoint\" class=\"headerlink\" title=\"Setting a Breakpoint\"></a>Setting a Breakpoint</h2><ol>\n<li><p>Set a breakpoint in <strong>src/components/HelloWorld.vue</strong> on <code>line 90</code> where the <code>data</code> function returns a string.</p>\n<p><img src=\"/images/breakpoint_set.png\" alt=\"Breakpoint Renderer\"></p>\n</li>\n<li><p>Open your favorite terminal at the root folder and serve the app using Vue CLI:</p>\n<pre><code class=\"hljs undefined\">npm run serve</code></pre>\n</li>\n<li><p>Go to the Debug view, select the <strong>‘vuejs: chrome/firefox’</strong> configuration, then press F5 or click the green play button.</p>\n</li>\n<li><p>Your breakpoint should now be hit as a new browser instance opens <code>http://localhost:8080</code>.</p>\n<p><img src=\"/images/breakpoint_hit.png\" alt=\"Breakpoint Hit\"></p>\n</li>\n</ol>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"Vue-Devtools\"><a href=\"#Vue-Devtools\" class=\"headerlink\" title=\"Vue Devtools\"></a>Vue Devtools</h3><p>There are other methods of debugging, varying in complexity. The most popular and simple of which is to use the excellent Vue.js devtools <a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd\" target=\"_blank\" rel=\"noopener\">for Chrome</a> and <a href=\"https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/\" target=\"_blank\" rel=\"noopener\">for Firefox</a>. Some of the benefits of working with the devtools are that they enable you to live-edit data properties and see the changes reflected immediately. The other major benefit is the ability to do time travel debugging for Vuex.</p>\n<p><img src=\"/images/devtools-timetravel.gif\" alt=\"Devtools Timetravel Debugger\"></p>\n<p class=\"tip\">Please note that if the page uses a production/minified build of Vue.js (such as the standard link from a CDN), devtools inspection is disabled by default so the Vue pane won’t show up. If you switch to an unminified version, you may have to give the page a hard refresh to see them.</p>\n\n<h3 id=\"Simple-Debugger-Statement\"><a href=\"#Simple-Debugger-Statement\" class=\"headerlink\" title=\"Simple Debugger Statement\"></a>Simple Debugger Statement</h3><p>The example above has a great workflow. However, there is an alternative option where you can use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger\" target=\"_blank\" rel=\"noopener\">native debugger statement</a> directly in your code. If you choose to work this way, it’s important that you remember to remove the statements when you’re done.</p>\n<pre><code class=\"hljs js\">&lt;script&gt;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  data() &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">const</span> hello = <span class=\"hljs-string\">'Hello World!'</span>\n    <span class=\"hljs-keyword\">debugger</span>\n    <span class=\"hljs-keyword\">this</span>.message = hello\n  &#125;\n&#125;;\n&lt;<span class=\"hljs-regexp\">/script&gt;</span></code></pre>\n<h2 id=\"Acknowledgements\"><a href=\"#Acknowledgements\" class=\"headerlink\" title=\"Acknowledgements\"></a>Acknowledgements</h2><p>This recipe was based on a contribution from <a href=\"https://twitter.com/auchenberg\" target=\"_blank\" rel=\"noopener\">Kenneth Auchenberg</a>, <a href=\"https://github.com/Microsoft/VSCode-recipes/tree/master/vuejs-cli\" target=\"_blank\" rel=\"noopener\">available here</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Every application reaches a point where it’s necessary to understand failures, small to large. In this recipe, we explore a few workflows for VS Code users who would like to debug their application in the browser.</p>\n<p>This recipe shows how to debug <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">Vue CLI</a> applications in VS Code as they run in the browser.</p>\n<p class=\"tip\">Note: This recipe covers Chrome and Firefox. If you know how to setup VS Code debugging with other browsers, please consider sharing your insights (see bottom of the page).</p>\n\n<h2 id=\"Prerequisites\"><a href=\"#Prerequisites\" class=\"headerlink\" title=\"Prerequisites\"></a>Prerequisites</h2><p>Make sure you have VS Code and the browser of your choice installed, and the latest version of the corresponding Debugger extension installed and enabled:</p>\n<ul>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome\" target=\"_blank\" rel=\"noopener\">Debugger for Chrome</a></li>\n<li><a href=\"https://marketplace.visualstudio.com/items?itemName=hbenl.vscode-firefox-debug\" target=\"_blank\" rel=\"noopener\">Debugger for Firefox</a></li>\n</ul>\n<p>Install and create a project with the <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">vue-cli</a>, following the instructions in the <a href=\"https://cli.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue CLI Guide</a>. Change into the newly created application directory and open VS Code.</p>\n<h3 id=\"Displaying-Source-Code-in-the-Browser\"><a href=\"#Displaying-Source-Code-in-the-Browser\" class=\"headerlink\" title=\"Displaying Source Code in the Browser\"></a>Displaying Source Code in the Browser</h3><p>Before you can debug your Vue components from VS Code, you need to update the generated Webpack config to build sourcemaps. We do this so that our debugger has a way to map the code within a compressed file back to its position in the original file. This ensures that you can debug an application even after your assets have been optimized by Webpack.</p>\n<p>If you use Vue CLI 2, set or update the <code>devtool</code> property inside <code>config/index.js</code>:</p>\n<pre><code class=\"hljs json\">devtool: 'source-map',</code></pre>\n<p>If you use Vue CLI 3, set or update the <code>devtool</code> property inside <code>vue.config.js</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-attr\">configureWebpack</span>: &#123;\n    <span class=\"hljs-attr\">devtool</span>: <span class=\"hljs-string\">'source-map'</span>\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Launching-the-Application-from-VS-Code\"><a href=\"#Launching-the-Application-from-VS-Code\" class=\"headerlink\" title=\"Launching the Application from VS Code\"></a>Launching the Application from VS Code</h3><p class=\"tip\">We’re assuming the port to be <code>8080</code> here. If it’s not the case (for instance, if <code>8080</code> has been taken and Vue CLI automatically picks another port for you), just modify the configuration accordingly.</p>\n\n<p>Click on the Debugging icon in the Activity Bar to bring up the Debug view, then click on the gear icon to configure a launch.json file, selecting <strong>Chrome/Firefox: Launch</strong> as the environment. Replace content of the generated launch.json with the corresponding configuration:</p>\n<p><img src=\"/images/config_add.png\" alt=\"Add Chrome Configuration\"></p>\n<pre><code class=\"hljs json\">&#123;\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.2.0\"</span>,\n  <span class=\"hljs-attr\">\"configurations\"</span>: [\n    &#123;\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"chrome\"</span>,\n      <span class=\"hljs-attr\">\"request\"</span>: <span class=\"hljs-string\">\"launch\"</span>,\n      <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"vuejs: chrome\"</span>,\n      <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"http://localhost:8080\"</span>,\n      <span class=\"hljs-attr\">\"webRoot\"</span>: <span class=\"hljs-string\">\"$&#123;workspaceFolder&#125;/src\"</span>,\n      <span class=\"hljs-attr\">\"breakOnLoad\"</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">\"sourceMapPathOverrides\"</span>: &#123;\n        <span class=\"hljs-attr\">\"webpack:///src/*\"</span>: <span class=\"hljs-string\">\"$&#123;webRoot&#125;/*\"</span>\n      &#125;\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-string\">\"firefox\"</span>,\n      <span class=\"hljs-attr\">\"request\"</span>: <span class=\"hljs-string\">\"launch\"</span>,\n      <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"vuejs: firefox\"</span>,\n      <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"http://localhost:8080\"</span>,\n      <span class=\"hljs-attr\">\"webRoot\"</span>: <span class=\"hljs-string\">\"$&#123;workspaceFolder&#125;/src\"</span>,\n      <span class=\"hljs-attr\">\"pathMappings\"</span>: [&#123; <span class=\"hljs-attr\">\"url\"</span>: <span class=\"hljs-string\">\"webpack:///src/\"</span>, <span class=\"hljs-attr\">\"path\"</span>: <span class=\"hljs-string\">\"$&#123;webRoot&#125;/\"</span> &#125;]\n    &#125;\n  ]\n&#125;</code></pre>\n<h2 id=\"Setting-a-Breakpoint\"><a href=\"#Setting-a-Breakpoint\" class=\"headerlink\" title=\"Setting a Breakpoint\"></a>Setting a Breakpoint</h2><ol>\n<li><p>Set a breakpoint in <strong>src/components/HelloWorld.vue</strong> on <code>line 90</code> where the <code>data</code> function returns a string.</p>\n<p><img src=\"/images/breakpoint_set.png\" alt=\"Breakpoint Renderer\"></p>\n</li>\n<li><p>Open your favorite terminal at the root folder and serve the app using Vue CLI:</p>\n<pre><code class=\"hljs undefined\">npm run serve</code></pre>\n</li>\n<li><p>Go to the Debug view, select the <strong>‘vuejs: chrome/firefox’</strong> configuration, then press F5 or click the green play button.</p>\n</li>\n<li><p>Your breakpoint should now be hit as a new browser instance opens <code>http://localhost:8080</code>.</p>\n<p><img src=\"/images/breakpoint_hit.png\" alt=\"Breakpoint Hit\"></p>\n</li>\n</ol>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"Vue-Devtools\"><a href=\"#Vue-Devtools\" class=\"headerlink\" title=\"Vue Devtools\"></a>Vue Devtools</h3><p>There are other methods of debugging, varying in complexity. The most popular and simple of which is to use the excellent Vue.js devtools <a href=\"https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd\" target=\"_blank\" rel=\"noopener\">for Chrome</a> and <a href=\"https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/\" target=\"_blank\" rel=\"noopener\">for Firefox</a>. Some of the benefits of working with the devtools are that they enable you to live-edit data properties and see the changes reflected immediately. The other major benefit is the ability to do time travel debugging for Vuex.</p>\n<p><img src=\"/images/devtools-timetravel.gif\" alt=\"Devtools Timetravel Debugger\"></p>\n<p class=\"tip\">Please note that if the page uses a production/minified build of Vue.js (such as the standard link from a CDN), devtools inspection is disabled by default so the Vue pane won’t show up. If you switch to an unminified version, you may have to give the page a hard refresh to see them.</p>\n\n<h3 id=\"Simple-Debugger-Statement\"><a href=\"#Simple-Debugger-Statement\" class=\"headerlink\" title=\"Simple Debugger Statement\"></a>Simple Debugger Statement</h3><p>The example above has a great workflow. However, there is an alternative option where you can use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger\" target=\"_blank\" rel=\"noopener\">native debugger statement</a> directly in your code. If you choose to work this way, it’s important that you remember to remove the statements when you’re done.</p>\n<pre><code class=\"hljs js\">&lt;script&gt;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  data() &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;,\n  mounted() &#123;\n    <span class=\"hljs-keyword\">const</span> hello = <span class=\"hljs-string\">'Hello World!'</span>\n    <span class=\"hljs-keyword\">debugger</span>\n    <span class=\"hljs-keyword\">this</span>.message = hello\n  &#125;\n&#125;;\n&lt;<span class=\"hljs-regexp\">/script&gt;</span></code></pre>\n<h2 id=\"Acknowledgements\"><a href=\"#Acknowledgements\" class=\"headerlink\" title=\"Acknowledgements\"></a>Acknowledgements</h2><p>This recipe was based on a contribution from <a href=\"https://twitter.com/auchenberg\" target=\"_blank\" rel=\"noopener\">Kenneth Auchenberg</a>, <a href=\"https://github.com/Microsoft/VSCode-recipes/tree/master/vuejs-cli\" target=\"_blank\" rel=\"noopener\">available here</a>.</p>\n"},{"title":"Dockerize Vue.js App","type":"cookbook","order":13,"_content":"\n## Simple Example\n\nSo you built your first Vue.js app using the amazing [Vue.js webpack template](https://github.com/vuejs-templates/webpack) and now you really want to show off with your colleagues by demonstrating that you can also run it in a Docker container.\n\nLet's start by creating a `Dockerfile` in the root folder of our project:\n\n```docker\nFROM node:lts-alpine\n\n# install simple http server for serving static content\nRUN npm install -g http-server\n\n# make the 'app' folder the current working directory\nWORKDIR /app\n\n# copy both 'package.json' and 'package-lock.json' (if available)\nCOPY package*.json ./\n\n# install project dependencies\nRUN npm install\n\n# copy project files and folders to the current working directory (i.e. 'app' folder)\nCOPY . .\n\n# build app for production with minification\nRUN npm run build\n\nEXPOSE 8080\nCMD [ \"http-server\", \"dist\" ]\n```\n\nIt may seem redundant to first copy `package.json` and `package-lock.json` and then all project files and folders in two separate steps but there is actually [a very good reason for that](http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/) (spoiler: it allows us to take advantage of cached Docker layers).\n\nNow let's build the Docker image of our Vue.js app:\n\n```bash\ndocker build -t vuejs-cookbook/dockerize-vuejs-app .\n```\n\nFinally, let's run our Vue.js app in a Docker container:\n\n```bash\ndocker run -it -p 8080:8080 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app\n```\n\nWe should be able to access our Vue.js app on `localhost:8080`.\n\n## Real-World Example\n\nIn the previous example, we used a simple, zero-configuration command-line [http server](https://github.com/indexzero/http-server) to serve our Vue.js app which is perfectly ok for quick prototyping and _may_ even be ok for simple production scenarios. After all, the documentation says:\n\n> It is powerful enough for production usage, but it's simple and hackable enough to be used for testing, local development, and learning.\n\nNevertheless, for realistically complex production use cases, it may be wiser to stand on the shoulders of some giant like [NGINX](https://www.nginx.com/) or [Apache](https://httpd.apache.org/) and that is exactly what we are going to do next: we are about to leverage NGINX to serve our Vue.js app because it is considered to be one of the most performant and battle-tested solutions out there.\n\nLet's refactor our `Dockerfile` to use NGINX:\n\n ```docker\n# build stage\nFROM node:lts-alpine as build-stage\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\n# production stage\nFROM nginx:stable-alpine as production-stage\nCOPY --from=build-stage /app/dist /usr/share/nginx/html\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\nOk, let's see what's going on here:\n* we have split our original `Dockerfile` in multiple stages by leveraging the Docker [multi-stage builds](https://docs.docker.com/develop/develop-images/multistage-build/) feature;\n* the first stage is responsible for building a production-ready artifact of our Vue.js app;\n* the second stage is responsible for serving such artifact using NGINX.\n\nNow let's build the Docker image of our Vue.js app:\n\n```bash\ndocker build -t vuejs-cookbook/dockerize-vuejs-app .\n```\n\nFinally, let's run our Vue.js app in a Docker container:\n\n```bash\ndocker run -it -p 8080:80 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app\n```\n\nWe should be able to access our Vue.js app on `localhost:8080`.\n\n## Additional Context\n\nIf you are reading this cookbook, chances are you already know why you decided to dockerize your Vue.js app. But if you simply landed on this page after hitting the Google's `I'm feeling lucky` button, let me share with you a couple of good reasons for doing that.\n\nToday's modern trend is to build applications using the [Cloud-Native](https://pivotal.io/cloud-native) approach which revolves mainly around the following buzzwords:\n* Microservices\n* DevOps\n* Continuous Delivery\n\nLet's see how these concepts actually affect our decision of dockerizing our Vue.js app.\n\n### Effects of Microservices\n\nBy adopting the [microservices architectural style](https://martinfowler.com/microservices/), we end up building a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. These services are built around business capabilities and independently deployable by fully automated deployment machinery.\n\nSo, committing to this architectural approach most of the time implies developing and delivering our front-end as an independent service.\n\n### Effects of DevOps\n\nThe adoption of [DevOps](https://martinfowler.com/bliki/DevOpsCulture.html) culture, tools and agile engineering practices has, among other things, the nice effect of increasing the collaboration between the roles of development and operations. One of the main problem of the past (but also today in some realities) is that the dev team tended to be uninterested in the operation and maintenance of a system once it was handed over to the ops team, while the latter tended to be not really aware of the system's business goals and, therefore, reluctant in satisfying the operational needs of the system (also referred to as \"whims of developers\").\n\nSo, delivering our Vue.js app as a Docker image helps reducing, if not removing entirely, the difference between running the service on a developer's laptop, the production environment or any environment we may think of.\n\n### Effects of Continuous Delivery\n\nBy leveraging the [Continuous Delivery](https://martinfowler.com/bliki/ContinuousDelivery.html) discipline we build our software in a way that it can potentially be released to production at any time. Such engineering practice is enabled by means of what is normally called [continuous delivery pipeline](https://martinfowler.com/bliki/DeploymentPipeline.html). The purpose of a continuous delivery pipeline is to split our build into stages (e.g. compilation, unit tests, integration tests, performance tests, etc.) and let each stage verify our build artifact whenever our software changes. Ultimately, each stage increases our confidence in the production readiness of our build artifact and, therefore, reduces the risk of breaking things in production (or any other environment for that matters).\n\nSo, creating a Docker image for our Vue.js app is a good choice here because that would represent our final build artifact, the same artifact that would be verified against our continuous delivery pipeline and that could potentially be released to production with confidence.\n\n## Alternative Patterns\n\nIf your company is not into Docker and Kubernetes just yet or you simply want to get your MVP out the door, maybe dockerizing your Vue.js app is not what you need.\n\nCommon alternatives are:\n* leveraging an all-in-one platform like [Netlify](https://www.netlify.com/);\n* hosting your SPA on [Amazon S3](https://aws.amazon.com/s3/) and serving it with [Amazon CloudFront](https://aws.amazon.com/cloudfront/) (see [this](https://serverless-stack.com/chapters/deploy-the-frontend.html) link for a detailed guide).\n","source":"v2/cookbook/dockerize-vuejs-app.md","raw":"---\ntitle: Dockerize Vue.js App\ntype: cookbook\norder: 13\n---\n\n## Simple Example\n\nSo you built your first Vue.js app using the amazing [Vue.js webpack template](https://github.com/vuejs-templates/webpack) and now you really want to show off with your colleagues by demonstrating that you can also run it in a Docker container.\n\nLet's start by creating a `Dockerfile` in the root folder of our project:\n\n```docker\nFROM node:lts-alpine\n\n# install simple http server for serving static content\nRUN npm install -g http-server\n\n# make the 'app' folder the current working directory\nWORKDIR /app\n\n# copy both 'package.json' and 'package-lock.json' (if available)\nCOPY package*.json ./\n\n# install project dependencies\nRUN npm install\n\n# copy project files and folders to the current working directory (i.e. 'app' folder)\nCOPY . .\n\n# build app for production with minification\nRUN npm run build\n\nEXPOSE 8080\nCMD [ \"http-server\", \"dist\" ]\n```\n\nIt may seem redundant to first copy `package.json` and `package-lock.json` and then all project files and folders in two separate steps but there is actually [a very good reason for that](http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/) (spoiler: it allows us to take advantage of cached Docker layers).\n\nNow let's build the Docker image of our Vue.js app:\n\n```bash\ndocker build -t vuejs-cookbook/dockerize-vuejs-app .\n```\n\nFinally, let's run our Vue.js app in a Docker container:\n\n```bash\ndocker run -it -p 8080:8080 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app\n```\n\nWe should be able to access our Vue.js app on `localhost:8080`.\n\n## Real-World Example\n\nIn the previous example, we used a simple, zero-configuration command-line [http server](https://github.com/indexzero/http-server) to serve our Vue.js app which is perfectly ok for quick prototyping and _may_ even be ok for simple production scenarios. After all, the documentation says:\n\n> It is powerful enough for production usage, but it's simple and hackable enough to be used for testing, local development, and learning.\n\nNevertheless, for realistically complex production use cases, it may be wiser to stand on the shoulders of some giant like [NGINX](https://www.nginx.com/) or [Apache](https://httpd.apache.org/) and that is exactly what we are going to do next: we are about to leverage NGINX to serve our Vue.js app because it is considered to be one of the most performant and battle-tested solutions out there.\n\nLet's refactor our `Dockerfile` to use NGINX:\n\n ```docker\n# build stage\nFROM node:lts-alpine as build-stage\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\n# production stage\nFROM nginx:stable-alpine as production-stage\nCOPY --from=build-stage /app/dist /usr/share/nginx/html\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n```\n\nOk, let's see what's going on here:\n* we have split our original `Dockerfile` in multiple stages by leveraging the Docker [multi-stage builds](https://docs.docker.com/develop/develop-images/multistage-build/) feature;\n* the first stage is responsible for building a production-ready artifact of our Vue.js app;\n* the second stage is responsible for serving such artifact using NGINX.\n\nNow let's build the Docker image of our Vue.js app:\n\n```bash\ndocker build -t vuejs-cookbook/dockerize-vuejs-app .\n```\n\nFinally, let's run our Vue.js app in a Docker container:\n\n```bash\ndocker run -it -p 8080:80 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app\n```\n\nWe should be able to access our Vue.js app on `localhost:8080`.\n\n## Additional Context\n\nIf you are reading this cookbook, chances are you already know why you decided to dockerize your Vue.js app. But if you simply landed on this page after hitting the Google's `I'm feeling lucky` button, let me share with you a couple of good reasons for doing that.\n\nToday's modern trend is to build applications using the [Cloud-Native](https://pivotal.io/cloud-native) approach which revolves mainly around the following buzzwords:\n* Microservices\n* DevOps\n* Continuous Delivery\n\nLet's see how these concepts actually affect our decision of dockerizing our Vue.js app.\n\n### Effects of Microservices\n\nBy adopting the [microservices architectural style](https://martinfowler.com/microservices/), we end up building a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. These services are built around business capabilities and independently deployable by fully automated deployment machinery.\n\nSo, committing to this architectural approach most of the time implies developing and delivering our front-end as an independent service.\n\n### Effects of DevOps\n\nThe adoption of [DevOps](https://martinfowler.com/bliki/DevOpsCulture.html) culture, tools and agile engineering practices has, among other things, the nice effect of increasing the collaboration between the roles of development and operations. One of the main problem of the past (but also today in some realities) is that the dev team tended to be uninterested in the operation and maintenance of a system once it was handed over to the ops team, while the latter tended to be not really aware of the system's business goals and, therefore, reluctant in satisfying the operational needs of the system (also referred to as \"whims of developers\").\n\nSo, delivering our Vue.js app as a Docker image helps reducing, if not removing entirely, the difference between running the service on a developer's laptop, the production environment or any environment we may think of.\n\n### Effects of Continuous Delivery\n\nBy leveraging the [Continuous Delivery](https://martinfowler.com/bliki/ContinuousDelivery.html) discipline we build our software in a way that it can potentially be released to production at any time. Such engineering practice is enabled by means of what is normally called [continuous delivery pipeline](https://martinfowler.com/bliki/DeploymentPipeline.html). The purpose of a continuous delivery pipeline is to split our build into stages (e.g. compilation, unit tests, integration tests, performance tests, etc.) and let each stage verify our build artifact whenever our software changes. Ultimately, each stage increases our confidence in the production readiness of our build artifact and, therefore, reduces the risk of breaking things in production (or any other environment for that matters).\n\nSo, creating a Docker image for our Vue.js app is a good choice here because that would represent our final build artifact, the same artifact that would be verified against our continuous delivery pipeline and that could potentially be released to production with confidence.\n\n## Alternative Patterns\n\nIf your company is not into Docker and Kubernetes just yet or you simply want to get your MVP out the door, maybe dockerizing your Vue.js app is not what you need.\n\nCommon alternatives are:\n* leveraging an all-in-one platform like [Netlify](https://www.netlify.com/);\n* hosting your SPA on [Amazon S3](https://aws.amazon.com/s3/) and serving it with [Amazon CloudFront](https://aws.amazon.com/cloudfront/) (see [this](https://serverless-stack.com/chapters/deploy-the-frontend.html) link for a detailed guide).\n","date":"2020-09-25T23:55:41.105Z","updated":"2020-09-25T23:55:41.105Z","path":"v2/cookbook/dockerize-vuejs-app.html","comments":1,"layout":"page","_id":"ckfl66gy4000mc2v50uz4vw17","content":"<h2 id=\"Simple-Example\"><a href=\"#Simple-Example\" class=\"headerlink\" title=\"Simple Example\"></a>Simple Example</h2><p>So you built your first Vue.js app using the amazing <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">Vue.js webpack template</a> and now you really want to show off with your colleagues by demonstrating that you can also run it in a Docker container.</p>\n<p>Let’s start by creating a <code>Dockerfile</code> in the root folder of our project:</p>\n<pre><code class=\"hljs docker\"><span class=\"hljs-keyword\">FROM</span> node:lts-alpine\n\n<span class=\"hljs-comment\"># install simple http server for serving static content</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install -g http-server</span>\n\n<span class=\"hljs-comment\"># make the 'app' folder the current working directory</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n\n<span class=\"hljs-comment\"># copy both 'package.json' and 'package-lock.json' (if available)</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> package*.json ./</span>\n\n<span class=\"hljs-comment\"># install project dependencies</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install</span>\n\n<span class=\"hljs-comment\"># copy project files and folders to the current working directory (i.e. 'app' folder)</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> . .</span>\n\n<span class=\"hljs-comment\"># build app for production with minification</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm run build</span>\n\n<span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">8080</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [ <span class=\"hljs-string\">\"http-server\"</span>, <span class=\"hljs-string\">\"dist\"</span> ]</span></code></pre>\n<p>It may seem redundant to first copy <code>package.json</code> and <code>package-lock.json</code> and then all project files and folders in two separate steps but there is actually <a href=\"http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/\" target=\"_blank\" rel=\"noopener\">a very good reason for that</a> (spoiler: it allows us to take advantage of cached Docker layers).</p>\n<p>Now let’s build the Docker image of our Vue.js app:</p>\n<pre><code class=\"hljs bash\">docker build -t vuejs-cookbook/dockerize-vuejs-app .</code></pre>\n<p>Finally, let’s run our Vue.js app in a Docker container:</p>\n<pre><code class=\"hljs bash\">docker run -it -p 8080:8080 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app</code></pre>\n<p>We should be able to access our Vue.js app on <code>localhost:8080</code>.</p>\n<h2 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h2><p>In the previous example, we used a simple, zero-configuration command-line <a href=\"https://github.com/indexzero/http-server\" target=\"_blank\" rel=\"noopener\">http server</a> to serve our Vue.js app which is perfectly ok for quick prototyping and <em>may</em> even be ok for simple production scenarios. After all, the documentation says:</p>\n<blockquote>\n<p>It is powerful enough for production usage, but it’s simple and hackable enough to be used for testing, local development, and learning.</p>\n</blockquote>\n<p>Nevertheless, for realistically complex production use cases, it may be wiser to stand on the shoulders of some giant like <a href=\"https://www.nginx.com/\" target=\"_blank\" rel=\"noopener\">NGINX</a> or <a href=\"https://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache</a> and that is exactly what we are going to do next: we are about to leverage NGINX to serve our Vue.js app because it is considered to be one of the most performant and battle-tested solutions out there.</p>\n<p>Let’s refactor our <code>Dockerfile</code> to use NGINX:</p>\n <pre><code class=\"hljs docker\"><span class=\"hljs-comment\"># build stage</span>\n<span class=\"hljs-keyword\">FROM</span> node:lts-alpine as build-stage\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> package*.json ./</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> . .</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm run build</span>\n\n<span class=\"hljs-comment\"># production stage</span>\n<span class=\"hljs-keyword\">FROM</span> nginx:stable-alpine as production-stage\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> --from=build-stage /app/dist /usr/share/nginx/html</span>\n<span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">80</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">\"nginx\"</span>, <span class=\"hljs-string\">\"-g\"</span>, <span class=\"hljs-string\">\"daemon off;\"</span>]</span></code></pre>\n<p>Ok, let’s see what’s going on here:</p>\n<ul>\n<li>we have split our original <code>Dockerfile</code> in multiple stages by leveraging the Docker <a href=\"https://docs.docker.com/develop/develop-images/multistage-build/\" target=\"_blank\" rel=\"noopener\">multi-stage builds</a> feature;</li>\n<li>the first stage is responsible for building a production-ready artifact of our Vue.js app;</li>\n<li>the second stage is responsible for serving such artifact using NGINX.</li>\n</ul>\n<p>Now let’s build the Docker image of our Vue.js app:</p>\n<pre><code class=\"hljs bash\">docker build -t vuejs-cookbook/dockerize-vuejs-app .</code></pre>\n<p>Finally, let’s run our Vue.js app in a Docker container:</p>\n<pre><code class=\"hljs bash\">docker run -it -p 8080:80 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app</code></pre>\n<p>We should be able to access our Vue.js app on <code>localhost:8080</code>.</p>\n<h2 id=\"Additional-Context\"><a href=\"#Additional-Context\" class=\"headerlink\" title=\"Additional Context\"></a>Additional Context</h2><p>If you are reading this cookbook, chances are you already know why you decided to dockerize your Vue.js app. But if you simply landed on this page after hitting the Google’s <code>I&#39;m feeling lucky</code> button, let me share with you a couple of good reasons for doing that.</p>\n<p>Today’s modern trend is to build applications using the <a href=\"https://pivotal.io/cloud-native\" target=\"_blank\" rel=\"noopener\">Cloud-Native</a> approach which revolves mainly around the following buzzwords:</p>\n<ul>\n<li>Microservices</li>\n<li>DevOps</li>\n<li>Continuous Delivery</li>\n</ul>\n<p>Let’s see how these concepts actually affect our decision of dockerizing our Vue.js app.</p>\n<h3 id=\"Effects-of-Microservices\"><a href=\"#Effects-of-Microservices\" class=\"headerlink\" title=\"Effects of Microservices\"></a>Effects of Microservices</h3><p>By adopting the <a href=\"https://martinfowler.com/microservices/\" target=\"_blank\" rel=\"noopener\">microservices architectural style</a>, we end up building a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. These services are built around business capabilities and independently deployable by fully automated deployment machinery.</p>\n<p>So, committing to this architectural approach most of the time implies developing and delivering our front-end as an independent service.</p>\n<h3 id=\"Effects-of-DevOps\"><a href=\"#Effects-of-DevOps\" class=\"headerlink\" title=\"Effects of DevOps\"></a>Effects of DevOps</h3><p>The adoption of <a href=\"https://martinfowler.com/bliki/DevOpsCulture.html\" target=\"_blank\" rel=\"noopener\">DevOps</a> culture, tools and agile engineering practices has, among other things, the nice effect of increasing the collaboration between the roles of development and operations. One of the main problem of the past (but also today in some realities) is that the dev team tended to be uninterested in the operation and maintenance of a system once it was handed over to the ops team, while the latter tended to be not really aware of the system’s business goals and, therefore, reluctant in satisfying the operational needs of the system (also referred to as “whims of developers”).</p>\n<p>So, delivering our Vue.js app as a Docker image helps reducing, if not removing entirely, the difference between running the service on a developer’s laptop, the production environment or any environment we may think of.</p>\n<h3 id=\"Effects-of-Continuous-Delivery\"><a href=\"#Effects-of-Continuous-Delivery\" class=\"headerlink\" title=\"Effects of Continuous Delivery\"></a>Effects of Continuous Delivery</h3><p>By leveraging the <a href=\"https://martinfowler.com/bliki/ContinuousDelivery.html\" target=\"_blank\" rel=\"noopener\">Continuous Delivery</a> discipline we build our software in a way that it can potentially be released to production at any time. Such engineering practice is enabled by means of what is normally called <a href=\"https://martinfowler.com/bliki/DeploymentPipeline.html\" target=\"_blank\" rel=\"noopener\">continuous delivery pipeline</a>. The purpose of a continuous delivery pipeline is to split our build into stages (e.g. compilation, unit tests, integration tests, performance tests, etc.) and let each stage verify our build artifact whenever our software changes. Ultimately, each stage increases our confidence in the production readiness of our build artifact and, therefore, reduces the risk of breaking things in production (or any other environment for that matters).</p>\n<p>So, creating a Docker image for our Vue.js app is a good choice here because that would represent our final build artifact, the same artifact that would be verified against our continuous delivery pipeline and that could potentially be released to production with confidence.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>If your company is not into Docker and Kubernetes just yet or you simply want to get your MVP out the door, maybe dockerizing your Vue.js app is not what you need.</p>\n<p>Common alternatives are:</p>\n<ul>\n<li>leveraging an all-in-one platform like <a href=\"https://www.netlify.com/\" target=\"_blank\" rel=\"noopener\">Netlify</a>;</li>\n<li>hosting your SPA on <a href=\"https://aws.amazon.com/s3/\" target=\"_blank\" rel=\"noopener\">Amazon S3</a> and serving it with <a href=\"https://aws.amazon.com/cloudfront/\" target=\"_blank\" rel=\"noopener\">Amazon CloudFront</a> (see <a href=\"https://serverless-stack.com/chapters/deploy-the-frontend.html\" target=\"_blank\" rel=\"noopener\">this</a> link for a detailed guide).</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Simple-Example\"><a href=\"#Simple-Example\" class=\"headerlink\" title=\"Simple Example\"></a>Simple Example</h2><p>So you built your first Vue.js app using the amazing <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">Vue.js webpack template</a> and now you really want to show off with your colleagues by demonstrating that you can also run it in a Docker container.</p>\n<p>Let’s start by creating a <code>Dockerfile</code> in the root folder of our project:</p>\n<pre><code class=\"hljs docker\"><span class=\"hljs-keyword\">FROM</span> node:lts-alpine\n\n<span class=\"hljs-comment\"># install simple http server for serving static content</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install -g http-server</span>\n\n<span class=\"hljs-comment\"># make the 'app' folder the current working directory</span>\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n\n<span class=\"hljs-comment\"># copy both 'package.json' and 'package-lock.json' (if available)</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> package*.json ./</span>\n\n<span class=\"hljs-comment\"># install project dependencies</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install</span>\n\n<span class=\"hljs-comment\"># copy project files and folders to the current working directory (i.e. 'app' folder)</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> . .</span>\n\n<span class=\"hljs-comment\"># build app for production with minification</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm run build</span>\n\n<span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">8080</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [ <span class=\"hljs-string\">\"http-server\"</span>, <span class=\"hljs-string\">\"dist\"</span> ]</span></code></pre>\n<p>It may seem redundant to first copy <code>package.json</code> and <code>package-lock.json</code> and then all project files and folders in two separate steps but there is actually <a href=\"http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/\" target=\"_blank\" rel=\"noopener\">a very good reason for that</a> (spoiler: it allows us to take advantage of cached Docker layers).</p>\n<p>Now let’s build the Docker image of our Vue.js app:</p>\n<pre><code class=\"hljs bash\">docker build -t vuejs-cookbook/dockerize-vuejs-app .</code></pre>\n<p>Finally, let’s run our Vue.js app in a Docker container:</p>\n<pre><code class=\"hljs bash\">docker run -it -p 8080:8080 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app</code></pre>\n<p>We should be able to access our Vue.js app on <code>localhost:8080</code>.</p>\n<h2 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h2><p>In the previous example, we used a simple, zero-configuration command-line <a href=\"https://github.com/indexzero/http-server\" target=\"_blank\" rel=\"noopener\">http server</a> to serve our Vue.js app which is perfectly ok for quick prototyping and <em>may</em> even be ok for simple production scenarios. After all, the documentation says:</p>\n<blockquote>\n<p>It is powerful enough for production usage, but it’s simple and hackable enough to be used for testing, local development, and learning.</p>\n</blockquote>\n<p>Nevertheless, for realistically complex production use cases, it may be wiser to stand on the shoulders of some giant like <a href=\"https://www.nginx.com/\" target=\"_blank\" rel=\"noopener\">NGINX</a> or <a href=\"https://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache</a> and that is exactly what we are going to do next: we are about to leverage NGINX to serve our Vue.js app because it is considered to be one of the most performant and battle-tested solutions out there.</p>\n<p>Let’s refactor our <code>Dockerfile</code> to use NGINX:</p>\n <pre><code class=\"hljs docker\"><span class=\"hljs-comment\"># build stage</span>\n<span class=\"hljs-keyword\">FROM</span> node:lts-alpine as build-stage\n<span class=\"hljs-keyword\">WORKDIR</span><span class=\"bash\"> /app</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> package*.json ./</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm install</span>\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> . .</span>\n<span class=\"hljs-keyword\">RUN</span><span class=\"bash\"> npm run build</span>\n\n<span class=\"hljs-comment\"># production stage</span>\n<span class=\"hljs-keyword\">FROM</span> nginx:stable-alpine as production-stage\n<span class=\"hljs-keyword\">COPY</span><span class=\"bash\"> --from=build-stage /app/dist /usr/share/nginx/html</span>\n<span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">80</span>\n<span class=\"hljs-keyword\">CMD</span><span class=\"bash\"> [<span class=\"hljs-string\">\"nginx\"</span>, <span class=\"hljs-string\">\"-g\"</span>, <span class=\"hljs-string\">\"daemon off;\"</span>]</span></code></pre>\n<p>Ok, let’s see what’s going on here:</p>\n<ul>\n<li>we have split our original <code>Dockerfile</code> in multiple stages by leveraging the Docker <a href=\"https://docs.docker.com/develop/develop-images/multistage-build/\" target=\"_blank\" rel=\"noopener\">multi-stage builds</a> feature;</li>\n<li>the first stage is responsible for building a production-ready artifact of our Vue.js app;</li>\n<li>the second stage is responsible for serving such artifact using NGINX.</li>\n</ul>\n<p>Now let’s build the Docker image of our Vue.js app:</p>\n<pre><code class=\"hljs bash\">docker build -t vuejs-cookbook/dockerize-vuejs-app .</code></pre>\n<p>Finally, let’s run our Vue.js app in a Docker container:</p>\n<pre><code class=\"hljs bash\">docker run -it -p 8080:80 --rm --name dockerize-vuejs-app-1 vuejs-cookbook/dockerize-vuejs-app</code></pre>\n<p>We should be able to access our Vue.js app on <code>localhost:8080</code>.</p>\n<h2 id=\"Additional-Context\"><a href=\"#Additional-Context\" class=\"headerlink\" title=\"Additional Context\"></a>Additional Context</h2><p>If you are reading this cookbook, chances are you already know why you decided to dockerize your Vue.js app. But if you simply landed on this page after hitting the Google’s <code>I&#39;m feeling lucky</code> button, let me share with you a couple of good reasons for doing that.</p>\n<p>Today’s modern trend is to build applications using the <a href=\"https://pivotal.io/cloud-native\" target=\"_blank\" rel=\"noopener\">Cloud-Native</a> approach which revolves mainly around the following buzzwords:</p>\n<ul>\n<li>Microservices</li>\n<li>DevOps</li>\n<li>Continuous Delivery</li>\n</ul>\n<p>Let’s see how these concepts actually affect our decision of dockerizing our Vue.js app.</p>\n<h3 id=\"Effects-of-Microservices\"><a href=\"#Effects-of-Microservices\" class=\"headerlink\" title=\"Effects of Microservices\"></a>Effects of Microservices</h3><p>By adopting the <a href=\"https://martinfowler.com/microservices/\" target=\"_blank\" rel=\"noopener\">microservices architectural style</a>, we end up building a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. These services are built around business capabilities and independently deployable by fully automated deployment machinery.</p>\n<p>So, committing to this architectural approach most of the time implies developing and delivering our front-end as an independent service.</p>\n<h3 id=\"Effects-of-DevOps\"><a href=\"#Effects-of-DevOps\" class=\"headerlink\" title=\"Effects of DevOps\"></a>Effects of DevOps</h3><p>The adoption of <a href=\"https://martinfowler.com/bliki/DevOpsCulture.html\" target=\"_blank\" rel=\"noopener\">DevOps</a> culture, tools and agile engineering practices has, among other things, the nice effect of increasing the collaboration between the roles of development and operations. One of the main problem of the past (but also today in some realities) is that the dev team tended to be uninterested in the operation and maintenance of a system once it was handed over to the ops team, while the latter tended to be not really aware of the system’s business goals and, therefore, reluctant in satisfying the operational needs of the system (also referred to as “whims of developers”).</p>\n<p>So, delivering our Vue.js app as a Docker image helps reducing, if not removing entirely, the difference between running the service on a developer’s laptop, the production environment or any environment we may think of.</p>\n<h3 id=\"Effects-of-Continuous-Delivery\"><a href=\"#Effects-of-Continuous-Delivery\" class=\"headerlink\" title=\"Effects of Continuous Delivery\"></a>Effects of Continuous Delivery</h3><p>By leveraging the <a href=\"https://martinfowler.com/bliki/ContinuousDelivery.html\" target=\"_blank\" rel=\"noopener\">Continuous Delivery</a> discipline we build our software in a way that it can potentially be released to production at any time. Such engineering practice is enabled by means of what is normally called <a href=\"https://martinfowler.com/bliki/DeploymentPipeline.html\" target=\"_blank\" rel=\"noopener\">continuous delivery pipeline</a>. The purpose of a continuous delivery pipeline is to split our build into stages (e.g. compilation, unit tests, integration tests, performance tests, etc.) and let each stage verify our build artifact whenever our software changes. Ultimately, each stage increases our confidence in the production readiness of our build artifact and, therefore, reduces the risk of breaking things in production (or any other environment for that matters).</p>\n<p>So, creating a Docker image for our Vue.js app is a good choice here because that would represent our final build artifact, the same artifact that would be verified against our continuous delivery pipeline and that could potentially be released to production with confidence.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>If your company is not into Docker and Kubernetes just yet or you simply want to get your MVP out the door, maybe dockerizing your Vue.js app is not what you need.</p>\n<p>Common alternatives are:</p>\n<ul>\n<li>leveraging an all-in-one platform like <a href=\"https://www.netlify.com/\" target=\"_blank\" rel=\"noopener\">Netlify</a>;</li>\n<li>hosting your SPA on <a href=\"https://aws.amazon.com/s3/\" target=\"_blank\" rel=\"noopener\">Amazon S3</a> and serving it with <a href=\"https://aws.amazon.com/cloudfront/\" target=\"_blank\" rel=\"noopener\">Amazon CloudFront</a> (see <a href=\"https://serverless-stack.com/chapters/deploy-the-frontend.html\" target=\"_blank\" rel=\"noopener\">this</a> link for a detailed guide).</li>\n</ul>\n"},{"title":"Editable SVG Icon Systems","type":"cookbook","order":4,"_content":"\n## Base Example\n\nThere are many ways to create an SVG Icon System, but one method that takes advantage of Vue's capabilities is to create editable inline icons as components. Some of the advantages of this way of working is:\n\n* They are easy to edit on the fly\n* They are animatable\n* You can use standard props and defaults to keep them to a typical size or alter them if you need to\n* They are inline, so no HTTP requests are necessary\n* They can be made accessible dynamically\n\nFirst, we'll create a folder for all of the icons, and name them in a standardized fashion for easy retrieval:\n\n> components/icons/IconBox.vue\n> components/icons/IconCalendar.vue\n> components/icons/IconEnvelope.vue\n\nHere's an example repo to get you going, where you can see the entire setup: [https://github.com/sdras/vue-sample-svg-icons/](https://github.com/sdras/vue-sample-svg-icons/)\n\n![Documentation site](https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/screendocs.jpg 'Docs demo')\n\nWe'll create a base icon (`IconBase.vue`) component that uses a slot.\n\n```html\n<template>\n  <svg xmlns=\"http://www.w3.org/2000/svg\"\n    :width=\"width\"\n    :height=\"height\"\n    viewBox=\"0 0 18 18\"\n    :aria-labelledby=\"iconName\"\n    role=\"presentation\"\n  >\n    <title\n      :id=\"iconName\"\n      lang=\"en\"\n    >{{ iconName }} icon</title>\n    <g :fill=\"iconColor\">\n      <slot />\n    </g>\n  </svg>\n</template>\n```\n\nYou can use this base icon as is- the only thing you might need to update is the `viewBox` depending on the `viewBox` of your icons. In the base, we're making the `width`, `height`, `iconColor`, and name of the icon props so that it can be dynamically updated with props. The name will be used for both the `<title>` content and its `id` for accessibility.\n\nOur script will look like this, we'll have some defaults so that our icon will be rendered consistently unless we state otherwise:\n\n```js\nexport default {\n  props: {\n    iconName: {\n      type: String,\n      default: 'box'\n    },\n    width: {\n      type: [Number, String],\n      default: 18\n    },\n    height: {\n      type: [Number, String],\n      default: 18\n    },\n    iconColor: {\n      type: String,\n      default: 'currentColor'\n    }\n  }\n}\n```\n\nThe `currentColor` property that's the default on the fill will make the icon inherit the color of whatever text surrounds it. We could also pass in a different color as a prop if we wish.\n\nWe can use it like so, with the only contents of `IconWrite.vue` containing the paths inside the icon:\n\n```html\n<icon-base icon-name=\"write\"><icon-write /></icon-base>\n```\n\nNow, if we'd like to make many sizes for the icon, we can do so very easily:\n\n```html\n<p>\n  <!-- you can pass in a smaller `width` and `height` as props -->\n  <icon-base\n    width=\"12\"\n    height=\"12\"\n    icon-name=\"write\"\n  ><icon-write /></icon-base>\n  <!-- or you can use the default, which is 18 -->\n  <icon-base icon-name=\"write\"><icon-write /></icon-base>\n  <!-- or make it a little bigger too :) -->\n  <icon-base\n    width=\"30\"\n    height=\"30\"\n    icon-name=\"write\"\n  ><icon-write /></icon-base>\n</p>\n```\n\n<img src=\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/Screen%20Shot%202018-01-01%20at%204.51.40%20PM.png\" width=\"450\" />\n\n## Animatable Icons\n\nKeeping icons in components comes in very handy when you'd like to animate them, especially on an interaction. Inline SVGs have the highest support for interaction of any method. Here's a very basic example of an icon that's animated on click:\n\n```html\n<template>\n  <svg\n    @click=\"startScissors\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 100 100\"\n    width=\"100\"\n    height=\"100\"\n    aria-labelledby=\"scissors\"\n    role=\"presentation\"\n  >\n    <title\n      id=\"scissors\"\n      lang=\"en\"\n    >Scissors Animated Icon</title>\n    <path\n      id=\"bk\"\n      fill=\"#fff\"\n      d=\"M0 0h100v100H0z\"/>\n    <g ref=\"leftscissor\">\n      <path d=\"M...\"/>\n      ...\n    </g>\n    <g ref=\"rightscissor\">\n      <path d=\"M...\"/>\n      ...\n    </g>\n  </svg>\n</template>\n```\n\n```js\nimport { TweenMax, Sine } from 'gsap'\n\nexport default {\n  methods: {\n    startScissors() {\n      this.scissorAnim(this.$refs.rightscissor, 30)\n      this.scissorAnim(this.$refs.leftscissor, -30)\n    },\n    scissorAnim(el, rot) {\n      TweenMax.to(el, 0.25, {\n        rotation: rot,\n        repeat: 3,\n        yoyo: true,\n        svgOrigin: '50 45',\n        ease: Sine.easeInOut\n      })\n    }\n  }\n}\n```\n\nWe're applying `refs` to the groups of paths we need to move, and as both sides of the scissors have to move in tandem, we'll create a function we can reuse where we'll pass in the `refs`. The use of GreenSock helps resolve animation support and `transform-origin` issues across browser.\n\n<p data-height=\"300\" data-theme-id=\"0\" data-slug-hash=\"dJRpgY\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Editable SVG Icon System: Animated icon\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/dJRpgY/\">Editable SVG Icon System: Animated icon</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p><script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<p style=\"margin-top:-30px\">Pretty easily accomplished! And easy to update on the fly.</p>\n\nYou can see more animated examples in the repo [here](https://github.com/sdras/vue-sample-svg-icons/)\n\n## Additional Notes\n\nDesigners may change their minds. Product requirements change. Keeping the logic for the entire icon system in one base component means you can quickly update all of your icons and have it propagate through the whole system. Even with the use of an icon loader, some situations require you to recreate or edit every SVG to make global changes. This method can save you that time and pain.\n\n## When To Avoid This Pattern\n\nThis type of SVG icon system is really useful when you have a number of icons that are used in different ways throughout your site. If you're repeating the same icon many times on one page (e.g. a giant table with a delete icon in each row), it might make more sense to have all of the sprites compiled into a sprite sheet and use `<use>` tags to load them.\n\n## Alternative Patterns\n\nOther tooling to help manage SVG icons includes:\n\n* [svg-sprite-loader](https://github.com/kisenka/svg-sprite-loader)\n* [svgo-loader](https://github.com/rpominov/svgo-loader)\n\nThese tools bundle SVGs at compile time, but make them a little harder to edit during runtime, because `<use>` tags can have strange cross-browser issues when doing anything more complex. They also leave you with two nested `viewBox` properties and thus two coordinate systems. This makes the implementation a little more complex.\n","source":"v2/cookbook/editable-svg-icons.md","raw":"---\ntitle: Editable SVG Icon Systems\ntype: cookbook\norder: 4\n---\n\n## Base Example\n\nThere are many ways to create an SVG Icon System, but one method that takes advantage of Vue's capabilities is to create editable inline icons as components. Some of the advantages of this way of working is:\n\n* They are easy to edit on the fly\n* They are animatable\n* You can use standard props and defaults to keep them to a typical size or alter them if you need to\n* They are inline, so no HTTP requests are necessary\n* They can be made accessible dynamically\n\nFirst, we'll create a folder for all of the icons, and name them in a standardized fashion for easy retrieval:\n\n> components/icons/IconBox.vue\n> components/icons/IconCalendar.vue\n> components/icons/IconEnvelope.vue\n\nHere's an example repo to get you going, where you can see the entire setup: [https://github.com/sdras/vue-sample-svg-icons/](https://github.com/sdras/vue-sample-svg-icons/)\n\n![Documentation site](https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/screendocs.jpg 'Docs demo')\n\nWe'll create a base icon (`IconBase.vue`) component that uses a slot.\n\n```html\n<template>\n  <svg xmlns=\"http://www.w3.org/2000/svg\"\n    :width=\"width\"\n    :height=\"height\"\n    viewBox=\"0 0 18 18\"\n    :aria-labelledby=\"iconName\"\n    role=\"presentation\"\n  >\n    <title\n      :id=\"iconName\"\n      lang=\"en\"\n    >{{ iconName }} icon</title>\n    <g :fill=\"iconColor\">\n      <slot />\n    </g>\n  </svg>\n</template>\n```\n\nYou can use this base icon as is- the only thing you might need to update is the `viewBox` depending on the `viewBox` of your icons. In the base, we're making the `width`, `height`, `iconColor`, and name of the icon props so that it can be dynamically updated with props. The name will be used for both the `<title>` content and its `id` for accessibility.\n\nOur script will look like this, we'll have some defaults so that our icon will be rendered consistently unless we state otherwise:\n\n```js\nexport default {\n  props: {\n    iconName: {\n      type: String,\n      default: 'box'\n    },\n    width: {\n      type: [Number, String],\n      default: 18\n    },\n    height: {\n      type: [Number, String],\n      default: 18\n    },\n    iconColor: {\n      type: String,\n      default: 'currentColor'\n    }\n  }\n}\n```\n\nThe `currentColor` property that's the default on the fill will make the icon inherit the color of whatever text surrounds it. We could also pass in a different color as a prop if we wish.\n\nWe can use it like so, with the only contents of `IconWrite.vue` containing the paths inside the icon:\n\n```html\n<icon-base icon-name=\"write\"><icon-write /></icon-base>\n```\n\nNow, if we'd like to make many sizes for the icon, we can do so very easily:\n\n```html\n<p>\n  <!-- you can pass in a smaller `width` and `height` as props -->\n  <icon-base\n    width=\"12\"\n    height=\"12\"\n    icon-name=\"write\"\n  ><icon-write /></icon-base>\n  <!-- or you can use the default, which is 18 -->\n  <icon-base icon-name=\"write\"><icon-write /></icon-base>\n  <!-- or make it a little bigger too :) -->\n  <icon-base\n    width=\"30\"\n    height=\"30\"\n    icon-name=\"write\"\n  ><icon-write /></icon-base>\n</p>\n```\n\n<img src=\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/Screen%20Shot%202018-01-01%20at%204.51.40%20PM.png\" width=\"450\" />\n\n## Animatable Icons\n\nKeeping icons in components comes in very handy when you'd like to animate them, especially on an interaction. Inline SVGs have the highest support for interaction of any method. Here's a very basic example of an icon that's animated on click:\n\n```html\n<template>\n  <svg\n    @click=\"startScissors\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 100 100\"\n    width=\"100\"\n    height=\"100\"\n    aria-labelledby=\"scissors\"\n    role=\"presentation\"\n  >\n    <title\n      id=\"scissors\"\n      lang=\"en\"\n    >Scissors Animated Icon</title>\n    <path\n      id=\"bk\"\n      fill=\"#fff\"\n      d=\"M0 0h100v100H0z\"/>\n    <g ref=\"leftscissor\">\n      <path d=\"M...\"/>\n      ...\n    </g>\n    <g ref=\"rightscissor\">\n      <path d=\"M...\"/>\n      ...\n    </g>\n  </svg>\n</template>\n```\n\n```js\nimport { TweenMax, Sine } from 'gsap'\n\nexport default {\n  methods: {\n    startScissors() {\n      this.scissorAnim(this.$refs.rightscissor, 30)\n      this.scissorAnim(this.$refs.leftscissor, -30)\n    },\n    scissorAnim(el, rot) {\n      TweenMax.to(el, 0.25, {\n        rotation: rot,\n        repeat: 3,\n        yoyo: true,\n        svgOrigin: '50 45',\n        ease: Sine.easeInOut\n      })\n    }\n  }\n}\n```\n\nWe're applying `refs` to the groups of paths we need to move, and as both sides of the scissors have to move in tandem, we'll create a function we can reuse where we'll pass in the `refs`. The use of GreenSock helps resolve animation support and `transform-origin` issues across browser.\n\n<p data-height=\"300\" data-theme-id=\"0\" data-slug-hash=\"dJRpgY\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Editable SVG Icon System: Animated icon\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/dJRpgY/\">Editable SVG Icon System: Animated icon</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p><script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<p style=\"margin-top:-30px\">Pretty easily accomplished! And easy to update on the fly.</p>\n\nYou can see more animated examples in the repo [here](https://github.com/sdras/vue-sample-svg-icons/)\n\n## Additional Notes\n\nDesigners may change their minds. Product requirements change. Keeping the logic for the entire icon system in one base component means you can quickly update all of your icons and have it propagate through the whole system. Even with the use of an icon loader, some situations require you to recreate or edit every SVG to make global changes. This method can save you that time and pain.\n\n## When To Avoid This Pattern\n\nThis type of SVG icon system is really useful when you have a number of icons that are used in different ways throughout your site. If you're repeating the same icon many times on one page (e.g. a giant table with a delete icon in each row), it might make more sense to have all of the sprites compiled into a sprite sheet and use `<use>` tags to load them.\n\n## Alternative Patterns\n\nOther tooling to help manage SVG icons includes:\n\n* [svg-sprite-loader](https://github.com/kisenka/svg-sprite-loader)\n* [svgo-loader](https://github.com/rpominov/svgo-loader)\n\nThese tools bundle SVGs at compile time, but make them a little harder to edit during runtime, because `<use>` tags can have strange cross-browser issues when doing anything more complex. They also leave you with two nested `viewBox` properties and thus two coordinate systems. This makes the implementation a little more complex.\n","date":"2020-09-25T23:55:41.106Z","updated":"2020-09-25T23:55:41.106Z","path":"v2/cookbook/editable-svg-icons.html","comments":1,"layout":"page","_id":"ckfl66gy4000nc2v5cc9lsq0n","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are many ways to create an SVG Icon System, but one method that takes advantage of Vue’s capabilities is to create editable inline icons as components. Some of the advantages of this way of working is:</p>\n<ul>\n<li>They are easy to edit on the fly</li>\n<li>They are animatable</li>\n<li>You can use standard props and defaults to keep them to a typical size or alter them if you need to</li>\n<li>They are inline, so no HTTP requests are necessary</li>\n<li>They can be made accessible dynamically</li>\n</ul>\n<p>First, we’ll create a folder for all of the icons, and name them in a standardized fashion for easy retrieval:</p>\n<blockquote>\n<p>components/icons/IconBox.vue<br>components/icons/IconCalendar.vue<br>components/icons/IconEnvelope.vue</p>\n</blockquote>\n<p>Here’s an example repo to get you going, where you can see the entire setup: <a href=\"https://github.com/sdras/vue-sample-svg-icons/\" target=\"_blank\" rel=\"noopener\">https://github.com/sdras/vue-sample-svg-icons/</a></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/screendocs.jpg\" alt=\"Documentation site\" title=\"Docs demo\"></p>\n<p>We’ll create a base icon (<code>IconBase.vue</code>) component that uses a slot.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span>\n    <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"width\"</span>\n    <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"height\"</span>\n    <span class=\"hljs-attr\">viewBox</span>=<span class=\"hljs-string\">\"0 0 18 18\"</span>\n    <span class=\"hljs-attr\">:aria-labelledby</span>=<span class=\"hljs-string\">\"iconName\"</span>\n    <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"presentation\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>\n      <span class=\"hljs-attr\">:id</span>=<span class=\"hljs-string\">\"iconName\"</span>\n      <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>\n    &gt;</span>&#123;&#123; iconName &#125;&#125; icon<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">:fill</span>=<span class=\"hljs-string\">\"iconColor\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>You can use this base icon as is- the only thing you might need to update is the <code>viewBox</code> depending on the <code>viewBox</code> of your icons. In the base, we’re making the <code>width</code>, <code>height</code>, <code>iconColor</code>, and name of the icon props so that it can be dynamically updated with props. The name will be used for both the <code>&lt;title&gt;</code> content and its <code>id</code> for accessibility.</p>\n<p>Our script will look like this, we’ll have some defaults so that our icon will be rendered consistently unless we state otherwise:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">iconName</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'box'</span>\n    &#125;,\n    <span class=\"hljs-attr\">width</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: [<span class=\"hljs-built_in\">Number</span>, <span class=\"hljs-built_in\">String</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">18</span>\n    &#125;,\n    <span class=\"hljs-attr\">height</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: [<span class=\"hljs-built_in\">Number</span>, <span class=\"hljs-built_in\">String</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">18</span>\n    &#125;,\n    <span class=\"hljs-attr\">iconColor</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'currentColor'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>The <code>currentColor</code> property that’s the default on the fill will make the icon inherit the color of whatever text surrounds it. We could also pass in a different color as a prop if we wish.</p>\n<p>We can use it like so, with the only contents of <code>IconWrite.vue</code> containing the paths inside the icon:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span> <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span></code></pre>\n<p>Now, if we’d like to make many sizes for the icon, we can do so very easily:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- you can pass in a smaller `width` and `height` as props --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"12\"</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"12\"</span>\n    <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>\n  &gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- or you can use the default, which is 18 --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span> <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- or make it a little bigger too :) --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"30\"</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"30\"</span>\n    <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>\n  &gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/Screen%20Shot%202018-01-01%20at%204.51.40%20PM.png\" width=\"450\"></p>\n<h2 id=\"Animatable-Icons\"><a href=\"#Animatable-Icons\" class=\"headerlink\" title=\"Animatable Icons\"></a>Animatable Icons</h2><p>Keeping icons in components comes in very handy when you’d like to animate them, especially on an interaction. Inline SVGs have the highest support for interaction of any method. Here’s a very basic example of an icon that’s animated on click:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>\n    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"startScissors\"</span>\n    <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span>\n    <span class=\"hljs-attr\">viewBox</span>=<span class=\"hljs-string\">\"0 0 100 100\"</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>\n    <span class=\"hljs-attr\">aria-labelledby</span>=<span class=\"hljs-string\">\"scissors\"</span>\n    <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"presentation\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"scissors\"</span>\n      <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>\n    &gt;</span>Scissors Animated Icon<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"bk\"</span>\n      <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#fff\"</span>\n      <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M0 0h100v100H0z\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"leftscissor\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M...\"</span>/&gt;</span>\n      ...\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"rightscissor\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M...\"</span>/&gt;</span>\n      ...\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; TweenMax, Sine &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'gsap'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    startScissors() &#123;\n      <span class=\"hljs-keyword\">this</span>.scissorAnim(<span class=\"hljs-keyword\">this</span>.$refs.rightscissor, <span class=\"hljs-number\">30</span>)\n      <span class=\"hljs-keyword\">this</span>.scissorAnim(<span class=\"hljs-keyword\">this</span>.$refs.leftscissor, <span class=\"hljs-number\">-30</span>)\n    &#125;,\n    scissorAnim(el, rot) &#123;\n      TweenMax.to(el, <span class=\"hljs-number\">0.25</span>, &#123;\n        <span class=\"hljs-attr\">rotation</span>: rot,\n        <span class=\"hljs-attr\">repeat</span>: <span class=\"hljs-number\">3</span>,\n        <span class=\"hljs-attr\">yoyo</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">svgOrigin</span>: <span class=\"hljs-string\">'50 45'</span>,\n        <span class=\"hljs-attr\">ease</span>: Sine.easeInOut\n      &#125;)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>We’re applying <code>refs</code> to the groups of paths we need to move, and as both sides of the scissors have to move in tandem, we’ll create a function we can reuse where we’ll pass in the <code>refs</code>. The use of GreenSock helps resolve animation support and <code>transform-origin</code> issues across browser.</p>\n<p data-height=\"300\" data-theme-id=\"0\" data-slug-hash=\"dJRpgY\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Editable SVG Icon System: Animated icon\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/dJRpgY/\" target=\"_blank\" rel=\"noopener\">Editable SVG Icon System: Animated icon</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script><br><br><p style=\"margin-top:-30px\">Pretty easily accomplished! And easy to update on the fly.</p>\n\n<p>You can see more animated examples in the repo <a href=\"https://github.com/sdras/vue-sample-svg-icons/\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<h2 id=\"Additional-Notes\"><a href=\"#Additional-Notes\" class=\"headerlink\" title=\"Additional Notes\"></a>Additional Notes</h2><p>Designers may change their minds. Product requirements change. Keeping the logic for the entire icon system in one base component means you can quickly update all of your icons and have it propagate through the whole system. Even with the use of an icon loader, some situations require you to recreate or edit every SVG to make global changes. This method can save you that time and pain.</p>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>This type of SVG icon system is really useful when you have a number of icons that are used in different ways throughout your site. If you’re repeating the same icon many times on one page (e.g. a giant table with a delete icon in each row), it might make more sense to have all of the sprites compiled into a sprite sheet and use <code>&lt;use&gt;</code> tags to load them.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>Other tooling to help manage SVG icons includes:</p>\n<ul>\n<li><a href=\"https://github.com/kisenka/svg-sprite-loader\" target=\"_blank\" rel=\"noopener\">svg-sprite-loader</a></li>\n<li><a href=\"https://github.com/rpominov/svgo-loader\" target=\"_blank\" rel=\"noopener\">svgo-loader</a></li>\n</ul>\n<p>These tools bundle SVGs at compile time, but make them a little harder to edit during runtime, because <code>&lt;use&gt;</code> tags can have strange cross-browser issues when doing anything more complex. They also leave you with two nested <code>viewBox</code> properties and thus two coordinate systems. This makes the implementation a little more complex.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are many ways to create an SVG Icon System, but one method that takes advantage of Vue’s capabilities is to create editable inline icons as components. Some of the advantages of this way of working is:</p>\n<ul>\n<li>They are easy to edit on the fly</li>\n<li>They are animatable</li>\n<li>You can use standard props and defaults to keep them to a typical size or alter them if you need to</li>\n<li>They are inline, so no HTTP requests are necessary</li>\n<li>They can be made accessible dynamically</li>\n</ul>\n<p>First, we’ll create a folder for all of the icons, and name them in a standardized fashion for easy retrieval:</p>\n<blockquote>\n<p>components/icons/IconBox.vue<br>components/icons/IconCalendar.vue<br>components/icons/IconEnvelope.vue</p>\n</blockquote>\n<p>Here’s an example repo to get you going, where you can see the entire setup: <a href=\"https://github.com/sdras/vue-sample-svg-icons/\" target=\"_blank\" rel=\"noopener\">https://github.com/sdras/vue-sample-svg-icons/</a></p>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/screendocs.jpg\" alt=\"Documentation site\" title=\"Docs demo\"></p>\n<p>We’ll create a base icon (<code>IconBase.vue</code>) component that uses a slot.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span>\n    <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"width\"</span>\n    <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"height\"</span>\n    <span class=\"hljs-attr\">viewBox</span>=<span class=\"hljs-string\">\"0 0 18 18\"</span>\n    <span class=\"hljs-attr\">:aria-labelledby</span>=<span class=\"hljs-string\">\"iconName\"</span>\n    <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"presentation\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>\n      <span class=\"hljs-attr\">:id</span>=<span class=\"hljs-string\">\"iconName\"</span>\n      <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>\n    &gt;</span>&#123;&#123; iconName &#125;&#125; icon<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">:fill</span>=<span class=\"hljs-string\">\"iconColor\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>You can use this base icon as is- the only thing you might need to update is the <code>viewBox</code> depending on the <code>viewBox</code> of your icons. In the base, we’re making the <code>width</code>, <code>height</code>, <code>iconColor</code>, and name of the icon props so that it can be dynamically updated with props. The name will be used for both the <code>&lt;title&gt;</code> content and its <code>id</code> for accessibility.</p>\n<p>Our script will look like this, we’ll have some defaults so that our icon will be rendered consistently unless we state otherwise:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">iconName</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'box'</span>\n    &#125;,\n    <span class=\"hljs-attr\">width</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: [<span class=\"hljs-built_in\">Number</span>, <span class=\"hljs-built_in\">String</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">18</span>\n    &#125;,\n    <span class=\"hljs-attr\">height</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: [<span class=\"hljs-built_in\">Number</span>, <span class=\"hljs-built_in\">String</span>],\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">18</span>\n    &#125;,\n    <span class=\"hljs-attr\">iconColor</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'currentColor'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>The <code>currentColor</code> property that’s the default on the fill will make the icon inherit the color of whatever text surrounds it. We could also pass in a different color as a prop if we wish.</p>\n<p>We can use it like so, with the only contents of <code>IconWrite.vue</code> containing the paths inside the icon:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span> <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span></code></pre>\n<p>Now, if we’d like to make many sizes for the icon, we can do so very easily:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- you can pass in a smaller `width` and `height` as props --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"12\"</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"12\"</span>\n    <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>\n  &gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- or you can use the default, which is 18 --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span> <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- or make it a little bigger too :) --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-base</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"30\"</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"30\"</span>\n    <span class=\"hljs-attr\">icon-name</span>=<span class=\"hljs-string\">\"write\"</span>\n  &gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">icon-write</span> /&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">icon-base</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p><img src=\"https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/Screen%20Shot%202018-01-01%20at%204.51.40%20PM.png\" width=\"450\"></p>\n<h2 id=\"Animatable-Icons\"><a href=\"#Animatable-Icons\" class=\"headerlink\" title=\"Animatable Icons\"></a>Animatable Icons</h2><p>Keeping icons in components comes in very handy when you’d like to animate them, especially on an interaction. Inline SVGs have the highest support for interaction of any method. Here’s a very basic example of an icon that’s animated on click:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>\n    @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"startScissors\"</span>\n    <span class=\"hljs-attr\">xmlns</span>=<span class=\"hljs-string\">\"http://www.w3.org/2000/svg\"</span>\n    <span class=\"hljs-attr\">viewBox</span>=<span class=\"hljs-string\">\"0 0 100 100\"</span>\n    <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span>\n    <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>\n    <span class=\"hljs-attr\">aria-labelledby</span>=<span class=\"hljs-string\">\"scissors\"</span>\n    <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"presentation\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"scissors\"</span>\n      <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">\"en\"</span>\n    &gt;</span>Scissors Animated Icon<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"bk\"</span>\n      <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"#fff\"</span>\n      <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M0 0h100v100H0z\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"leftscissor\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M...\"</span>/&gt;</span>\n      ...\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"rightscissor\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">path</span> <span class=\"hljs-attr\">d</span>=<span class=\"hljs-string\">\"M...\"</span>/&gt;</span>\n      ...\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; TweenMax, Sine &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'gsap'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    startScissors() &#123;\n      <span class=\"hljs-keyword\">this</span>.scissorAnim(<span class=\"hljs-keyword\">this</span>.$refs.rightscissor, <span class=\"hljs-number\">30</span>)\n      <span class=\"hljs-keyword\">this</span>.scissorAnim(<span class=\"hljs-keyword\">this</span>.$refs.leftscissor, <span class=\"hljs-number\">-30</span>)\n    &#125;,\n    scissorAnim(el, rot) &#123;\n      TweenMax.to(el, <span class=\"hljs-number\">0.25</span>, &#123;\n        <span class=\"hljs-attr\">rotation</span>: rot,\n        <span class=\"hljs-attr\">repeat</span>: <span class=\"hljs-number\">3</span>,\n        <span class=\"hljs-attr\">yoyo</span>: <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-attr\">svgOrigin</span>: <span class=\"hljs-string\">'50 45'</span>,\n        <span class=\"hljs-attr\">ease</span>: Sine.easeInOut\n      &#125;)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>We’re applying <code>refs</code> to the groups of paths we need to move, and as both sides of the scissors have to move in tandem, we’ll create a function we can reuse where we’ll pass in the <code>refs</code>. The use of GreenSock helps resolve animation support and <code>transform-origin</code> issues across browser.</p>\n<p data-height=\"300\" data-theme-id=\"0\" data-slug-hash=\"dJRpgY\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Editable SVG Icon System: Animated icon\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/dJRpgY/\" target=\"_blank\" rel=\"noopener\">Editable SVG Icon System: Animated icon</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script><br><br><p style=\"margin-top:-30px\">Pretty easily accomplished! And easy to update on the fly.</p>\n\n<p>You can see more animated examples in the repo <a href=\"https://github.com/sdras/vue-sample-svg-icons/\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<h2 id=\"Additional-Notes\"><a href=\"#Additional-Notes\" class=\"headerlink\" title=\"Additional Notes\"></a>Additional Notes</h2><p>Designers may change their minds. Product requirements change. Keeping the logic for the entire icon system in one base component means you can quickly update all of your icons and have it propagate through the whole system. Even with the use of an icon loader, some situations require you to recreate or edit every SVG to make global changes. This method can save you that time and pain.</p>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>This type of SVG icon system is really useful when you have a number of icons that are used in different ways throughout your site. If you’re repeating the same icon many times on one page (e.g. a giant table with a delete icon in each row), it might make more sense to have all of the sprites compiled into a sprite sheet and use <code>&lt;use&gt;</code> tags to load them.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>Other tooling to help manage SVG icons includes:</p>\n<ul>\n<li><a href=\"https://github.com/kisenka/svg-sprite-loader\" target=\"_blank\" rel=\"noopener\">svg-sprite-loader</a></li>\n<li><a href=\"https://github.com/rpominov/svgo-loader\" target=\"_blank\" rel=\"noopener\">svgo-loader</a></li>\n</ul>\n<p>These tools bundle SVGs at compile time, but make them a little harder to edit during runtime, because <code>&lt;use&gt;</code> tags can have strange cross-browser issues when doing anything more complex. They also leave you with two nested <code>viewBox</code> properties and thus two coordinate systems. This makes the implementation a little more complex.</p>\n"},{"title":"Form Validation","type":"cookbook","order":3,"_content":"\n## Base Example\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-form-validation-diy?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Form Validation Lesson\">Watch a free lesson on Vue School</a></div>\n\nForm validation is natively supported by the browser, but sometimes different browsers will handle things in a manner which makes relying on it a bit tricky. Even when validation is supported perfectly, there may be times when custom validations are needed and a more manual, Vue-based solution may be more appropriate. Let's begin with a simple example.\n\nGiven a form of three fields, make two required. Let's look at the HTML first:\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  action=\"https://vuejs.org/\"\n  method=\"post\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    <label for=\"name\">Name</label>\n    <input\n      id=\"name\"\n      v-model=\"name\"\n      type=\"text\"\n      name=\"name\"\n    >\n  </p>\n\n  <p>\n    <label for=\"age\">Age</label>\n    <input\n      id=\"age\"\n      v-model=\"age\"\n      type=\"number\"\n      name=\"age\"\n      min=\"0\"\n    >\n  </p>\n\n  <p>\n    <label for=\"movie\">Favorite Movie</label>\n    <select\n      id=\"movie\"\n      v-model=\"movie\"\n      name=\"movie\"\n    >\n      <option>Star Wars</option>\n      <option>Vanilla Sky</option>\n      <option>Atomic Blonde</option>\n    </select>\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nLet's cover it from the top. The `<form>` tag has an ID that we'll be using for the Vue component. There's a submit handler that you'll see in a bit, and the `action` is a temporary URL that would point to something real on a server someplace (where you have backup server-side validation of course).\n\nBeneath that there is a paragraph that shows or hides itself based on an error state. This will render a simple list of errors on top of the form. Also note we fire the validation on submit rather than as every field is modified.\n\nThe final thing to note is that each of the three fields has a corresponding `v-model` to connect them to values we will work with in the JavaScript. Now let's look at that.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    errors: [],\n    name: null,\n    age: null,\n    movie: null\n  },\n  methods:{\n    checkForm: function (e) {\n      if (this.name && this.age) {\n        return true;\n      }\n\n      this.errors = [];\n\n      if (!this.name) {\n        this.errors.push('Name required.');\n      }\n      if (!this.age) {\n        this.errors.push('Age required.');\n      }\n\n      e.preventDefault();\n    }\n  }\n})\n```\n\nFairly short and simple. We define an array to hold errors and set `null` values for the three form fields. The `checkForm` logic (which is run on submit remember) checks for name and age only as movie is optional. If they are empty we check each and set a specific error for each. And that's really it. You can run the demo below. Don't forget that on a successful submission it's going to POST to a temporary URL.\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"GObpZM\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 1\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/GObpZM/\">form validation 1</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Using Custom Validation\n\nFor the second example, the second text field (age) was switched to email which will be validated with a bit of custom logic. The code is taken from the StackOverflow question, [How to validate email address in JavaScript?](https://stackoverflow.com/questions/46155/how-to-validate-email-address-in-javascript). This is an awesome question because it makes your most intense Facebook political/religious argument look like a slight disagreement over who makes the best beer. Seriously - it's insane. Here is the HTML, even though it's really close to the first example.\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  action=\"https://vuejs.org/\"\n  method=\"post\"\n  novalidate=\"true\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    <label for=\"name\">Name</label>\n    <input\n      id=\"name\"\n      v-model=\"name\"\n      type=\"text\"\n      name=\"name\"\n    >\n  </p>\n\n  <p>\n    <label for=\"email\">Email</label>\n    <input\n      id=\"email\"\n      v-model=\"email\"\n      type=\"email\"\n      name=\"email\"\n    >\n  </p>\n\n  <p>\n    <label for=\"movie\">Favorite Movie</label>\n    <select\n      id=\"movie\"\n      v-model=\"movie\"\n      name=\"movie\"\n    >\n      <option>Star Wars</option>\n      <option>Vanilla Sky</option>\n      <option>Atomic Blonde</option>\n    </select>\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nWhile the change here is small, note the `novalidate=\"true\"` on top. This is important because the browser will attempt to validate the email address in the field when `type=\"email\"`. Frankly it may make more sense to trust the browser in this case, but as we wanted an example with custom validation, we're disabling it. Here's the updated JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    errors: [],\n    name: null,\n    email: null,\n    movie: null\n  },\n  methods: {\n    checkForm: function (e) {\n      this.errors = [];\n\n      if (!this.name) {\n        this.errors.push(\"Name required.\");\n      }\n      if (!this.email) {\n        this.errors.push('Email required.');\n      } else if (!this.validEmail(this.email)) {\n        this.errors.push('Valid email required.');\n      }\n\n      if (!this.errors.length) {\n        return true;\n      }\n\n      e.preventDefault();\n    },\n    validEmail: function (email) {\n      var re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n      return re.test(email);\n    }\n  }\n})\n```\n\nAs you can see, we've added `validEmail` as a new method and it is simply called from `checkForm`. You can play with this example here:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqNXZ\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqNXZ/\">form validation 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Another Example of Custom Validation\n\nFor the third example, we've built something you've probably seen in survey apps. The user is asked to spend a \"budget\" for a set of features for a new Star Destroyer model. The total must equal 100. First, the HTML.\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  action=\"https://vuejs.org/\"\n  method=\"post\"\n  novalidate=\"true\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    Given a budget of 100 dollars, indicate how much\n    you would spend on the following features for the\n    next generation Star Destroyer. Your total must sum up to 100.\n  </p>\n\n  <p>\n    <input\n      v-model.number=\"weapons\"\n      type=\"number\"\n      name=\"weapons\"\n    > Weapons <br/>\n    <input\n      v-model.number=\"shields\"\n      type=\"number\"\n      name=\"shields\"\n    > Shields <br/>\n    <input\n      v-model.number=\"coffee\"\n      type=\"number\"\n      name=\"coffee\"\n    > Coffee <br/>\n    <input\n      v-model.number=\"ac\"\n      type=\"number\"\n      name=\"ac\"\n    > Air Conditioning <br/>\n    <input\n      v-model.number=\"mousedroids\"\n      type=\"number\"\n      name=\"mousedroids\"\n    > Mouse Droids <br/>\n  </p>\n\n  <p>\n    Current Total: {{total}}\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nNote the set of inputs covering the five different features. Note the addition of `.number` to the `v-model` attribute. This tells Vue to cast the value to a number when you use it. However, there is a bug with this feature such that when the value is blank, it turns back into a string. You'll see the workaround below. To make it a bit easier for the user, we also added a current total right below so they can see, in real time, what their total is. Now let's look at the JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data:{\n    errors: [],\n    weapons: 0,\n    shields: 0,\n    coffee: 0,\n    ac: 0,\n    mousedroids: 0\n  },\n  computed: {\n     total: function () {\n       // must parse because Vue turns empty value to string\n       return Number(this.weapons) +\n         Number(this.shields) +\n         Number(this.coffee) +\n         Number(this.ac+this.mousedroids);\n     }\n  },\n  methods:{\n    checkForm: function (e) {\n      this.errors = [];\n\n      if (this.total != 100) {\n        this.errors.push('Total must be 100!');\n      }\n\n      if (!this.errors.length) {\n        return true;\n      }\n\n      e.preventDefault();\n    }\n  }\n})\n```\n\nWe set up the total value as a computed value, and outside of that bug I ran into, it was simple enough to setup. My checkForm method now just needs to see if the total is 100 and that's it. You can play with this here:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqGoy\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 3\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqGoy/\">form validation 3</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Server-side Validation\n\nIn my final example, we built something that makes use of Ajax to validate at the server. The form will ask you to name a new product and will then check to ensure that the name is unique. We wrote a quick [Netlify](https://netlify.com/) serverless action to do the validation. While it isn't terribly important, here is the logic:\n\n``` js\nexports.handler = async (event, context) => {\n  \n    const badNames = ['vista', 'empire', 'mbp'];\n    const name = event.queryStringParameters.name;\n\n    if (badNames.includes(name)) {\n      return { \n        statusCode: 400,         \n        body: JSON.stringify({error: 'Invalid name passed.'}) \n      }\n    }\n\n    return {\n      statusCode: 204\n    }\n\n}\n\n```\n\nBasically any name but \"vista\", \"empire\", and \"mbp\" are acceptable. Ok, so let's look at the form.\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  method=\"post\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    <label for=\"name\">New Product Name: </label>\n    <input\n      id=\"name\"\n      v-model=\"name\"\n      type=\"text\"\n      name=\"name\"\n    >\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nThere isn't anything special here. So let's go on to the JavaScript.\n\n``` js\nconst apiUrl = 'https://vuecookbook.netlify.com/.netlify/functions/product-name?name=';\n\nconst app = new Vue({\n  el: '#app',\n  data: {\n    errors: [],\n    name: ''\n  },\n  methods:{\n    checkForm: function (e) {\n      e.preventDefault();\n\n      this.errors = [];\n\n      if (this.name === '') {\n        this.errors.push('Product name is required.');\n      } else {\n        fetch(apiUrl + encodeURIComponent(this.name))\n        .then(async res => {\n          if (res.status === 204) {\n            alert('OK');\n          } else if (res.status === 400) {\n            let errorResponse = await res.json();\n            this.errors.push(errorResponse.error);\n          }\n        });\n      }\n    }\n  }\n})\n```\n\nWe start off with a variable representing the URL of the API that is running on OpenWhisk. Now look at `checkForm`. In this version, we always prevent the form from submitting (which, by the way, could be done in the HTML with Vue as well). You can see a basic check on `this.name` being empty, and then we hit the API. If it's bad, we add an error as before. If it's good, right now we do nothing (just an alert), but you could navigate the user to a new page with the product name in the URL, or do other actions as well. You can run this demo below:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"BmgzeM\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 4\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/BmgzeM/\">form validation 4</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Alternative Patterns\n\nWhile this cookbook entry focused on doing form validation \"by hand\", there are, of course, some great Vue libraries that will handle a lot of this for you. Switching to a prepackage library may impact the final size of your application, but the benefits could be tremendous. You have code that is (most likely) heavily tested and also updated on a regular basis. Some examples of form validation libraries for Vue include:\n\n* [vuelidate](https://github.com/monterail/vuelidate)\n* [VeeValidate](https://logaretm.github.io/vee-validate/)\n","source":"v2/cookbook/form-validation.md","raw":"---\ntitle: Form Validation\ntype: cookbook\norder: 3\n---\n\n## Base Example\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-form-validation-diy?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Form Validation Lesson\">Watch a free lesson on Vue School</a></div>\n\nForm validation is natively supported by the browser, but sometimes different browsers will handle things in a manner which makes relying on it a bit tricky. Even when validation is supported perfectly, there may be times when custom validations are needed and a more manual, Vue-based solution may be more appropriate. Let's begin with a simple example.\n\nGiven a form of three fields, make two required. Let's look at the HTML first:\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  action=\"https://vuejs.org/\"\n  method=\"post\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    <label for=\"name\">Name</label>\n    <input\n      id=\"name\"\n      v-model=\"name\"\n      type=\"text\"\n      name=\"name\"\n    >\n  </p>\n\n  <p>\n    <label for=\"age\">Age</label>\n    <input\n      id=\"age\"\n      v-model=\"age\"\n      type=\"number\"\n      name=\"age\"\n      min=\"0\"\n    >\n  </p>\n\n  <p>\n    <label for=\"movie\">Favorite Movie</label>\n    <select\n      id=\"movie\"\n      v-model=\"movie\"\n      name=\"movie\"\n    >\n      <option>Star Wars</option>\n      <option>Vanilla Sky</option>\n      <option>Atomic Blonde</option>\n    </select>\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nLet's cover it from the top. The `<form>` tag has an ID that we'll be using for the Vue component. There's a submit handler that you'll see in a bit, and the `action` is a temporary URL that would point to something real on a server someplace (where you have backup server-side validation of course).\n\nBeneath that there is a paragraph that shows or hides itself based on an error state. This will render a simple list of errors on top of the form. Also note we fire the validation on submit rather than as every field is modified.\n\nThe final thing to note is that each of the three fields has a corresponding `v-model` to connect them to values we will work with in the JavaScript. Now let's look at that.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    errors: [],\n    name: null,\n    age: null,\n    movie: null\n  },\n  methods:{\n    checkForm: function (e) {\n      if (this.name && this.age) {\n        return true;\n      }\n\n      this.errors = [];\n\n      if (!this.name) {\n        this.errors.push('Name required.');\n      }\n      if (!this.age) {\n        this.errors.push('Age required.');\n      }\n\n      e.preventDefault();\n    }\n  }\n})\n```\n\nFairly short and simple. We define an array to hold errors and set `null` values for the three form fields. The `checkForm` logic (which is run on submit remember) checks for name and age only as movie is optional. If they are empty we check each and set a specific error for each. And that's really it. You can run the demo below. Don't forget that on a successful submission it's going to POST to a temporary URL.\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"GObpZM\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 1\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/GObpZM/\">form validation 1</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Using Custom Validation\n\nFor the second example, the second text field (age) was switched to email which will be validated with a bit of custom logic. The code is taken from the StackOverflow question, [How to validate email address in JavaScript?](https://stackoverflow.com/questions/46155/how-to-validate-email-address-in-javascript). This is an awesome question because it makes your most intense Facebook political/religious argument look like a slight disagreement over who makes the best beer. Seriously - it's insane. Here is the HTML, even though it's really close to the first example.\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  action=\"https://vuejs.org/\"\n  method=\"post\"\n  novalidate=\"true\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    <label for=\"name\">Name</label>\n    <input\n      id=\"name\"\n      v-model=\"name\"\n      type=\"text\"\n      name=\"name\"\n    >\n  </p>\n\n  <p>\n    <label for=\"email\">Email</label>\n    <input\n      id=\"email\"\n      v-model=\"email\"\n      type=\"email\"\n      name=\"email\"\n    >\n  </p>\n\n  <p>\n    <label for=\"movie\">Favorite Movie</label>\n    <select\n      id=\"movie\"\n      v-model=\"movie\"\n      name=\"movie\"\n    >\n      <option>Star Wars</option>\n      <option>Vanilla Sky</option>\n      <option>Atomic Blonde</option>\n    </select>\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nWhile the change here is small, note the `novalidate=\"true\"` on top. This is important because the browser will attempt to validate the email address in the field when `type=\"email\"`. Frankly it may make more sense to trust the browser in this case, but as we wanted an example with custom validation, we're disabling it. Here's the updated JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data: {\n    errors: [],\n    name: null,\n    email: null,\n    movie: null\n  },\n  methods: {\n    checkForm: function (e) {\n      this.errors = [];\n\n      if (!this.name) {\n        this.errors.push(\"Name required.\");\n      }\n      if (!this.email) {\n        this.errors.push('Email required.');\n      } else if (!this.validEmail(this.email)) {\n        this.errors.push('Valid email required.');\n      }\n\n      if (!this.errors.length) {\n        return true;\n      }\n\n      e.preventDefault();\n    },\n    validEmail: function (email) {\n      var re = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n      return re.test(email);\n    }\n  }\n})\n```\n\nAs you can see, we've added `validEmail` as a new method and it is simply called from `checkForm`. You can play with this example here:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqNXZ\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqNXZ/\">form validation 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Another Example of Custom Validation\n\nFor the third example, we've built something you've probably seen in survey apps. The user is asked to spend a \"budget\" for a set of features for a new Star Destroyer model. The total must equal 100. First, the HTML.\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  action=\"https://vuejs.org/\"\n  method=\"post\"\n  novalidate=\"true\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    Given a budget of 100 dollars, indicate how much\n    you would spend on the following features for the\n    next generation Star Destroyer. Your total must sum up to 100.\n  </p>\n\n  <p>\n    <input\n      v-model.number=\"weapons\"\n      type=\"number\"\n      name=\"weapons\"\n    > Weapons <br/>\n    <input\n      v-model.number=\"shields\"\n      type=\"number\"\n      name=\"shields\"\n    > Shields <br/>\n    <input\n      v-model.number=\"coffee\"\n      type=\"number\"\n      name=\"coffee\"\n    > Coffee <br/>\n    <input\n      v-model.number=\"ac\"\n      type=\"number\"\n      name=\"ac\"\n    > Air Conditioning <br/>\n    <input\n      v-model.number=\"mousedroids\"\n      type=\"number\"\n      name=\"mousedroids\"\n    > Mouse Droids <br/>\n  </p>\n\n  <p>\n    Current Total: {{total}}\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nNote the set of inputs covering the five different features. Note the addition of `.number` to the `v-model` attribute. This tells Vue to cast the value to a number when you use it. However, there is a bug with this feature such that when the value is blank, it turns back into a string. You'll see the workaround below. To make it a bit easier for the user, we also added a current total right below so they can see, in real time, what their total is. Now let's look at the JavaScript.\n\n``` js\nconst app = new Vue({\n  el: '#app',\n  data:{\n    errors: [],\n    weapons: 0,\n    shields: 0,\n    coffee: 0,\n    ac: 0,\n    mousedroids: 0\n  },\n  computed: {\n     total: function () {\n       // must parse because Vue turns empty value to string\n       return Number(this.weapons) +\n         Number(this.shields) +\n         Number(this.coffee) +\n         Number(this.ac+this.mousedroids);\n     }\n  },\n  methods:{\n    checkForm: function (e) {\n      this.errors = [];\n\n      if (this.total != 100) {\n        this.errors.push('Total must be 100!');\n      }\n\n      if (!this.errors.length) {\n        return true;\n      }\n\n      e.preventDefault();\n    }\n  }\n})\n```\n\nWe set up the total value as a computed value, and outside of that bug I ran into, it was simple enough to setup. My checkForm method now just needs to see if the total is 100 and that's it. You can play with this here:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqGoy\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 3\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqGoy/\">form validation 3</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Server-side Validation\n\nIn my final example, we built something that makes use of Ajax to validate at the server. The form will ask you to name a new product and will then check to ensure that the name is unique. We wrote a quick [Netlify](https://netlify.com/) serverless action to do the validation. While it isn't terribly important, here is the logic:\n\n``` js\nexports.handler = async (event, context) => {\n  \n    const badNames = ['vista', 'empire', 'mbp'];\n    const name = event.queryStringParameters.name;\n\n    if (badNames.includes(name)) {\n      return { \n        statusCode: 400,         \n        body: JSON.stringify({error: 'Invalid name passed.'}) \n      }\n    }\n\n    return {\n      statusCode: 204\n    }\n\n}\n\n```\n\nBasically any name but \"vista\", \"empire\", and \"mbp\" are acceptable. Ok, so let's look at the form.\n\n``` html\n<form\n  id=\"app\"\n  @submit=\"checkForm\"\n  method=\"post\"\n>\n\n  <p v-if=\"errors.length\">\n    <b>Please correct the following error(s):</b>\n    <ul>\n      <li v-for=\"error in errors\">{{ error }}</li>\n    </ul>\n  </p>\n\n  <p>\n    <label for=\"name\">New Product Name: </label>\n    <input\n      id=\"name\"\n      v-model=\"name\"\n      type=\"text\"\n      name=\"name\"\n    >\n  </p>\n\n  <p>\n    <input\n      type=\"submit\"\n      value=\"Submit\"\n    >\n  </p>\n\n</form>\n```\n\nThere isn't anything special here. So let's go on to the JavaScript.\n\n``` js\nconst apiUrl = 'https://vuecookbook.netlify.com/.netlify/functions/product-name?name=';\n\nconst app = new Vue({\n  el: '#app',\n  data: {\n    errors: [],\n    name: ''\n  },\n  methods:{\n    checkForm: function (e) {\n      e.preventDefault();\n\n      this.errors = [];\n\n      if (this.name === '') {\n        this.errors.push('Product name is required.');\n      } else {\n        fetch(apiUrl + encodeURIComponent(this.name))\n        .then(async res => {\n          if (res.status === 204) {\n            alert('OK');\n          } else if (res.status === 400) {\n            let errorResponse = await res.json();\n            this.errors.push(errorResponse.error);\n          }\n        });\n      }\n    }\n  }\n})\n```\n\nWe start off with a variable representing the URL of the API that is running on OpenWhisk. Now look at `checkForm`. In this version, we always prevent the form from submitting (which, by the way, could be done in the HTML with Vue as well). You can see a basic check on `this.name` being empty, and then we hit the API. If it's bad, we add an error as before. If it's good, right now we do nothing (just an alert), but you could navigate the user to a new page with the product name in the URL, or do other actions as well. You can run this demo below:\n\n<p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"BmgzeM\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 4\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/BmgzeM/\">form validation 4</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\">@cfjedimaster</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n## Alternative Patterns\n\nWhile this cookbook entry focused on doing form validation \"by hand\", there are, of course, some great Vue libraries that will handle a lot of this for you. Switching to a prepackage library may impact the final size of your application, but the benefits could be tremendous. You have code that is (most likely) heavily tested and also updated on a regular basis. Some examples of form validation libraries for Vue include:\n\n* [vuelidate](https://github.com/monterail/vuelidate)\n* [VeeValidate](https://logaretm.github.io/vee-validate/)\n","date":"2020-09-25T23:55:41.106Z","updated":"2020-09-25T23:55:41.106Z","path":"v2/cookbook/form-validation.html","comments":1,"layout":"page","_id":"ckfl66gy4000oc2v5d8zc2c14","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-form-validation-diy?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Form Validation Lesson\">Watch a free lesson on Vue School</a></div>\n\n<p>Form validation is natively supported by the browser, but sometimes different browsers will handle things in a manner which makes relying on it a bit tricky. Even when validation is supported perfectly, there may be times when custom validations are needed and a more manual, Vue-based solution may be more appropriate. Let’s begin with a simple example.</p>\n<p>Given a form of three fields, make two required. Let’s look at the HTML first:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"https://vuejs.org/\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"age\"</span>&gt;</span>Age<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"age\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"age\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"age\"</span>\n      <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"movie\"</span>&gt;</span>Favorite Movie<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"movie\"</span>\n    &gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Star Wars<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Vanilla Sky<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Atomic Blonde<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>Let’s cover it from the top. The <code>&lt;form&gt;</code> tag has an ID that we’ll be using for the Vue component. There’s a submit handler that you’ll see in a bit, and the <code>action</code> is a temporary URL that would point to something real on a server someplace (where you have backup server-side validation of course).</p>\n<p>Beneath that there is a paragraph that shows or hides itself based on an error state. This will render a simple list of errors on top of the form. Also note we fire the validation on submit rather than as every field is modified.</p>\n<p>The final thing to note is that each of the three fields has a corresponding <code>v-model</code> to connect them to values we will work with in the JavaScript. Now let’s look at that.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">movie</span>: <span class=\"hljs-literal\">null</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>:&#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.name &amp;&amp; <span class=\"hljs-keyword\">this</span>.age) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n      &#125;\n\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.name) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Name required.'</span>);\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.age) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Age required.'</span>);\n      &#125;\n\n      e.preventDefault();\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Fairly short and simple. We define an array to hold errors and set <code>null</code> values for the three form fields. The <code>checkForm</code> logic (which is run on submit remember) checks for name and age only as movie is optional. If they are empty we check each and set a specific error for each. And that’s really it. You can run the demo below. Don’t forget that on a successful submission it’s going to POST to a temporary URL.</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"GObpZM\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 1\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/GObpZM/\" target=\"_blank\" rel=\"noopener\">form validation 1</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Using-Custom-Validation\"><a href=\"#Using-Custom-Validation\" class=\"headerlink\" title=\"Using Custom Validation\"></a>Using Custom Validation</h2><p>For the second example, the second text field (age) was switched to email which will be validated with a bit of custom logic. The code is taken from the StackOverflow question, <a href=\"https://stackoverflow.com/questions/46155/how-to-validate-email-address-in-javascript\" target=\"_blank\" rel=\"noopener\">How to validate email address in JavaScript?</a>. This is an awesome question because it makes your most intense Facebook political/religious argument look like a slight disagreement over who makes the best beer. Seriously - it’s insane. Here is the HTML, even though it’s really close to the first example.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"https://vuejs.org/\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n  <span class=\"hljs-attr\">novalidate</span>=<span class=\"hljs-string\">\"true\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"email\"</span>&gt;</span>Email<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"email\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"email\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"email\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"email\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"movie\"</span>&gt;</span>Favorite Movie<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"movie\"</span>\n    &gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Star Wars<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Vanilla Sky<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Atomic Blonde<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>While the change here is small, note the <code>novalidate=&quot;true&quot;</code> on top. This is important because the browser will attempt to validate the email address in the field when <code>type=&quot;email&quot;</code>. Frankly it may make more sense to trust the browser in this case, but as we wanted an example with custom validation, we’re disabling it. Here’s the updated JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">email</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">movie</span>: <span class=\"hljs-literal\">null</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.name) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">\"Name required.\"</span>);\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.email) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Email required.'</span>);\n      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.validEmail(<span class=\"hljs-keyword\">this</span>.email)) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Valid email required.'</span>);\n      &#125;\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.errors.length) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n      &#125;\n\n      e.preventDefault();\n    &#125;,\n    <span class=\"hljs-attr\">validEmail</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">email</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-regexp\">/^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$/</span>;\n      <span class=\"hljs-keyword\">return</span> re.test(email);\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>As you can see, we’ve added <code>validEmail</code> as a new method and it is simply called from <code>checkForm</code>. You can play with this example here:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqNXZ\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqNXZ/\" target=\"_blank\" rel=\"noopener\">form validation 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Another-Example-of-Custom-Validation\"><a href=\"#Another-Example-of-Custom-Validation\" class=\"headerlink\" title=\"Another Example of Custom Validation\"></a>Another Example of Custom Validation</h2><p>For the third example, we’ve built something you’ve probably seen in survey apps. The user is asked to spend a “budget” for a set of features for a new Star Destroyer model. The total must equal 100. First, the HTML.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"https://vuejs.org/\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n  <span class=\"hljs-attr\">novalidate</span>=<span class=\"hljs-string\">\"true\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    Given a budget of 100 dollars, indicate how much\n    you would spend on the following features for the\n    next generation Star Destroyer. Your total must sum up to 100.\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"weapons\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"weapons\"</span>\n    &gt;</span> Weapons <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"shields\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"shields\"</span>\n    &gt;</span> Shields <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"coffee\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"coffee\"</span>\n    &gt;</span> Coffee <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"ac\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"ac\"</span>\n    &gt;</span> Air Conditioning <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"mousedroids\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"mousedroids\"</span>\n    &gt;</span> Mouse Droids <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    Current Total: &#123;&#123;total&#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>Note the set of inputs covering the five different features. Note the addition of <code>.number</code> to the <code>v-model</code> attribute. This tells Vue to cast the value to a number when you use it. However, there is a bug with this feature such that when the value is blank, it turns back into a string. You’ll see the workaround below. To make it a bit easier for the user, we also added a current total right below so they can see, in real time, what their total is. Now let’s look at the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>:&#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">weapons</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">shields</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">coffee</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">ac</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">mousedroids</span>: <span class=\"hljs-number\">0</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n     <span class=\"hljs-attr\">total</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n       <span class=\"hljs-comment\">// must parse because Vue turns empty value to string</span>\n       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.weapons) +\n         <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.shields) +\n         <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.coffee) +\n         <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.ac+<span class=\"hljs-keyword\">this</span>.mousedroids);\n     &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>:&#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.total != <span class=\"hljs-number\">100</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Total must be 100!'</span>);\n      &#125;\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.errors.length) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n      &#125;\n\n      e.preventDefault();\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>We set up the total value as a computed value, and outside of that bug I ran into, it was simple enough to setup. My checkForm method now just needs to see if the total is 100 and that’s it. You can play with this here:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqGoy\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 3\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqGoy/\" target=\"_blank\" rel=\"noopener\">form validation 3</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Server-side-Validation\"><a href=\"#Server-side-Validation\" class=\"headerlink\" title=\"Server-side Validation\"></a>Server-side Validation</h2><p>In my final example, we built something that makes use of Ajax to validate at the server. The form will ask you to name a new product and will then check to ensure that the name is unique. We wrote a quick <a href=\"https://netlify.com/\" target=\"_blank\" rel=\"noopener\">Netlify</a> serverless action to do the validation. While it isn’t terribly important, here is the logic:</p>\n<pre><code class=\"hljs js\">exports.handler = <span class=\"hljs-keyword\">async</span> (event, context) =&gt; &#123;\n  \n    <span class=\"hljs-keyword\">const</span> badNames = [<span class=\"hljs-string\">'vista'</span>, <span class=\"hljs-string\">'empire'</span>, <span class=\"hljs-string\">'mbp'</span>];\n    <span class=\"hljs-keyword\">const</span> name = event.queryStringParameters.name;\n\n    <span class=\"hljs-keyword\">if</span> (badNames.includes(name)) &#123;\n      <span class=\"hljs-keyword\">return</span> &#123; \n        <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-number\">400</span>,         \n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(&#123;<span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'Invalid name passed.'</span>&#125;) \n      &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-number\">204</span>\n    &#125;\n\n&#125;</code></pre>\n<p>Basically any name but “vista”, “empire”, and “mbp” are acceptable. Ok, so let’s look at the form.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>New Product Name: <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>There isn’t anything special here. So let’s go on to the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> apiUrl = <span class=\"hljs-string\">'https://vuecookbook.netlify.com/.netlify/functions/product-name?name='</span>;\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>:&#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      e.preventDefault();\n\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.name === <span class=\"hljs-string\">''</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Product name is required.'</span>);\n      &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        fetch(apiUrl + <span class=\"hljs-built_in\">encodeURIComponent</span>(<span class=\"hljs-keyword\">this</span>.name))\n        .then(<span class=\"hljs-keyword\">async</span> res =&gt; &#123;\n          <span class=\"hljs-keyword\">if</span> (res.status === <span class=\"hljs-number\">204</span>) &#123;\n            alert(<span class=\"hljs-string\">'OK'</span>);\n          &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res.status === <span class=\"hljs-number\">400</span>) &#123;\n            <span class=\"hljs-keyword\">let</span> errorResponse = <span class=\"hljs-keyword\">await</span> res.json();\n            <span class=\"hljs-keyword\">this</span>.errors.push(errorResponse.error);\n          &#125;\n        &#125;);\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>We start off with a variable representing the URL of the API that is running on OpenWhisk. Now look at <code>checkForm</code>. In this version, we always prevent the form from submitting (which, by the way, could be done in the HTML with Vue as well). You can see a basic check on <code>this.name</code> being empty, and then we hit the API. If it’s bad, we add an error as before. If it’s good, right now we do nothing (just an alert), but you could navigate the user to a new page with the product name in the URL, or do other actions as well. You can run this demo below:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"BmgzeM\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 4\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/BmgzeM/\" target=\"_blank\" rel=\"noopener\">form validation 4</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>While this cookbook entry focused on doing form validation “by hand”, there are, of course, some great Vue libraries that will handle a lot of this for you. Switching to a prepackage library may impact the final size of your application, but the benefits could be tremendous. You have code that is (most likely) heavily tested and also updated on a regular basis. Some examples of form validation libraries for Vue include:</p>\n<ul>\n<li><a href=\"https://github.com/monterail/vuelidate\" target=\"_blank\" rel=\"noopener\">vuelidate</a></li>\n<li><a href=\"https://logaretm.github.io/vee-validate/\" target=\"_blank\" rel=\"noopener\">VeeValidate</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-form-validation-diy?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Form Validation Lesson\">Watch a free lesson on Vue School</a></div>\n\n<p>Form validation is natively supported by the browser, but sometimes different browsers will handle things in a manner which makes relying on it a bit tricky. Even when validation is supported perfectly, there may be times when custom validations are needed and a more manual, Vue-based solution may be more appropriate. Let’s begin with a simple example.</p>\n<p>Given a form of three fields, make two required. Let’s look at the HTML first:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"https://vuejs.org/\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"age\"</span>&gt;</span>Age<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"age\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"age\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"age\"</span>\n      <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"movie\"</span>&gt;</span>Favorite Movie<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"movie\"</span>\n    &gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Star Wars<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Vanilla Sky<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Atomic Blonde<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>Let’s cover it from the top. The <code>&lt;form&gt;</code> tag has an ID that we’ll be using for the Vue component. There’s a submit handler that you’ll see in a bit, and the <code>action</code> is a temporary URL that would point to something real on a server someplace (where you have backup server-side validation of course).</p>\n<p>Beneath that there is a paragraph that shows or hides itself based on an error state. This will render a simple list of errors on top of the form. Also note we fire the validation on submit rather than as every field is modified.</p>\n<p>The final thing to note is that each of the three fields has a corresponding <code>v-model</code> to connect them to values we will work with in the JavaScript. Now let’s look at that.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">age</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">movie</span>: <span class=\"hljs-literal\">null</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>:&#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.name &amp;&amp; <span class=\"hljs-keyword\">this</span>.age) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n      &#125;\n\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.name) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Name required.'</span>);\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.age) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Age required.'</span>);\n      &#125;\n\n      e.preventDefault();\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Fairly short and simple. We define an array to hold errors and set <code>null</code> values for the three form fields. The <code>checkForm</code> logic (which is run on submit remember) checks for name and age only as movie is optional. If they are empty we check each and set a specific error for each. And that’s really it. You can run the demo below. Don’t forget that on a successful submission it’s going to POST to a temporary URL.</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"GObpZM\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 1\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/GObpZM/\" target=\"_blank\" rel=\"noopener\">form validation 1</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Using-Custom-Validation\"><a href=\"#Using-Custom-Validation\" class=\"headerlink\" title=\"Using Custom Validation\"></a>Using Custom Validation</h2><p>For the second example, the second text field (age) was switched to email which will be validated with a bit of custom logic. The code is taken from the StackOverflow question, <a href=\"https://stackoverflow.com/questions/46155/how-to-validate-email-address-in-javascript\" target=\"_blank\" rel=\"noopener\">How to validate email address in JavaScript?</a>. This is an awesome question because it makes your most intense Facebook political/religious argument look like a slight disagreement over who makes the best beer. Seriously - it’s insane. Here is the HTML, even though it’s really close to the first example.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"https://vuejs.org/\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n  <span class=\"hljs-attr\">novalidate</span>=<span class=\"hljs-string\">\"true\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"email\"</span>&gt;</span>Email<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"email\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"email\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"email\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"email\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"movie\"</span>&gt;</span>Favorite Movie<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"movie\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"movie\"</span>\n    &gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Star Wars<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Vanilla Sky<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>Atomic Blonde<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>While the change here is small, note the <code>novalidate=&quot;true&quot;</code> on top. This is important because the browser will attempt to validate the email address in the field when <code>type=&quot;email&quot;</code>. Frankly it may make more sense to trust the browser in this case, but as we wanted an example with custom validation, we’re disabling it. Here’s the updated JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">email</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">movie</span>: <span class=\"hljs-literal\">null</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.name) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">\"Name required.\"</span>);\n      &#125;\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.email) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Email required.'</span>);\n      &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.validEmail(<span class=\"hljs-keyword\">this</span>.email)) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Valid email required.'</span>);\n      &#125;\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.errors.length) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n      &#125;\n\n      e.preventDefault();\n    &#125;,\n    <span class=\"hljs-attr\">validEmail</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">email</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> re = <span class=\"hljs-regexp\">/^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$/</span>;\n      <span class=\"hljs-keyword\">return</span> re.test(email);\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>As you can see, we’ve added <code>validEmail</code> as a new method and it is simply called from <code>checkForm</code>. You can play with this example here:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqNXZ\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 2\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqNXZ/\" target=\"_blank\" rel=\"noopener\">form validation 2</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Another-Example-of-Custom-Validation\"><a href=\"#Another-Example-of-Custom-Validation\" class=\"headerlink\" title=\"Another Example of Custom Validation\"></a>Another Example of Custom Validation</h2><p>For the third example, we’ve built something you’ve probably seen in survey apps. The user is asked to spend a “budget” for a set of features for a new Star Destroyer model. The total must equal 100. First, the HTML.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">\"https://vuejs.org/\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n  <span class=\"hljs-attr\">novalidate</span>=<span class=\"hljs-string\">\"true\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    Given a budget of 100 dollars, indicate how much\n    you would spend on the following features for the\n    next generation Star Destroyer. Your total must sum up to 100.\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"weapons\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"weapons\"</span>\n    &gt;</span> Weapons <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"shields\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"shields\"</span>\n    &gt;</span> Shields <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"coffee\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"coffee\"</span>\n    &gt;</span> Coffee <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"ac\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"ac\"</span>\n    &gt;</span> Air Conditioning <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"mousedroids\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"mousedroids\"</span>\n    &gt;</span> Mouse Droids <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    Current Total: &#123;&#123;total&#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>Note the set of inputs covering the five different features. Note the addition of <code>.number</code> to the <code>v-model</code> attribute. This tells Vue to cast the value to a number when you use it. However, there is a bug with this feature such that when the value is blank, it turns back into a string. You’ll see the workaround below. To make it a bit easier for the user, we also added a current total right below so they can see, in real time, what their total is. Now let’s look at the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>:&#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">weapons</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">shields</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">coffee</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">ac</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">mousedroids</span>: <span class=\"hljs-number\">0</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n     <span class=\"hljs-attr\">total</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n       <span class=\"hljs-comment\">// must parse because Vue turns empty value to string</span>\n       <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.weapons) +\n         <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.shields) +\n         <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.coffee) +\n         <span class=\"hljs-built_in\">Number</span>(<span class=\"hljs-keyword\">this</span>.ac+<span class=\"hljs-keyword\">this</span>.mousedroids);\n     &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>:&#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.total != <span class=\"hljs-number\">100</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Total must be 100!'</span>);\n      &#125;\n\n      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.errors.length) &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n      &#125;\n\n      e.preventDefault();\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>We set up the total value as a computed value, and outside of that bug I ran into, it was simple enough to setup. My checkForm method now just needs to see if the total is 100 and that’s it. You can play with this here:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"vWqGoy\" data-default-tab=\"html,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 3\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/vWqGoy/\" target=\"_blank\" rel=\"noopener\">form validation 3</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Server-side-Validation\"><a href=\"#Server-side-Validation\" class=\"headerlink\" title=\"Server-side Validation\"></a>Server-side Validation</h2><p>In my final example, we built something that makes use of Ajax to validate at the server. The form will ask you to name a new product and will then check to ensure that the name is unique. We wrote a quick <a href=\"https://netlify.com/\" target=\"_blank\" rel=\"noopener\">Netlify</a> serverless action to do the validation. While it isn’t terribly important, here is the logic:</p>\n<pre><code class=\"hljs js\">exports.handler = <span class=\"hljs-keyword\">async</span> (event, context) =&gt; &#123;\n  \n    <span class=\"hljs-keyword\">const</span> badNames = [<span class=\"hljs-string\">'vista'</span>, <span class=\"hljs-string\">'empire'</span>, <span class=\"hljs-string\">'mbp'</span>];\n    <span class=\"hljs-keyword\">const</span> name = event.queryStringParameters.name;\n\n    <span class=\"hljs-keyword\">if</span> (badNames.includes(name)) &#123;\n      <span class=\"hljs-keyword\">return</span> &#123; \n        <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-number\">400</span>,         \n        <span class=\"hljs-attr\">body</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(&#123;<span class=\"hljs-attr\">error</span>: <span class=\"hljs-string\">'Invalid name passed.'</span>&#125;) \n      &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-number\">204</span>\n    &#125;\n\n&#125;</code></pre>\n<p>Basically any name but “vista”, “empire”, and “mbp” are acceptable. Ok, so let’s look at the form.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span>\n  <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>\n  @<span class=\"hljs-attr\">submit</span>=<span class=\"hljs-string\">\"checkForm\"</span>\n  <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">\"post\"</span>\n&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errors.length\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">b</span>&gt;</span>Please correct the following error(s):<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">b</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"error in errors\"</span>&gt;</span>&#123;&#123; error &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>New Product Name: <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"name\"</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>\n      <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>\n      <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Submit\"</span>\n    &gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>There isn’t anything special here. So let’s go on to the JavaScript.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> apiUrl = <span class=\"hljs-string\">'https://vuecookbook.netlify.com/.netlify/functions/product-name?name='</span>;\n\n<span class=\"hljs-keyword\">const</span> app = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">errors</span>: [],\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">''</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>:&#123;\n    <span class=\"hljs-attr\">checkForm</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;\n      e.preventDefault();\n\n      <span class=\"hljs-keyword\">this</span>.errors = [];\n\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.name === <span class=\"hljs-string\">''</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.errors.push(<span class=\"hljs-string\">'Product name is required.'</span>);\n      &#125; <span class=\"hljs-keyword\">else</span> &#123;\n        fetch(apiUrl + <span class=\"hljs-built_in\">encodeURIComponent</span>(<span class=\"hljs-keyword\">this</span>.name))\n        .then(<span class=\"hljs-keyword\">async</span> res =&gt; &#123;\n          <span class=\"hljs-keyword\">if</span> (res.status === <span class=\"hljs-number\">204</span>) &#123;\n            alert(<span class=\"hljs-string\">'OK'</span>);\n          &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (res.status === <span class=\"hljs-number\">400</span>) &#123;\n            <span class=\"hljs-keyword\">let</span> errorResponse = <span class=\"hljs-keyword\">await</span> res.json();\n            <span class=\"hljs-keyword\">this</span>.errors.push(errorResponse.error);\n          &#125;\n        &#125;);\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>We start off with a variable representing the URL of the API that is running on OpenWhisk. Now look at <code>checkForm</code>. In this version, we always prevent the form from submitting (which, by the way, could be done in the HTML with Vue as well). You can see a basic check on <code>this.name</code> being empty, and then we hit the API. If it’s bad, we add an error as before. If it’s good, right now we do nothing (just an alert), but you could navigate the user to a new page with the product name in the URL, or do other actions as well. You can run this demo below:</p>\n<p></p><p data-height=\"265\" data-theme-id=\"0\" data-slug-hash=\"BmgzeM\" data-default-tab=\"js,result\" data-user=\"cfjedimaster\" data-embed-version=\"2\" data-pen-title=\"form validation 4\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/cfjedimaster/pen/BmgzeM/\" target=\"_blank\" rel=\"noopener\">form validation 4</a> by Raymond Camden (<a href=\"https://codepen.io/cfjedimaster\" target=\"_blank\" rel=\"noopener\">@cfjedimaster</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>While this cookbook entry focused on doing form validation “by hand”, there are, of course, some great Vue libraries that will handle a lot of this for you. Switching to a prepackage library may impact the final size of your application, but the benefits could be tremendous. You have code that is (most likely) heavily tested and also updated on a regular basis. Some examples of form validation libraries for Vue include:</p>\n<ul>\n<li><a href=\"https://github.com/monterail/vuelidate\" target=\"_blank\" rel=\"noopener\">vuelidate</a></li>\n<li><a href=\"https://logaretm.github.io/vee-validate/\" target=\"_blank\" rel=\"noopener\">VeeValidate</a></li>\n</ul>\n"},{"title":"Introduction","type":"cookbook","order":0,"_content":"\n## The Cookbook vs the Guide\n\nHow is the cookbook different from the guide? Why is this necessary?\n\n* **Greater Focus**: In the guide, we're essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.\n\n* **Greater Depth**: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.\n\n* **Teaching JavaScript**: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won't explain how `Array.prototype.filter` works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.\n\n* **Exploring the Ecosystem**: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don't explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.\n\n<p class=\"tip\">With all these differences, please note that the cookbook is still _not_ a step-by-step manual. For most of its content, you are expected to have a basic understanding of concepts like HTML, CSS, JavaScript, npm/yarn, etc.</p>\n\n## Cookbook Contributions\n\n### What we're looking for\n\nThe Cookbook gives developers examples to work off of that both cover common or interesting use cases, and also progressively explain more complex detail. Our goal is to move beyond a simple introductory example, and demonstrate concepts that are more widely applicable, as well as some caveats to the approach.\n\nIf you're interested in contributing, please initiate collaboration by filing an issue under the tag **cookbook idea** with your concept so that we can help guide you to a successful pull request. After your idea has been approved, please follow the template below as much as possible. Some sections are required, and some are optional. Following the numerical order is strongly suggested, but not required.\n\nRecipes should generally:\n\n> * Solve a specific, common problem\n> * Start with the simplest possible example\n> * Introduce complexities one at a time\n> * Link to other docs, rather than re-explaining concepts\n> * Describe the problem, rather than assuming familiarity\n> * Explain the process, rather than just the end result\n> * Explain the pros and cons of your strategy, including when it is and isn't appropriate\n> * Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe\n\nWe request that you follow the template below. We understand, however, that there are times when you may necessarily need to deviate for clarity or flow. Either way, all recipes should at some point discuss the nuance of the choice made using this pattern, preferably in the form of the alternative patterns section.\n\n### Base Example\n\n_required_\n\n1.  Articulate the problem in a sentence or two.\n2.  Explain the simplest possible solution in a sentence or two.\n3.  Show a small code sample.\n4.  Explain what this accomplishes in a sentence.\n\n### Details about the Value\n\n_required_\n\n1.  Address common questions that one might have while looking at the example. (Blockquotes are great for this)\n2.  Show examples of common missteps and how they can be avoided.\n3.  Show very simple code samples of good and bad patterns.\n4.  Discuss why this may be a compelling pattern. Links for reference are not required but encouraged.\n\n### Real-World Example\n\n_required_\n\nDemonstrate the code that would power a common or interesting use case, either by:\n\n1.  Walking through a few terse examples of setup, or\n2.  Embedding a codepen/jsfiddle example\n\nIf you choose to do the latter, you should still talk through what it is and does.\n\n### Additional Context\n\n_optional_\n\nIt's extremely helpful to write a bit about this pattern, where else it would apply, why it works well, and run through a bit of code as you do so or give people further reading materials here.\n\n### When To Avoid This Pattern\n\n_optional_\n\nThis section is not required, but heavily recommended. It won't make sense to write it for something very simple such as toggling classes based on state change, but for more advanced patterns like mixins it's vital. The answer to most questions about development is [\"It depends!\"](https://codepen.io/rachsmith/pen/YweZbG), this section embraces that. Here, we'll take an honest look at when the pattern is useful and when it should be avoided, or when something else makes more sense.\n\n### Alternative Patterns\n\n_required_\n\nThis section is required when you've provided the section above about avoidance. It's important to explore other methods so that people told that something is an antipattern in certain situations are not left wondering. In doing so, consider that the web is a big tent and that many people have different codebase structures and are solving different goals. Is the app large or small? Are they integrating Vue into an existing project, or are they building from scratch? Are their users only trying to achieve one goal or many? Is there a lot of asynchronous data? All of these concerns will impact alternative implementations. A good cookbook recipe gives developers this context.\n\n## Thank you\n\nIt takes time to contribute to documentation, and if you spend the time to submit a PR to this section of our docs, you do so with our gratitude.\n","source":"v2/cookbook/index.md","raw":"---\ntitle: Introduction\ntype: cookbook\norder: 0\n---\n\n## The Cookbook vs the Guide\n\nHow is the cookbook different from the guide? Why is this necessary?\n\n* **Greater Focus**: In the guide, we're essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.\n\n* **Greater Depth**: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.\n\n* **Teaching JavaScript**: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won't explain how `Array.prototype.filter` works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.\n\n* **Exploring the Ecosystem**: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don't explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.\n\n<p class=\"tip\">With all these differences, please note that the cookbook is still _not_ a step-by-step manual. For most of its content, you are expected to have a basic understanding of concepts like HTML, CSS, JavaScript, npm/yarn, etc.</p>\n\n## Cookbook Contributions\n\n### What we're looking for\n\nThe Cookbook gives developers examples to work off of that both cover common or interesting use cases, and also progressively explain more complex detail. Our goal is to move beyond a simple introductory example, and demonstrate concepts that are more widely applicable, as well as some caveats to the approach.\n\nIf you're interested in contributing, please initiate collaboration by filing an issue under the tag **cookbook idea** with your concept so that we can help guide you to a successful pull request. After your idea has been approved, please follow the template below as much as possible. Some sections are required, and some are optional. Following the numerical order is strongly suggested, but not required.\n\nRecipes should generally:\n\n> * Solve a specific, common problem\n> * Start with the simplest possible example\n> * Introduce complexities one at a time\n> * Link to other docs, rather than re-explaining concepts\n> * Describe the problem, rather than assuming familiarity\n> * Explain the process, rather than just the end result\n> * Explain the pros and cons of your strategy, including when it is and isn't appropriate\n> * Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe\n\nWe request that you follow the template below. We understand, however, that there are times when you may necessarily need to deviate for clarity or flow. Either way, all recipes should at some point discuss the nuance of the choice made using this pattern, preferably in the form of the alternative patterns section.\n\n### Base Example\n\n_required_\n\n1.  Articulate the problem in a sentence or two.\n2.  Explain the simplest possible solution in a sentence or two.\n3.  Show a small code sample.\n4.  Explain what this accomplishes in a sentence.\n\n### Details about the Value\n\n_required_\n\n1.  Address common questions that one might have while looking at the example. (Blockquotes are great for this)\n2.  Show examples of common missteps and how they can be avoided.\n3.  Show very simple code samples of good and bad patterns.\n4.  Discuss why this may be a compelling pattern. Links for reference are not required but encouraged.\n\n### Real-World Example\n\n_required_\n\nDemonstrate the code that would power a common or interesting use case, either by:\n\n1.  Walking through a few terse examples of setup, or\n2.  Embedding a codepen/jsfiddle example\n\nIf you choose to do the latter, you should still talk through what it is and does.\n\n### Additional Context\n\n_optional_\n\nIt's extremely helpful to write a bit about this pattern, where else it would apply, why it works well, and run through a bit of code as you do so or give people further reading materials here.\n\n### When To Avoid This Pattern\n\n_optional_\n\nThis section is not required, but heavily recommended. It won't make sense to write it for something very simple such as toggling classes based on state change, but for more advanced patterns like mixins it's vital. The answer to most questions about development is [\"It depends!\"](https://codepen.io/rachsmith/pen/YweZbG), this section embraces that. Here, we'll take an honest look at when the pattern is useful and when it should be avoided, or when something else makes more sense.\n\n### Alternative Patterns\n\n_required_\n\nThis section is required when you've provided the section above about avoidance. It's important to explore other methods so that people told that something is an antipattern in certain situations are not left wondering. In doing so, consider that the web is a big tent and that many people have different codebase structures and are solving different goals. Is the app large or small? Are they integrating Vue into an existing project, or are they building from scratch? Are their users only trying to achieve one goal or many? Is there a lot of asynchronous data? All of these concerns will impact alternative implementations. A good cookbook recipe gives developers this context.\n\n## Thank you\n\nIt takes time to contribute to documentation, and if you spend the time to submit a PR to this section of our docs, you do so with our gratitude.\n","date":"2020-09-25T23:55:41.107Z","updated":"2020-09-25T23:55:41.107Z","path":"v2/cookbook/index.html","comments":1,"layout":"page","_id":"ckfl66gy5000pc2v5l21pb0n5","content":"<h2 id=\"The-Cookbook-vs-the-Guide\"><a href=\"#The-Cookbook-vs-the-Guide\" class=\"headerlink\" title=\"The Cookbook vs the Guide\"></a>The Cookbook vs the Guide</h2><p>How is the cookbook different from the guide? Why is this necessary?</p>\n<ul>\n<li><p><strong>Greater Focus</strong>: In the guide, we’re essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.</p>\n</li>\n<li><p><strong>Greater Depth</strong>: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.</p>\n</li>\n<li><p><strong>Teaching JavaScript</strong>: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won’t explain how <code>Array.prototype.filter</code> works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.</p>\n</li>\n<li><p><strong>Exploring the Ecosystem</strong>: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don’t explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.</p>\n</li>\n</ul>\n<p class=\"tip\">With all these differences, please note that the cookbook is still <em>not</em> a step-by-step manual. For most of its content, you are expected to have a basic understanding of concepts like HTML, CSS, JavaScript, npm/yarn, etc.</p>\n\n<h2 id=\"Cookbook-Contributions\"><a href=\"#Cookbook-Contributions\" class=\"headerlink\" title=\"Cookbook Contributions\"></a>Cookbook Contributions</h2><h3 id=\"What-we’re-looking-for\"><a href=\"#What-we’re-looking-for\" class=\"headerlink\" title=\"What we’re looking for\"></a>What we’re looking for</h3><p>The Cookbook gives developers examples to work off of that both cover common or interesting use cases, and also progressively explain more complex detail. Our goal is to move beyond a simple introductory example, and demonstrate concepts that are more widely applicable, as well as some caveats to the approach.</p>\n<p>If you’re interested in contributing, please initiate collaboration by filing an issue under the tag <strong>cookbook idea</strong> with your concept so that we can help guide you to a successful pull request. After your idea has been approved, please follow the template below as much as possible. Some sections are required, and some are optional. Following the numerical order is strongly suggested, but not required.</p>\n<p>Recipes should generally:</p>\n<blockquote>\n<ul>\n<li>Solve a specific, common problem</li>\n<li>Start with the simplest possible example</li>\n<li>Introduce complexities one at a time</li>\n<li>Link to other docs, rather than re-explaining concepts</li>\n<li>Describe the problem, rather than assuming familiarity</li>\n<li>Explain the process, rather than just the end result</li>\n<li>Explain the pros and cons of your strategy, including when it is and isn’t appropriate</li>\n<li>Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe</li>\n</ul>\n</blockquote>\n<p>We request that you follow the template below. We understand, however, that there are times when you may necessarily need to deviate for clarity or flow. Either way, all recipes should at some point discuss the nuance of the choice made using this pattern, preferably in the form of the alternative patterns section.</p>\n<h3 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h3><p><em>required</em></p>\n<ol>\n<li>Articulate the problem in a sentence or two.</li>\n<li>Explain the simplest possible solution in a sentence or two.</li>\n<li>Show a small code sample.</li>\n<li>Explain what this accomplishes in a sentence.</li>\n</ol>\n<h3 id=\"Details-about-the-Value\"><a href=\"#Details-about-the-Value\" class=\"headerlink\" title=\"Details about the Value\"></a>Details about the Value</h3><p><em>required</em></p>\n<ol>\n<li>Address common questions that one might have while looking at the example. (Blockquotes are great for this)</li>\n<li>Show examples of common missteps and how they can be avoided.</li>\n<li>Show very simple code samples of good and bad patterns.</li>\n<li>Discuss why this may be a compelling pattern. Links for reference are not required but encouraged.</li>\n</ol>\n<h3 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h3><p><em>required</em></p>\n<p>Demonstrate the code that would power a common or interesting use case, either by:</p>\n<ol>\n<li>Walking through a few terse examples of setup, or</li>\n<li>Embedding a codepen/jsfiddle example</li>\n</ol>\n<p>If you choose to do the latter, you should still talk through what it is and does.</p>\n<h3 id=\"Additional-Context\"><a href=\"#Additional-Context\" class=\"headerlink\" title=\"Additional Context\"></a>Additional Context</h3><p><em>optional</em></p>\n<p>It’s extremely helpful to write a bit about this pattern, where else it would apply, why it works well, and run through a bit of code as you do so or give people further reading materials here.</p>\n<h3 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h3><p><em>optional</em></p>\n<p>This section is not required, but heavily recommended. It won’t make sense to write it for something very simple such as toggling classes based on state change, but for more advanced patterns like mixins it’s vital. The answer to most questions about development is <a href=\"https://codepen.io/rachsmith/pen/YweZbG\" target=\"_blank\" rel=\"noopener\">“It depends!”</a>, this section embraces that. Here, we’ll take an honest look at when the pattern is useful and when it should be avoided, or when something else makes more sense.</p>\n<h3 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h3><p><em>required</em></p>\n<p>This section is required when you’ve provided the section above about avoidance. It’s important to explore other methods so that people told that something is an antipattern in certain situations are not left wondering. In doing so, consider that the web is a big tent and that many people have different codebase structures and are solving different goals. Is the app large or small? Are they integrating Vue into an existing project, or are they building from scratch? Are their users only trying to achieve one goal or many? Is there a lot of asynchronous data? All of these concerns will impact alternative implementations. A good cookbook recipe gives developers this context.</p>\n<h2 id=\"Thank-you\"><a href=\"#Thank-you\" class=\"headerlink\" title=\"Thank you\"></a>Thank you</h2><p>It takes time to contribute to documentation, and if you spend the time to submit a PR to this section of our docs, you do so with our gratitude.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"The-Cookbook-vs-the-Guide\"><a href=\"#The-Cookbook-vs-the-Guide\" class=\"headerlink\" title=\"The Cookbook vs the Guide\"></a>The Cookbook vs the Guide</h2><p>How is the cookbook different from the guide? Why is this necessary?</p>\n<ul>\n<li><p><strong>Greater Focus</strong>: In the guide, we’re essentially telling a story. Each section builds on and assumes knowledge from each previous section. In the cookbook, each recipe can and should stand on its own. This means recipes can focus on one specific aspect of Vue, rather than having to give a general overview.</p>\n</li>\n<li><p><strong>Greater Depth</strong>: To avoid making the guide too long, we try to include only the simplest possible examples to help you understand each feature. Then we move on. In the cookbook, we can include more complex examples, combining features in interesting ways. Each recipe can also be as long and detailed as it needs to be, in order to fully explore its niche.</p>\n</li>\n<li><p><strong>Teaching JavaScript</strong>: In the guide, we assume at least intermediate familiarity with ES5 JavaScript. For example, we won’t explain how <code>Array.prototype.filter</code> works in a computed property that filters a list. In the cookbook however, essential JavaScript features (including ES6/2015+) can be explored and explained in the context of how they help us build better Vue applications.</p>\n</li>\n<li><p><strong>Exploring the Ecosystem</strong>: For advanced features, we assume some ecosystem knowledge. For example, if you want to use single-file components in Webpack, we don’t explain how to configure the non-Vue parts of the Webpack config. In the cookbook, we have the space to explore these ecosystem libraries in more depth - at least to the extent that is universally useful for Vue developers.</p>\n</li>\n</ul>\n<p class=\"tip\">With all these differences, please note that the cookbook is still <em>not</em> a step-by-step manual. For most of its content, you are expected to have a basic understanding of concepts like HTML, CSS, JavaScript, npm/yarn, etc.</p>\n\n<h2 id=\"Cookbook-Contributions\"><a href=\"#Cookbook-Contributions\" class=\"headerlink\" title=\"Cookbook Contributions\"></a>Cookbook Contributions</h2><h3 id=\"What-we’re-looking-for\"><a href=\"#What-we’re-looking-for\" class=\"headerlink\" title=\"What we’re looking for\"></a>What we’re looking for</h3><p>The Cookbook gives developers examples to work off of that both cover common or interesting use cases, and also progressively explain more complex detail. Our goal is to move beyond a simple introductory example, and demonstrate concepts that are more widely applicable, as well as some caveats to the approach.</p>\n<p>If you’re interested in contributing, please initiate collaboration by filing an issue under the tag <strong>cookbook idea</strong> with your concept so that we can help guide you to a successful pull request. After your idea has been approved, please follow the template below as much as possible. Some sections are required, and some are optional. Following the numerical order is strongly suggested, but not required.</p>\n<p>Recipes should generally:</p>\n<blockquote>\n<ul>\n<li>Solve a specific, common problem</li>\n<li>Start with the simplest possible example</li>\n<li>Introduce complexities one at a time</li>\n<li>Link to other docs, rather than re-explaining concepts</li>\n<li>Describe the problem, rather than assuming familiarity</li>\n<li>Explain the process, rather than just the end result</li>\n<li>Explain the pros and cons of your strategy, including when it is and isn’t appropriate</li>\n<li>Mention alternative solutions, if relevant, but leave in-depth explorations to a separate recipe</li>\n</ul>\n</blockquote>\n<p>We request that you follow the template below. We understand, however, that there are times when you may necessarily need to deviate for clarity or flow. Either way, all recipes should at some point discuss the nuance of the choice made using this pattern, preferably in the form of the alternative patterns section.</p>\n<h3 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h3><p><em>required</em></p>\n<ol>\n<li>Articulate the problem in a sentence or two.</li>\n<li>Explain the simplest possible solution in a sentence or two.</li>\n<li>Show a small code sample.</li>\n<li>Explain what this accomplishes in a sentence.</li>\n</ol>\n<h3 id=\"Details-about-the-Value\"><a href=\"#Details-about-the-Value\" class=\"headerlink\" title=\"Details about the Value\"></a>Details about the Value</h3><p><em>required</em></p>\n<ol>\n<li>Address common questions that one might have while looking at the example. (Blockquotes are great for this)</li>\n<li>Show examples of common missteps and how they can be avoided.</li>\n<li>Show very simple code samples of good and bad patterns.</li>\n<li>Discuss why this may be a compelling pattern. Links for reference are not required but encouraged.</li>\n</ol>\n<h3 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h3><p><em>required</em></p>\n<p>Demonstrate the code that would power a common or interesting use case, either by:</p>\n<ol>\n<li>Walking through a few terse examples of setup, or</li>\n<li>Embedding a codepen/jsfiddle example</li>\n</ol>\n<p>If you choose to do the latter, you should still talk through what it is and does.</p>\n<h3 id=\"Additional-Context\"><a href=\"#Additional-Context\" class=\"headerlink\" title=\"Additional Context\"></a>Additional Context</h3><p><em>optional</em></p>\n<p>It’s extremely helpful to write a bit about this pattern, where else it would apply, why it works well, and run through a bit of code as you do so or give people further reading materials here.</p>\n<h3 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h3><p><em>optional</em></p>\n<p>This section is not required, but heavily recommended. It won’t make sense to write it for something very simple such as toggling classes based on state change, but for more advanced patterns like mixins it’s vital. The answer to most questions about development is <a href=\"https://codepen.io/rachsmith/pen/YweZbG\" target=\"_blank\" rel=\"noopener\">“It depends!”</a>, this section embraces that. Here, we’ll take an honest look at when the pattern is useful and when it should be avoided, or when something else makes more sense.</p>\n<h3 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h3><p><em>required</em></p>\n<p>This section is required when you’ve provided the section above about avoidance. It’s important to explore other methods so that people told that something is an antipattern in certain situations are not left wondering. In doing so, consider that the web is a big tent and that many people have different codebase structures and are solving different goals. Is the app large or small? Are they integrating Vue into an existing project, or are they building from scratch? Are their users only trying to achieve one goal or many? Is there a lot of asynchronous data? All of these concerns will impact alternative implementations. A good cookbook recipe gives developers this context.</p>\n<h2 id=\"Thank-you\"><a href=\"#Thank-you\" class=\"headerlink\" title=\"Thank you\"></a>Thank you</h2><p>It takes time to contribute to documentation, and if you spend the time to submit a PR to this section of our docs, you do so with our gratitude.</p>\n"},{"title":"Practical use of scoped slots with GoogleMaps","type":"cookbook","order":14,"_content":"\n## Base Example\n\nThere are situations when you want the template inside the slot to be able to access data from the child component that is responsible for rendering the slot content. This is particularly useful when you need freedom in creating custom templates that use the child component's data properties. That is a typical use case for scoped slots.\n\nImagine a component that configures and prepares an external API to be used in another component, but is not tightly coupled with any specific template. Such a component could then be reused in multiple places rendering different templates but using the same base object with specific API.\n\nWe'll create a component (`GoogleMapLoader.vue`) that:\n1. Initializes the [Google Maps API](https://developers.google.com/maps/documentation/javascript/reference/)\n2. Creates `google` and `map` objects\n3. Exposes those objects to the parent component in which the `GoogleMapLoader` is used\n\nBelow is an example of how this can be achieved. We will analyze the code piece-by-piece and see what is actually happening in the next section.\n\nLet’s first establish our `GoogleMapLoader.vue` template:\n\n```html\n<template>\n  <div>\n    <div class=\"google-map\" ref=\"googleMap\"></div>\n    <template v-if=\"Boolean(this.google) && Boolean(this.map)\">\n      <slot\n        :google=\"google\"\n        :map=\"map\"\n      />\n    </template>\n  </div>\n</template>\n```\n\nNow, our script needs to pass some props to the component which allows us to set the [Google Maps API](https://developers.google.com/maps/documentation/javascript/reference/) and [Map object](https://developers.google.com/maps/documentation/javascript/reference/map#Map):\n\n```js\nimport GoogleMapsApiLoader from 'google-maps-api-loader'\n\nexport default {\n  props: {\n    mapConfig: Object,\n    apiKey: String,\n  },\n\n  data() {\n    return {\n      google: null,\n      map: null\n    }\n  },\n\n  async mounted() {\n    const googleMapApi = await GoogleMapsApiLoader({\n      apiKey: this.apiKey\n    })\n    this.google = googleMapApi\n    this.initializeMap()\n  },\n\n  methods: {\n    initializeMap() {\n      const mapContainer = this.$refs.googleMap\n      this.map = new this.google.maps.Map(\n        mapContainer, this.mapConfig\n      )\n    }\n  }\n}\n```\n\nThis is just part of a working example, you can find the whole example in the Codesandbox below.\n\n<iframe src=\"https://codesandbox.io/embed/1o45zvxk0q\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n## Real-World Example: Creating a Google Map Loader component\n\n### 1. Create a component that initializes our map\n\n`GoogleMapLoader.vue`\n\nIn the template, we create a container for the map which will be used to mount the [Map](https://developers.google.com/maps/documentation/javascript/reference/map#Map) object extracted from the Google Maps API.\n\n```html\n<template>\n  <div>\n    <div class=\"google-map\" ref=\"googleMap\"></div>\n  </div>\n</template>\n```\n\nNext up, our script needs to receive props from the parent component which will allow us to set the Google Map. Those props consist of:\n\n- [mapConfig](https://developers.google.com/maps/documentation/javascript/reference/3/map#MapOptions): Google Maps config object\n- [apiKey](https://developers.google.com/maps/documentation/javascript/get-api-key): Our personal api key required by Google Maps\n\n```js\nimport GoogleMapsApiLoader from 'google-maps-api-loader'\n\nexport default {\n  props: {\n    mapConfig: Object,\n    apiKey: String,\n  },\n```\nThen, we set the initial values of google and map to null:\n\n```js\n  data() {\n    return {\n      google: null,\n      map: null\n    }\n  },\n```\n\nOn `mounted` hook we instantiate a `googleMapApi` and `Map` objects from the `GoogleMapsApi` and we set the values of `google` and `map` to the created instances:\n\n```js\n  async mounted() {\n    const googleMapApi = await GoogleMapsApiLoader({\n      apiKey: this.apiKey\n    })\n    this.google = googleMapApi\n    this.initializeMap()\n  },\n\n  methods: {\n    initializeMap() {\n      const mapContainer = this.$refs.googleMap\n      this.map = new this.google.maps.Map(mapContainer, this.mapConfig)\n    }\n  }\n}\n```\n\nSo far, so good. With all that done, we could continue adding the other objects to the map (Markers, Polylines, etc.) and use it as an ordinary map component.\n\nBut, we want to use our `GoogleMapLoader` component only as a loader that prepares the map — we don’t want to render anything on it.\n\nTo achieve that, we need to allow the parent component that will use our `GoogleMapLoader` to access `this.google` and `this.map` that are set inside the `GoogleMapLoader` component. That’s where [scoped slots](https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots) really shine. Scoped slots allow us to expose the properties set in a child component to the parent component. It may sound like Inception, but bear with me one more minute as we break that down further.\n\n### 2. Create component that uses our initializer component.\n\n`TravelMap.vue`\n\nIn the template, we render the `GoogleMapLoader` component and pass props that are required to initialize the map.\n\n```html\n<template>\n  <GoogleMapLoader\n    :mapConfig=\"mapConfig\"\n    apiKey=\"yourApiKey\"\n  />\n</template>\n```\n\nOur script tag will look like this:\n\n```js\n<script>\nimport GoogleMapLoader from './GoogleMapLoader'\nimport { mapSettings } from '@/constants/mapSettings'\n\nexport default {\n  components: {\n    GoogleMapLoader\n  },\n\n  computed: {\n    mapConfig () {\n      return {\n        ...mapSettings,\n        center: { lat: 0, lng: 0 }\n      }\n    },\n  },\n}\n</script>\n```\n\nStill no scoped slots, so let's add one.\n\n### 3. Expose `google` and `map` properties to the parent component by adding a scoped slot.\n\nFinally, we can add a scoped slot that will do the job and allow us to access the child component props in the parent component. We do that by adding the `<slot>` tag in the child component and passing the props that we want to expose (using `v-bind` directive or `:propName` shorthand). It does not differ from passing the props down to the child component, but doing it in the `<slot>` tag will reverse the direction of data flow.\n\n`GoogleMapLoader.vue`\n\n```html\n<template>\n  <div>\n    <div class=\"google-map\" ref=\"googleMap\"></div>\n    <template v-if=\"Boolean(this.google) && Boolean(this.map)\">\n      <slot\n        :google=\"google\"\n        :map=\"map\"\n      />\n    </template>\n  </div>\n</template>\n```\n\nNow, when we have the slot in the child component, we need to receive and consume the exposed props in the parent component.\n\n### 4. Receive exposed props in the parent component using `slot-scope` attribute.\n\nTo receive the props in the parent component, we declare a template element and use the `slot-scope` attribute. This attribute has access to the object carrying all the props exposed from the child component. We can grab the whole object or we can [de-structure that object](https://vuejs.org/v2/guide/components-slots.html#Destructuring-slot-scope) and only what we need.\n\nLet’s de-structure this thing to get what we need.\n\n`TravelMap.vue`\n\n```html\n<GoogleMapLoader\n  :mapConfig=\"mapConfig\"\n  apiKey=\"yourApiKey\"\n>\n  <template slot-scope=\"{ google, map }\">\n  \t{{ map }}\n  \t{{ google }}\n  </template>\n</GoogleMapLoader>\n```\n\nEven though the `google` and `map` props do not exist in the `TravelMap` scope, the component has access to them and we can use them in the template.\n\nYou might wonder why would we do things like that and what is the use of all that?\n\nScoped slots allow us to pass a template to the slot instead of a rendered element. It’s called a `scoped` slot because it will have access to certain child component data even though the template is rendered in the parent component scope. This gives us the freedom to fill the template with custom content from the parent component.\n\n### 5. Create factory components for Markers and Polylines\n\nNow when we have our map ready we will create two factory components that will be used to add elements to the `TravelMap`.\n\n`GoogleMapMarker.vue`\n\n```js\nimport { POINT_MARKER_ICON_CONFIG } from '@/constants/mapSettings'\n\nexport default {\n  props: {\n    google: {\n      type: Object,\n      required: true\n    },\n    map: {\n      type: Object,\n      required: true\n    },\n    marker: {\n      type: Object,\n      required: true\n    }\n  },\n\n  mounted() {\n    new this.google.maps.Marker({\n      position: this.marker.position,\n      marker: this.marker,\n      map: this.map,\n      icon: POINT_MARKER_ICON_CONFIG\n    })\n  }\n}\n```\n\n`GoogleMapLine.vue`\n\n```js\nimport { LINE_PATH_CONFIG } from '@/constants/mapSettings'\n\nexport default {\n  props: {\n    google: {\n      type: Object,\n      required: true\n    },\n    map: {\n      type: Object,\n      required: true\n    },\n    path: {\n      type: Array,\n      required: true\n    }\n  },\n\n  mounted() {\n    new this.google.maps.Polyline({\n      path: this.path,\n      map: this.map,\n      ...LINE_PATH_CONFIG\n    })\n  }\n}\n```\n\nBoth of these receive `google` that we use to extract the required object (Marker or Polyline) as well as `map` which gives as a reference to the map on which we want to place our element.\n\nEach component also expects an extra prop to create a corresponding element. In this case, we have `marker` and `path`, respectively.\n\nOn the mounted hook, we create an element (Marker/Polyline) and attach it to our map by passing the `map` property to the object constructor.\n\nThere’s still one more step to go...\n\n### 6. Add elements to map\n\nLet’s use our factory components to add elements to our map. We must render the factory component and pass the `google` and `map` objects so data flows to the right places.\n\nWe also need to provide the data that’s required by the element itself. In our case, that’s the `marker` object with the position of the marker and the `path` object with Polyline coordinates.\n\nHere we go, integrating the data points directly into the template:\n\n```html\n<GoogleMapLoader\n  :mapConfig=\"mapConfig\"\n  apiKey=\"yourApiKey\"\n>\n  <template slot-scope=\"{ google, map }\">\n    <GoogleMapMarker\n      v-for=\"marker in markers\"\n      :key=\"marker.id\"\n      :marker=\"marker\"\n      :google=\"google\"\n      :map=\"map\"\n    />\n    <GoogleMapLine\n      v-for=\"line in lines\"\n      :key=\"line.id\"\n      :path.sync=\"line.path\"\n      :google=\"google\"\n      :map=\"map\"\n    />\n  </template>\n</GoogleMapLoader>\n```\n\nWe need to import the required factory components in our script and set the data that will be passed to the markers and lines:\n\n```js\nimport { mapSettings } from '@/constants/mapSettings'\n\nexport default {\n  components: {\n    GoogleMapLoader,\n    GoogleMapMarker,\n    GoogleMapLine\n  },\n\n  data () {\n    return {\n      markers: [\n      { id: 'a', position: { lat: 3, lng: 101 } },\n      { id: 'b', position: { lat: 5, lng: 99 } },\n      { id: 'c', position: { lat: 6, lng: 97 } },\n      ],\n      lines: [\n        { id: '1', path: [{ lat: 3, lng: 101 }, { lat: 5, lng: 99 }] },\n        { id: '2', path: [{ lat: 5, lng: 99 }, { lat: 6, lng: 97 }] }\n      ],\n    }\n  },\n\n  computed: {\n    mapConfig () {\n      return {\n        ...mapSettings,\n        center: this.mapCenter\n      }\n    },\n\n    mapCenter () {\n      return this.markers[1].position\n    }\n  },\n}\n```\n\n## When To Avoid This Pattern\nIt might be tempting to create a very complex solution based on the example, but at some point we can get to the situation where this abstraction becomes an independent part of the code living in our codebase. If we get to that point it might be worth considering extraction to an add-on.\n\n## Wrapping Up\nThat's it. With all those bits and pieces created we can now re-use the `GoogleMapLoader` component as a base for all our maps by passing different templates to each one of them. Imagine that you need to create another map with different Markers or just Markers without Polylines. By using the above pattern it becomes very easy as we just need to pass different content to the `GoogleMapLoader` component.\n\nThis pattern is not strictly connected to Google Maps; it can be used with any library to set the base component and expose the library's API that might be then used in the component that summoned the base component.","source":"v2/cookbook/practical-use-of-scoped-slots.md","raw":"---\ntitle: Practical use of scoped slots with GoogleMaps\ntype: cookbook\norder: 14\n---\n\n## Base Example\n\nThere are situations when you want the template inside the slot to be able to access data from the child component that is responsible for rendering the slot content. This is particularly useful when you need freedom in creating custom templates that use the child component's data properties. That is a typical use case for scoped slots.\n\nImagine a component that configures and prepares an external API to be used in another component, but is not tightly coupled with any specific template. Such a component could then be reused in multiple places rendering different templates but using the same base object with specific API.\n\nWe'll create a component (`GoogleMapLoader.vue`) that:\n1. Initializes the [Google Maps API](https://developers.google.com/maps/documentation/javascript/reference/)\n2. Creates `google` and `map` objects\n3. Exposes those objects to the parent component in which the `GoogleMapLoader` is used\n\nBelow is an example of how this can be achieved. We will analyze the code piece-by-piece and see what is actually happening in the next section.\n\nLet’s first establish our `GoogleMapLoader.vue` template:\n\n```html\n<template>\n  <div>\n    <div class=\"google-map\" ref=\"googleMap\"></div>\n    <template v-if=\"Boolean(this.google) && Boolean(this.map)\">\n      <slot\n        :google=\"google\"\n        :map=\"map\"\n      />\n    </template>\n  </div>\n</template>\n```\n\nNow, our script needs to pass some props to the component which allows us to set the [Google Maps API](https://developers.google.com/maps/documentation/javascript/reference/) and [Map object](https://developers.google.com/maps/documentation/javascript/reference/map#Map):\n\n```js\nimport GoogleMapsApiLoader from 'google-maps-api-loader'\n\nexport default {\n  props: {\n    mapConfig: Object,\n    apiKey: String,\n  },\n\n  data() {\n    return {\n      google: null,\n      map: null\n    }\n  },\n\n  async mounted() {\n    const googleMapApi = await GoogleMapsApiLoader({\n      apiKey: this.apiKey\n    })\n    this.google = googleMapApi\n    this.initializeMap()\n  },\n\n  methods: {\n    initializeMap() {\n      const mapContainer = this.$refs.googleMap\n      this.map = new this.google.maps.Map(\n        mapContainer, this.mapConfig\n      )\n    }\n  }\n}\n```\n\nThis is just part of a working example, you can find the whole example in the Codesandbox below.\n\n<iframe src=\"https://codesandbox.io/embed/1o45zvxk0q\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n## Real-World Example: Creating a Google Map Loader component\n\n### 1. Create a component that initializes our map\n\n`GoogleMapLoader.vue`\n\nIn the template, we create a container for the map which will be used to mount the [Map](https://developers.google.com/maps/documentation/javascript/reference/map#Map) object extracted from the Google Maps API.\n\n```html\n<template>\n  <div>\n    <div class=\"google-map\" ref=\"googleMap\"></div>\n  </div>\n</template>\n```\n\nNext up, our script needs to receive props from the parent component which will allow us to set the Google Map. Those props consist of:\n\n- [mapConfig](https://developers.google.com/maps/documentation/javascript/reference/3/map#MapOptions): Google Maps config object\n- [apiKey](https://developers.google.com/maps/documentation/javascript/get-api-key): Our personal api key required by Google Maps\n\n```js\nimport GoogleMapsApiLoader from 'google-maps-api-loader'\n\nexport default {\n  props: {\n    mapConfig: Object,\n    apiKey: String,\n  },\n```\nThen, we set the initial values of google and map to null:\n\n```js\n  data() {\n    return {\n      google: null,\n      map: null\n    }\n  },\n```\n\nOn `mounted` hook we instantiate a `googleMapApi` and `Map` objects from the `GoogleMapsApi` and we set the values of `google` and `map` to the created instances:\n\n```js\n  async mounted() {\n    const googleMapApi = await GoogleMapsApiLoader({\n      apiKey: this.apiKey\n    })\n    this.google = googleMapApi\n    this.initializeMap()\n  },\n\n  methods: {\n    initializeMap() {\n      const mapContainer = this.$refs.googleMap\n      this.map = new this.google.maps.Map(mapContainer, this.mapConfig)\n    }\n  }\n}\n```\n\nSo far, so good. With all that done, we could continue adding the other objects to the map (Markers, Polylines, etc.) and use it as an ordinary map component.\n\nBut, we want to use our `GoogleMapLoader` component only as a loader that prepares the map — we don’t want to render anything on it.\n\nTo achieve that, we need to allow the parent component that will use our `GoogleMapLoader` to access `this.google` and `this.map` that are set inside the `GoogleMapLoader` component. That’s where [scoped slots](https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots) really shine. Scoped slots allow us to expose the properties set in a child component to the parent component. It may sound like Inception, but bear with me one more minute as we break that down further.\n\n### 2. Create component that uses our initializer component.\n\n`TravelMap.vue`\n\nIn the template, we render the `GoogleMapLoader` component and pass props that are required to initialize the map.\n\n```html\n<template>\n  <GoogleMapLoader\n    :mapConfig=\"mapConfig\"\n    apiKey=\"yourApiKey\"\n  />\n</template>\n```\n\nOur script tag will look like this:\n\n```js\n<script>\nimport GoogleMapLoader from './GoogleMapLoader'\nimport { mapSettings } from '@/constants/mapSettings'\n\nexport default {\n  components: {\n    GoogleMapLoader\n  },\n\n  computed: {\n    mapConfig () {\n      return {\n        ...mapSettings,\n        center: { lat: 0, lng: 0 }\n      }\n    },\n  },\n}\n</script>\n```\n\nStill no scoped slots, so let's add one.\n\n### 3. Expose `google` and `map` properties to the parent component by adding a scoped slot.\n\nFinally, we can add a scoped slot that will do the job and allow us to access the child component props in the parent component. We do that by adding the `<slot>` tag in the child component and passing the props that we want to expose (using `v-bind` directive or `:propName` shorthand). It does not differ from passing the props down to the child component, but doing it in the `<slot>` tag will reverse the direction of data flow.\n\n`GoogleMapLoader.vue`\n\n```html\n<template>\n  <div>\n    <div class=\"google-map\" ref=\"googleMap\"></div>\n    <template v-if=\"Boolean(this.google) && Boolean(this.map)\">\n      <slot\n        :google=\"google\"\n        :map=\"map\"\n      />\n    </template>\n  </div>\n</template>\n```\n\nNow, when we have the slot in the child component, we need to receive and consume the exposed props in the parent component.\n\n### 4. Receive exposed props in the parent component using `slot-scope` attribute.\n\nTo receive the props in the parent component, we declare a template element and use the `slot-scope` attribute. This attribute has access to the object carrying all the props exposed from the child component. We can grab the whole object or we can [de-structure that object](https://vuejs.org/v2/guide/components-slots.html#Destructuring-slot-scope) and only what we need.\n\nLet’s de-structure this thing to get what we need.\n\n`TravelMap.vue`\n\n```html\n<GoogleMapLoader\n  :mapConfig=\"mapConfig\"\n  apiKey=\"yourApiKey\"\n>\n  <template slot-scope=\"{ google, map }\">\n  \t{{ map }}\n  \t{{ google }}\n  </template>\n</GoogleMapLoader>\n```\n\nEven though the `google` and `map` props do not exist in the `TravelMap` scope, the component has access to them and we can use them in the template.\n\nYou might wonder why would we do things like that and what is the use of all that?\n\nScoped slots allow us to pass a template to the slot instead of a rendered element. It’s called a `scoped` slot because it will have access to certain child component data even though the template is rendered in the parent component scope. This gives us the freedom to fill the template with custom content from the parent component.\n\n### 5. Create factory components for Markers and Polylines\n\nNow when we have our map ready we will create two factory components that will be used to add elements to the `TravelMap`.\n\n`GoogleMapMarker.vue`\n\n```js\nimport { POINT_MARKER_ICON_CONFIG } from '@/constants/mapSettings'\n\nexport default {\n  props: {\n    google: {\n      type: Object,\n      required: true\n    },\n    map: {\n      type: Object,\n      required: true\n    },\n    marker: {\n      type: Object,\n      required: true\n    }\n  },\n\n  mounted() {\n    new this.google.maps.Marker({\n      position: this.marker.position,\n      marker: this.marker,\n      map: this.map,\n      icon: POINT_MARKER_ICON_CONFIG\n    })\n  }\n}\n```\n\n`GoogleMapLine.vue`\n\n```js\nimport { LINE_PATH_CONFIG } from '@/constants/mapSettings'\n\nexport default {\n  props: {\n    google: {\n      type: Object,\n      required: true\n    },\n    map: {\n      type: Object,\n      required: true\n    },\n    path: {\n      type: Array,\n      required: true\n    }\n  },\n\n  mounted() {\n    new this.google.maps.Polyline({\n      path: this.path,\n      map: this.map,\n      ...LINE_PATH_CONFIG\n    })\n  }\n}\n```\n\nBoth of these receive `google` that we use to extract the required object (Marker or Polyline) as well as `map` which gives as a reference to the map on which we want to place our element.\n\nEach component also expects an extra prop to create a corresponding element. In this case, we have `marker` and `path`, respectively.\n\nOn the mounted hook, we create an element (Marker/Polyline) and attach it to our map by passing the `map` property to the object constructor.\n\nThere’s still one more step to go...\n\n### 6. Add elements to map\n\nLet’s use our factory components to add elements to our map. We must render the factory component and pass the `google` and `map` objects so data flows to the right places.\n\nWe also need to provide the data that’s required by the element itself. In our case, that’s the `marker` object with the position of the marker and the `path` object with Polyline coordinates.\n\nHere we go, integrating the data points directly into the template:\n\n```html\n<GoogleMapLoader\n  :mapConfig=\"mapConfig\"\n  apiKey=\"yourApiKey\"\n>\n  <template slot-scope=\"{ google, map }\">\n    <GoogleMapMarker\n      v-for=\"marker in markers\"\n      :key=\"marker.id\"\n      :marker=\"marker\"\n      :google=\"google\"\n      :map=\"map\"\n    />\n    <GoogleMapLine\n      v-for=\"line in lines\"\n      :key=\"line.id\"\n      :path.sync=\"line.path\"\n      :google=\"google\"\n      :map=\"map\"\n    />\n  </template>\n</GoogleMapLoader>\n```\n\nWe need to import the required factory components in our script and set the data that will be passed to the markers and lines:\n\n```js\nimport { mapSettings } from '@/constants/mapSettings'\n\nexport default {\n  components: {\n    GoogleMapLoader,\n    GoogleMapMarker,\n    GoogleMapLine\n  },\n\n  data () {\n    return {\n      markers: [\n      { id: 'a', position: { lat: 3, lng: 101 } },\n      { id: 'b', position: { lat: 5, lng: 99 } },\n      { id: 'c', position: { lat: 6, lng: 97 } },\n      ],\n      lines: [\n        { id: '1', path: [{ lat: 3, lng: 101 }, { lat: 5, lng: 99 }] },\n        { id: '2', path: [{ lat: 5, lng: 99 }, { lat: 6, lng: 97 }] }\n      ],\n    }\n  },\n\n  computed: {\n    mapConfig () {\n      return {\n        ...mapSettings,\n        center: this.mapCenter\n      }\n    },\n\n    mapCenter () {\n      return this.markers[1].position\n    }\n  },\n}\n```\n\n## When To Avoid This Pattern\nIt might be tempting to create a very complex solution based on the example, but at some point we can get to the situation where this abstraction becomes an independent part of the code living in our codebase. If we get to that point it might be worth considering extraction to an add-on.\n\n## Wrapping Up\nThat's it. With all those bits and pieces created we can now re-use the `GoogleMapLoader` component as a base for all our maps by passing different templates to each one of them. Imagine that you need to create another map with different Markers or just Markers without Polylines. By using the above pattern it becomes very easy as we just need to pass different content to the `GoogleMapLoader` component.\n\nThis pattern is not strictly connected to Google Maps; it can be used with any library to set the base component and expose the library's API that might be then used in the component that summoned the base component.","date":"2020-09-25T23:55:41.107Z","updated":"2020-09-25T23:55:41.107Z","path":"v2/cookbook/practical-use-of-scoped-slots.html","comments":1,"layout":"page","_id":"ckfl66gy5000qc2v5o0p4yho8","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are situations when you want the template inside the slot to be able to access data from the child component that is responsible for rendering the slot content. This is particularly useful when you need freedom in creating custom templates that use the child component’s data properties. That is a typical use case for scoped slots.</p>\n<p>Imagine a component that configures and prepares an external API to be used in another component, but is not tightly coupled with any specific template. Such a component could then be reused in multiple places rendering different templates but using the same base object with specific API.</p>\n<p>We’ll create a component (<code>GoogleMapLoader.vue</code>) that:</p>\n<ol>\n<li>Initializes the <a href=\"https://developers.google.com/maps/documentation/javascript/reference/\" target=\"_blank\" rel=\"noopener\">Google Maps API</a></li>\n<li>Creates <code>google</code> and <code>map</code> objects</li>\n<li>Exposes those objects to the parent component in which the <code>GoogleMapLoader</code> is used</li>\n</ol>\n<p>Below is an example of how this can be achieved. We will analyze the code piece-by-piece and see what is actually happening in the next section.</p>\n<p>Let’s first establish our <code>GoogleMapLoader.vue</code> template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"google-map\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"googleMap\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Boolean(this.google) &amp;&amp; Boolean(this.map)\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>\n        <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n        <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n      /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Now, our script needs to pass some props to the component which allows us to set the <a href=\"https://developers.google.com/maps/documentation/javascript/reference/\" target=\"_blank\" rel=\"noopener\">Google Maps API</a> and <a href=\"https://developers.google.com/maps/documentation/javascript/reference/map#Map\" target=\"_blank\" rel=\"noopener\">Map object</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> GoogleMapsApiLoader <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'google-maps-api-loader'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">mapConfig</span>: <span class=\"hljs-built_in\">Object</span>,\n    <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-built_in\">String</span>,\n  &#125;,\n\n  data() &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">google</span>: <span class=\"hljs-literal\">null</span>,\n      <span class=\"hljs-attr\">map</span>: <span class=\"hljs-literal\">null</span>\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-keyword\">async</span> mounted() &#123;\n    <span class=\"hljs-keyword\">const</span> googleMapApi = <span class=\"hljs-keyword\">await</span> GoogleMapsApiLoader(&#123;\n      <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-keyword\">this</span>.apiKey\n    &#125;)\n    <span class=\"hljs-keyword\">this</span>.google = googleMapApi\n    <span class=\"hljs-keyword\">this</span>.initializeMap()\n  &#125;,\n\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    initializeMap() &#123;\n      <span class=\"hljs-keyword\">const</span> mapContainer = <span class=\"hljs-keyword\">this</span>.$refs.googleMap\n      <span class=\"hljs-keyword\">this</span>.map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Map(\n        mapContainer, <span class=\"hljs-keyword\">this</span>.mapConfig\n      )\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>This is just part of a working example, you can find the whole example in the Codesandbox below.</p>\n<iframe src=\"https://codesandbox.io/embed/1o45zvxk0q\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<h2 id=\"Real-World-Example-Creating-a-Google-Map-Loader-component\"><a href=\"#Real-World-Example-Creating-a-Google-Map-Loader-component\" class=\"headerlink\" title=\"Real-World Example: Creating a Google Map Loader component\"></a>Real-World Example: Creating a Google Map Loader component</h2><h3 id=\"1-Create-a-component-that-initializes-our-map\"><a href=\"#1-Create-a-component-that-initializes-our-map\" class=\"headerlink\" title=\"1. Create a component that initializes our map\"></a>1. Create a component that initializes our map</h3><p><code>GoogleMapLoader.vue</code></p>\n<p>In the template, we create a container for the map which will be used to mount the <a href=\"https://developers.google.com/maps/documentation/javascript/reference/map#Map\" target=\"_blank\" rel=\"noopener\">Map</a> object extracted from the Google Maps API.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"google-map\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"googleMap\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Next up, our script needs to receive props from the parent component which will allow us to set the Google Map. Those props consist of:</p>\n<ul>\n<li><a href=\"https://developers.google.com/maps/documentation/javascript/reference/3/map#MapOptions\" target=\"_blank\" rel=\"noopener\">mapConfig</a>: Google Maps config object</li>\n<li><a href=\"https://developers.google.com/maps/documentation/javascript/get-api-key\" target=\"_blank\" rel=\"noopener\">apiKey</a>: Our personal api key required by Google Maps</li>\n</ul>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> GoogleMapsApiLoader <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'google-maps-api-loader'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">mapConfig</span>: <span class=\"hljs-built_in\">Object</span>,\n    <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-built_in\">String</span>,\n  &#125;,</code></pre>\n<p>Then, we set the initial values of google and map to null:</p>\n<pre><code class=\"hljs js\">data() &#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">google</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">map</span>: <span class=\"hljs-literal\">null</span>\n  &#125;\n&#125;,</code></pre>\n<p>On <code>mounted</code> hook we instantiate a <code>googleMapApi</code> and <code>Map</code> objects from the <code>GoogleMapsApi</code> and we set the values of <code>google</code> and <code>map</code> to the created instances:</p>\n<pre><code class=\"hljs js\">  <span class=\"hljs-keyword\">async</span> mounted() &#123;\n    <span class=\"hljs-keyword\">const</span> googleMapApi = <span class=\"hljs-keyword\">await</span> GoogleMapsApiLoader(&#123;\n      <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-keyword\">this</span>.apiKey\n    &#125;)\n    <span class=\"hljs-keyword\">this</span>.google = googleMapApi\n    <span class=\"hljs-keyword\">this</span>.initializeMap()\n  &#125;,\n\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    initializeMap() &#123;\n      <span class=\"hljs-keyword\">const</span> mapContainer = <span class=\"hljs-keyword\">this</span>.$refs.googleMap\n      <span class=\"hljs-keyword\">this</span>.map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Map(mapContainer, <span class=\"hljs-keyword\">this</span>.mapConfig)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>So far, so good. With all that done, we could continue adding the other objects to the map (Markers, Polylines, etc.) and use it as an ordinary map component.</p>\n<p>But, we want to use our <code>GoogleMapLoader</code> component only as a loader that prepares the map — we don’t want to render anything on it.</p>\n<p>To achieve that, we need to allow the parent component that will use our <code>GoogleMapLoader</code> to access <code>this.google</code> and <code>this.map</code> that are set inside the <code>GoogleMapLoader</code> component. That’s where <a href=\"https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots\">scoped slots</a> really shine. Scoped slots allow us to expose the properties set in a child component to the parent component. It may sound like Inception, but bear with me one more minute as we break that down further.</p>\n<h3 id=\"2-Create-component-that-uses-our-initializer-component\"><a href=\"#2-Create-component-that-uses-our-initializer-component\" class=\"headerlink\" title=\"2. Create component that uses our initializer component.\"></a>2. Create component that uses our initializer component.</h3><p><code>TravelMap.vue</code></p>\n<p>In the template, we render the <code>GoogleMapLoader</code> component and pass props that are required to initialize the map.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLoader</span>\n    <span class=\"hljs-attr\">:mapConfig</span>=<span class=\"hljs-string\">\"mapConfig\"</span>\n    <span class=\"hljs-attr\">apiKey</span>=<span class=\"hljs-string\">\"yourApiKey\"</span>\n  /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Our script tag will look like this:</p>\n<pre><code class=\"hljs js\">&lt;script&gt;\n<span class=\"hljs-keyword\">import</span> GoogleMapLoader <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./GoogleMapLoader'</span>\n<span class=\"hljs-keyword\">import</span> &#123; mapSettings &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    GoogleMapLoader\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    mapConfig () &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...mapSettings,\n        <span class=\"hljs-attr\">center</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">0</span> &#125;\n      &#125;\n    &#125;,\n  &#125;,\n&#125;\n&lt;<span class=\"hljs-regexp\">/script&gt;</span></code></pre>\n<p>Still no scoped slots, so let’s add one.</p>\n<h3 id=\"3-Expose-google-and-map-properties-to-the-parent-component-by-adding-a-scoped-slot\"><a href=\"#3-Expose-google-and-map-properties-to-the-parent-component-by-adding-a-scoped-slot\" class=\"headerlink\" title=\"3. Expose google and map properties to the parent component by adding a scoped slot.\"></a>3. Expose <code>google</code> and <code>map</code> properties to the parent component by adding a scoped slot.</h3><p>Finally, we can add a scoped slot that will do the job and allow us to access the child component props in the parent component. We do that by adding the <code>&lt;slot&gt;</code> tag in the child component and passing the props that we want to expose (using <code>v-bind</code> directive or <code>:propName</code> shorthand). It does not differ from passing the props down to the child component, but doing it in the <code>&lt;slot&gt;</code> tag will reverse the direction of data flow.</p>\n<p><code>GoogleMapLoader.vue</code></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"google-map\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"googleMap\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Boolean(this.google) &amp;&amp; Boolean(this.map)\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>\n        <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n        <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n      /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Now, when we have the slot in the child component, we need to receive and consume the exposed props in the parent component.</p>\n<h3 id=\"4-Receive-exposed-props-in-the-parent-component-using-slot-scope-attribute\"><a href=\"#4-Receive-exposed-props-in-the-parent-component-using-slot-scope-attribute\" class=\"headerlink\" title=\"4. Receive exposed props in the parent component using slot-scope attribute.\"></a>4. Receive exposed props in the parent component using <code>slot-scope</code> attribute.</h3><p>To receive the props in the parent component, we declare a template element and use the <code>slot-scope</code> attribute. This attribute has access to the object carrying all the props exposed from the child component. We can grab the whole object or we can <a href=\"https://vuejs.org/v2/guide/components-slots.html#Destructuring-slot-scope\">de-structure that object</a> and only what we need.</p>\n<p>Let’s de-structure this thing to get what we need.</p>\n<p><code>TravelMap.vue</code></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLoader</span>\n  <span class=\"hljs-attr\">:mapConfig</span>=<span class=\"hljs-string\">\"mapConfig\"</span>\n  <span class=\"hljs-attr\">apiKey</span>=<span class=\"hljs-string\">\"yourApiKey\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; google, map &#125;\"</span>&gt;</span>\n  \t&#123;&#123; map &#125;&#125;\n  \t&#123;&#123; google &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">GoogleMapLoader</span>&gt;</span></code></pre>\n<p>Even though the <code>google</code> and <code>map</code> props do not exist in the <code>TravelMap</code> scope, the component has access to them and we can use them in the template.</p>\n<p>You might wonder why would we do things like that and what is the use of all that?</p>\n<p>Scoped slots allow us to pass a template to the slot instead of a rendered element. It’s called a <code>scoped</code> slot because it will have access to certain child component data even though the template is rendered in the parent component scope. This gives us the freedom to fill the template with custom content from the parent component.</p>\n<h3 id=\"5-Create-factory-components-for-Markers-and-Polylines\"><a href=\"#5-Create-factory-components-for-Markers-and-Polylines\" class=\"headerlink\" title=\"5. Create factory components for Markers and Polylines\"></a>5. Create factory components for Markers and Polylines</h3><p>Now when we have our map ready we will create two factory components that will be used to add elements to the <code>TravelMap</code>.</p>\n<p><code>GoogleMapMarker.vue</code></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; POINT_MARKER_ICON_CONFIG &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">google</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">map</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">marker</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n\n  mounted() &#123;\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Marker(&#123;\n      <span class=\"hljs-attr\">position</span>: <span class=\"hljs-keyword\">this</span>.marker.position,\n      <span class=\"hljs-attr\">marker</span>: <span class=\"hljs-keyword\">this</span>.marker,\n      <span class=\"hljs-attr\">map</span>: <span class=\"hljs-keyword\">this</span>.map,\n      <span class=\"hljs-attr\">icon</span>: POINT_MARKER_ICON_CONFIG\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p><code>GoogleMapLine.vue</code></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; LINE_PATH_CONFIG &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">google</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">map</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">path</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Array</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n\n  mounted() &#123;\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Polyline(&#123;\n      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-keyword\">this</span>.path,\n      <span class=\"hljs-attr\">map</span>: <span class=\"hljs-keyword\">this</span>.map,\n      ...LINE_PATH_CONFIG\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p>Both of these receive <code>google</code> that we use to extract the required object (Marker or Polyline) as well as <code>map</code> which gives as a reference to the map on which we want to place our element.</p>\n<p>Each component also expects an extra prop to create a corresponding element. In this case, we have <code>marker</code> and <code>path</code>, respectively.</p>\n<p>On the mounted hook, we create an element (Marker/Polyline) and attach it to our map by passing the <code>map</code> property to the object constructor.</p>\n<p>There’s still one more step to go…</p>\n<h3 id=\"6-Add-elements-to-map\"><a href=\"#6-Add-elements-to-map\" class=\"headerlink\" title=\"6. Add elements to map\"></a>6. Add elements to map</h3><p>Let’s use our factory components to add elements to our map. We must render the factory component and pass the <code>google</code> and <code>map</code> objects so data flows to the right places.</p>\n<p>We also need to provide the data that’s required by the element itself. In our case, that’s the <code>marker</code> object with the position of the marker and the <code>path</code> object with Polyline coordinates.</p>\n<p>Here we go, integrating the data points directly into the template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLoader</span>\n  <span class=\"hljs-attr\">:mapConfig</span>=<span class=\"hljs-string\">\"mapConfig\"</span>\n  <span class=\"hljs-attr\">apiKey</span>=<span class=\"hljs-string\">\"yourApiKey\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; google, map &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapMarker</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"marker in markers\"</span>\n      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"marker.id\"</span>\n      <span class=\"hljs-attr\">:marker</span>=<span class=\"hljs-string\">\"marker\"</span>\n      <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n      <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n    /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLine</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"line in lines\"</span>\n      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"line.id\"</span>\n      <span class=\"hljs-attr\">:path.sync</span>=<span class=\"hljs-string\">\"line.path\"</span>\n      <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n      <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n    /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">GoogleMapLoader</span>&gt;</span></code></pre>\n<p>We need to import the required factory components in our script and set the data that will be passed to the markers and lines:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; mapSettings &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    GoogleMapLoader,\n    GoogleMapMarker,\n    GoogleMapLine\n  &#125;,\n\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">markers</span>: [\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-attr\">position</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">101</span> &#125; &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-attr\">position</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">99</span> &#125; &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-attr\">position</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">97</span> &#125; &#125;,\n      ],\n      <span class=\"hljs-attr\">lines</span>: [\n        &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'1'</span>, <span class=\"hljs-attr\">path</span>: [&#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">101</span> &#125;, &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">99</span> &#125;] &#125;,\n        &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'2'</span>, <span class=\"hljs-attr\">path</span>: [&#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">99</span> &#125;, &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">97</span> &#125;] &#125;\n      ],\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    mapConfig () &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...mapSettings,\n        <span class=\"hljs-attr\">center</span>: <span class=\"hljs-keyword\">this</span>.mapCenter\n      &#125;\n    &#125;,\n\n    mapCenter () &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.markers[<span class=\"hljs-number\">1</span>].position\n    &#125;\n  &#125;,\n&#125;</code></pre>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>It might be tempting to create a very complex solution based on the example, but at some point we can get to the situation where this abstraction becomes an independent part of the code living in our codebase. If we get to that point it might be worth considering extraction to an add-on.</p>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>That’s it. With all those bits and pieces created we can now re-use the <code>GoogleMapLoader</code> component as a base for all our maps by passing different templates to each one of them. Imagine that you need to create another map with different Markers or just Markers without Polylines. By using the above pattern it becomes very easy as we just need to pass different content to the <code>GoogleMapLoader</code> component.</p>\n<p>This pattern is not strictly connected to Google Maps; it can be used with any library to set the base component and expose the library’s API that might be then used in the component that summoned the base component.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are situations when you want the template inside the slot to be able to access data from the child component that is responsible for rendering the slot content. This is particularly useful when you need freedom in creating custom templates that use the child component’s data properties. That is a typical use case for scoped slots.</p>\n<p>Imagine a component that configures and prepares an external API to be used in another component, but is not tightly coupled with any specific template. Such a component could then be reused in multiple places rendering different templates but using the same base object with specific API.</p>\n<p>We’ll create a component (<code>GoogleMapLoader.vue</code>) that:</p>\n<ol>\n<li>Initializes the <a href=\"https://developers.google.com/maps/documentation/javascript/reference/\" target=\"_blank\" rel=\"noopener\">Google Maps API</a></li>\n<li>Creates <code>google</code> and <code>map</code> objects</li>\n<li>Exposes those objects to the parent component in which the <code>GoogleMapLoader</code> is used</li>\n</ol>\n<p>Below is an example of how this can be achieved. We will analyze the code piece-by-piece and see what is actually happening in the next section.</p>\n<p>Let’s first establish our <code>GoogleMapLoader.vue</code> template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"google-map\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"googleMap\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Boolean(this.google) &amp;&amp; Boolean(this.map)\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>\n        <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n        <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n      /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Now, our script needs to pass some props to the component which allows us to set the <a href=\"https://developers.google.com/maps/documentation/javascript/reference/\" target=\"_blank\" rel=\"noopener\">Google Maps API</a> and <a href=\"https://developers.google.com/maps/documentation/javascript/reference/map#Map\" target=\"_blank\" rel=\"noopener\">Map object</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> GoogleMapsApiLoader <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'google-maps-api-loader'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">mapConfig</span>: <span class=\"hljs-built_in\">Object</span>,\n    <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-built_in\">String</span>,\n  &#125;,\n\n  data() &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">google</span>: <span class=\"hljs-literal\">null</span>,\n      <span class=\"hljs-attr\">map</span>: <span class=\"hljs-literal\">null</span>\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-keyword\">async</span> mounted() &#123;\n    <span class=\"hljs-keyword\">const</span> googleMapApi = <span class=\"hljs-keyword\">await</span> GoogleMapsApiLoader(&#123;\n      <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-keyword\">this</span>.apiKey\n    &#125;)\n    <span class=\"hljs-keyword\">this</span>.google = googleMapApi\n    <span class=\"hljs-keyword\">this</span>.initializeMap()\n  &#125;,\n\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    initializeMap() &#123;\n      <span class=\"hljs-keyword\">const</span> mapContainer = <span class=\"hljs-keyword\">this</span>.$refs.googleMap\n      <span class=\"hljs-keyword\">this</span>.map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Map(\n        mapContainer, <span class=\"hljs-keyword\">this</span>.mapConfig\n      )\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>This is just part of a working example, you can find the whole example in the Codesandbox below.</p>\n<iframe src=\"https://codesandbox.io/embed/1o45zvxk0q\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n\n<h2 id=\"Real-World-Example-Creating-a-Google-Map-Loader-component\"><a href=\"#Real-World-Example-Creating-a-Google-Map-Loader-component\" class=\"headerlink\" title=\"Real-World Example: Creating a Google Map Loader component\"></a>Real-World Example: Creating a Google Map Loader component</h2><h3 id=\"1-Create-a-component-that-initializes-our-map\"><a href=\"#1-Create-a-component-that-initializes-our-map\" class=\"headerlink\" title=\"1. Create a component that initializes our map\"></a>1. Create a component that initializes our map</h3><p><code>GoogleMapLoader.vue</code></p>\n<p>In the template, we create a container for the map which will be used to mount the <a href=\"https://developers.google.com/maps/documentation/javascript/reference/map#Map\" target=\"_blank\" rel=\"noopener\">Map</a> object extracted from the Google Maps API.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"google-map\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"googleMap\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Next up, our script needs to receive props from the parent component which will allow us to set the Google Map. Those props consist of:</p>\n<ul>\n<li><a href=\"https://developers.google.com/maps/documentation/javascript/reference/3/map#MapOptions\" target=\"_blank\" rel=\"noopener\">mapConfig</a>: Google Maps config object</li>\n<li><a href=\"https://developers.google.com/maps/documentation/javascript/get-api-key\" target=\"_blank\" rel=\"noopener\">apiKey</a>: Our personal api key required by Google Maps</li>\n</ul>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> GoogleMapsApiLoader <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'google-maps-api-loader'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">mapConfig</span>: <span class=\"hljs-built_in\">Object</span>,\n    <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-built_in\">String</span>,\n  &#125;,</code></pre>\n<p>Then, we set the initial values of google and map to null:</p>\n<pre><code class=\"hljs js\">data() &#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">google</span>: <span class=\"hljs-literal\">null</span>,\n    <span class=\"hljs-attr\">map</span>: <span class=\"hljs-literal\">null</span>\n  &#125;\n&#125;,</code></pre>\n<p>On <code>mounted</code> hook we instantiate a <code>googleMapApi</code> and <code>Map</code> objects from the <code>GoogleMapsApi</code> and we set the values of <code>google</code> and <code>map</code> to the created instances:</p>\n<pre><code class=\"hljs js\">  <span class=\"hljs-keyword\">async</span> mounted() &#123;\n    <span class=\"hljs-keyword\">const</span> googleMapApi = <span class=\"hljs-keyword\">await</span> GoogleMapsApiLoader(&#123;\n      <span class=\"hljs-attr\">apiKey</span>: <span class=\"hljs-keyword\">this</span>.apiKey\n    &#125;)\n    <span class=\"hljs-keyword\">this</span>.google = googleMapApi\n    <span class=\"hljs-keyword\">this</span>.initializeMap()\n  &#125;,\n\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    initializeMap() &#123;\n      <span class=\"hljs-keyword\">const</span> mapContainer = <span class=\"hljs-keyword\">this</span>.$refs.googleMap\n      <span class=\"hljs-keyword\">this</span>.map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Map(mapContainer, <span class=\"hljs-keyword\">this</span>.mapConfig)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>So far, so good. With all that done, we could continue adding the other objects to the map (Markers, Polylines, etc.) and use it as an ordinary map component.</p>\n<p>But, we want to use our <code>GoogleMapLoader</code> component only as a loader that prepares the map — we don’t want to render anything on it.</p>\n<p>To achieve that, we need to allow the parent component that will use our <code>GoogleMapLoader</code> to access <code>this.google</code> and <code>this.map</code> that are set inside the <code>GoogleMapLoader</code> component. That’s where <a href=\"https://vuejs.org/v2/guide/components-slots.html#Scoped-Slots\">scoped slots</a> really shine. Scoped slots allow us to expose the properties set in a child component to the parent component. It may sound like Inception, but bear with me one more minute as we break that down further.</p>\n<h3 id=\"2-Create-component-that-uses-our-initializer-component\"><a href=\"#2-Create-component-that-uses-our-initializer-component\" class=\"headerlink\" title=\"2. Create component that uses our initializer component.\"></a>2. Create component that uses our initializer component.</h3><p><code>TravelMap.vue</code></p>\n<p>In the template, we render the <code>GoogleMapLoader</code> component and pass props that are required to initialize the map.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLoader</span>\n    <span class=\"hljs-attr\">:mapConfig</span>=<span class=\"hljs-string\">\"mapConfig\"</span>\n    <span class=\"hljs-attr\">apiKey</span>=<span class=\"hljs-string\">\"yourApiKey\"</span>\n  /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Our script tag will look like this:</p>\n<pre><code class=\"hljs js\">&lt;script&gt;\n<span class=\"hljs-keyword\">import</span> GoogleMapLoader <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./GoogleMapLoader'</span>\n<span class=\"hljs-keyword\">import</span> &#123; mapSettings &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    GoogleMapLoader\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    mapConfig () &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...mapSettings,\n        <span class=\"hljs-attr\">center</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">0</span> &#125;\n      &#125;\n    &#125;,\n  &#125;,\n&#125;\n&lt;<span class=\"hljs-regexp\">/script&gt;</span></code></pre>\n<p>Still no scoped slots, so let’s add one.</p>\n<h3 id=\"3-Expose-google-and-map-properties-to-the-parent-component-by-adding-a-scoped-slot\"><a href=\"#3-Expose-google-and-map-properties-to-the-parent-component-by-adding-a-scoped-slot\" class=\"headerlink\" title=\"3. Expose google and map properties to the parent component by adding a scoped slot.\"></a>3. Expose <code>google</code> and <code>map</code> properties to the parent component by adding a scoped slot.</h3><p>Finally, we can add a scoped slot that will do the job and allow us to access the child component props in the parent component. We do that by adding the <code>&lt;slot&gt;</code> tag in the child component and passing the props that we want to expose (using <code>v-bind</code> directive or <code>:propName</code> shorthand). It does not differ from passing the props down to the child component, but doing it in the <code>&lt;slot&gt;</code> tag will reverse the direction of data flow.</p>\n<p><code>GoogleMapLoader.vue</code></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"google-map\"</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"googleMap\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Boolean(this.google) &amp;&amp; Boolean(this.map)\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>\n        <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n        <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n      /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Now, when we have the slot in the child component, we need to receive and consume the exposed props in the parent component.</p>\n<h3 id=\"4-Receive-exposed-props-in-the-parent-component-using-slot-scope-attribute\"><a href=\"#4-Receive-exposed-props-in-the-parent-component-using-slot-scope-attribute\" class=\"headerlink\" title=\"4. Receive exposed props in the parent component using slot-scope attribute.\"></a>4. Receive exposed props in the parent component using <code>slot-scope</code> attribute.</h3><p>To receive the props in the parent component, we declare a template element and use the <code>slot-scope</code> attribute. This attribute has access to the object carrying all the props exposed from the child component. We can grab the whole object or we can <a href=\"https://vuejs.org/v2/guide/components-slots.html#Destructuring-slot-scope\">de-structure that object</a> and only what we need.</p>\n<p>Let’s de-structure this thing to get what we need.</p>\n<p><code>TravelMap.vue</code></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLoader</span>\n  <span class=\"hljs-attr\">:mapConfig</span>=<span class=\"hljs-string\">\"mapConfig\"</span>\n  <span class=\"hljs-attr\">apiKey</span>=<span class=\"hljs-string\">\"yourApiKey\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; google, map &#125;\"</span>&gt;</span>\n  \t&#123;&#123; map &#125;&#125;\n  \t&#123;&#123; google &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">GoogleMapLoader</span>&gt;</span></code></pre>\n<p>Even though the <code>google</code> and <code>map</code> props do not exist in the <code>TravelMap</code> scope, the component has access to them and we can use them in the template.</p>\n<p>You might wonder why would we do things like that and what is the use of all that?</p>\n<p>Scoped slots allow us to pass a template to the slot instead of a rendered element. It’s called a <code>scoped</code> slot because it will have access to certain child component data even though the template is rendered in the parent component scope. This gives us the freedom to fill the template with custom content from the parent component.</p>\n<h3 id=\"5-Create-factory-components-for-Markers-and-Polylines\"><a href=\"#5-Create-factory-components-for-Markers-and-Polylines\" class=\"headerlink\" title=\"5. Create factory components for Markers and Polylines\"></a>5. Create factory components for Markers and Polylines</h3><p>Now when we have our map ready we will create two factory components that will be used to add elements to the <code>TravelMap</code>.</p>\n<p><code>GoogleMapMarker.vue</code></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; POINT_MARKER_ICON_CONFIG &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">google</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">map</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">marker</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n\n  mounted() &#123;\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Marker(&#123;\n      <span class=\"hljs-attr\">position</span>: <span class=\"hljs-keyword\">this</span>.marker.position,\n      <span class=\"hljs-attr\">marker</span>: <span class=\"hljs-keyword\">this</span>.marker,\n      <span class=\"hljs-attr\">map</span>: <span class=\"hljs-keyword\">this</span>.map,\n      <span class=\"hljs-attr\">icon</span>: POINT_MARKER_ICON_CONFIG\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p><code>GoogleMapLine.vue</code></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; LINE_PATH_CONFIG &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">google</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">map</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">path</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Array</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n\n  mounted() &#123;\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.google.maps.Polyline(&#123;\n      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-keyword\">this</span>.path,\n      <span class=\"hljs-attr\">map</span>: <span class=\"hljs-keyword\">this</span>.map,\n      ...LINE_PATH_CONFIG\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p>Both of these receive <code>google</code> that we use to extract the required object (Marker or Polyline) as well as <code>map</code> which gives as a reference to the map on which we want to place our element.</p>\n<p>Each component also expects an extra prop to create a corresponding element. In this case, we have <code>marker</code> and <code>path</code>, respectively.</p>\n<p>On the mounted hook, we create an element (Marker/Polyline) and attach it to our map by passing the <code>map</code> property to the object constructor.</p>\n<p>There’s still one more step to go…</p>\n<h3 id=\"6-Add-elements-to-map\"><a href=\"#6-Add-elements-to-map\" class=\"headerlink\" title=\"6. Add elements to map\"></a>6. Add elements to map</h3><p>Let’s use our factory components to add elements to our map. We must render the factory component and pass the <code>google</code> and <code>map</code> objects so data flows to the right places.</p>\n<p>We also need to provide the data that’s required by the element itself. In our case, that’s the <code>marker</code> object with the position of the marker and the <code>path</code> object with Polyline coordinates.</p>\n<p>Here we go, integrating the data points directly into the template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLoader</span>\n  <span class=\"hljs-attr\">:mapConfig</span>=<span class=\"hljs-string\">\"mapConfig\"</span>\n  <span class=\"hljs-attr\">apiKey</span>=<span class=\"hljs-string\">\"yourApiKey\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; google, map &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapMarker</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"marker in markers\"</span>\n      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"marker.id\"</span>\n      <span class=\"hljs-attr\">:marker</span>=<span class=\"hljs-string\">\"marker\"</span>\n      <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n      <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n    /&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">GoogleMapLine</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"line in lines\"</span>\n      <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"line.id\"</span>\n      <span class=\"hljs-attr\">:path.sync</span>=<span class=\"hljs-string\">\"line.path\"</span>\n      <span class=\"hljs-attr\">:google</span>=<span class=\"hljs-string\">\"google\"</span>\n      <span class=\"hljs-attr\">:map</span>=<span class=\"hljs-string\">\"map\"</span>\n    /&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">GoogleMapLoader</span>&gt;</span></code></pre>\n<p>We need to import the required factory components in our script and set the data that will be passed to the markers and lines:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; mapSettings &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/constants/mapSettings'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    GoogleMapLoader,\n    GoogleMapMarker,\n    GoogleMapLine\n  &#125;,\n\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">markers</span>: [\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'a'</span>, <span class=\"hljs-attr\">position</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">101</span> &#125; &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-attr\">position</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">99</span> &#125; &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'c'</span>, <span class=\"hljs-attr\">position</span>: &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">97</span> &#125; &#125;,\n      ],\n      <span class=\"hljs-attr\">lines</span>: [\n        &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'1'</span>, <span class=\"hljs-attr\">path</span>: [&#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">101</span> &#125;, &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">99</span> &#125;] &#125;,\n        &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'2'</span>, <span class=\"hljs-attr\">path</span>: [&#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">5</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">99</span> &#125;, &#123; <span class=\"hljs-attr\">lat</span>: <span class=\"hljs-number\">6</span>, <span class=\"hljs-attr\">lng</span>: <span class=\"hljs-number\">97</span> &#125;] &#125;\n      ],\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    mapConfig () &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...mapSettings,\n        <span class=\"hljs-attr\">center</span>: <span class=\"hljs-keyword\">this</span>.mapCenter\n      &#125;\n    &#125;,\n\n    mapCenter () &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.markers[<span class=\"hljs-number\">1</span>].position\n    &#125;\n  &#125;,\n&#125;</code></pre>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>It might be tempting to create a very complex solution based on the example, but at some point we can get to the situation where this abstraction becomes an independent part of the code living in our codebase. If we get to that point it might be worth considering extraction to an add-on.</p>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>That’s it. With all those bits and pieces created we can now re-use the <code>GoogleMapLoader</code> component as a base for all our maps by passing different templates to each one of them. Imagine that you need to create another map with different Markers or just Markers without Polylines. By using the above pattern it becomes very easy as we just need to pass different content to the <code>GoogleMapLoader</code> component.</p>\n<p>This pattern is not strictly connected to Google Maps; it can be used with any library to set the base component and expose the library’s API that might be then used in the component that summoned the base component.</p>\n"},{"title":"Create a CMS-Powered Blog","type":"cookbook","order":5,"_content":"\nSo you've just launched your Vue.js website, congrats! Now you want to add a blog that quickly plugs into your website and you don't want to have to spin up a whole server just to host a Wordpress instance (or any DB-powered CMS for that matter). You want to just be able to add a few Vue.js blog components and some routes and have it all just work, right? What you're looking for is a blog that's powered entirely by API's you can consume directly from your Vue.js application. This tutorial will teach you how to do just that, let's dive in!\n\nWe're going to quickly build a CMS-powered blog with Vue.js. It uses [ButterCMS](https://buttercms.com/), an API-first CMS that lets you manage content using the ButterCMS dashboard and integrate our content API into your Vue.js app. You can use ButterCMS for new or existing Vue.js projects.\n\n![Butter Dashboard](https://user-images.githubusercontent.com/160873/36677285-648798e4-1ad3-11e8-9454-d22fca8280b7.png \"Butter Dashboard\")\n\n## Install\n\nRun this in your commandline:\n\n```bash\nnpm install buttercms --save\n```\n\nButter can also be loaded using a CDN:\n\n```html\n<script src=\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"></script>\n```\n\n## Quickstart\n\nSet your API token:\n\n```javascript\nvar butter = require('buttercms')('your_api_token');\n```\n\nUsing ES6:\n\n```javascript\nimport Butter from 'buttercms';\nconst butter = Butter('your_api_token');\n```\n\nUsing CDN:\n\n```html\n<script src=\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"></script>\n<script>\n  var butter = Butter('your_api_token');\n</script>\n```\n\nImport this file into any component you want to use ButterCMS. Then from the console run:\n\n```javascript\nbutter.post.list({page: 1, page_size: 10}).then(function(response) {\n  console.log(response)\n})\n```\n\nThis API request fetches your blog posts. Your account comes with one example post which you'll see in the response.\n\n## Display posts\n\nTo display posts we create a `/blog` route (using Vue Router) in our app and fetch blog posts from the Butter API, as well as a `/blog/:slug` route to handle individual posts.\n\nSee the ButterCMS [API reference](https://buttercms.com/docs/api/?javascript#blog-posts) for additional options such as filtering by category or author. The response also includes some metadata we'll use for pagination.\n\n`router/index.js:`\n\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport BlogHome from '@/components/BlogHome'\nimport BlogPost from '@/components/BlogPost'\n\nVue.use(Router)\n\nexport default new Router({\n  mode: 'history',\n  routes: [\n    {\n      path: '/blog/',\n      name: 'blog-home',\n      component: BlogHome\n    },\n    {\n      path: '/blog/:slug',\n      name: 'blog-post',\n      component: BlogPost\n    }\n  ]\n})\n```\n\nThen create `components/BlogHome.vue` which will be your blog homepage that lists your most recent posts.\n\n```html\n<script>\n  import { butter } from '@/buttercms'\n  export default {\n    name: 'blog-home',\n    data() {\n      return {\n        page_title: 'Blog',\n        posts: []\n      }\n    },\n    methods: {\n      getPosts() {\n        butter.post.list({\n          page: 1,\n          page_size: 10\n        }).then(res => {\n          this.posts = res.data.data\n        })\n      }\n    },\n    created() {\n      this.getPosts()\n    }\n  }\n</script>\n\n<template>\n  <div id=\"blog-home\">\n      <h1>{{ page_title }}</h1>\n      <!-- Create `v-for` and apply a `key` for Vue. Here we are using a combination of the slug and index. -->\n      <div\n        v-for=\"(post,index) in posts\"\n        :key=\"post.slug + '_' + index\"\n      >\n        <router-link :to=\"'/blog/' + post.slug\">\n          <article class=\"media\">\n            <figure>\n              <!-- Bind results using a `:` -->\n              <!-- Use a `v-if`/`else` if there is a `featured_image` -->\n              <img\n                v-if=\"post.featured_image\"\n                :src=\"post.featured_image\"\n                alt=\"\"\n              >\n              <img\n                v-else\n                src=\"http://via.placeholder.com/250x250\"\n                alt=\"\"\n              >\n            </figure>\n            <h2>{{ post.title }}</h2>\n            <p>{{ post.summary }}</p>\n          </article>\n        </router-link>\n      </div>\n  </div>\n</template>\n```\n\nHere's what it looks like (note we added CSS from https://bulma.io/ for quick styling):\n\n![buttercms-bloglist](https://user-images.githubusercontent.com/160873/36868500-1b22e374-1d5e-11e8-82a0-20c8dc312716.png)\n\nNow create `components/BlogPost.vue` which will be your Blog Post page to list a single post.\n\n```html\n<script>\n  import { butter } from '@/buttercms'\n  export default {\n    name: 'blog-post',\n    data() {\n      return {\n        post: {}\n      }\n    },\n    methods: {\n      getPost() {\n        butter.post.retrieve(this.$route.params.slug)\n          .then(res => {\n            this.post = res.data\n          }).catch(res => {\n            console.log(res)\n          })\n      }\n    },\n    created() {\n      this.getPost()\n    }\n  }\n</script>\n\n<template>\n  <div id=\"blog-post\">\n    <h1>{{ post.data.title }}</h1>\n    <h4>{{ post.data.author.first_name }} {{ post.data.author.last_name }}</h4>\n    <div v-html=\"post.data.body\"></div>\n\n    <router-link\n      v-if=\"post.meta.previous_post\"\n      :to=\"/blog/ + post.meta.previous_post.slug\"\n      class=\"button\"\n    >\n      {{ post.meta.previous_post.title }}\n    </router-link>\n    <router-link\n      v-if=\"post.meta.next_post\"\n      :to=\"/blog/ + post.meta.next_post.slug\"\n      class=\"button\"\n    >\n      {{ post.meta.next_post.title }}\n    </router-link>\n  </div>\n</template>\n```\n\nHere's a preview:\n\n![buttercms-blogdetail](https://user-images.githubusercontent.com/160873/36868506-218c86b6-1d5e-11e8-8691-0409d91366d6.png)\n\nNow our app is pulling all blog posts and we can navigate to individual posts. However, our next/previous post buttons are not working.\n\nOne thing to note when using routes with params is that when the user navigates from `/blog/foo` to `/blog/bar`, the same component instance will be reused. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one.\n\n<p class=\"tip\">Be aware, that using the component this way will mean that the lifecycle hooks of the component will not be called. Visit the Vue Router's docs to learn more about [Dynamic Route Matching](https://router.vuejs.org/en/essentials/dynamic-matching.html)</p>\n\nTo fix this we need to watch the `$route` object and call `getPost()` when the route changes.\n\nUpdated `<script>` section in `components/BlogPost.vue`:\n\n```html\n<script>\n  import { butter } from '@/buttercms'\n  export default {\n    name: 'blog-post',\n    data() {\n      return {\n        post: null\n      }\n    },\n    methods: {\n      getPost() {\n        butter.post.retrieve(this.$route.params.slug)\n          .then(res => {\n            this.post = res.data\n          }).catch(res => {\n            console.log(res)\n          })\n      }\n    },\n    watch: {\n      $route: {\n        immediate: true,\n        handler(to, from) {\n          this.getPost()\n        }\n      }\n    }\n  }\n</script>\n```\n\nNow your app has a working blog that can be updated easily in the ButterCMS dashboard.\n\n## Categories, Tags, and Authors\n\nUse Butter's APIs for categories, tags, and authors to feature and filter content on your blog.\n\nSee the ButterCMS API reference for more information about these objects:\n\n* [Categories](https://buttercms.com/docs/api/?ruby#categories)\n* [Tags](https://buttercms.com/docs/api/?ruby#tags)\n* [Authors](https://buttercms.com/docs/api/?ruby#authors)\n\nHere's an example of listing all categories and getting posts by category. Call these methods on the `created()` lifecycle hook:\n\n```javascript\nmethods: {\n  // ...\n  getCategories() {\n    butter.category.list()\n      .then(res => {\n        console.log('List of Categories:')\n        console.log(res.data.data)\n      })\n  },\n  getPostsByCategory() {\n    butter.category.retrieve('example-category', {\n        include: 'recent_posts'\n      })\n      .then(res => {\n        console.log('Posts with specific category:')\n        console.log(res)\n      })\n  }\n},\ncreated() {\n  // ...\n  this.getCategories()\n  this.getPostsByCategory()\n}\n```\n\n## Alternative Patterns\n\nAn alternative pattern to consider, especially if you prefer writing only in Markdown, is using something like [Nuxtent](https://nuxtent-module.netlify.com/guide/writing/#async-components). Nuxtent allows you to use `Vue Component` inside of Markdown files. This approach would be akin to a static site approach (i.e. Jekyll) where you compose your blog posts in Markdown files. Nuxtent adds a nice integration between Vue.js and Markdown allowing you to live in a 100% Vue.js world.\n\n## Wrap up\n\nThat's it! You now have a fully functional CMS-powered blog running in your app. We hope this tutorial was helpful and made your development experience with Vue.js even more enjoyable :)\n","source":"v2/cookbook/serverless-blog.md","raw":"---\ntitle: Create a CMS-Powered Blog\ntype: cookbook\norder: 5\n---\n\nSo you've just launched your Vue.js website, congrats! Now you want to add a blog that quickly plugs into your website and you don't want to have to spin up a whole server just to host a Wordpress instance (or any DB-powered CMS for that matter). You want to just be able to add a few Vue.js blog components and some routes and have it all just work, right? What you're looking for is a blog that's powered entirely by API's you can consume directly from your Vue.js application. This tutorial will teach you how to do just that, let's dive in!\n\nWe're going to quickly build a CMS-powered blog with Vue.js. It uses [ButterCMS](https://buttercms.com/), an API-first CMS that lets you manage content using the ButterCMS dashboard and integrate our content API into your Vue.js app. You can use ButterCMS for new or existing Vue.js projects.\n\n![Butter Dashboard](https://user-images.githubusercontent.com/160873/36677285-648798e4-1ad3-11e8-9454-d22fca8280b7.png \"Butter Dashboard\")\n\n## Install\n\nRun this in your commandline:\n\n```bash\nnpm install buttercms --save\n```\n\nButter can also be loaded using a CDN:\n\n```html\n<script src=\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"></script>\n```\n\n## Quickstart\n\nSet your API token:\n\n```javascript\nvar butter = require('buttercms')('your_api_token');\n```\n\nUsing ES6:\n\n```javascript\nimport Butter from 'buttercms';\nconst butter = Butter('your_api_token');\n```\n\nUsing CDN:\n\n```html\n<script src=\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"></script>\n<script>\n  var butter = Butter('your_api_token');\n</script>\n```\n\nImport this file into any component you want to use ButterCMS. Then from the console run:\n\n```javascript\nbutter.post.list({page: 1, page_size: 10}).then(function(response) {\n  console.log(response)\n})\n```\n\nThis API request fetches your blog posts. Your account comes with one example post which you'll see in the response.\n\n## Display posts\n\nTo display posts we create a `/blog` route (using Vue Router) in our app and fetch blog posts from the Butter API, as well as a `/blog/:slug` route to handle individual posts.\n\nSee the ButterCMS [API reference](https://buttercms.com/docs/api/?javascript#blog-posts) for additional options such as filtering by category or author. The response also includes some metadata we'll use for pagination.\n\n`router/index.js:`\n\n```javascript\nimport Vue from 'vue'\nimport Router from 'vue-router'\nimport BlogHome from '@/components/BlogHome'\nimport BlogPost from '@/components/BlogPost'\n\nVue.use(Router)\n\nexport default new Router({\n  mode: 'history',\n  routes: [\n    {\n      path: '/blog/',\n      name: 'blog-home',\n      component: BlogHome\n    },\n    {\n      path: '/blog/:slug',\n      name: 'blog-post',\n      component: BlogPost\n    }\n  ]\n})\n```\n\nThen create `components/BlogHome.vue` which will be your blog homepage that lists your most recent posts.\n\n```html\n<script>\n  import { butter } from '@/buttercms'\n  export default {\n    name: 'blog-home',\n    data() {\n      return {\n        page_title: 'Blog',\n        posts: []\n      }\n    },\n    methods: {\n      getPosts() {\n        butter.post.list({\n          page: 1,\n          page_size: 10\n        }).then(res => {\n          this.posts = res.data.data\n        })\n      }\n    },\n    created() {\n      this.getPosts()\n    }\n  }\n</script>\n\n<template>\n  <div id=\"blog-home\">\n      <h1>{{ page_title }}</h1>\n      <!-- Create `v-for` and apply a `key` for Vue. Here we are using a combination of the slug and index. -->\n      <div\n        v-for=\"(post,index) in posts\"\n        :key=\"post.slug + '_' + index\"\n      >\n        <router-link :to=\"'/blog/' + post.slug\">\n          <article class=\"media\">\n            <figure>\n              <!-- Bind results using a `:` -->\n              <!-- Use a `v-if`/`else` if there is a `featured_image` -->\n              <img\n                v-if=\"post.featured_image\"\n                :src=\"post.featured_image\"\n                alt=\"\"\n              >\n              <img\n                v-else\n                src=\"http://via.placeholder.com/250x250\"\n                alt=\"\"\n              >\n            </figure>\n            <h2>{{ post.title }}</h2>\n            <p>{{ post.summary }}</p>\n          </article>\n        </router-link>\n      </div>\n  </div>\n</template>\n```\n\nHere's what it looks like (note we added CSS from https://bulma.io/ for quick styling):\n\n![buttercms-bloglist](https://user-images.githubusercontent.com/160873/36868500-1b22e374-1d5e-11e8-82a0-20c8dc312716.png)\n\nNow create `components/BlogPost.vue` which will be your Blog Post page to list a single post.\n\n```html\n<script>\n  import { butter } from '@/buttercms'\n  export default {\n    name: 'blog-post',\n    data() {\n      return {\n        post: {}\n      }\n    },\n    methods: {\n      getPost() {\n        butter.post.retrieve(this.$route.params.slug)\n          .then(res => {\n            this.post = res.data\n          }).catch(res => {\n            console.log(res)\n          })\n      }\n    },\n    created() {\n      this.getPost()\n    }\n  }\n</script>\n\n<template>\n  <div id=\"blog-post\">\n    <h1>{{ post.data.title }}</h1>\n    <h4>{{ post.data.author.first_name }} {{ post.data.author.last_name }}</h4>\n    <div v-html=\"post.data.body\"></div>\n\n    <router-link\n      v-if=\"post.meta.previous_post\"\n      :to=\"/blog/ + post.meta.previous_post.slug\"\n      class=\"button\"\n    >\n      {{ post.meta.previous_post.title }}\n    </router-link>\n    <router-link\n      v-if=\"post.meta.next_post\"\n      :to=\"/blog/ + post.meta.next_post.slug\"\n      class=\"button\"\n    >\n      {{ post.meta.next_post.title }}\n    </router-link>\n  </div>\n</template>\n```\n\nHere's a preview:\n\n![buttercms-blogdetail](https://user-images.githubusercontent.com/160873/36868506-218c86b6-1d5e-11e8-8691-0409d91366d6.png)\n\nNow our app is pulling all blog posts and we can navigate to individual posts. However, our next/previous post buttons are not working.\n\nOne thing to note when using routes with params is that when the user navigates from `/blog/foo` to `/blog/bar`, the same component instance will be reused. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one.\n\n<p class=\"tip\">Be aware, that using the component this way will mean that the lifecycle hooks of the component will not be called. Visit the Vue Router's docs to learn more about [Dynamic Route Matching](https://router.vuejs.org/en/essentials/dynamic-matching.html)</p>\n\nTo fix this we need to watch the `$route` object and call `getPost()` when the route changes.\n\nUpdated `<script>` section in `components/BlogPost.vue`:\n\n```html\n<script>\n  import { butter } from '@/buttercms'\n  export default {\n    name: 'blog-post',\n    data() {\n      return {\n        post: null\n      }\n    },\n    methods: {\n      getPost() {\n        butter.post.retrieve(this.$route.params.slug)\n          .then(res => {\n            this.post = res.data\n          }).catch(res => {\n            console.log(res)\n          })\n      }\n    },\n    watch: {\n      $route: {\n        immediate: true,\n        handler(to, from) {\n          this.getPost()\n        }\n      }\n    }\n  }\n</script>\n```\n\nNow your app has a working blog that can be updated easily in the ButterCMS dashboard.\n\n## Categories, Tags, and Authors\n\nUse Butter's APIs for categories, tags, and authors to feature and filter content on your blog.\n\nSee the ButterCMS API reference for more information about these objects:\n\n* [Categories](https://buttercms.com/docs/api/?ruby#categories)\n* [Tags](https://buttercms.com/docs/api/?ruby#tags)\n* [Authors](https://buttercms.com/docs/api/?ruby#authors)\n\nHere's an example of listing all categories and getting posts by category. Call these methods on the `created()` lifecycle hook:\n\n```javascript\nmethods: {\n  // ...\n  getCategories() {\n    butter.category.list()\n      .then(res => {\n        console.log('List of Categories:')\n        console.log(res.data.data)\n      })\n  },\n  getPostsByCategory() {\n    butter.category.retrieve('example-category', {\n        include: 'recent_posts'\n      })\n      .then(res => {\n        console.log('Posts with specific category:')\n        console.log(res)\n      })\n  }\n},\ncreated() {\n  // ...\n  this.getCategories()\n  this.getPostsByCategory()\n}\n```\n\n## Alternative Patterns\n\nAn alternative pattern to consider, especially if you prefer writing only in Markdown, is using something like [Nuxtent](https://nuxtent-module.netlify.com/guide/writing/#async-components). Nuxtent allows you to use `Vue Component` inside of Markdown files. This approach would be akin to a static site approach (i.e. Jekyll) where you compose your blog posts in Markdown files. Nuxtent adds a nice integration between Vue.js and Markdown allowing you to live in a 100% Vue.js world.\n\n## Wrap up\n\nThat's it! You now have a fully functional CMS-powered blog running in your app. We hope this tutorial was helpful and made your development experience with Vue.js even more enjoyable :)\n","date":"2020-09-25T23:55:41.108Z","updated":"2020-09-25T23:55:41.108Z","path":"v2/cookbook/serverless-blog.html","comments":1,"layout":"page","_id":"ckfl66gy5000rc2v56kxn1c6p","content":"<p>So you’ve just launched your Vue.js website, congrats! Now you want to add a blog that quickly plugs into your website and you don’t want to have to spin up a whole server just to host a Wordpress instance (or any DB-powered CMS for that matter). You want to just be able to add a few Vue.js blog components and some routes and have it all just work, right? What you’re looking for is a blog that’s powered entirely by API’s you can consume directly from your Vue.js application. This tutorial will teach you how to do just that, let’s dive in!</p>\n<p>We’re going to quickly build a CMS-powered blog with Vue.js. It uses <a href=\"https://buttercms.com/\" target=\"_blank\" rel=\"noopener\">ButterCMS</a>, an API-first CMS that lets you manage content using the ButterCMS dashboard and integrate our content API into your Vue.js app. You can use ButterCMS for new or existing Vue.js projects.</p>\n<p><img src=\"https://user-images.githubusercontent.com/160873/36677285-648798e4-1ad3-11e8-9454-d22fca8280b7.png\" alt=\"Butter Dashboard\" title=\"Butter Dashboard\"></p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p>Run this in your commandline:</p>\n<pre><code class=\"hljs bash\">npm install buttercms --save</code></pre>\n<p>Butter can also be loaded using a CDN:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<h2 id=\"Quickstart\"><a href=\"#Quickstart\" class=\"headerlink\" title=\"Quickstart\"></a>Quickstart</h2><p>Set your API token:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> butter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'buttercms'</span>)(<span class=\"hljs-string\">'your_api_token'</span>);</code></pre>\n<p>Using ES6:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> Butter <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'buttercms'</span>;\n<span class=\"hljs-keyword\">const</span> butter = Butter(<span class=\"hljs-string\">'your_api_token'</span>);</code></pre>\n<p>Using CDN:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">var</span> butter = Butter(<span class=\"hljs-string\">'your_api_token'</span>);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>Import this file into any component you want to use ButterCMS. Then from the console run:</p>\n<pre><code class=\"hljs javascript\">butter.post.list(&#123;<span class=\"hljs-attr\">page</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">page_size</span>: <span class=\"hljs-number\">10</span>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">response</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(response)\n&#125;)</code></pre>\n<p>This API request fetches your blog posts. Your account comes with one example post which you’ll see in the response.</p>\n<h2 id=\"Display-posts\"><a href=\"#Display-posts\" class=\"headerlink\" title=\"Display posts\"></a>Display posts</h2><p>To display posts we create a <code>/blog</code> route (using Vue Router) in our app and fetch blog posts from the Butter API, as well as a <code>/blog/:slug</code> route to handle individual posts.</p>\n<p>See the ButterCMS <a href=\"https://buttercms.com/docs/api/?javascript#blog-posts\" target=\"_blank\" rel=\"noopener\">API reference</a> for additional options such as filtering by category or author. The response also includes some metadata we’ll use for pagination.</p>\n<p><code>router/index.js:</code></p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> Router <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue-router'</span>\n<span class=\"hljs-keyword\">import</span> BlogHome <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/components/BlogHome'</span>\n<span class=\"hljs-keyword\">import</span> BlogPost <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/components/BlogPost'</span>\n\nVue.use(Router)\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">new</span> Router(&#123;\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'history'</span>,\n  <span class=\"hljs-attr\">routes</span>: [\n    &#123;\n      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/blog/'</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-home'</span>,\n      <span class=\"hljs-attr\">component</span>: BlogHome\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/blog/:slug'</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-post'</span>,\n      <span class=\"hljs-attr\">component</span>: BlogPost\n    &#125;\n  ]\n&#125;)</code></pre>\n<p>Then create <code>components/BlogHome.vue</code> which will be your blog homepage that lists your most recent posts.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> &#123; butter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/buttercms'</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-home'</span>,\n    data() &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        <span class=\"hljs-attr\">page_title</span>: <span class=\"hljs-string\">'Blog'</span>,\n        <span class=\"hljs-attr\">posts</span>: []\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">methods</span>: &#123;\n      getPosts() &#123;\n        butter.post.list(&#123;\n          <span class=\"hljs-attr\">page</span>: <span class=\"hljs-number\">1</span>,\n          <span class=\"hljs-attr\">page_size</span>: <span class=\"hljs-number\">10</span>\n        &#125;).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n          <span class=\"hljs-keyword\">this</span>.posts = res.data.data\n        &#125;)\n      &#125;\n    &#125;,\n    created() &#123;\n      <span class=\"hljs-keyword\">this</span>.getPosts()\n    &#125;\n  &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"blog-home\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123; page_title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-comment\">&lt;!-- Create `v-for` and apply a `key` for Vue. Here we are using a combination of the slug and index. --&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(post,index) in posts\"</span>\n        <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"post.slug + '_' + index\"</span>\n      &gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"'/blog/' + post.slug\"</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">article</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"media\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">figure</span>&gt;</span>\n              <span class=\"hljs-comment\">&lt;!-- Bind results using a `:` --&gt;</span>\n              <span class=\"hljs-comment\">&lt;!-- Use a `v-if`/`else` if there is a `featured_image` --&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n                <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"post.featured_image\"</span>\n                <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"post.featured_image\"</span>\n                <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>\n              &gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n                <span class=\"hljs-attr\">v-else</span>\n                <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"http://via.placeholder.com/250x250\"</span>\n                <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>\n              &gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">figure</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; post.summary &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">article</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Here’s what it looks like (note we added CSS from <a href=\"https://bulma.io/\" target=\"_blank\" rel=\"noopener\">https://bulma.io/</a> for quick styling):</p>\n<p><img src=\"https://user-images.githubusercontent.com/160873/36868500-1b22e374-1d5e-11e8-82a0-20c8dc312716.png\" alt=\"buttercms-bloglist\"></p>\n<p>Now create <code>components/BlogPost.vue</code> which will be your Blog Post page to list a single post.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> &#123; butter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/buttercms'</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-post'</span>,\n    data() &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        <span class=\"hljs-attr\">post</span>: &#123;&#125;\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">methods</span>: &#123;\n      getPost() &#123;\n        butter.post.retrieve(<span class=\"hljs-keyword\">this</span>.$route.params.slug)\n          .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-keyword\">this</span>.post = res.data\n          &#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-built_in\">console</span>.log(res)\n          &#125;)\n      &#125;\n    &#125;,\n    created() &#123;\n      <span class=\"hljs-keyword\">this</span>.getPost()\n    &#125;\n  &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"blog-post\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123; post.data.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>&#123;&#123; post.data.author.first_name &#125;&#125; &#123;&#123; post.data.author.last_name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"post.data.body\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"post.meta.previous_post\"</span>\n      <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"/blog/ + post.meta.previous_post.slug\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button\"</span>\n    &gt;</span>\n      &#123;&#123; post.meta.previous_post.title &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"post.meta.next_post\"</span>\n      <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"/blog/ + post.meta.next_post.slug\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button\"</span>\n    &gt;</span>\n      &#123;&#123; post.meta.next_post.title &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Here’s a preview:</p>\n<p><img src=\"https://user-images.githubusercontent.com/160873/36868506-218c86b6-1d5e-11e8-8691-0409d91366d6.png\" alt=\"buttercms-blogdetail\"></p>\n<p>Now our app is pulling all blog posts and we can navigate to individual posts. However, our next/previous post buttons are not working.</p>\n<p>One thing to note when using routes with params is that when the user navigates from <code>/blog/foo</code> to <code>/blog/bar</code>, the same component instance will be reused. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one.</p>\n<p class=\"tip\">Be aware, that using the component this way will mean that the lifecycle hooks of the component will not be called. Visit the Vue Router’s docs to learn more about <a href=\"https://router.vuejs.org/en/essentials/dynamic-matching.html\" target=\"_blank\" rel=\"noopener\">Dynamic Route Matching</a></p>\n\n<p>To fix this we need to watch the <code>$route</code> object and call <code>getPost()</code> when the route changes.</p>\n<p>Updated <code>&lt;script&gt;</code> section in <code>components/BlogPost.vue</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> &#123; butter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/buttercms'</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-post'</span>,\n    data() &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        <span class=\"hljs-attr\">post</span>: <span class=\"hljs-literal\">null</span>\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">methods</span>: &#123;\n      getPost() &#123;\n        butter.post.retrieve(<span class=\"hljs-keyword\">this</span>.$route.params.slug)\n          .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-keyword\">this</span>.post = res.data\n          &#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-built_in\">console</span>.log(res)\n          &#125;)\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">watch</span>: &#123;\n      <span class=\"hljs-attr\">$route</span>: &#123;\n        <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>,\n        handler(to, <span class=\"hljs-keyword\">from</span>) &#123;\n          <span class=\"hljs-keyword\">this</span>.getPost()\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>Now your app has a working blog that can be updated easily in the ButterCMS dashboard.</p>\n<h2 id=\"Categories-Tags-and-Authors\"><a href=\"#Categories-Tags-and-Authors\" class=\"headerlink\" title=\"Categories, Tags, and Authors\"></a>Categories, Tags, and Authors</h2><p>Use Butter’s APIs for categories, tags, and authors to feature and filter content on your blog.</p>\n<p>See the ButterCMS API reference for more information about these objects:</p>\n<ul>\n<li><a href=\"https://buttercms.com/docs/api/?ruby#categories\" target=\"_blank\" rel=\"noopener\">Categories</a></li>\n<li><a href=\"https://buttercms.com/docs/api/?ruby#tags\" target=\"_blank\" rel=\"noopener\">Tags</a></li>\n<li><a href=\"https://buttercms.com/docs/api/?ruby#authors\" target=\"_blank\" rel=\"noopener\">Authors</a></li>\n</ul>\n<p>Here’s an example of listing all categories and getting posts by category. Call these methods on the <code>created()</code> lifecycle hook:</p>\n<pre><code class=\"hljs javascript\">methods: &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  getCategories() &#123;\n    butter.category.list()\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'List of Categories:'</span>)\n        <span class=\"hljs-built_in\">console</span>.log(res.data.data)\n      &#125;)\n  &#125;,\n  getPostsByCategory() &#123;\n    butter.category.retrieve(<span class=\"hljs-string\">'example-category'</span>, &#123;\n        <span class=\"hljs-attr\">include</span>: <span class=\"hljs-string\">'recent_posts'</span>\n      &#125;)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Posts with specific category:'</span>)\n        <span class=\"hljs-built_in\">console</span>.log(res)\n      &#125;)\n  &#125;\n&#125;,\ncreated() &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">this</span>.getCategories()\n  <span class=\"hljs-keyword\">this</span>.getPostsByCategory()\n&#125;</code></pre>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>An alternative pattern to consider, especially if you prefer writing only in Markdown, is using something like <a href=\"https://nuxtent-module.netlify.com/guide/writing/#async-components\" target=\"_blank\" rel=\"noopener\">Nuxtent</a>. Nuxtent allows you to use <code>Vue Component</code> inside of Markdown files. This approach would be akin to a static site approach (i.e. Jekyll) where you compose your blog posts in Markdown files. Nuxtent adds a nice integration between Vue.js and Markdown allowing you to live in a 100% Vue.js world.</p>\n<h2 id=\"Wrap-up\"><a href=\"#Wrap-up\" class=\"headerlink\" title=\"Wrap up\"></a>Wrap up</h2><p>That’s it! You now have a fully functional CMS-powered blog running in your app. We hope this tutorial was helpful and made your development experience with Vue.js even more enjoyable :)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>So you’ve just launched your Vue.js website, congrats! Now you want to add a blog that quickly plugs into your website and you don’t want to have to spin up a whole server just to host a Wordpress instance (or any DB-powered CMS for that matter). You want to just be able to add a few Vue.js blog components and some routes and have it all just work, right? What you’re looking for is a blog that’s powered entirely by API’s you can consume directly from your Vue.js application. This tutorial will teach you how to do just that, let’s dive in!</p>\n<p>We’re going to quickly build a CMS-powered blog with Vue.js. It uses <a href=\"https://buttercms.com/\" target=\"_blank\" rel=\"noopener\">ButterCMS</a>, an API-first CMS that lets you manage content using the ButterCMS dashboard and integrate our content API into your Vue.js app. You can use ButterCMS for new or existing Vue.js projects.</p>\n<p><img src=\"https://user-images.githubusercontent.com/160873/36677285-648798e4-1ad3-11e8-9454-d22fca8280b7.png\" alt=\"Butter Dashboard\" title=\"Butter Dashboard\"></p>\n<h2 id=\"Install\"><a href=\"#Install\" class=\"headerlink\" title=\"Install\"></a>Install</h2><p>Run this in your commandline:</p>\n<pre><code class=\"hljs bash\">npm install buttercms --save</code></pre>\n<p>Butter can also be loaded using a CDN:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<h2 id=\"Quickstart\"><a href=\"#Quickstart\" class=\"headerlink\" title=\"Quickstart\"></a>Quickstart</h2><p>Set your API token:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> butter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'buttercms'</span>)(<span class=\"hljs-string\">'your_api_token'</span>);</code></pre>\n<p>Using ES6:</p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> Butter <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'buttercms'</span>;\n<span class=\"hljs-keyword\">const</span> butter = Butter(<span class=\"hljs-string\">'your_api_token'</span>);</code></pre>\n<p>Using CDN:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdnjs.buttercms.com/buttercms-1.1.0.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">var</span> butter = Butter(<span class=\"hljs-string\">'your_api_token'</span>);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>Import this file into any component you want to use ButterCMS. Then from the console run:</p>\n<pre><code class=\"hljs javascript\">butter.post.list(&#123;<span class=\"hljs-attr\">page</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">page_size</span>: <span class=\"hljs-number\">10</span>&#125;).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">response</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(response)\n&#125;)</code></pre>\n<p>This API request fetches your blog posts. Your account comes with one example post which you’ll see in the response.</p>\n<h2 id=\"Display-posts\"><a href=\"#Display-posts\" class=\"headerlink\" title=\"Display posts\"></a>Display posts</h2><p>To display posts we create a <code>/blog</code> route (using Vue Router) in our app and fetch blog posts from the Butter API, as well as a <code>/blog/:slug</code> route to handle individual posts.</p>\n<p>See the ButterCMS <a href=\"https://buttercms.com/docs/api/?javascript#blog-posts\" target=\"_blank\" rel=\"noopener\">API reference</a> for additional options such as filtering by category or author. The response also includes some metadata we’ll use for pagination.</p>\n<p><code>router/index.js:</code></p>\n<pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> Router <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue-router'</span>\n<span class=\"hljs-keyword\">import</span> BlogHome <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/components/BlogHome'</span>\n<span class=\"hljs-keyword\">import</span> BlogPost <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/components/BlogPost'</span>\n\nVue.use(Router)\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">new</span> Router(&#123;\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'history'</span>,\n  <span class=\"hljs-attr\">routes</span>: [\n    &#123;\n      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/blog/'</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-home'</span>,\n      <span class=\"hljs-attr\">component</span>: BlogHome\n    &#125;,\n    &#123;\n      <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">'/blog/:slug'</span>,\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-post'</span>,\n      <span class=\"hljs-attr\">component</span>: BlogPost\n    &#125;\n  ]\n&#125;)</code></pre>\n<p>Then create <code>components/BlogHome.vue</code> which will be your blog homepage that lists your most recent posts.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> &#123; butter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/buttercms'</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-home'</span>,\n    data() &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        <span class=\"hljs-attr\">page_title</span>: <span class=\"hljs-string\">'Blog'</span>,\n        <span class=\"hljs-attr\">posts</span>: []\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">methods</span>: &#123;\n      getPosts() &#123;\n        butter.post.list(&#123;\n          <span class=\"hljs-attr\">page</span>: <span class=\"hljs-number\">1</span>,\n          <span class=\"hljs-attr\">page_size</span>: <span class=\"hljs-number\">10</span>\n        &#125;).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n          <span class=\"hljs-keyword\">this</span>.posts = res.data.data\n        &#125;)\n      &#125;\n    &#125;,\n    created() &#123;\n      <span class=\"hljs-keyword\">this</span>.getPosts()\n    &#125;\n  &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"blog-home\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123; page_title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n      <span class=\"hljs-comment\">&lt;!-- Create `v-for` and apply a `key` for Vue. Here we are using a combination of the slug and index. --&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n        <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(post,index) in posts\"</span>\n        <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"post.slug + '_' + index\"</span>\n      &gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span> <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"'/blog/' + post.slug\"</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">article</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"media\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">figure</span>&gt;</span>\n              <span class=\"hljs-comment\">&lt;!-- Bind results using a `:` --&gt;</span>\n              <span class=\"hljs-comment\">&lt;!-- Use a `v-if`/`else` if there is a `featured_image` --&gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n                <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"post.featured_image\"</span>\n                <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"post.featured_image\"</span>\n                <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>\n              &gt;</span>\n              <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n                <span class=\"hljs-attr\">v-else</span>\n                <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"http://via.placeholder.com/250x250\"</span>\n                <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"\"</span>\n              &gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">figure</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span>&gt;</span>&#123;&#123; post.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; post.summary &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">article</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Here’s what it looks like (note we added CSS from <a href=\"https://bulma.io/\" target=\"_blank\" rel=\"noopener\">https://bulma.io/</a> for quick styling):</p>\n<p><img src=\"https://user-images.githubusercontent.com/160873/36868500-1b22e374-1d5e-11e8-82a0-20c8dc312716.png\" alt=\"buttercms-bloglist\"></p>\n<p>Now create <code>components/BlogPost.vue</code> which will be your Blog Post page to list a single post.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> &#123; butter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/buttercms'</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-post'</span>,\n    data() &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        <span class=\"hljs-attr\">post</span>: &#123;&#125;\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">methods</span>: &#123;\n      getPost() &#123;\n        butter.post.retrieve(<span class=\"hljs-keyword\">this</span>.$route.params.slug)\n          .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-keyword\">this</span>.post = res.data\n          &#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-built_in\">console</span>.log(res)\n          &#125;)\n      &#125;\n    &#125;,\n    created() &#123;\n      <span class=\"hljs-keyword\">this</span>.getPost()\n    &#125;\n  &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"blog-post\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123; post.data.title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span>&gt;</span>&#123;&#123; post.data.author.first_name &#125;&#125; &#123;&#123; post.data.author.last_name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"post.data.body\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"post.meta.previous_post\"</span>\n      <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"/blog/ + post.meta.previous_post.slug\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button\"</span>\n    &gt;</span>\n      &#123;&#123; post.meta.previous_post.title &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-link</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"post.meta.next_post\"</span>\n      <span class=\"hljs-attr\">:to</span>=<span class=\"hljs-string\">\"/blog/ + post.meta.next_post.slug\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button\"</span>\n    &gt;</span>\n      &#123;&#123; post.meta.next_post.title &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-link</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Here’s a preview:</p>\n<p><img src=\"https://user-images.githubusercontent.com/160873/36868506-218c86b6-1d5e-11e8-8691-0409d91366d6.png\" alt=\"buttercms-blogdetail\"></p>\n<p>Now our app is pulling all blog posts and we can navigate to individual posts. However, our next/previous post buttons are not working.</p>\n<p>One thing to note when using routes with params is that when the user navigates from <code>/blog/foo</code> to <code>/blog/bar</code>, the same component instance will be reused. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one.</p>\n<p class=\"tip\">Be aware, that using the component this way will mean that the lifecycle hooks of the component will not be called. Visit the Vue Router’s docs to learn more about <a href=\"https://router.vuejs.org/en/essentials/dynamic-matching.html\" target=\"_blank\" rel=\"noopener\">Dynamic Route Matching</a></p>\n\n<p>To fix this we need to watch the <code>$route</code> object and call <code>getPost()</code> when the route changes.</p>\n<p>Updated <code>&lt;script&gt;</code> section in <code>components/BlogPost.vue</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> &#123; butter &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@/buttercms'</span>\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'blog-post'</span>,\n    data() &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        <span class=\"hljs-attr\">post</span>: <span class=\"hljs-literal\">null</span>\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">methods</span>: &#123;\n      getPost() &#123;\n        butter.post.retrieve(<span class=\"hljs-keyword\">this</span>.$route.params.slug)\n          .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-keyword\">this</span>.post = res.data\n          &#125;).catch(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n            <span class=\"hljs-built_in\">console</span>.log(res)\n          &#125;)\n      &#125;\n    &#125;,\n    <span class=\"hljs-attr\">watch</span>: &#123;\n      <span class=\"hljs-attr\">$route</span>: &#123;\n        <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>,\n        handler(to, <span class=\"hljs-keyword\">from</span>) &#123;\n          <span class=\"hljs-keyword\">this</span>.getPost()\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>Now your app has a working blog that can be updated easily in the ButterCMS dashboard.</p>\n<h2 id=\"Categories-Tags-and-Authors\"><a href=\"#Categories-Tags-and-Authors\" class=\"headerlink\" title=\"Categories, Tags, and Authors\"></a>Categories, Tags, and Authors</h2><p>Use Butter’s APIs for categories, tags, and authors to feature and filter content on your blog.</p>\n<p>See the ButterCMS API reference for more information about these objects:</p>\n<ul>\n<li><a href=\"https://buttercms.com/docs/api/?ruby#categories\" target=\"_blank\" rel=\"noopener\">Categories</a></li>\n<li><a href=\"https://buttercms.com/docs/api/?ruby#tags\" target=\"_blank\" rel=\"noopener\">Tags</a></li>\n<li><a href=\"https://buttercms.com/docs/api/?ruby#authors\" target=\"_blank\" rel=\"noopener\">Authors</a></li>\n</ul>\n<p>Here’s an example of listing all categories and getting posts by category. Call these methods on the <code>created()</code> lifecycle hook:</p>\n<pre><code class=\"hljs javascript\">methods: &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  getCategories() &#123;\n    butter.category.list()\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'List of Categories:'</span>)\n        <span class=\"hljs-built_in\">console</span>.log(res.data.data)\n      &#125;)\n  &#125;,\n  getPostsByCategory() &#123;\n    butter.category.retrieve(<span class=\"hljs-string\">'example-category'</span>, &#123;\n        <span class=\"hljs-attr\">include</span>: <span class=\"hljs-string\">'recent_posts'</span>\n      &#125;)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'Posts with specific category:'</span>)\n        <span class=\"hljs-built_in\">console</span>.log(res)\n      &#125;)\n  &#125;\n&#125;,\ncreated() &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-keyword\">this</span>.getCategories()\n  <span class=\"hljs-keyword\">this</span>.getPostsByCategory()\n&#125;</code></pre>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>An alternative pattern to consider, especially if you prefer writing only in Markdown, is using something like <a href=\"https://nuxtent-module.netlify.com/guide/writing/#async-components\" target=\"_blank\" rel=\"noopener\">Nuxtent</a>. Nuxtent allows you to use <code>Vue Component</code> inside of Markdown files. This approach would be akin to a static site approach (i.e. Jekyll) where you compose your blog posts in Markdown files. Nuxtent adds a nice integration between Vue.js and Markdown allowing you to live in a 100% Vue.js world.</p>\n<h2 id=\"Wrap-up\"><a href=\"#Wrap-up\" class=\"headerlink\" title=\"Wrap up\"></a>Wrap up</h2><p>That’s it! You now have a fully functional CMS-powered blog running in your app. We hope this tutorial was helpful and made your development experience with Vue.js even more enjoyable :)</p>\n"},{"title":"Packaging Vue Components for npm","type":"cookbook","order":12,"_content":"\n## Base Example\n\nVue components by nature are meant to be re-used. This is easy when the component is only used within a single application. But how can you write a component once and use it in multiple sites/applications? Perhaps the easiest solution is via npm.\n\nBy packaging your component to be shared via npm, it can be imported/required into a build process for use in full-fledged web applications:\n\n```js\nimport MyComponent from 'my-component';\n\nexport default {\n  components: {\n    MyComponent,\n  },\n  // rest of the component\n}\n```\n\nOr even used via `<script>` tag in the browser directly:\n\n```html\n  <script src=\"https://unpkg.com/vue\"></script>\n  <script src=\"https://unpkg.com/my-component\"></script>\n  ...\n  <my-component></my-component>\n  ...\n```\n\nNot only does this help you avoid copy/pasting components around, but it also allows you to give back to the Vue community!\n\n## Can't I Just Share `.vue` Files Directly?\n\nVue already allows components to be written as a single file. Because a Single File Component (SFC) is already just one file, you might ask:\n\n> \"Why can't people use my `.vue` file directly? Isn't that the simplest way to share components?\"\n\nIt's true, you can share `.vue` files directly, and anyone using a [Vue build](https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds) containing the Vue compiler can consume it immediately. Also, the SSR build uses string concatenation as an optimization, so the `.vue` file might be preferred in this scenario (see [Packaging Components for npm > SSR Usage](#SSR-Usage) for details). However, this excludes anyone who wishes to use the component directly in a browser via `<script>` tag, anyone who uses a runtime-only build, or build processes which don't understand what to do with `.vue` files.\n\nProperly packaging your SFC for distribution via npm enables your component to be shared in a way which is ready to use everywhere!\n\n## Packaging Components for npm\n\nFor the purposes of this section, assume the following file structure:\n\n```\npackage.json\nbuild/\n   rollup.config.js\nsrc/\n   wrapper.js\n   my-component.vue\ndist/\n```\n\n<p class=\"tip\">Throughout this document, references are made to the package.json file listed above. The file used in these examples was generated by hand, and will include the minimum configuration required for the discussion/task at hand. It is likely your own package.json file will contain a lot more than is listed here.</p>\n\n### How does npm know which version to serve to a browser/build process?\n\nThe package.json file used by npm really only requires one version (`main`), but as it turns out, we aren't limited to that. We can address the most common use cases by specifying 2 additional versions (`module` and `unpkg`), and provide access to the `.vue` file itself using the `browser` field. A sample package.json would look like this:\n\n```json\n{\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": {\n    \"./sfc\": \"src/my-component.vue\"\n  },\n  ...\n}\n```\n\nWhen webpack 2+, Rollup, or other modern build tools are used, they will pick up on the `module` build. Legacy applications would use the `main` build, and the `unpkg` build can be used directly in browsers. In fact, the [unpkg](https://unpkg.com) cdn automatically uses this when someone enters the URL for your module into their service!\n\n### SSR Usage\n\nYou might have noticed something interesting - browsers aren't going to be using the `browser` version. That's because this field is actually intended to allow authors to provide [hints to bundlers](https://github.com/defunctzombie/package-browser-field-spec#spec) which in turn create their own packages for client side use. With a little creativity, this field allows us to map an alias to the `.vue` file itself. For example:\n\n```js\nimport MyComponent from 'my-component/sfc'; // Note the '/sfc'\n```\n\nCompatible bundlers see the `browser` definition in package.json and translate requests for `my-component/sfc` into `my-component/src/my-component.vue`, resulting in the original `.vue` file being used instead. Now the SSR process can use the string concatenation optimizations it needs to for a boost in performance.\n\n<p class=\"tip\">Note: When using `.vue` components directly, pay attention to any type of pre-processing required by `script` and `style` tags. These dependencies will be passed on to users. Consider providing 'plain' SFCs to keep things as light as possible.</p>\n\n### How do I make multiple versions of my component?\n\nThere is no need to write your module multiple times. It is possible to prepare all 3 versions of your module in one step, in a matter of seconds. The example here uses [Rollup](https://rollupjs.org) due to its minimal configuration, but similar configuration is possible with other build tools - more details on this decision can be found [here](https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c). The package.json `scripts` section can be updated with a single entry for each build target, and a more generic `build` script that runs them all in one pass. The sample package.json file now looks like this:\n\n```json\n{\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": {\n    \"./sfc\": \"src/my-component.vue\"\n  },\n  \"scripts\": {\n    \"build\": \"npm run build:umd & npm run build:es & npm run build:unpkg\",\n    \"build:umd\": \"rollup --config build/rollup.config.js --format umd --file dist/my-component.umd.js\",\n    \"build:es\": \"rollup --config build/rollup.config.js --format es --file dist/my-component.esm.js\",\n    \"build:unpkg\": \"rollup --config build/rollup.config.js --format iife --file dist/my-component.min.js\"\n  },\n  \"devDependencies\": {\n    \"rollup\": \"^1.17.0\",\n    \"@rollup/plugin-buble\": \"^0.21.3\",\n    \"@rollup/plugin-commonjs\": \"^11.1.0\",\n    \"rollup-plugin-vue\": \"^5.0.1\",\n    \"vue\": \"^2.6.10\",\n    \"vue-template-compiler\": \"^2.6.10\"\n    ...\n  },\n  ...\n}\n```\n\n<p class=\"tip\">Remember, if you have an existing package.json file, it will likely contain a lot more than this one does. This merely illustrates a starting point. Also, the <i>packages</i> listed in devDependencies (not their versions) are the minimum requirements for rollup to create the three separate builds (umd, es, and unpkg) mentioned. As newer versions become available, they should be updated as necessary.</p>\n\nOur changes to package.json are complete. Next, we need a small wrapper to export/auto-install the actual SFC, plus a minimal Rollup configuration, and we're set!\n\n### What does my packaged component look like?\n\nDepending on how your component is being used, it needs to be exposed as either a [CommonJS/UMD](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#c33a) javascript module, an [ES6 javascript](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#4f5e) module, or in the case of a `<script>` tag, it will be automatically loaded into Vue via `Vue.use(...)` so it's immediately available to the page. This is accomplished by a simple wrapper.js file which handles the module export and auto-install. That wrapper, in its entirety, looks like this:\n\n```js\n// Import vue component\nimport component from './my-component.vue';\n\n// Declare install function executed by Vue.use()\nexport function install(Vue) {\n\tif (install.installed) return;\n\tinstall.installed = true;\n\tVue.component('MyComponent', component);\n}\n\n// Create module definition for Vue.use()\nconst plugin = {\n\tinstall,\n};\n\n// Auto-install when vue is found (eg. in browser via <script> tag)\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n\tGlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n\tGlobalVue = global.Vue;\n}\nif (GlobalVue) {\n\tGlobalVue.use(plugin);\n}\n\n// To allow use as module (npm/webpack/etc.) export component\nexport default component;\n```\n\nNotice the first line directly imports your SFC, and the last line exports it unchanged. As indicated by the comments in the rest of the code, the wrapper provides an `install` function for Vue, then attempts to detect Vue and automatically install the component. With 90% of the work done, it's time to sprint to the finish!\n\n### How do I configure the Rollup build?\n\nWith the package.json `scripts` section ready and the SFC wrapper in place, all that is left is to ensure Rollup is properly configured. Fortunately, this can be done with a small 16 line rollup.config.js file:\n\n```js\nimport commonjs from '@rollup/plugin-commonjs'; // Convert CommonJS modules to ES6\nimport vue from 'rollup-plugin-vue'; // Handle .vue SFC files\nimport buble from '@rollup/plugin-buble'; // Transpile/polyfill with reasonable browser support\nexport default {\n    input: 'src/wrapper.js', // Path relative to package.json\n    output: {\n        name: 'MyComponent',\n        exports: 'named',\n    },\n    plugins: [\n        commonjs(),\n        vue({\n            css: true, // Dynamically inject css as a <style> tag\n            compileTemplate: true, // Explicitly convert template to render function\n        }),\n        buble(), // Transpile to ES5\n    ],\n};\n```\n\nThis sample config file contains the minimum settings to package your SFC for npm. There is room for customization, such as extracting CSS to a separate file, using a CSS preprocessor, uglifying the JS output, etc.\n\nAlso, it is worth noting the `name` given the component here. This is a PascalCase name that the component will be given, and should correspond with the kebab-case name used elsewhere throughout this recipe.\n\n### Will this replace my current development process?\n\nThe configuration here is not meant to replace the development process that you currently use. If you currently have a webpack setup with hot module reloading (HMR), keep using it! If you're starting from scratch, feel free to install [Vue CLI 3](https://github.com/vuejs/vue-cli/), which will give you the whole HMR experience config free:\n\n```bash\nvue serve --open src/my-component.vue\n```\n\nIn other words, do all of your development in whatever way you are comfortable. The things outlined in this recipe are more like 'finishing touches' than a full dev process.\n\n## When to Avoid this Pattern\n\nPackaging SFCs in this manner might not be a good idea in certain scenarios. This recipe doesn't go into detail on how the components themselves are written. Some components might provide side effects like directives, or extend other libraries with additional functionality. In those cases, you will need to evaluate whether or not the changes required to this recipe are too extensive.\n\nIn addition, pay attention to any dependencies that your SFC might have. For example, if you require a third party library for sorting or communication with an API, Rollup might roll those packages into the final code if not properly configured. To continue using this recipe, you would need to configure Rollup to exclude those files from the output, then update your documentation to inform your users about these dependencies.\n\n## Alternative Patterns\n\nAt the time this recipe was written, Vue CLI 3 was itself in beta. This version of the CLI comes with a built-in `library` build mode, which creates CommonJS and UMD versions of a component. This might be adequate for your use cases, though you will still need to make sure your package.json file points to `main` and `unpkg` properly. Also, there will be no ES6 `module` output unless that capability is added to the CLI before its release or via plugin.\n\n## Acknowledgements\n\nThis recipe is the result of a lightning talk given by [Mike Dodge](https://twitter.com/webdevdodge) at VueConf.us in March 2018. He has published a utility to npm which will quickly scaffold a sample SFC using this recipe. You can download the utility, [vue-sfc-rollup](https://www.npmjs.com/package/vue-sfc-rollup), from npm. You can also [clone the repo](https://github.com/team-innovation/vue-sfc-rollup) and customize it.\n","source":"v2/cookbook/packaging-sfc-for-npm.md","raw":"---\ntitle: Packaging Vue Components for npm\ntype: cookbook\norder: 12\n---\n\n## Base Example\n\nVue components by nature are meant to be re-used. This is easy when the component is only used within a single application. But how can you write a component once and use it in multiple sites/applications? Perhaps the easiest solution is via npm.\n\nBy packaging your component to be shared via npm, it can be imported/required into a build process for use in full-fledged web applications:\n\n```js\nimport MyComponent from 'my-component';\n\nexport default {\n  components: {\n    MyComponent,\n  },\n  // rest of the component\n}\n```\n\nOr even used via `<script>` tag in the browser directly:\n\n```html\n  <script src=\"https://unpkg.com/vue\"></script>\n  <script src=\"https://unpkg.com/my-component\"></script>\n  ...\n  <my-component></my-component>\n  ...\n```\n\nNot only does this help you avoid copy/pasting components around, but it also allows you to give back to the Vue community!\n\n## Can't I Just Share `.vue` Files Directly?\n\nVue already allows components to be written as a single file. Because a Single File Component (SFC) is already just one file, you might ask:\n\n> \"Why can't people use my `.vue` file directly? Isn't that the simplest way to share components?\"\n\nIt's true, you can share `.vue` files directly, and anyone using a [Vue build](https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds) containing the Vue compiler can consume it immediately. Also, the SSR build uses string concatenation as an optimization, so the `.vue` file might be preferred in this scenario (see [Packaging Components for npm > SSR Usage](#SSR-Usage) for details). However, this excludes anyone who wishes to use the component directly in a browser via `<script>` tag, anyone who uses a runtime-only build, or build processes which don't understand what to do with `.vue` files.\n\nProperly packaging your SFC for distribution via npm enables your component to be shared in a way which is ready to use everywhere!\n\n## Packaging Components for npm\n\nFor the purposes of this section, assume the following file structure:\n\n```\npackage.json\nbuild/\n   rollup.config.js\nsrc/\n   wrapper.js\n   my-component.vue\ndist/\n```\n\n<p class=\"tip\">Throughout this document, references are made to the package.json file listed above. The file used in these examples was generated by hand, and will include the minimum configuration required for the discussion/task at hand. It is likely your own package.json file will contain a lot more than is listed here.</p>\n\n### How does npm know which version to serve to a browser/build process?\n\nThe package.json file used by npm really only requires one version (`main`), but as it turns out, we aren't limited to that. We can address the most common use cases by specifying 2 additional versions (`module` and `unpkg`), and provide access to the `.vue` file itself using the `browser` field. A sample package.json would look like this:\n\n```json\n{\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": {\n    \"./sfc\": \"src/my-component.vue\"\n  },\n  ...\n}\n```\n\nWhen webpack 2+, Rollup, or other modern build tools are used, they will pick up on the `module` build. Legacy applications would use the `main` build, and the `unpkg` build can be used directly in browsers. In fact, the [unpkg](https://unpkg.com) cdn automatically uses this when someone enters the URL for your module into their service!\n\n### SSR Usage\n\nYou might have noticed something interesting - browsers aren't going to be using the `browser` version. That's because this field is actually intended to allow authors to provide [hints to bundlers](https://github.com/defunctzombie/package-browser-field-spec#spec) which in turn create their own packages for client side use. With a little creativity, this field allows us to map an alias to the `.vue` file itself. For example:\n\n```js\nimport MyComponent from 'my-component/sfc'; // Note the '/sfc'\n```\n\nCompatible bundlers see the `browser` definition in package.json and translate requests for `my-component/sfc` into `my-component/src/my-component.vue`, resulting in the original `.vue` file being used instead. Now the SSR process can use the string concatenation optimizations it needs to for a boost in performance.\n\n<p class=\"tip\">Note: When using `.vue` components directly, pay attention to any type of pre-processing required by `script` and `style` tags. These dependencies will be passed on to users. Consider providing 'plain' SFCs to keep things as light as possible.</p>\n\n### How do I make multiple versions of my component?\n\nThere is no need to write your module multiple times. It is possible to prepare all 3 versions of your module in one step, in a matter of seconds. The example here uses [Rollup](https://rollupjs.org) due to its minimal configuration, but similar configuration is possible with other build tools - more details on this decision can be found [here](https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c). The package.json `scripts` section can be updated with a single entry for each build target, and a more generic `build` script that runs them all in one pass. The sample package.json file now looks like this:\n\n```json\n{\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": {\n    \"./sfc\": \"src/my-component.vue\"\n  },\n  \"scripts\": {\n    \"build\": \"npm run build:umd & npm run build:es & npm run build:unpkg\",\n    \"build:umd\": \"rollup --config build/rollup.config.js --format umd --file dist/my-component.umd.js\",\n    \"build:es\": \"rollup --config build/rollup.config.js --format es --file dist/my-component.esm.js\",\n    \"build:unpkg\": \"rollup --config build/rollup.config.js --format iife --file dist/my-component.min.js\"\n  },\n  \"devDependencies\": {\n    \"rollup\": \"^1.17.0\",\n    \"@rollup/plugin-buble\": \"^0.21.3\",\n    \"@rollup/plugin-commonjs\": \"^11.1.0\",\n    \"rollup-plugin-vue\": \"^5.0.1\",\n    \"vue\": \"^2.6.10\",\n    \"vue-template-compiler\": \"^2.6.10\"\n    ...\n  },\n  ...\n}\n```\n\n<p class=\"tip\">Remember, if you have an existing package.json file, it will likely contain a lot more than this one does. This merely illustrates a starting point. Also, the <i>packages</i> listed in devDependencies (not their versions) are the minimum requirements for rollup to create the three separate builds (umd, es, and unpkg) mentioned. As newer versions become available, they should be updated as necessary.</p>\n\nOur changes to package.json are complete. Next, we need a small wrapper to export/auto-install the actual SFC, plus a minimal Rollup configuration, and we're set!\n\n### What does my packaged component look like?\n\nDepending on how your component is being used, it needs to be exposed as either a [CommonJS/UMD](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#c33a) javascript module, an [ES6 javascript](https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#4f5e) module, or in the case of a `<script>` tag, it will be automatically loaded into Vue via `Vue.use(...)` so it's immediately available to the page. This is accomplished by a simple wrapper.js file which handles the module export and auto-install. That wrapper, in its entirety, looks like this:\n\n```js\n// Import vue component\nimport component from './my-component.vue';\n\n// Declare install function executed by Vue.use()\nexport function install(Vue) {\n\tif (install.installed) return;\n\tinstall.installed = true;\n\tVue.component('MyComponent', component);\n}\n\n// Create module definition for Vue.use()\nconst plugin = {\n\tinstall,\n};\n\n// Auto-install when vue is found (eg. in browser via <script> tag)\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n\tGlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n\tGlobalVue = global.Vue;\n}\nif (GlobalVue) {\n\tGlobalVue.use(plugin);\n}\n\n// To allow use as module (npm/webpack/etc.) export component\nexport default component;\n```\n\nNotice the first line directly imports your SFC, and the last line exports it unchanged. As indicated by the comments in the rest of the code, the wrapper provides an `install` function for Vue, then attempts to detect Vue and automatically install the component. With 90% of the work done, it's time to sprint to the finish!\n\n### How do I configure the Rollup build?\n\nWith the package.json `scripts` section ready and the SFC wrapper in place, all that is left is to ensure Rollup is properly configured. Fortunately, this can be done with a small 16 line rollup.config.js file:\n\n```js\nimport commonjs from '@rollup/plugin-commonjs'; // Convert CommonJS modules to ES6\nimport vue from 'rollup-plugin-vue'; // Handle .vue SFC files\nimport buble from '@rollup/plugin-buble'; // Transpile/polyfill with reasonable browser support\nexport default {\n    input: 'src/wrapper.js', // Path relative to package.json\n    output: {\n        name: 'MyComponent',\n        exports: 'named',\n    },\n    plugins: [\n        commonjs(),\n        vue({\n            css: true, // Dynamically inject css as a <style> tag\n            compileTemplate: true, // Explicitly convert template to render function\n        }),\n        buble(), // Transpile to ES5\n    ],\n};\n```\n\nThis sample config file contains the minimum settings to package your SFC for npm. There is room for customization, such as extracting CSS to a separate file, using a CSS preprocessor, uglifying the JS output, etc.\n\nAlso, it is worth noting the `name` given the component here. This is a PascalCase name that the component will be given, and should correspond with the kebab-case name used elsewhere throughout this recipe.\n\n### Will this replace my current development process?\n\nThe configuration here is not meant to replace the development process that you currently use. If you currently have a webpack setup with hot module reloading (HMR), keep using it! If you're starting from scratch, feel free to install [Vue CLI 3](https://github.com/vuejs/vue-cli/), which will give you the whole HMR experience config free:\n\n```bash\nvue serve --open src/my-component.vue\n```\n\nIn other words, do all of your development in whatever way you are comfortable. The things outlined in this recipe are more like 'finishing touches' than a full dev process.\n\n## When to Avoid this Pattern\n\nPackaging SFCs in this manner might not be a good idea in certain scenarios. This recipe doesn't go into detail on how the components themselves are written. Some components might provide side effects like directives, or extend other libraries with additional functionality. In those cases, you will need to evaluate whether or not the changes required to this recipe are too extensive.\n\nIn addition, pay attention to any dependencies that your SFC might have. For example, if you require a third party library for sorting or communication with an API, Rollup might roll those packages into the final code if not properly configured. To continue using this recipe, you would need to configure Rollup to exclude those files from the output, then update your documentation to inform your users about these dependencies.\n\n## Alternative Patterns\n\nAt the time this recipe was written, Vue CLI 3 was itself in beta. This version of the CLI comes with a built-in `library` build mode, which creates CommonJS and UMD versions of a component. This might be adequate for your use cases, though you will still need to make sure your package.json file points to `main` and `unpkg` properly. Also, there will be no ES6 `module` output unless that capability is added to the CLI before its release or via plugin.\n\n## Acknowledgements\n\nThis recipe is the result of a lightning talk given by [Mike Dodge](https://twitter.com/webdevdodge) at VueConf.us in March 2018. He has published a utility to npm which will quickly scaffold a sample SFC using this recipe. You can download the utility, [vue-sfc-rollup](https://www.npmjs.com/package/vue-sfc-rollup), from npm. You can also [clone the repo](https://github.com/team-innovation/vue-sfc-rollup) and customize it.\n","date":"2020-09-25T23:55:41.107Z","updated":"2020-09-25T23:55:41.107Z","path":"v2/cookbook/packaging-sfc-for-npm.html","comments":1,"layout":"page","_id":"ckfl66gy6000sc2v5ykbl6yi3","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Vue components by nature are meant to be re-used. This is easy when the component is only used within a single application. But how can you write a component once and use it in multiple sites/applications? Perhaps the easiest solution is via npm.</p>\n<p>By packaging your component to be shared via npm, it can be imported/required into a build process for use in full-fledged web applications:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'my-component'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    MyComponent,\n  &#125;,\n  <span class=\"hljs-comment\">// rest of the component</span>\n&#125;</code></pre>\n<p>Or even used via <code>&lt;script&gt;</code> tag in the browser directly:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://unpkg.com/vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://unpkg.com/my-component\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n...\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n...</code></pre>\n<p>Not only does this help you avoid copy/pasting components around, but it also allows you to give back to the Vue community!</p>\n<h2 id=\"Can’t-I-Just-Share-vue-Files-Directly\"><a href=\"#Can’t-I-Just-Share-vue-Files-Directly\" class=\"headerlink\" title=\"Can’t I Just Share .vue Files Directly?\"></a>Can’t I Just Share <code>.vue</code> Files Directly?</h2><p>Vue already allows components to be written as a single file. Because a Single File Component (SFC) is already just one file, you might ask:</p>\n<blockquote>\n<p>“Why can’t people use my <code>.vue</code> file directly? Isn’t that the simplest way to share components?”</p>\n</blockquote>\n<p>It’s true, you can share <code>.vue</code> files directly, and anyone using a <a href=\"https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds\">Vue build</a> containing the Vue compiler can consume it immediately. Also, the SSR build uses string concatenation as an optimization, so the <code>.vue</code> file might be preferred in this scenario (see <a href=\"#SSR-Usage\">Packaging Components for npm &gt; SSR Usage</a> for details). However, this excludes anyone who wishes to use the component directly in a browser via <code>&lt;script&gt;</code> tag, anyone who uses a runtime-only build, or build processes which don’t understand what to do with <code>.vue</code> files.</p>\n<p>Properly packaging your SFC for distribution via npm enables your component to be shared in a way which is ready to use everywhere!</p>\n<h2 id=\"Packaging-Components-for-npm\"><a href=\"#Packaging-Components-for-npm\" class=\"headerlink\" title=\"Packaging Components for npm\"></a>Packaging Components for npm</h2><p>For the purposes of this section, assume the following file structure:</p>\n<pre><code class=\"hljs undefined\">package.json\nbuild/\n   rollup.config.js\nsrc/\n   wrapper.js\n   my-component.vue\ndist/</code></pre>\n<p class=\"tip\">Throughout this document, references are made to the package.json file listed above. The file used in these examples was generated by hand, and will include the minimum configuration required for the discussion/task at hand. It is likely your own package.json file will contain a lot more than is listed here.</p>\n\n<h3 id=\"How-does-npm-know-which-version-to-serve-to-a-browser-build-process\"><a href=\"#How-does-npm-know-which-version-to-serve-to-a-browser-build-process\" class=\"headerlink\" title=\"How does npm know which version to serve to a browser/build process?\"></a>How does npm know which version to serve to a browser/build process?</h3><p>The package.json file used by npm really only requires one version (<code>main</code>), but as it turns out, we aren’t limited to that. We can address the most common use cases by specifying 2 additional versions (<code>module</code> and <code>unpkg</code>), and provide access to the <code>.vue</code> file itself using the <code>browser</code> field. A sample package.json would look like this:</p>\n<pre><code class=\"hljs json\">&#123;\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": &#123;\n    \"./sfc\": \"src/my-component.vue\"\n  &#125;,\n  ...\n&#125;</code></pre>\n<p>When webpack 2+, Rollup, or other modern build tools are used, they will pick up on the <code>module</code> build. Legacy applications would use the <code>main</code> build, and the <code>unpkg</code> build can be used directly in browsers. In fact, the <a href=\"https://unpkg.com\" target=\"_blank\" rel=\"noopener\">unpkg</a> cdn automatically uses this when someone enters the URL for your module into their service!</p>\n<h3 id=\"SSR-Usage\"><a href=\"#SSR-Usage\" class=\"headerlink\" title=\"SSR Usage\"></a>SSR Usage</h3><p>You might have noticed something interesting - browsers aren’t going to be using the <code>browser</code> version. That’s because this field is actually intended to allow authors to provide <a href=\"https://github.com/defunctzombie/package-browser-field-spec#spec\" target=\"_blank\" rel=\"noopener\">hints to bundlers</a> which in turn create their own packages for client side use. With a little creativity, this field allows us to map an alias to the <code>.vue</code> file itself. For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'my-component/sfc'</span>; <span class=\"hljs-comment\">// Note the '/sfc'</span></code></pre>\n<p>Compatible bundlers see the <code>browser</code> definition in package.json and translate requests for <code>my-component/sfc</code> into <code>my-component/src/my-component.vue</code>, resulting in the original <code>.vue</code> file being used instead. Now the SSR process can use the string concatenation optimizations it needs to for a boost in performance.</p>\n<p class=\"tip\">Note: When using <code>.vue</code> components directly, pay attention to any type of pre-processing required by <code>script</code> and <code>style</code> tags. These dependencies will be passed on to users. Consider providing ‘plain’ SFCs to keep things as light as possible.</p>\n\n<h3 id=\"How-do-I-make-multiple-versions-of-my-component\"><a href=\"#How-do-I-make-multiple-versions-of-my-component\" class=\"headerlink\" title=\"How do I make multiple versions of my component?\"></a>How do I make multiple versions of my component?</h3><p>There is no need to write your module multiple times. It is possible to prepare all 3 versions of your module in one step, in a matter of seconds. The example here uses <a href=\"https://rollupjs.org\" target=\"_blank\" rel=\"noopener\">Rollup</a> due to its minimal configuration, but similar configuration is possible with other build tools - more details on this decision can be found <a href=\"https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c\" target=\"_blank\" rel=\"noopener\">here</a>. The package.json <code>scripts</code> section can be updated with a single entry for each build target, and a more generic <code>build</code> script that runs them all in one pass. The sample package.json file now looks like this:</p>\n<pre><code class=\"hljs json\">&#123;\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": &#123;\n    \"./sfc\": \"src/my-component.vue\"\n  &#125;,\n  \"scripts\": &#123;\n    \"build\": \"npm run build:umd &amp; npm run build:es &amp; npm run build:unpkg\",\n    \"build:umd\": \"rollup --config build/rollup.config.js --format umd --file dist/my-component.umd.js\",\n    \"build:es\": \"rollup --config build/rollup.config.js --format es --file dist/my-component.esm.js\",\n    \"build:unpkg\": \"rollup --config build/rollup.config.js --format iife --file dist/my-component.min.js\"\n  &#125;,\n  \"devDependencies\": &#123;\n    \"rollup\": \"^1.17.0\",\n    \"@rollup/plugin-buble\": \"^0.21.3\",\n    \"@rollup/plugin-commonjs\": \"^11.1.0\",\n    \"rollup-plugin-vue\": \"^5.0.1\",\n    \"vue\": \"^2.6.10\",\n    \"vue-template-compiler\": \"^2.6.10\"\n    ...\n  &#125;,\n  ...\n&#125;</code></pre>\n<p class=\"tip\">Remember, if you have an existing package.json file, it will likely contain a lot more than this one does. This merely illustrates a starting point. Also, the <i>packages</i> listed in devDependencies (not their versions) are the minimum requirements for rollup to create the three separate builds (umd, es, and unpkg) mentioned. As newer versions become available, they should be updated as necessary.</p>\n\n<p>Our changes to package.json are complete. Next, we need a small wrapper to export/auto-install the actual SFC, plus a minimal Rollup configuration, and we’re set!</p>\n<h3 id=\"What-does-my-packaged-component-look-like\"><a href=\"#What-does-my-packaged-component-look-like\" class=\"headerlink\" title=\"What does my packaged component look like?\"></a>What does my packaged component look like?</h3><p>Depending on how your component is being used, it needs to be exposed as either a <a href=\"https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#c33a\" target=\"_blank\" rel=\"noopener\">CommonJS/UMD</a> javascript module, an <a href=\"https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#4f5e\" target=\"_blank\" rel=\"noopener\">ES6 javascript</a> module, or in the case of a <code>&lt;script&gt;</code> tag, it will be automatically loaded into Vue via <code>Vue.use(...)</code> so it’s immediately available to the page. This is accomplished by a simple wrapper.js file which handles the module export and auto-install. That wrapper, in its entirety, looks like this:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Import vue component</span>\n<span class=\"hljs-keyword\">import</span> component <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-component.vue'</span>;\n\n<span class=\"hljs-comment\">// Declare install function executed by Vue.use()</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">install</span>(<span class=\"hljs-params\">Vue</span>) </span>&#123;\n\t<span class=\"hljs-keyword\">if</span> (install.installed) <span class=\"hljs-keyword\">return</span>;\n\tinstall.installed = <span class=\"hljs-literal\">true</span>;\n\tVue.component(<span class=\"hljs-string\">'MyComponent'</span>, component);\n&#125;\n\n<span class=\"hljs-comment\">// Create module definition for Vue.use()</span>\n<span class=\"hljs-keyword\">const</span> plugin = &#123;\n\tinstall,\n&#125;;\n\n<span class=\"hljs-comment\">// Auto-install when vue is found (eg. in browser via &lt;script&gt; tag)</span>\n<span class=\"hljs-keyword\">let</span> GlobalVue = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">'undefined'</span>) &#123;\n\tGlobalVue = <span class=\"hljs-built_in\">window</span>.Vue;\n&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> global !== <span class=\"hljs-string\">'undefined'</span>) &#123;\n\tGlobalVue = global.Vue;\n&#125;\n<span class=\"hljs-keyword\">if</span> (GlobalVue) &#123;\n\tGlobalVue.use(plugin);\n&#125;\n\n<span class=\"hljs-comment\">// To allow use as module (npm/webpack/etc.) export component</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> component;</code></pre>\n<p>Notice the first line directly imports your SFC, and the last line exports it unchanged. As indicated by the comments in the rest of the code, the wrapper provides an <code>install</code> function for Vue, then attempts to detect Vue and automatically install the component. With 90% of the work done, it’s time to sprint to the finish!</p>\n<h3 id=\"How-do-I-configure-the-Rollup-build\"><a href=\"#How-do-I-configure-the-Rollup-build\" class=\"headerlink\" title=\"How do I configure the Rollup build?\"></a>How do I configure the Rollup build?</h3><p>With the package.json <code>scripts</code> section ready and the SFC wrapper in place, all that is left is to ensure Rollup is properly configured. Fortunately, this can be done with a small 16 line rollup.config.js file:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> commonjs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@rollup/plugin-commonjs'</span>; <span class=\"hljs-comment\">// Convert CommonJS modules to ES6</span>\n<span class=\"hljs-keyword\">import</span> vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-vue'</span>; <span class=\"hljs-comment\">// Handle .vue SFC files</span>\n<span class=\"hljs-keyword\">import</span> buble <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@rollup/plugin-buble'</span>; <span class=\"hljs-comment\">// Transpile/polyfill with reasonable browser support</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/wrapper.js'</span>, <span class=\"hljs-comment\">// Path relative to package.json</span>\n    <span class=\"hljs-attr\">output</span>: &#123;\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'MyComponent'</span>,\n        <span class=\"hljs-attr\">exports</span>: <span class=\"hljs-string\">'named'</span>,\n    &#125;,\n    <span class=\"hljs-attr\">plugins</span>: [\n        commonjs(),\n        vue(&#123;\n            <span class=\"hljs-attr\">css</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// Dynamically inject css as a &lt;style&gt; tag</span>\n            <span class=\"hljs-attr\">compileTemplate</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// Explicitly convert template to render function</span>\n        &#125;),\n        buble(), <span class=\"hljs-comment\">// Transpile to ES5</span>\n    ],\n&#125;;</code></pre>\n<p>This sample config file contains the minimum settings to package your SFC for npm. There is room for customization, such as extracting CSS to a separate file, using a CSS preprocessor, uglifying the JS output, etc.</p>\n<p>Also, it is worth noting the <code>name</code> given the component here. This is a PascalCase name that the component will be given, and should correspond with the kebab-case name used elsewhere throughout this recipe.</p>\n<h3 id=\"Will-this-replace-my-current-development-process\"><a href=\"#Will-this-replace-my-current-development-process\" class=\"headerlink\" title=\"Will this replace my current development process?\"></a>Will this replace my current development process?</h3><p>The configuration here is not meant to replace the development process that you currently use. If you currently have a webpack setup with hot module reloading (HMR), keep using it! If you’re starting from scratch, feel free to install <a href=\"https://github.com/vuejs/vue-cli/\" target=\"_blank\" rel=\"noopener\">Vue CLI 3</a>, which will give you the whole HMR experience config free:</p>\n<pre><code class=\"hljs bash\">vue serve --open src/my-component.vue</code></pre>\n<p>In other words, do all of your development in whatever way you are comfortable. The things outlined in this recipe are more like ‘finishing touches’ than a full dev process.</p>\n<h2 id=\"When-to-Avoid-this-Pattern\"><a href=\"#When-to-Avoid-this-Pattern\" class=\"headerlink\" title=\"When to Avoid this Pattern\"></a>When to Avoid this Pattern</h2><p>Packaging SFCs in this manner might not be a good idea in certain scenarios. This recipe doesn’t go into detail on how the components themselves are written. Some components might provide side effects like directives, or extend other libraries with additional functionality. In those cases, you will need to evaluate whether or not the changes required to this recipe are too extensive.</p>\n<p>In addition, pay attention to any dependencies that your SFC might have. For example, if you require a third party library for sorting or communication with an API, Rollup might roll those packages into the final code if not properly configured. To continue using this recipe, you would need to configure Rollup to exclude those files from the output, then update your documentation to inform your users about these dependencies.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>At the time this recipe was written, Vue CLI 3 was itself in beta. This version of the CLI comes with a built-in <code>library</code> build mode, which creates CommonJS and UMD versions of a component. This might be adequate for your use cases, though you will still need to make sure your package.json file points to <code>main</code> and <code>unpkg</code> properly. Also, there will be no ES6 <code>module</code> output unless that capability is added to the CLI before its release or via plugin.</p>\n<h2 id=\"Acknowledgements\"><a href=\"#Acknowledgements\" class=\"headerlink\" title=\"Acknowledgements\"></a>Acknowledgements</h2><p>This recipe is the result of a lightning talk given by <a href=\"https://twitter.com/webdevdodge\" target=\"_blank\" rel=\"noopener\">Mike Dodge</a> at VueConf.us in March 2018. He has published a utility to npm which will quickly scaffold a sample SFC using this recipe. You can download the utility, <a href=\"https://www.npmjs.com/package/vue-sfc-rollup\" target=\"_blank\" rel=\"noopener\">vue-sfc-rollup</a>, from npm. You can also <a href=\"https://github.com/team-innovation/vue-sfc-rollup\" target=\"_blank\" rel=\"noopener\">clone the repo</a> and customize it.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Vue components by nature are meant to be re-used. This is easy when the component is only used within a single application. But how can you write a component once and use it in multiple sites/applications? Perhaps the easiest solution is via npm.</p>\n<p>By packaging your component to be shared via npm, it can be imported/required into a build process for use in full-fledged web applications:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'my-component'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    MyComponent,\n  &#125;,\n  <span class=\"hljs-comment\">// rest of the component</span>\n&#125;</code></pre>\n<p>Or even used via <code>&lt;script&gt;</code> tag in the browser directly:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://unpkg.com/vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://unpkg.com/my-component\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n...\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n...</code></pre>\n<p>Not only does this help you avoid copy/pasting components around, but it also allows you to give back to the Vue community!</p>\n<h2 id=\"Can’t-I-Just-Share-vue-Files-Directly\"><a href=\"#Can’t-I-Just-Share-vue-Files-Directly\" class=\"headerlink\" title=\"Can’t I Just Share .vue Files Directly?\"></a>Can’t I Just Share <code>.vue</code> Files Directly?</h2><p>Vue already allows components to be written as a single file. Because a Single File Component (SFC) is already just one file, you might ask:</p>\n<blockquote>\n<p>“Why can’t people use my <code>.vue</code> file directly? Isn’t that the simplest way to share components?”</p>\n</blockquote>\n<p>It’s true, you can share <code>.vue</code> files directly, and anyone using a <a href=\"https://vuejs.org/v2/guide/installation.html#Explanation-of-Different-Builds\">Vue build</a> containing the Vue compiler can consume it immediately. Also, the SSR build uses string concatenation as an optimization, so the <code>.vue</code> file might be preferred in this scenario (see <a href=\"#SSR-Usage\">Packaging Components for npm &gt; SSR Usage</a> for details). However, this excludes anyone who wishes to use the component directly in a browser via <code>&lt;script&gt;</code> tag, anyone who uses a runtime-only build, or build processes which don’t understand what to do with <code>.vue</code> files.</p>\n<p>Properly packaging your SFC for distribution via npm enables your component to be shared in a way which is ready to use everywhere!</p>\n<h2 id=\"Packaging-Components-for-npm\"><a href=\"#Packaging-Components-for-npm\" class=\"headerlink\" title=\"Packaging Components for npm\"></a>Packaging Components for npm</h2><p>For the purposes of this section, assume the following file structure:</p>\n<pre><code class=\"hljs undefined\">package.json\nbuild/\n   rollup.config.js\nsrc/\n   wrapper.js\n   my-component.vue\ndist/</code></pre>\n<p class=\"tip\">Throughout this document, references are made to the package.json file listed above. The file used in these examples was generated by hand, and will include the minimum configuration required for the discussion/task at hand. It is likely your own package.json file will contain a lot more than is listed here.</p>\n\n<h3 id=\"How-does-npm-know-which-version-to-serve-to-a-browser-build-process\"><a href=\"#How-does-npm-know-which-version-to-serve-to-a-browser-build-process\" class=\"headerlink\" title=\"How does npm know which version to serve to a browser/build process?\"></a>How does npm know which version to serve to a browser/build process?</h3><p>The package.json file used by npm really only requires one version (<code>main</code>), but as it turns out, we aren’t limited to that. We can address the most common use cases by specifying 2 additional versions (<code>module</code> and <code>unpkg</code>), and provide access to the <code>.vue</code> file itself using the <code>browser</code> field. A sample package.json would look like this:</p>\n<pre><code class=\"hljs json\">&#123;\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": &#123;\n    \"./sfc\": \"src/my-component.vue\"\n  &#125;,\n  ...\n&#125;</code></pre>\n<p>When webpack 2+, Rollup, or other modern build tools are used, they will pick up on the <code>module</code> build. Legacy applications would use the <code>main</code> build, and the <code>unpkg</code> build can be used directly in browsers. In fact, the <a href=\"https://unpkg.com\" target=\"_blank\" rel=\"noopener\">unpkg</a> cdn automatically uses this when someone enters the URL for your module into their service!</p>\n<h3 id=\"SSR-Usage\"><a href=\"#SSR-Usage\" class=\"headerlink\" title=\"SSR Usage\"></a>SSR Usage</h3><p>You might have noticed something interesting - browsers aren’t going to be using the <code>browser</code> version. That’s because this field is actually intended to allow authors to provide <a href=\"https://github.com/defunctzombie/package-browser-field-spec#spec\" target=\"_blank\" rel=\"noopener\">hints to bundlers</a> which in turn create their own packages for client side use. With a little creativity, this field allows us to map an alias to the <code>.vue</code> file itself. For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'my-component/sfc'</span>; <span class=\"hljs-comment\">// Note the '/sfc'</span></code></pre>\n<p>Compatible bundlers see the <code>browser</code> definition in package.json and translate requests for <code>my-component/sfc</code> into <code>my-component/src/my-component.vue</code>, resulting in the original <code>.vue</code> file being used instead. Now the SSR process can use the string concatenation optimizations it needs to for a boost in performance.</p>\n<p class=\"tip\">Note: When using <code>.vue</code> components directly, pay attention to any type of pre-processing required by <code>script</code> and <code>style</code> tags. These dependencies will be passed on to users. Consider providing ‘plain’ SFCs to keep things as light as possible.</p>\n\n<h3 id=\"How-do-I-make-multiple-versions-of-my-component\"><a href=\"#How-do-I-make-multiple-versions-of-my-component\" class=\"headerlink\" title=\"How do I make multiple versions of my component?\"></a>How do I make multiple versions of my component?</h3><p>There is no need to write your module multiple times. It is possible to prepare all 3 versions of your module in one step, in a matter of seconds. The example here uses <a href=\"https://rollupjs.org\" target=\"_blank\" rel=\"noopener\">Rollup</a> due to its minimal configuration, but similar configuration is possible with other build tools - more details on this decision can be found <a href=\"https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c\" target=\"_blank\" rel=\"noopener\">here</a>. The package.json <code>scripts</code> section can be updated with a single entry for each build target, and a more generic <code>build</code> script that runs them all in one pass. The sample package.json file now looks like this:</p>\n<pre><code class=\"hljs json\">&#123;\n  \"name\": \"my-component\",\n  \"version\": \"1.2.3\",\n  \"main\": \"dist/my-component.umd.js\",\n  \"module\": \"dist/my-component.esm.js\",\n  \"unpkg\": \"dist/my-component.min.js\",\n  \"browser\": &#123;\n    \"./sfc\": \"src/my-component.vue\"\n  &#125;,\n  \"scripts\": &#123;\n    \"build\": \"npm run build:umd &amp; npm run build:es &amp; npm run build:unpkg\",\n    \"build:umd\": \"rollup --config build/rollup.config.js --format umd --file dist/my-component.umd.js\",\n    \"build:es\": \"rollup --config build/rollup.config.js --format es --file dist/my-component.esm.js\",\n    \"build:unpkg\": \"rollup --config build/rollup.config.js --format iife --file dist/my-component.min.js\"\n  &#125;,\n  \"devDependencies\": &#123;\n    \"rollup\": \"^1.17.0\",\n    \"@rollup/plugin-buble\": \"^0.21.3\",\n    \"@rollup/plugin-commonjs\": \"^11.1.0\",\n    \"rollup-plugin-vue\": \"^5.0.1\",\n    \"vue\": \"^2.6.10\",\n    \"vue-template-compiler\": \"^2.6.10\"\n    ...\n  &#125;,\n  ...\n&#125;</code></pre>\n<p class=\"tip\">Remember, if you have an existing package.json file, it will likely contain a lot more than this one does. This merely illustrates a starting point. Also, the <i>packages</i> listed in devDependencies (not their versions) are the minimum requirements for rollup to create the three separate builds (umd, es, and unpkg) mentioned. As newer versions become available, they should be updated as necessary.</p>\n\n<p>Our changes to package.json are complete. Next, we need a small wrapper to export/auto-install the actual SFC, plus a minimal Rollup configuration, and we’re set!</p>\n<h3 id=\"What-does-my-packaged-component-look-like\"><a href=\"#What-does-my-packaged-component-look-like\" class=\"headerlink\" title=\"What does my packaged component look like?\"></a>What does my packaged component look like?</h3><p>Depending on how your component is being used, it needs to be exposed as either a <a href=\"https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#c33a\" target=\"_blank\" rel=\"noopener\">CommonJS/UMD</a> javascript module, an <a href=\"https://medium.freecodecamp.org/javascript-modules-a-beginner-s-guide-783f7d7a5fcc#4f5e\" target=\"_blank\" rel=\"noopener\">ES6 javascript</a> module, or in the case of a <code>&lt;script&gt;</code> tag, it will be automatically loaded into Vue via <code>Vue.use(...)</code> so it’s immediately available to the page. This is accomplished by a simple wrapper.js file which handles the module export and auto-install. That wrapper, in its entirety, looks like this:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Import vue component</span>\n<span class=\"hljs-keyword\">import</span> component <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./my-component.vue'</span>;\n\n<span class=\"hljs-comment\">// Declare install function executed by Vue.use()</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">install</span>(<span class=\"hljs-params\">Vue</span>) </span>&#123;\n\t<span class=\"hljs-keyword\">if</span> (install.installed) <span class=\"hljs-keyword\">return</span>;\n\tinstall.installed = <span class=\"hljs-literal\">true</span>;\n\tVue.component(<span class=\"hljs-string\">'MyComponent'</span>, component);\n&#125;\n\n<span class=\"hljs-comment\">// Create module definition for Vue.use()</span>\n<span class=\"hljs-keyword\">const</span> plugin = &#123;\n\tinstall,\n&#125;;\n\n<span class=\"hljs-comment\">// Auto-install when vue is found (eg. in browser via &lt;script&gt; tag)</span>\n<span class=\"hljs-keyword\">let</span> GlobalVue = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">window</span> !== <span class=\"hljs-string\">'undefined'</span>) &#123;\n\tGlobalVue = <span class=\"hljs-built_in\">window</span>.Vue;\n&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> global !== <span class=\"hljs-string\">'undefined'</span>) &#123;\n\tGlobalVue = global.Vue;\n&#125;\n<span class=\"hljs-keyword\">if</span> (GlobalVue) &#123;\n\tGlobalVue.use(plugin);\n&#125;\n\n<span class=\"hljs-comment\">// To allow use as module (npm/webpack/etc.) export component</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> component;</code></pre>\n<p>Notice the first line directly imports your SFC, and the last line exports it unchanged. As indicated by the comments in the rest of the code, the wrapper provides an <code>install</code> function for Vue, then attempts to detect Vue and automatically install the component. With 90% of the work done, it’s time to sprint to the finish!</p>\n<h3 id=\"How-do-I-configure-the-Rollup-build\"><a href=\"#How-do-I-configure-the-Rollup-build\" class=\"headerlink\" title=\"How do I configure the Rollup build?\"></a>How do I configure the Rollup build?</h3><p>With the package.json <code>scripts</code> section ready and the SFC wrapper in place, all that is left is to ensure Rollup is properly configured. Fortunately, this can be done with a small 16 line rollup.config.js file:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> commonjs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@rollup/plugin-commonjs'</span>; <span class=\"hljs-comment\">// Convert CommonJS modules to ES6</span>\n<span class=\"hljs-keyword\">import</span> vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rollup-plugin-vue'</span>; <span class=\"hljs-comment\">// Handle .vue SFC files</span>\n<span class=\"hljs-keyword\">import</span> buble <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@rollup/plugin-buble'</span>; <span class=\"hljs-comment\">// Transpile/polyfill with reasonable browser support</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n    <span class=\"hljs-attr\">input</span>: <span class=\"hljs-string\">'src/wrapper.js'</span>, <span class=\"hljs-comment\">// Path relative to package.json</span>\n    <span class=\"hljs-attr\">output</span>: &#123;\n        <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'MyComponent'</span>,\n        <span class=\"hljs-attr\">exports</span>: <span class=\"hljs-string\">'named'</span>,\n    &#125;,\n    <span class=\"hljs-attr\">plugins</span>: [\n        commonjs(),\n        vue(&#123;\n            <span class=\"hljs-attr\">css</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// Dynamically inject css as a &lt;style&gt; tag</span>\n            <span class=\"hljs-attr\">compileTemplate</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-comment\">// Explicitly convert template to render function</span>\n        &#125;),\n        buble(), <span class=\"hljs-comment\">// Transpile to ES5</span>\n    ],\n&#125;;</code></pre>\n<p>This sample config file contains the minimum settings to package your SFC for npm. There is room for customization, such as extracting CSS to a separate file, using a CSS preprocessor, uglifying the JS output, etc.</p>\n<p>Also, it is worth noting the <code>name</code> given the component here. This is a PascalCase name that the component will be given, and should correspond with the kebab-case name used elsewhere throughout this recipe.</p>\n<h3 id=\"Will-this-replace-my-current-development-process\"><a href=\"#Will-this-replace-my-current-development-process\" class=\"headerlink\" title=\"Will this replace my current development process?\"></a>Will this replace my current development process?</h3><p>The configuration here is not meant to replace the development process that you currently use. If you currently have a webpack setup with hot module reloading (HMR), keep using it! If you’re starting from scratch, feel free to install <a href=\"https://github.com/vuejs/vue-cli/\" target=\"_blank\" rel=\"noopener\">Vue CLI 3</a>, which will give you the whole HMR experience config free:</p>\n<pre><code class=\"hljs bash\">vue serve --open src/my-component.vue</code></pre>\n<p>In other words, do all of your development in whatever way you are comfortable. The things outlined in this recipe are more like ‘finishing touches’ than a full dev process.</p>\n<h2 id=\"When-to-Avoid-this-Pattern\"><a href=\"#When-to-Avoid-this-Pattern\" class=\"headerlink\" title=\"When to Avoid this Pattern\"></a>When to Avoid this Pattern</h2><p>Packaging SFCs in this manner might not be a good idea in certain scenarios. This recipe doesn’t go into detail on how the components themselves are written. Some components might provide side effects like directives, or extend other libraries with additional functionality. In those cases, you will need to evaluate whether or not the changes required to this recipe are too extensive.</p>\n<p>In addition, pay attention to any dependencies that your SFC might have. For example, if you require a third party library for sorting or communication with an API, Rollup might roll those packages into the final code if not properly configured. To continue using this recipe, you would need to configure Rollup to exclude those files from the output, then update your documentation to inform your users about these dependencies.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><p>At the time this recipe was written, Vue CLI 3 was itself in beta. This version of the CLI comes with a built-in <code>library</code> build mode, which creates CommonJS and UMD versions of a component. This might be adequate for your use cases, though you will still need to make sure your package.json file points to <code>main</code> and <code>unpkg</code> properly. Also, there will be no ES6 <code>module</code> output unless that capability is added to the CLI before its release or via plugin.</p>\n<h2 id=\"Acknowledgements\"><a href=\"#Acknowledgements\" class=\"headerlink\" title=\"Acknowledgements\"></a>Acknowledgements</h2><p>This recipe is the result of a lightning talk given by <a href=\"https://twitter.com/webdevdodge\" target=\"_blank\" rel=\"noopener\">Mike Dodge</a> at VueConf.us in March 2018. He has published a utility to npm which will quickly scaffold a sample SFC using this recipe. You can download the utility, <a href=\"https://www.npmjs.com/package/vue-sfc-rollup\" target=\"_blank\" rel=\"noopener\">vue-sfc-rollup</a>, from npm. You can also <a href=\"https://github.com/team-innovation/vue-sfc-rollup\" target=\"_blank\" rel=\"noopener\">clone the repo</a> and customize it.</p>\n"},{"title":"Unit Testing Vue Components","type":"cookbook","order":6,"_content":"\n## Base Example\n\nUnit testing is a fundamental part of software development. Unit tests execute the smallest units of code in isolation, in order to increase ease of adding new features and track down bugs. Vue's [single-file components](../guide/single-file-components.html) make it straight forward to write unit tests for components in isolation. This lets you develop new features with confidence you are not breaking existing ones, and helps other developers understand what your component does.\n\nThis simple example tests whether some text is rendered:\n\n```html\n<template>\n  <div>\n    <input v-model=\"username\">\n    <div\n      v-if=\"error\"\n      class=\"error\"\n    >\n      {{ error }}\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Hello',\n  data () {\n    return {\n      username: ''\n    }\n  },\n\n  computed: {\n    error () {\n      return this.username.trim().length < 7\n        ? 'Please enter a longer username'\n        : ''\n    }\n  }\n}\n</script>\n```\n\n```js\nimport { shallowMount } from '@vue/test-utils'\nimport Hello from './Hello.vue'\n\ntest('Hello', () => {\n  // render the component\n  const wrapper = shallowMount(Hello)\n\n  // should not allow for `username` less than 7 characters, excludes whitespace\n  wrapper.setData({ username: ' '.repeat(7) })\n\n  // assert the error is rendered\n  expect(wrapper.find('.error').exists()).toBe(true)\n\n  // update the name to be long enough\n  wrapper.setData({ username: 'Lachlan' })\n\n  // assert the error has gone away\n  expect(wrapper.find('.error').exists()).toBe(false)\n})\n```\n\nThe above code snippet shows how to test whether an error message is rendered based on the length of the username. It demonstrates the general idea of unit testing Vue components: render the component, and assert that the markup matches the state of the component.\n\n## Why test?\n\nComponent unit tests have lots of benefits:\n\n- Provide documentation on how the component should behave\n- Save time over testing manually\n- Reduce bugs in new features\n- Improve design\n- Facilitate refactoring\n\nAutomated testing allows large teams of developers to maintain complex codebases.\n\n#### Getting started\n\n[Vue Test Utils](https://github.com/vuejs/vue-test-utils) is the official library for unit testing Vue components. The [vue-cli](https://github.com/vuejs/vue-cli) `webpack` template comes with either Karma or Jest, both well supported test runners, and there are some [guides](https://vue-test-utils.vuejs.org/guides/) in the Vue Test Utils documentation.\n\n## Real-World Example\n\nUnit tests should be:\n\n- Fast to run\n- Easy to understand\n- Only test a _single unit of work_\n\nLet's continue building on the previous example, while introducing the idea of a <a href=\"https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)\">factory function</a> to make our test more compact and readable. The component should:\n\n- show a 'Welcome to the Vue.js cookbook' greeting.\n- prompt the user to enter their username\n- display an error if the entered username is less than seven letters\n\nLet's take a look at the component code first:\n\n```html\n<template>\n  <div>\n    <div class=\"message\">\n      {{ message }}\n    </div>\n    Enter your username: <input v-model=\"username\">\n    <div\n      v-if=\"error\"\n      class=\"error\"\n    >\n      Please enter a username with at least seven letters.\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Foo',\n\n  data () {\n    return {\n      message: 'Welcome to the Vue.js cookbook',\n      username: ''\n    }\n  },\n\n  computed: {\n    error () {\n      return this.username.trim().length < 7\n    }\n  }\n}\n</script>\n```\n\nThe things that we should test are:\n\n- is the `message` rendered?\n- if `error` is `true`, `<div class=\"error\">` should be present\n- if `error` is `false`, `<div class=\"error\">` should not be present\n\nAnd our first attempt at test:\n\n```js\nimport { shallowMount } from '@vue/test-utils'\nimport Foo from './Foo.vue'\n\ndescribe('Foo', () => {\n  it('renders a message and responds correctly to user input', () => {\n    const wrapper = shallowMount(Foo, {\n      data() {\n        return {\n          message: 'Hello World',\n          username: ''\n        }\n      }\n    })\n\n    // see if the message renders\n    expect(wrapper.find('.message').text()).toEqual('Hello World')\n\n    // assert the error is rendered\n    expect(wrapper.find('.error').exists()).toBeTruthy()\n\n    // update the `username` and assert error is no longer rendered\n    wrapper.setData({ username: 'Lachlan' })\n    expect(wrapper.find('.error').exists()).toBeFalsy()\n  })\n})\n```\n\nThere are some problems with the above:\n\n- a single test is making assertions about different things\n- difficult to tell the different states the component can be in, and what should be rendered\n\nThe below example improves the test by:\n\n- only making one assertion per `it` block\n- having short, clear test descriptions\n- providing only the minimum data required for the test\n- refactoring duplicated logic (creating the `wrapper` and setting the `username` variable) into a factory function\n\n*Updated test*:\n```js\nimport { shallowMount } from '@vue/test-utils'\nimport Foo from './Foo'\n\nconst factory = (values = {}) => {\n  return shallowMount(Foo, {\n    data () {\n      return {\n        ...values\n      }\n    }\n  })\n}\n\ndescribe('Foo', () => {\n  it('renders a welcome message', () => {\n    const wrapper = factory()\n\n    expect(wrapper.find('.message').text()).toEqual(\"Welcome to the Vue.js cookbook\")\n  })\n\n  it('renders an error when username is less than 7 characters', () => {\n    const wrapper = factory({ username: ''  })\n\n    expect(wrapper.find('.error').exists()).toBeTruthy()\n  })\n\n  it('renders an error when username is whitespace', () => {\n    const wrapper = factory({ username: ' '.repeat(7) })\n\n    expect(wrapper.find('.error').exists()).toBeTruthy()\n  })\n\n  it('does not render an error when username is 7 characters or more', () => {\n    const wrapper = factory({ username: 'Lachlan'  })\n\n    expect(wrapper.find('.error').exists()).toBeFalsy()\n  })\n})\n```\n\nPoints to note:\n\nAt the top, we declare the factory function which merges the `values` object into `data` and returns a new `wrapper` instance. This way, we don't need to duplicate `const wrapper = shallowMount(Foo)` in every test. Another great benefit to this is when more complex components with a method or computed property you might want to mock or stub in every test, you only need to declare it once.\n\n## Additional Context\n\nThe above test is fairly simple, but in practice Vue components often have other behaviors you want to test, such as:\n\n- making API calls\n- committing or dispatching mutations or actions with a `Vuex` store\n- testing interaction\n\nThere are more complete examples showing such tests in the Vue Test Utils [guides](https://vue-test-utils.vuejs.org/guides/).\n\nVue Test Utils and the enormous JavaScript ecosystem provides plenty of tooling to facilitate almost 100% test coverage. Unit tests are only one part of the testing pyramid, though. Some other types of tests include e2e (end to end) tests, and snapshot tests. Unit tests are the smallest and most simple of tests - they make assertions on the smallest units of work, isolating each part of a single component.\n\nSnapshot tests save the markup of your Vue component, and compare to the new one generated each time the test runs. If something changes, the developer is notified, and can decide if the change was intentional (the component was updated) or accidental (the component is behaving incorrectly).\n\nEnd to end tests ensure a number of components interact well together. They are more high level. Some examples might be testing if a user can sign up, log in, and update their username. These are slower to run than unit tests or snapshot tests.\n\nUnit tests are most useful during development, either to help a developer think about how to design a component, or refactor an existing component, and are often run every time code is changed.\n\nHigher level tests, such as end to end tests, run much slower. These usually run pre-deploy, to ensure each part of the system is working together correctly.\n\nMore information about testing Vue components can be found in [Testing Vue.js Applications](https://www.manning.com/books/testing-vuejs-applications) by core team member [Edd Yerburgh](https://eddyerburgh.me/).\n\n## When To Avoid This Pattern\n\nUnit testing is an important part of any serious application. At first, when the vision of an application is not clear, unit testing might slow down development, but once a vision is established and real users will be interacting with the application, unit tests (and other types of automated tests) are absolutely essential to ensure the codebase is maintainable and scalable.\n","source":"v2/cookbook/unit-testing-vue-components.md","raw":"---\ntitle: Unit Testing Vue Components\ntype: cookbook\norder: 6\n---\n\n## Base Example\n\nUnit testing is a fundamental part of software development. Unit tests execute the smallest units of code in isolation, in order to increase ease of adding new features and track down bugs. Vue's [single-file components](../guide/single-file-components.html) make it straight forward to write unit tests for components in isolation. This lets you develop new features with confidence you are not breaking existing ones, and helps other developers understand what your component does.\n\nThis simple example tests whether some text is rendered:\n\n```html\n<template>\n  <div>\n    <input v-model=\"username\">\n    <div\n      v-if=\"error\"\n      class=\"error\"\n    >\n      {{ error }}\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Hello',\n  data () {\n    return {\n      username: ''\n    }\n  },\n\n  computed: {\n    error () {\n      return this.username.trim().length < 7\n        ? 'Please enter a longer username'\n        : ''\n    }\n  }\n}\n</script>\n```\n\n```js\nimport { shallowMount } from '@vue/test-utils'\nimport Hello from './Hello.vue'\n\ntest('Hello', () => {\n  // render the component\n  const wrapper = shallowMount(Hello)\n\n  // should not allow for `username` less than 7 characters, excludes whitespace\n  wrapper.setData({ username: ' '.repeat(7) })\n\n  // assert the error is rendered\n  expect(wrapper.find('.error').exists()).toBe(true)\n\n  // update the name to be long enough\n  wrapper.setData({ username: 'Lachlan' })\n\n  // assert the error has gone away\n  expect(wrapper.find('.error').exists()).toBe(false)\n})\n```\n\nThe above code snippet shows how to test whether an error message is rendered based on the length of the username. It demonstrates the general idea of unit testing Vue components: render the component, and assert that the markup matches the state of the component.\n\n## Why test?\n\nComponent unit tests have lots of benefits:\n\n- Provide documentation on how the component should behave\n- Save time over testing manually\n- Reduce bugs in new features\n- Improve design\n- Facilitate refactoring\n\nAutomated testing allows large teams of developers to maintain complex codebases.\n\n#### Getting started\n\n[Vue Test Utils](https://github.com/vuejs/vue-test-utils) is the official library for unit testing Vue components. The [vue-cli](https://github.com/vuejs/vue-cli) `webpack` template comes with either Karma or Jest, both well supported test runners, and there are some [guides](https://vue-test-utils.vuejs.org/guides/) in the Vue Test Utils documentation.\n\n## Real-World Example\n\nUnit tests should be:\n\n- Fast to run\n- Easy to understand\n- Only test a _single unit of work_\n\nLet's continue building on the previous example, while introducing the idea of a <a href=\"https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)\">factory function</a> to make our test more compact and readable. The component should:\n\n- show a 'Welcome to the Vue.js cookbook' greeting.\n- prompt the user to enter their username\n- display an error if the entered username is less than seven letters\n\nLet's take a look at the component code first:\n\n```html\n<template>\n  <div>\n    <div class=\"message\">\n      {{ message }}\n    </div>\n    Enter your username: <input v-model=\"username\">\n    <div\n      v-if=\"error\"\n      class=\"error\"\n    >\n      Please enter a username with at least seven letters.\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Foo',\n\n  data () {\n    return {\n      message: 'Welcome to the Vue.js cookbook',\n      username: ''\n    }\n  },\n\n  computed: {\n    error () {\n      return this.username.trim().length < 7\n    }\n  }\n}\n</script>\n```\n\nThe things that we should test are:\n\n- is the `message` rendered?\n- if `error` is `true`, `<div class=\"error\">` should be present\n- if `error` is `false`, `<div class=\"error\">` should not be present\n\nAnd our first attempt at test:\n\n```js\nimport { shallowMount } from '@vue/test-utils'\nimport Foo from './Foo.vue'\n\ndescribe('Foo', () => {\n  it('renders a message and responds correctly to user input', () => {\n    const wrapper = shallowMount(Foo, {\n      data() {\n        return {\n          message: 'Hello World',\n          username: ''\n        }\n      }\n    })\n\n    // see if the message renders\n    expect(wrapper.find('.message').text()).toEqual('Hello World')\n\n    // assert the error is rendered\n    expect(wrapper.find('.error').exists()).toBeTruthy()\n\n    // update the `username` and assert error is no longer rendered\n    wrapper.setData({ username: 'Lachlan' })\n    expect(wrapper.find('.error').exists()).toBeFalsy()\n  })\n})\n```\n\nThere are some problems with the above:\n\n- a single test is making assertions about different things\n- difficult to tell the different states the component can be in, and what should be rendered\n\nThe below example improves the test by:\n\n- only making one assertion per `it` block\n- having short, clear test descriptions\n- providing only the minimum data required for the test\n- refactoring duplicated logic (creating the `wrapper` and setting the `username` variable) into a factory function\n\n*Updated test*:\n```js\nimport { shallowMount } from '@vue/test-utils'\nimport Foo from './Foo'\n\nconst factory = (values = {}) => {\n  return shallowMount(Foo, {\n    data () {\n      return {\n        ...values\n      }\n    }\n  })\n}\n\ndescribe('Foo', () => {\n  it('renders a welcome message', () => {\n    const wrapper = factory()\n\n    expect(wrapper.find('.message').text()).toEqual(\"Welcome to the Vue.js cookbook\")\n  })\n\n  it('renders an error when username is less than 7 characters', () => {\n    const wrapper = factory({ username: ''  })\n\n    expect(wrapper.find('.error').exists()).toBeTruthy()\n  })\n\n  it('renders an error when username is whitespace', () => {\n    const wrapper = factory({ username: ' '.repeat(7) })\n\n    expect(wrapper.find('.error').exists()).toBeTruthy()\n  })\n\n  it('does not render an error when username is 7 characters or more', () => {\n    const wrapper = factory({ username: 'Lachlan'  })\n\n    expect(wrapper.find('.error').exists()).toBeFalsy()\n  })\n})\n```\n\nPoints to note:\n\nAt the top, we declare the factory function which merges the `values` object into `data` and returns a new `wrapper` instance. This way, we don't need to duplicate `const wrapper = shallowMount(Foo)` in every test. Another great benefit to this is when more complex components with a method or computed property you might want to mock or stub in every test, you only need to declare it once.\n\n## Additional Context\n\nThe above test is fairly simple, but in practice Vue components often have other behaviors you want to test, such as:\n\n- making API calls\n- committing or dispatching mutations or actions with a `Vuex` store\n- testing interaction\n\nThere are more complete examples showing such tests in the Vue Test Utils [guides](https://vue-test-utils.vuejs.org/guides/).\n\nVue Test Utils and the enormous JavaScript ecosystem provides plenty of tooling to facilitate almost 100% test coverage. Unit tests are only one part of the testing pyramid, though. Some other types of tests include e2e (end to end) tests, and snapshot tests. Unit tests are the smallest and most simple of tests - they make assertions on the smallest units of work, isolating each part of a single component.\n\nSnapshot tests save the markup of your Vue component, and compare to the new one generated each time the test runs. If something changes, the developer is notified, and can decide if the change was intentional (the component was updated) or accidental (the component is behaving incorrectly).\n\nEnd to end tests ensure a number of components interact well together. They are more high level. Some examples might be testing if a user can sign up, log in, and update their username. These are slower to run than unit tests or snapshot tests.\n\nUnit tests are most useful during development, either to help a developer think about how to design a component, or refactor an existing component, and are often run every time code is changed.\n\nHigher level tests, such as end to end tests, run much slower. These usually run pre-deploy, to ensure each part of the system is working together correctly.\n\nMore information about testing Vue components can be found in [Testing Vue.js Applications](https://www.manning.com/books/testing-vuejs-applications) by core team member [Edd Yerburgh](https://eddyerburgh.me/).\n\n## When To Avoid This Pattern\n\nUnit testing is an important part of any serious application. At first, when the vision of an application is not clear, unit testing might slow down development, but once a vision is established and real users will be interacting with the application, unit tests (and other types of automated tests) are absolutely essential to ensure the codebase is maintainable and scalable.\n","date":"2020-09-25T23:55:41.108Z","updated":"2020-09-25T23:55:41.108Z","path":"v2/cookbook/unit-testing-vue-components.html","comments":1,"layout":"page","_id":"ckfl66gy6000tc2v5okra6ht2","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Unit testing is a fundamental part of software development. Unit tests execute the smallest units of code in isolation, in order to increase ease of adding new features and track down bugs. Vue’s <a href=\"../guide/single-file-components.html\">single-file components</a> make it straight forward to write unit tests for components in isolation. This lets you develop new features with confidence you are not breaking existing ones, and helps other developers understand what your component does.</p>\n<p>This simple example tests whether some text is rendered:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"username\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"error\"</span>\n    &gt;</span>\n      &#123;&#123; error &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Hello'</span>,\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    error () &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.username.trim().length &lt; <span class=\"hljs-number\">7</span>\n        ? <span class=\"hljs-string\">'Please enter a longer username'</span>\n        : <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; shallowMount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vue/test-utils'</span>\n<span class=\"hljs-keyword\">import</span> Hello <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Hello.vue'</span>\n\ntest(<span class=\"hljs-string\">'Hello'</span>, () =&gt; &#123;\n  <span class=\"hljs-comment\">// render the component</span>\n  <span class=\"hljs-keyword\">const</span> wrapper = shallowMount(Hello)\n\n  <span class=\"hljs-comment\">// should not allow for `username` less than 7 characters, excludes whitespace</span>\n  wrapper.setData(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">' '</span>.repeat(<span class=\"hljs-number\">7</span>) &#125;)\n\n  <span class=\"hljs-comment\">// assert the error is rendered</span>\n  expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBe(<span class=\"hljs-literal\">true</span>)\n\n  <span class=\"hljs-comment\">// update the name to be long enough</span>\n  wrapper.setData(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">'Lachlan'</span> &#125;)\n\n  <span class=\"hljs-comment\">// assert the error has gone away</span>\n  expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBe(<span class=\"hljs-literal\">false</span>)\n&#125;)</code></pre>\n<p>The above code snippet shows how to test whether an error message is rendered based on the length of the username. It demonstrates the general idea of unit testing Vue components: render the component, and assert that the markup matches the state of the component.</p>\n<h2 id=\"Why-test\"><a href=\"#Why-test\" class=\"headerlink\" title=\"Why test?\"></a>Why test?</h2><p>Component unit tests have lots of benefits:</p>\n<ul>\n<li>Provide documentation on how the component should behave</li>\n<li>Save time over testing manually</li>\n<li>Reduce bugs in new features</li>\n<li>Improve design</li>\n<li>Facilitate refactoring</li>\n</ul>\n<p>Automated testing allows large teams of developers to maintain complex codebases.</p>\n<h4 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h4><p><a href=\"https://github.com/vuejs/vue-test-utils\" target=\"_blank\" rel=\"noopener\">Vue Test Utils</a> is the official library for unit testing Vue components. The <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">vue-cli</a> <code>webpack</code> template comes with either Karma or Jest, both well supported test runners, and there are some <a href=\"https://vue-test-utils.vuejs.org/guides/\" target=\"_blank\" rel=\"noopener\">guides</a> in the Vue Test Utils documentation.</p>\n<h2 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h2><p>Unit tests should be:</p>\n<ul>\n<li>Fast to run</li>\n<li>Easy to understand</li>\n<li>Only test a <em>single unit of work</em></li>\n</ul>\n<p>Let’s continue building on the previous example, while introducing the idea of a <a href=\"https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)\" target=\"_blank\" rel=\"noopener\">factory function</a> to make our test more compact and readable. The component should:</p>\n<ul>\n<li>show a ‘Welcome to the Vue.js cookbook’ greeting.</li>\n<li>prompt the user to enter their username</li>\n<li>display an error if the entered username is less than seven letters</li>\n</ul>\n<p>Let’s take a look at the component code first:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"message\"</span>&gt;</span>\n      &#123;&#123; message &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    Enter your username: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"username\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"error\"</span>\n    &gt;</span>\n      Please enter a username with at least seven letters.\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Foo'</span>,\n\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Welcome to the Vue.js cookbook'</span>,\n      <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    error () &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.username.trim().length &lt; <span class=\"hljs-number\">7</span>\n    &#125;\n  &#125;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>The things that we should test are:</p>\n<ul>\n<li>is the <code>message</code> rendered?</li>\n<li>if <code>error</code> is <code>true</code>, <code>&lt;div class=&quot;error&quot;&gt;</code> should be present</li>\n<li>if <code>error</code> is <code>false</code>, <code>&lt;div class=&quot;error&quot;&gt;</code> should not be present</li>\n</ul>\n<p>And our first attempt at test:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; shallowMount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vue/test-utils'</span>\n<span class=\"hljs-keyword\">import</span> Foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Foo.vue'</span>\n\ndescribe(<span class=\"hljs-string\">'Foo'</span>, () =&gt; &#123;\n  it(<span class=\"hljs-string\">'renders a message and responds correctly to user input'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = shallowMount(Foo, &#123;\n      data() &#123;\n        <span class=\"hljs-keyword\">return</span> &#123;\n          <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello World'</span>,\n          <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>\n        &#125;\n      &#125;\n    &#125;)\n\n    <span class=\"hljs-comment\">// see if the message renders</span>\n    expect(wrapper.find(<span class=\"hljs-string\">'.message'</span>).text()).toEqual(<span class=\"hljs-string\">'Hello World'</span>)\n\n    <span class=\"hljs-comment\">// assert the error is rendered</span>\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeTruthy()\n\n    <span class=\"hljs-comment\">// update the `username` and assert error is no longer rendered</span>\n    wrapper.setData(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">'Lachlan'</span> &#125;)\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeFalsy()\n  &#125;)\n&#125;)</code></pre>\n<p>There are some problems with the above:</p>\n<ul>\n<li>a single test is making assertions about different things</li>\n<li>difficult to tell the different states the component can be in, and what should be rendered</li>\n</ul>\n<p>The below example improves the test by:</p>\n<ul>\n<li>only making one assertion per <code>it</code> block</li>\n<li>having short, clear test descriptions</li>\n<li>providing only the minimum data required for the test</li>\n<li>refactoring duplicated logic (creating the <code>wrapper</code> and setting the <code>username</code> variable) into a factory function</li>\n</ul>\n<p><em>Updated test</em>:<br><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; shallowMount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vue/test-utils'</span>\n<span class=\"hljs-keyword\">import</span> Foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Foo'</span>\n\n<span class=\"hljs-keyword\">const</span> factory = <span class=\"hljs-function\">(<span class=\"hljs-params\">values = &#123;&#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> shallowMount(Foo, &#123;\n    data () &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...values\n      &#125;\n    &#125;\n  &#125;)\n&#125;\n\ndescribe(<span class=\"hljs-string\">'Foo'</span>, () =&gt; &#123;\n  it(<span class=\"hljs-string\">'renders a welcome message'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory()\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.message'</span>).text()).toEqual(<span class=\"hljs-string\">\"Welcome to the Vue.js cookbook\"</span>)\n  &#125;)\n\n  it(<span class=\"hljs-string\">'renders an error when username is less than 7 characters'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>  &#125;)\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeTruthy()\n  &#125;)\n\n  it(<span class=\"hljs-string\">'renders an error when username is whitespace'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">' '</span>.repeat(<span class=\"hljs-number\">7</span>) &#125;)\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeTruthy()\n  &#125;)\n\n  it(<span class=\"hljs-string\">'does not render an error when username is 7 characters or more'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">'Lachlan'</span>  &#125;)\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeFalsy()\n  &#125;)\n&#125;)</code></pre></p>\n<p>Points to note:</p>\n<p>At the top, we declare the factory function which merges the <code>values</code> object into <code>data</code> and returns a new <code>wrapper</code> instance. This way, we don’t need to duplicate <code>const wrapper = shallowMount(Foo)</code> in every test. Another great benefit to this is when more complex components with a method or computed property you might want to mock or stub in every test, you only need to declare it once.</p>\n<h2 id=\"Additional-Context\"><a href=\"#Additional-Context\" class=\"headerlink\" title=\"Additional Context\"></a>Additional Context</h2><p>The above test is fairly simple, but in practice Vue components often have other behaviors you want to test, such as:</p>\n<ul>\n<li>making API calls</li>\n<li>committing or dispatching mutations or actions with a <code>Vuex</code> store</li>\n<li>testing interaction</li>\n</ul>\n<p>There are more complete examples showing such tests in the Vue Test Utils <a href=\"https://vue-test-utils.vuejs.org/guides/\" target=\"_blank\" rel=\"noopener\">guides</a>.</p>\n<p>Vue Test Utils and the enormous JavaScript ecosystem provides plenty of tooling to facilitate almost 100% test coverage. Unit tests are only one part of the testing pyramid, though. Some other types of tests include e2e (end to end) tests, and snapshot tests. Unit tests are the smallest and most simple of tests - they make assertions on the smallest units of work, isolating each part of a single component.</p>\n<p>Snapshot tests save the markup of your Vue component, and compare to the new one generated each time the test runs. If something changes, the developer is notified, and can decide if the change was intentional (the component was updated) or accidental (the component is behaving incorrectly).</p>\n<p>End to end tests ensure a number of components interact well together. They are more high level. Some examples might be testing if a user can sign up, log in, and update their username. These are slower to run than unit tests or snapshot tests.</p>\n<p>Unit tests are most useful during development, either to help a developer think about how to design a component, or refactor an existing component, and are often run every time code is changed.</p>\n<p>Higher level tests, such as end to end tests, run much slower. These usually run pre-deploy, to ensure each part of the system is working together correctly.</p>\n<p>More information about testing Vue components can be found in <a href=\"https://www.manning.com/books/testing-vuejs-applications\" target=\"_blank\" rel=\"noopener\">Testing Vue.js Applications</a> by core team member <a href=\"https://eddyerburgh.me/\" target=\"_blank\" rel=\"noopener\">Edd Yerburgh</a>.</p>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>Unit testing is an important part of any serious application. At first, when the vision of an application is not clear, unit testing might slow down development, but once a vision is established and real users will be interacting with the application, unit tests (and other types of automated tests) are absolutely essential to ensure the codebase is maintainable and scalable.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Unit testing is a fundamental part of software development. Unit tests execute the smallest units of code in isolation, in order to increase ease of adding new features and track down bugs. Vue’s <a href=\"../guide/single-file-components.html\">single-file components</a> make it straight forward to write unit tests for components in isolation. This lets you develop new features with confidence you are not breaking existing ones, and helps other developers understand what your component does.</p>\n<p>This simple example tests whether some text is rendered:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"username\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"error\"</span>\n    &gt;</span>\n      &#123;&#123; error &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Hello'</span>,\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    error () &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.username.trim().length &lt; <span class=\"hljs-number\">7</span>\n        ? <span class=\"hljs-string\">'Please enter a longer username'</span>\n        : <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; shallowMount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vue/test-utils'</span>\n<span class=\"hljs-keyword\">import</span> Hello <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Hello.vue'</span>\n\ntest(<span class=\"hljs-string\">'Hello'</span>, () =&gt; &#123;\n  <span class=\"hljs-comment\">// render the component</span>\n  <span class=\"hljs-keyword\">const</span> wrapper = shallowMount(Hello)\n\n  <span class=\"hljs-comment\">// should not allow for `username` less than 7 characters, excludes whitespace</span>\n  wrapper.setData(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">' '</span>.repeat(<span class=\"hljs-number\">7</span>) &#125;)\n\n  <span class=\"hljs-comment\">// assert the error is rendered</span>\n  expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBe(<span class=\"hljs-literal\">true</span>)\n\n  <span class=\"hljs-comment\">// update the name to be long enough</span>\n  wrapper.setData(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">'Lachlan'</span> &#125;)\n\n  <span class=\"hljs-comment\">// assert the error has gone away</span>\n  expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBe(<span class=\"hljs-literal\">false</span>)\n&#125;)</code></pre>\n<p>The above code snippet shows how to test whether an error message is rendered based on the length of the username. It demonstrates the general idea of unit testing Vue components: render the component, and assert that the markup matches the state of the component.</p>\n<h2 id=\"Why-test\"><a href=\"#Why-test\" class=\"headerlink\" title=\"Why test?\"></a>Why test?</h2><p>Component unit tests have lots of benefits:</p>\n<ul>\n<li>Provide documentation on how the component should behave</li>\n<li>Save time over testing manually</li>\n<li>Reduce bugs in new features</li>\n<li>Improve design</li>\n<li>Facilitate refactoring</li>\n</ul>\n<p>Automated testing allows large teams of developers to maintain complex codebases.</p>\n<h4 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h4><p><a href=\"https://github.com/vuejs/vue-test-utils\" target=\"_blank\" rel=\"noopener\">Vue Test Utils</a> is the official library for unit testing Vue components. The <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">vue-cli</a> <code>webpack</code> template comes with either Karma or Jest, both well supported test runners, and there are some <a href=\"https://vue-test-utils.vuejs.org/guides/\" target=\"_blank\" rel=\"noopener\">guides</a> in the Vue Test Utils documentation.</p>\n<h2 id=\"Real-World-Example\"><a href=\"#Real-World-Example\" class=\"headerlink\" title=\"Real-World Example\"></a>Real-World Example</h2><p>Unit tests should be:</p>\n<ul>\n<li>Fast to run</li>\n<li>Easy to understand</li>\n<li>Only test a <em>single unit of work</em></li>\n</ul>\n<p>Let’s continue building on the previous example, while introducing the idea of a <a href=\"https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)\" target=\"_blank\" rel=\"noopener\">factory function</a> to make our test more compact and readable. The component should:</p>\n<ul>\n<li>show a ‘Welcome to the Vue.js cookbook’ greeting.</li>\n<li>prompt the user to enter their username</li>\n<li>display an error if the entered username is less than seven letters</li>\n</ul>\n<p>Let’s take a look at the component code first:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"message\"</span>&gt;</span>\n      &#123;&#123; message &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    Enter your username: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"username\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n      <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"error\"</span>\n    &gt;</span>\n      Please enter a username with at least seven letters.\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Foo'</span>,\n\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Welcome to the Vue.js cookbook'</span>,\n      <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;,\n\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    error () &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.username.trim().length &lt; <span class=\"hljs-number\">7</span>\n    &#125;\n  &#125;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>The things that we should test are:</p>\n<ul>\n<li>is the <code>message</code> rendered?</li>\n<li>if <code>error</code> is <code>true</code>, <code>&lt;div class=&quot;error&quot;&gt;</code> should be present</li>\n<li>if <code>error</code> is <code>false</code>, <code>&lt;div class=&quot;error&quot;&gt;</code> should not be present</li>\n</ul>\n<p>And our first attempt at test:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; shallowMount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vue/test-utils'</span>\n<span class=\"hljs-keyword\">import</span> Foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Foo.vue'</span>\n\ndescribe(<span class=\"hljs-string\">'Foo'</span>, () =&gt; &#123;\n  it(<span class=\"hljs-string\">'renders a message and responds correctly to user input'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = shallowMount(Foo, &#123;\n      data() &#123;\n        <span class=\"hljs-keyword\">return</span> &#123;\n          <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello World'</span>,\n          <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>\n        &#125;\n      &#125;\n    &#125;)\n\n    <span class=\"hljs-comment\">// see if the message renders</span>\n    expect(wrapper.find(<span class=\"hljs-string\">'.message'</span>).text()).toEqual(<span class=\"hljs-string\">'Hello World'</span>)\n\n    <span class=\"hljs-comment\">// assert the error is rendered</span>\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeTruthy()\n\n    <span class=\"hljs-comment\">// update the `username` and assert error is no longer rendered</span>\n    wrapper.setData(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">'Lachlan'</span> &#125;)\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeFalsy()\n  &#125;)\n&#125;)</code></pre>\n<p>There are some problems with the above:</p>\n<ul>\n<li>a single test is making assertions about different things</li>\n<li>difficult to tell the different states the component can be in, and what should be rendered</li>\n</ul>\n<p>The below example improves the test by:</p>\n<ul>\n<li>only making one assertion per <code>it</code> block</li>\n<li>having short, clear test descriptions</li>\n<li>providing only the minimum data required for the test</li>\n<li>refactoring duplicated logic (creating the <code>wrapper</code> and setting the <code>username</code> variable) into a factory function</li>\n</ul>\n<p><em>Updated test</em>:<br><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> &#123; shallowMount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@vue/test-utils'</span>\n<span class=\"hljs-keyword\">import</span> Foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./Foo'</span>\n\n<span class=\"hljs-keyword\">const</span> factory = <span class=\"hljs-function\">(<span class=\"hljs-params\">values = &#123;&#125;</span>) =&gt;</span> &#123;\n  <span class=\"hljs-keyword\">return</span> shallowMount(Foo, &#123;\n    data () &#123;\n      <span class=\"hljs-keyword\">return</span> &#123;\n        ...values\n      &#125;\n    &#125;\n  &#125;)\n&#125;\n\ndescribe(<span class=\"hljs-string\">'Foo'</span>, () =&gt; &#123;\n  it(<span class=\"hljs-string\">'renders a welcome message'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory()\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.message'</span>).text()).toEqual(<span class=\"hljs-string\">\"Welcome to the Vue.js cookbook\"</span>)\n  &#125;)\n\n  it(<span class=\"hljs-string\">'renders an error when username is less than 7 characters'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">''</span>  &#125;)\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeTruthy()\n  &#125;)\n\n  it(<span class=\"hljs-string\">'renders an error when username is whitespace'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">' '</span>.repeat(<span class=\"hljs-number\">7</span>) &#125;)\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeTruthy()\n  &#125;)\n\n  it(<span class=\"hljs-string\">'does not render an error when username is 7 characters or more'</span>, () =&gt; &#123;\n    <span class=\"hljs-keyword\">const</span> wrapper = factory(&#123; <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">'Lachlan'</span>  &#125;)\n\n    expect(wrapper.find(<span class=\"hljs-string\">'.error'</span>).exists()).toBeFalsy()\n  &#125;)\n&#125;)</code></pre></p>\n<p>Points to note:</p>\n<p>At the top, we declare the factory function which merges the <code>values</code> object into <code>data</code> and returns a new <code>wrapper</code> instance. This way, we don’t need to duplicate <code>const wrapper = shallowMount(Foo)</code> in every test. Another great benefit to this is when more complex components with a method or computed property you might want to mock or stub in every test, you only need to declare it once.</p>\n<h2 id=\"Additional-Context\"><a href=\"#Additional-Context\" class=\"headerlink\" title=\"Additional Context\"></a>Additional Context</h2><p>The above test is fairly simple, but in practice Vue components often have other behaviors you want to test, such as:</p>\n<ul>\n<li>making API calls</li>\n<li>committing or dispatching mutations or actions with a <code>Vuex</code> store</li>\n<li>testing interaction</li>\n</ul>\n<p>There are more complete examples showing such tests in the Vue Test Utils <a href=\"https://vue-test-utils.vuejs.org/guides/\" target=\"_blank\" rel=\"noopener\">guides</a>.</p>\n<p>Vue Test Utils and the enormous JavaScript ecosystem provides plenty of tooling to facilitate almost 100% test coverage. Unit tests are only one part of the testing pyramid, though. Some other types of tests include e2e (end to end) tests, and snapshot tests. Unit tests are the smallest and most simple of tests - they make assertions on the smallest units of work, isolating each part of a single component.</p>\n<p>Snapshot tests save the markup of your Vue component, and compare to the new one generated each time the test runs. If something changes, the developer is notified, and can decide if the change was intentional (the component was updated) or accidental (the component is behaving incorrectly).</p>\n<p>End to end tests ensure a number of components interact well together. They are more high level. Some examples might be testing if a user can sign up, log in, and update their username. These are slower to run than unit tests or snapshot tests.</p>\n<p>Unit tests are most useful during development, either to help a developer think about how to design a component, or refactor an existing component, and are often run every time code is changed.</p>\n<p>Higher level tests, such as end to end tests, run much slower. These usually run pre-deploy, to ensure each part of the system is working together correctly.</p>\n<p>More information about testing Vue components can be found in <a href=\"https://www.manning.com/books/testing-vuejs-applications\" target=\"_blank\" rel=\"noopener\">Testing Vue.js Applications</a> by core team member <a href=\"https://eddyerburgh.me/\" target=\"_blank\" rel=\"noopener\">Edd Yerburgh</a>.</p>\n<h2 id=\"When-To-Avoid-This-Pattern\"><a href=\"#When-To-Avoid-This-Pattern\" class=\"headerlink\" title=\"When To Avoid This Pattern\"></a>When To Avoid This Pattern</h2><p>Unit testing is an important part of any serious application. At first, when the vision of an application is not clear, unit testing might slow down development, but once a vision is established and real users will be interacting with the application, unit tests (and other types of automated tests) are absolutely essential to ensure the codebase is maintainable and scalable.</p>\n"},{"title":"Using Axios to Consume APIs","type":"cookbook","order":9,"_content":"\n## Base Example\n\nThere are many times when building application for the web that you may want to consume and display data from an API. There are several ways to do so, but a very popular approach is to use [axios](https://github.com/axios/axios), a promise-based HTTP client.\n\nIn this exercise, we'll use the [CoinDesk API](https://www.coindesk.com/api/) to walk through displaying Bitcoin prices, updated every minute. First, we'd install axios with either npm/yarn or through a CDN link.\n\nThere are a number of ways we can request information from the API, but it's nice to first find out what the shape of the data looks like, in order to know what to display. In order to do so, we'll make a call to the API endpoint and output it so we can see it. We can see in the CoinDesk API documentation, that this call will be made to `https://api.coindesk.com/v1/bpi/currentprice.json`. So first, we'll create a data property that will eventually house our information, and we'll retrieve the data and assign it using the `mounted` lifecycle hook:\n\n```js\nnew Vue({\n  el: '#app',\n  data () {\n    return {\n      info: null\n    }\n  },\n  mounted () {\n    axios\n      .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n      .then(response => (this.info = response))\n  }\n})\n```\n\n```html\n<div id=\"app\">\n  {{ info }}\n</div>\n```\n\nAnd what we get is this:\n\n<p data-height=\"350\" data-theme-id=\"32763\" data-slug-hash=\"80043dfdb7b90f138f5585ade1a5286f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"First Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/80043dfdb7b90f138f5585ade1a5286f/\">First Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nExcellent! We've got some data. But it looks pretty messy right now so let's display it properly and add some error handling in case things aren't working as expected or it takes longer than we thought to get the information.\n\n## Real-World Example: Working with the Data\n\n### Displaying Data from an API\n\nIt's pretty typical that the information we'll need is within the response, and we'll have to traverse what we've just stored to access it properly. In our case, we can see that the price information we need lives in `response.data.bpi`. If we use this instead, our output is as follows:\n\n```js\naxios\n  .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n  .then(response => (this.info = response.data.bpi))\n```\n\n<p data-height=\"200\" data-theme-id=\"32763\" data-slug-hash=\"6100b10f1b4ac2961208643560ba7d11\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Second Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6100b10f1b4ac2961208643560ba7d11/\">Second Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nThis is a lot easier for us to display, so we can now update our HTML to display only the information we need from the data we've received, and we'll create a [filter](../api/#Vue-filter) to make sure that the decimal is in the appropriate place as well.\n\n```html\n<div id=\"app\">\n  <h1>Bitcoin Price Index</h1>\n  <div\n    v-for=\"currency in info\"\n    class=\"currency\"\n  >\n    {{ currency.description }}:\n    <span class=\"lighten\">\n      <span v-html=\"currency.symbol\"></span>{{ currency.rate_float | currencydecimal }}\n    </span>\n  </div>\n</div>\n```\n\n```js\nfilters: {\n  currencydecimal (value) {\n    return value.toFixed(2)\n  }\n},\n```\n\n<p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"9d59319c09eaccfaf35d9e9f11990f0f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Third Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/9d59319c09eaccfaf35d9e9f11990f0f/\">Third Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n### Dealing with Errors\n\nThere are times when we might not get the data we need from the API. There are several reasons that our axios call might fail, including but not limited to:\n\n* The API is down.\n* The request was made incorrectly.\n* The API isn't giving us the information in the format that we anticipated.\n\nWhen making this request, we should be checking for just such circumstances, and giving ourselves information in every case so we know how to handle the problem. In an axios call, we'll do so by using `catch`.\n\n```js\naxios\n  .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n  .then(response => (this.info = response.data.bpi))\n  .catch(error => console.log(error))\n```\n\nThis will let us know if something failed during the API request, but what if the data is mangled or the API is down? Right now the user will just see nothing. We might want to build a loader for this case, and then tell the user if we're not able to get the data at all.\n\n```js\nnew Vue({\n  el: '#app',\n  data () {\n    return {\n      info: null,\n      loading: true,\n      errored: false\n    }\n  },\n  filters: {\n    currencydecimal (value) {\n      return value.toFixed(2)\n    }\n  },\n  mounted () {\n    axios\n      .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n      .then(response => {\n        this.info = response.data.bpi\n      })\n      .catch(error => {\n        console.log(error)\n        this.errored = true\n      })\n      .finally(() => this.loading = false)\n  }\n})\n```\n\n```html\n<div id=\"app\">\n  <h1>Bitcoin Price Index</h1>\n\n  <section v-if=\"errored\">\n    <p>We're sorry, we're not able to retrieve this information at the moment, please try back later</p>\n  </section>\n\n  <section v-else>\n    <div v-if=\"loading\">Loading...</div>\n\n    <div\n      v-else\n      v-for=\"currency in info\"\n      class=\"currency\"\n    >\n      {{ currency.description }}:\n      <span class=\"lighten\">\n        <span v-html=\"currency.symbol\"></span>{{ currency.rate_float | currencydecimal }}\n      </span>\n    </div>\n\n  </section>\n</div>\n```\n\nYou can hit the rerun button on this pen to see the loading status briefly while we gather data from the API:\n\n<p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"6c01922c9af3883890fd7393e8147ec4\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Fourth Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6c01922c9af3883890fd7393e8147ec4/\">Fourth Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nThis can be even further improved with the use of components for different sections and more distinct error reporting, depending on the API you're using and the complexity of your application.\n\n## Alternative Patterns\n\n### Fetch API\n\nThe [Fetch API](https://developers.google.com/web/updates/2015/03/introduction-to-fetch) is a powerful native API for these types of requests. You may have heard that one of the benefits of the Fetch API is that you don't need to load an external resource in order to use it, which is true! Except... that it's not fully supported yet, so you will still need to use a polyfill. There are also some gotchas when working with this API, which is why many prefer to use axios for now. This may very well change in the future though.\n\nIf you're interested in using the Fetch API, there are some [very good articles](https://scotch.io/@bedakb/lets-build-type-ahead-component-with-vuejs-2-and-fetch-api) explaining how to do so.\n\n## Wrapping Up\n\nThere are many ways to work with Vue and axios beyond consuming and displaying an API. You can also communicate with Serverless Functions, post/edit/delete from an API where you have write access, and many other benefits. Due to the straightforward integration of these two libraries, it's become a very common choice for developers who need to integrate HTTP clients into their workflow.\n","source":"v2/cookbook/using-axios-to-consume-apis.md","raw":"---\ntitle: Using Axios to Consume APIs\ntype: cookbook\norder: 9\n---\n\n## Base Example\n\nThere are many times when building application for the web that you may want to consume and display data from an API. There are several ways to do so, but a very popular approach is to use [axios](https://github.com/axios/axios), a promise-based HTTP client.\n\nIn this exercise, we'll use the [CoinDesk API](https://www.coindesk.com/api/) to walk through displaying Bitcoin prices, updated every minute. First, we'd install axios with either npm/yarn or through a CDN link.\n\nThere are a number of ways we can request information from the API, but it's nice to first find out what the shape of the data looks like, in order to know what to display. In order to do so, we'll make a call to the API endpoint and output it so we can see it. We can see in the CoinDesk API documentation, that this call will be made to `https://api.coindesk.com/v1/bpi/currentprice.json`. So first, we'll create a data property that will eventually house our information, and we'll retrieve the data and assign it using the `mounted` lifecycle hook:\n\n```js\nnew Vue({\n  el: '#app',\n  data () {\n    return {\n      info: null\n    }\n  },\n  mounted () {\n    axios\n      .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n      .then(response => (this.info = response))\n  }\n})\n```\n\n```html\n<div id=\"app\">\n  {{ info }}\n</div>\n```\n\nAnd what we get is this:\n\n<p data-height=\"350\" data-theme-id=\"32763\" data-slug-hash=\"80043dfdb7b90f138f5585ade1a5286f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"First Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/80043dfdb7b90f138f5585ade1a5286f/\">First Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nExcellent! We've got some data. But it looks pretty messy right now so let's display it properly and add some error handling in case things aren't working as expected or it takes longer than we thought to get the information.\n\n## Real-World Example: Working with the Data\n\n### Displaying Data from an API\n\nIt's pretty typical that the information we'll need is within the response, and we'll have to traverse what we've just stored to access it properly. In our case, we can see that the price information we need lives in `response.data.bpi`. If we use this instead, our output is as follows:\n\n```js\naxios\n  .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n  .then(response => (this.info = response.data.bpi))\n```\n\n<p data-height=\"200\" data-theme-id=\"32763\" data-slug-hash=\"6100b10f1b4ac2961208643560ba7d11\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Second Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6100b10f1b4ac2961208643560ba7d11/\">Second Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nThis is a lot easier for us to display, so we can now update our HTML to display only the information we need from the data we've received, and we'll create a [filter](../api/#Vue-filter) to make sure that the decimal is in the appropriate place as well.\n\n```html\n<div id=\"app\">\n  <h1>Bitcoin Price Index</h1>\n  <div\n    v-for=\"currency in info\"\n    class=\"currency\"\n  >\n    {{ currency.description }}:\n    <span class=\"lighten\">\n      <span v-html=\"currency.symbol\"></span>{{ currency.rate_float | currencydecimal }}\n    </span>\n  </div>\n</div>\n```\n\n```js\nfilters: {\n  currencydecimal (value) {\n    return value.toFixed(2)\n  }\n},\n```\n\n<p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"9d59319c09eaccfaf35d9e9f11990f0f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Third Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/9d59319c09eaccfaf35d9e9f11990f0f/\">Third Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n### Dealing with Errors\n\nThere are times when we might not get the data we need from the API. There are several reasons that our axios call might fail, including but not limited to:\n\n* The API is down.\n* The request was made incorrectly.\n* The API isn't giving us the information in the format that we anticipated.\n\nWhen making this request, we should be checking for just such circumstances, and giving ourselves information in every case so we know how to handle the problem. In an axios call, we'll do so by using `catch`.\n\n```js\naxios\n  .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n  .then(response => (this.info = response.data.bpi))\n  .catch(error => console.log(error))\n```\n\nThis will let us know if something failed during the API request, but what if the data is mangled or the API is down? Right now the user will just see nothing. We might want to build a loader for this case, and then tell the user if we're not able to get the data at all.\n\n```js\nnew Vue({\n  el: '#app',\n  data () {\n    return {\n      info: null,\n      loading: true,\n      errored: false\n    }\n  },\n  filters: {\n    currencydecimal (value) {\n      return value.toFixed(2)\n    }\n  },\n  mounted () {\n    axios\n      .get('https://api.coindesk.com/v1/bpi/currentprice.json')\n      .then(response => {\n        this.info = response.data.bpi\n      })\n      .catch(error => {\n        console.log(error)\n        this.errored = true\n      })\n      .finally(() => this.loading = false)\n  }\n})\n```\n\n```html\n<div id=\"app\">\n  <h1>Bitcoin Price Index</h1>\n\n  <section v-if=\"errored\">\n    <p>We're sorry, we're not able to retrieve this information at the moment, please try back later</p>\n  </section>\n\n  <section v-else>\n    <div v-if=\"loading\">Loading...</div>\n\n    <div\n      v-else\n      v-for=\"currency in info\"\n      class=\"currency\"\n    >\n      {{ currency.description }}:\n      <span class=\"lighten\">\n        <span v-html=\"currency.symbol\"></span>{{ currency.rate_float | currencydecimal }}\n      </span>\n    </div>\n\n  </section>\n</div>\n```\n\nYou can hit the rerun button on this pen to see the loading status briefly while we gather data from the API:\n\n<p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"6c01922c9af3883890fd7393e8147ec4\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Fourth Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6c01922c9af3883890fd7393e8147ec4/\">Fourth Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\">@Vue</a>) on <a href=\"https://codepen.io\">CodePen</a>.</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\nThis can be even further improved with the use of components for different sections and more distinct error reporting, depending on the API you're using and the complexity of your application.\n\n## Alternative Patterns\n\n### Fetch API\n\nThe [Fetch API](https://developers.google.com/web/updates/2015/03/introduction-to-fetch) is a powerful native API for these types of requests. You may have heard that one of the benefits of the Fetch API is that you don't need to load an external resource in order to use it, which is true! Except... that it's not fully supported yet, so you will still need to use a polyfill. There are also some gotchas when working with this API, which is why many prefer to use axios for now. This may very well change in the future though.\n\nIf you're interested in using the Fetch API, there are some [very good articles](https://scotch.io/@bedakb/lets-build-type-ahead-component-with-vuejs-2-and-fetch-api) explaining how to do so.\n\n## Wrapping Up\n\nThere are many ways to work with Vue and axios beyond consuming and displaying an API. You can also communicate with Serverless Functions, post/edit/delete from an API where you have write access, and many other benefits. Due to the straightforward integration of these two libraries, it's become a very common choice for developers who need to integrate HTTP clients into their workflow.\n","date":"2020-09-25T23:55:41.108Z","updated":"2020-09-25T23:55:41.108Z","path":"v2/cookbook/using-axios-to-consume-apis.html","comments":1,"layout":"page","_id":"ckfl66gy6000uc2v55wkrf985","content":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are many times when building application for the web that you may want to consume and display data from an API. There are several ways to do so, but a very popular approach is to use <a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"noopener\">axios</a>, a promise-based HTTP client.</p>\n<p>In this exercise, we’ll use the <a href=\"https://www.coindesk.com/api/\" target=\"_blank\" rel=\"noopener\">CoinDesk API</a> to walk through displaying Bitcoin prices, updated every minute. First, we’d install axios with either npm/yarn or through a CDN link.</p>\n<p>There are a number of ways we can request information from the API, but it’s nice to first find out what the shape of the data looks like, in order to know what to display. In order to do so, we’ll make a call to the API endpoint and output it so we can see it. We can see in the CoinDesk API documentation, that this call will be made to <code>https://api.coindesk.com/v1/bpi/currentprice.json</code>. So first, we’ll create a data property that will eventually house our information, and we’ll retrieve the data and assign it using the <code>mounted</code> lifecycle hook:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">info</span>: <span class=\"hljs-literal\">null</span>\n    &#125;\n  &#125;,\n  mounted () &#123;\n    axios\n      .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> (<span class=\"hljs-keyword\">this</span>.info = response))\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  &#123;&#123; info &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>And what we get is this:</p>\n<p></p><p data-height=\"350\" data-theme-id=\"32763\" data-slug-hash=\"80043dfdb7b90f138f5585ade1a5286f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"First Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/80043dfdb7b90f138f5585ade1a5286f/\" target=\"_blank\" rel=\"noopener\">First Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>Excellent! We’ve got some data. But it looks pretty messy right now so let’s display it properly and add some error handling in case things aren’t working as expected or it takes longer than we thought to get the information.</p>\n<h2 id=\"Real-World-Example-Working-with-the-Data\"><a href=\"#Real-World-Example-Working-with-the-Data\" class=\"headerlink\" title=\"Real-World Example: Working with the Data\"></a>Real-World Example: Working with the Data</h2><h3 id=\"Displaying-Data-from-an-API\"><a href=\"#Displaying-Data-from-an-API\" class=\"headerlink\" title=\"Displaying Data from an API\"></a>Displaying Data from an API</h3><p>It’s pretty typical that the information we’ll need is within the response, and we’ll have to traverse what we’ve just stored to access it properly. In our case, we can see that the price information we need lives in <code>response.data.bpi</code>. If we use this instead, our output is as follows:</p>\n<pre><code class=\"hljs js\">axios\n  .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> (<span class=\"hljs-keyword\">this</span>.info = response.data.bpi))</code></pre>\n<p></p><p data-height=\"200\" data-theme-id=\"32763\" data-slug-hash=\"6100b10f1b4ac2961208643560ba7d11\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Second Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6100b10f1b4ac2961208643560ba7d11/\" target=\"_blank\" rel=\"noopener\">Second Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>This is a lot easier for us to display, so we can now update our HTML to display only the information we need from the data we’ve received, and we’ll create a <a href=\"../api/#Vue-filter\">filter</a> to make sure that the decimal is in the appropriate place as well.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Bitcoin Price Index<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"currency in info\"</span>\n    <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"currency\"</span>\n  &gt;</span>\n    &#123;&#123; currency.description &#125;&#125;:\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"lighten\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"currency.symbol\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; currency.rate_float | currencydecimal &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">filters: &#123;\n  currencydecimal (value) &#123;\n    <span class=\"hljs-keyword\">return</span> value.toFixed(<span class=\"hljs-number\">2</span>)\n  &#125;\n&#125;,</code></pre>\n<p></p><p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"9d59319c09eaccfaf35d9e9f11990f0f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Third Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/9d59319c09eaccfaf35d9e9f11990f0f/\" target=\"_blank\" rel=\"noopener\">Third Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<h3 id=\"Dealing-with-Errors\"><a href=\"#Dealing-with-Errors\" class=\"headerlink\" title=\"Dealing with Errors\"></a>Dealing with Errors</h3><p>There are times when we might not get the data we need from the API. There are several reasons that our axios call might fail, including but not limited to:</p>\n<ul>\n<li>The API is down.</li>\n<li>The request was made incorrectly.</li>\n<li>The API isn’t giving us the information in the format that we anticipated.</li>\n</ul>\n<p>When making this request, we should be checking for just such circumstances, and giving ourselves information in every case so we know how to handle the problem. In an axios call, we’ll do so by using <code>catch</code>.</p>\n<pre><code class=\"hljs js\">axios\n  .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> (<span class=\"hljs-keyword\">this</span>.info = response.data.bpi))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(error))</code></pre>\n<p>This will let us know if something failed during the API request, but what if the data is mangled or the API is down? Right now the user will just see nothing. We might want to build a loader for this case, and then tell the user if we’re not able to get the data at all.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">info</span>: <span class=\"hljs-literal\">null</span>,\n      <span class=\"hljs-attr\">loading</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">errored</span>: <span class=\"hljs-literal\">false</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">filters</span>: &#123;\n    currencydecimal (value) &#123;\n      <span class=\"hljs-keyword\">return</span> value.toFixed(<span class=\"hljs-number\">2</span>)\n    &#125;\n  &#125;,\n  mounted () &#123;\n    axios\n      .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.info = response.data.bpi\n      &#125;)\n      .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> &#123;\n        <span class=\"hljs-built_in\">console</span>.log(error)\n        <span class=\"hljs-keyword\">this</span>.errored = <span class=\"hljs-literal\">true</span>\n      &#125;)\n      .finally(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.loading = <span class=\"hljs-literal\">false</span>)\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Bitcoin Price Index<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errored\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>We're sorry, we're not able to retrieve this information at the moment, please try back later<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"loading\"</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n      <span class=\"hljs-attr\">v-else</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"currency in info\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"currency\"</span>\n    &gt;</span>\n      &#123;&#123; currency.description &#125;&#125;:\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"lighten\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"currency.symbol\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; currency.rate_float | currencydecimal &#125;&#125;\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>You can hit the rerun button on this pen to see the loading status briefly while we gather data from the API:</p>\n<p></p><p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"6c01922c9af3883890fd7393e8147ec4\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Fourth Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6c01922c9af3883890fd7393e8147ec4/\" target=\"_blank\" rel=\"noopener\">Fourth Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>This can be even further improved with the use of components for different sections and more distinct error reporting, depending on the API you’re using and the complexity of your application.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"Fetch-API\"><a href=\"#Fetch-API\" class=\"headerlink\" title=\"Fetch API\"></a>Fetch API</h3><p>The <a href=\"https://developers.google.com/web/updates/2015/03/introduction-to-fetch\" target=\"_blank\" rel=\"noopener\">Fetch API</a> is a powerful native API for these types of requests. You may have heard that one of the benefits of the Fetch API is that you don’t need to load an external resource in order to use it, which is true! Except… that it’s not fully supported yet, so you will still need to use a polyfill. There are also some gotchas when working with this API, which is why many prefer to use axios for now. This may very well change in the future though.</p>\n<p>If you’re interested in using the Fetch API, there are some <a href=\"https://scotch.io/@bedakb/lets-build-type-ahead-component-with-vuejs-2-and-fetch-api\" target=\"_blank\" rel=\"noopener\">very good articles</a> explaining how to do so.</p>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>There are many ways to work with Vue and axios beyond consuming and displaying an API. You can also communicate with Serverless Functions, post/edit/delete from an API where you have write access, and many other benefits. Due to the straightforward integration of these two libraries, it’s become a very common choice for developers who need to integrate HTTP clients into their workflow.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>There are many times when building application for the web that you may want to consume and display data from an API. There are several ways to do so, but a very popular approach is to use <a href=\"https://github.com/axios/axios\" target=\"_blank\" rel=\"noopener\">axios</a>, a promise-based HTTP client.</p>\n<p>In this exercise, we’ll use the <a href=\"https://www.coindesk.com/api/\" target=\"_blank\" rel=\"noopener\">CoinDesk API</a> to walk through displaying Bitcoin prices, updated every minute. First, we’d install axios with either npm/yarn or through a CDN link.</p>\n<p>There are a number of ways we can request information from the API, but it’s nice to first find out what the shape of the data looks like, in order to know what to display. In order to do so, we’ll make a call to the API endpoint and output it so we can see it. We can see in the CoinDesk API documentation, that this call will be made to <code>https://api.coindesk.com/v1/bpi/currentprice.json</code>. So first, we’ll create a data property that will eventually house our information, and we’ll retrieve the data and assign it using the <code>mounted</code> lifecycle hook:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">info</span>: <span class=\"hljs-literal\">null</span>\n    &#125;\n  &#125;,\n  mounted () &#123;\n    axios\n      .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> (<span class=\"hljs-keyword\">this</span>.info = response))\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  &#123;&#123; info &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>And what we get is this:</p>\n<p></p><p data-height=\"350\" data-theme-id=\"32763\" data-slug-hash=\"80043dfdb7b90f138f5585ade1a5286f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"First Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/80043dfdb7b90f138f5585ade1a5286f/\" target=\"_blank\" rel=\"noopener\">First Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>Excellent! We’ve got some data. But it looks pretty messy right now so let’s display it properly and add some error handling in case things aren’t working as expected or it takes longer than we thought to get the information.</p>\n<h2 id=\"Real-World-Example-Working-with-the-Data\"><a href=\"#Real-World-Example-Working-with-the-Data\" class=\"headerlink\" title=\"Real-World Example: Working with the Data\"></a>Real-World Example: Working with the Data</h2><h3 id=\"Displaying-Data-from-an-API\"><a href=\"#Displaying-Data-from-an-API\" class=\"headerlink\" title=\"Displaying Data from an API\"></a>Displaying Data from an API</h3><p>It’s pretty typical that the information we’ll need is within the response, and we’ll have to traverse what we’ve just stored to access it properly. In our case, we can see that the price information we need lives in <code>response.data.bpi</code>. If we use this instead, our output is as follows:</p>\n<pre><code class=\"hljs js\">axios\n  .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> (<span class=\"hljs-keyword\">this</span>.info = response.data.bpi))</code></pre>\n<p></p><p data-height=\"200\" data-theme-id=\"32763\" data-slug-hash=\"6100b10f1b4ac2961208643560ba7d11\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Second Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6100b10f1b4ac2961208643560ba7d11/\" target=\"_blank\" rel=\"noopener\">Second Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>This is a lot easier for us to display, so we can now update our HTML to display only the information we need from the data we’ve received, and we’ll create a <a href=\"../api/#Vue-filter\">filter</a> to make sure that the decimal is in the appropriate place as well.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Bitcoin Price Index<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"currency in info\"</span>\n    <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"currency\"</span>\n  &gt;</span>\n    &#123;&#123; currency.description &#125;&#125;:\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"lighten\"</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"currency.symbol\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; currency.rate_float | currencydecimal &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">filters: &#123;\n  currencydecimal (value) &#123;\n    <span class=\"hljs-keyword\">return</span> value.toFixed(<span class=\"hljs-number\">2</span>)\n  &#125;\n&#125;,</code></pre>\n<p></p><p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"9d59319c09eaccfaf35d9e9f11990f0f\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Third Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/9d59319c09eaccfaf35d9e9f11990f0f/\" target=\"_blank\" rel=\"noopener\">Third Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<h3 id=\"Dealing-with-Errors\"><a href=\"#Dealing-with-Errors\" class=\"headerlink\" title=\"Dealing with Errors\"></a>Dealing with Errors</h3><p>There are times when we might not get the data we need from the API. There are several reasons that our axios call might fail, including but not limited to:</p>\n<ul>\n<li>The API is down.</li>\n<li>The request was made incorrectly.</li>\n<li>The API isn’t giving us the information in the format that we anticipated.</li>\n</ul>\n<p>When making this request, we should be checking for just such circumstances, and giving ourselves information in every case so we know how to handle the problem. In an axios call, we’ll do so by using <code>catch</code>.</p>\n<pre><code class=\"hljs js\">axios\n  .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> (<span class=\"hljs-keyword\">this</span>.info = response.data.bpi))\n  .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(error))</code></pre>\n<p>This will let us know if something failed during the API request, but what if the data is mangled or the API is down? Right now the user will just see nothing. We might want to build a loader for this case, and then tell the user if we’re not able to get the data at all.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">info</span>: <span class=\"hljs-literal\">null</span>,\n      <span class=\"hljs-attr\">loading</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">errored</span>: <span class=\"hljs-literal\">false</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">filters</span>: &#123;\n    currencydecimal (value) &#123;\n      <span class=\"hljs-keyword\">return</span> value.toFixed(<span class=\"hljs-number\">2</span>)\n    &#125;\n  &#125;,\n  mounted () &#123;\n    axios\n      .get(<span class=\"hljs-string\">'https://api.coindesk.com/v1/bpi/currentprice.json'</span>)\n      .then(<span class=\"hljs-function\"><span class=\"hljs-params\">response</span> =&gt;</span> &#123;\n        <span class=\"hljs-keyword\">this</span>.info = response.data.bpi\n      &#125;)\n      .catch(<span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> &#123;\n        <span class=\"hljs-built_in\">console</span>.log(error)\n        <span class=\"hljs-keyword\">this</span>.errored = <span class=\"hljs-literal\">true</span>\n      &#125;)\n      .finally(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">this</span>.loading = <span class=\"hljs-literal\">false</span>)\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Bitcoin Price Index<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"errored\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>We're sorry, we're not able to retrieve this information at the moment, please try back later<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">section</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"loading\"</span>&gt;</span>Loading...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n      <span class=\"hljs-attr\">v-else</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"currency in info\"</span>\n      <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"currency\"</span>\n    &gt;</span>\n      &#123;&#123; currency.description &#125;&#125;:\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"lighten\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"currency.symbol\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; currency.rate_float | currencydecimal &#125;&#125;\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">section</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>You can hit the rerun button on this pen to see the loading status briefly while we gather data from the API:</p>\n<p></p><p data-height=\"300\" data-theme-id=\"32763\" data-slug-hash=\"6c01922c9af3883890fd7393e8147ec4\" data-default-tab=\"result\" data-user=\"Vue\" data-embed-version=\"2\" data-pen-title=\"Fourth Step Axios and Vue\" class=\"codepen\">See the Pen <a href=\"https://codepen.io/team/Vue/pen/6c01922c9af3883890fd7393e8147ec4/\" target=\"_blank\" rel=\"noopener\">Fourth Step Axios and Vue</a> by Vue (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.</p><p></p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n<p>This can be even further improved with the use of components for different sections and more distinct error reporting, depending on the API you’re using and the complexity of your application.</p>\n<h2 id=\"Alternative-Patterns\"><a href=\"#Alternative-Patterns\" class=\"headerlink\" title=\"Alternative Patterns\"></a>Alternative Patterns</h2><h3 id=\"Fetch-API\"><a href=\"#Fetch-API\" class=\"headerlink\" title=\"Fetch API\"></a>Fetch API</h3><p>The <a href=\"https://developers.google.com/web/updates/2015/03/introduction-to-fetch\" target=\"_blank\" rel=\"noopener\">Fetch API</a> is a powerful native API for these types of requests. You may have heard that one of the benefits of the Fetch API is that you don’t need to load an external resource in order to use it, which is true! Except… that it’s not fully supported yet, so you will still need to use a polyfill. There are also some gotchas when working with this API, which is why many prefer to use axios for now. This may very well change in the future though.</p>\n<p>If you’re interested in using the Fetch API, there are some <a href=\"https://scotch.io/@bedakb/lets-build-type-ahead-component-with-vuejs-2-and-fetch-api\" target=\"_blank\" rel=\"noopener\">very good articles</a> explaining how to do so.</p>\n<h2 id=\"Wrapping-Up\"><a href=\"#Wrapping-Up\" class=\"headerlink\" title=\"Wrapping Up\"></a>Wrapping Up</h2><p>There are many ways to work with Vue and axios beyond consuming and displaying an API. You can also communicate with Serverless Functions, post/edit/delete from an API where you have write access, and many other benefits. Due to the straightforward integration of these two libraries, it’s become a very common choice for developers who need to integrate HTTP clients into their workflow.</p>\n"},{"title":"Tween Class","type":"bytepath","order":9,"_content":"\n- tween class is a helper object that handles transitioning your animation from state A (the state of your component at the start of the animation frame)\nto state B (The state at the end of your animation frame)\n\n- you can use it to smoothly transition between Start and End state for each data point\n\n- tween methods\n    - number tweens between two numbers\n    - hex tweens between two hex strings to do colour transitions\n    -between  Value A is set at the start of the animation frame, Value B at the end \n    - lookAt acceps the ID of a dom element and smoothly transitions the camera to look at whatever you provide\n    - follow, same as look at but always keeps its distance allowing you to make a camera that follows characters (think mario games on your nintendo)\n    \n    \n- animation provides the tween class the start and end frames of the animation so that it's able to calculate smooth transitions\n\n    \n","source":"v2/bytepath/Tween Class.md","raw":"---\ntitle: Tween Class\ntype: bytepath\norder: 9\n---\n\n- tween class is a helper object that handles transitioning your animation from state A (the state of your component at the start of the animation frame)\nto state B (The state at the end of your animation frame)\n\n- you can use it to smoothly transition between Start and End state for each data point\n\n- tween methods\n    - number tweens between two numbers\n    - hex tweens between two hex strings to do colour transitions\n    -between  Value A is set at the start of the animation frame, Value B at the end \n    - lookAt acceps the ID of a dom element and smoothly transitions the camera to look at whatever you provide\n    - follow, same as look at but always keeps its distance allowing you to make a camera that follows characters (think mario games on your nintendo)\n    \n    \n- animation provides the tween class the start and end frames of the animation so that it's able to calculate smooth transitions\n\n    \n","date":"2020-09-28T11:39:37.022Z","updated":"2020-09-28T11:39:37.022Z","path":"v2/bytepath/Tween Class.html","_id":"ckfl66gy7000vc2v5ywmrnbca","comments":1,"layout":"page","content":"<ul>\n<li><p>tween class is a helper object that handles transitioning your animation from state A (the state of your component at the start of the animation frame)<br>to state B (The state at the end of your animation frame)</p>\n</li>\n<li><p>you can use it to smoothly transition between Start and End state for each data point</p>\n</li>\n<li><p>tween methods</p>\n<ul>\n<li>number tweens between two numbers</li>\n<li>hex tweens between two hex strings to do colour transitions<br>-between  Value A is set at the start of the animation frame, Value B at the end </li>\n<li>lookAt acceps the ID of a dom element and smoothly transitions the camera to look at whatever you provide</li>\n<li>follow, same as look at but always keeps its distance allowing you to make a camera that follows characters (think mario games on your nintendo)</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>animation provides the tween class the start and end frames of the animation so that it’s able to calculate smooth transitions</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>tween class is a helper object that handles transitioning your animation from state A (the state of your component at the start of the animation frame)<br>to state B (The state at the end of your animation frame)</p>\n</li>\n<li><p>you can use it to smoothly transition between Start and End state for each data point</p>\n</li>\n<li><p>tween methods</p>\n<ul>\n<li>number tweens between two numbers</li>\n<li>hex tweens between two hex strings to do colour transitions<br>-between  Value A is set at the start of the animation frame, Value B at the end </li>\n<li>lookAt acceps the ID of a dom element and smoothly transitions the camera to look at whatever you provide</li>\n<li>follow, same as look at but always keeps its distance allowing you to make a camera that follows characters (think mario games on your nintendo)</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>animation provides the tween class the start and end frames of the animation so that it’s able to calculate smooth transitions</li>\n</ul>\n"},{"title":"Animation Reuse","type":"bytepath","order":11,"_content":"\n- animations quickly make your single file components hard to read\n- Animations are just javascript so we can move them into their own files \n- provides tree shaking so that we only bundle what we need in the final project\n","source":"v2/bytepath/animationreuse.md","raw":"---\ntitle: Animation Reuse\ntype: bytepath\norder: 11\n---\n\n- animations quickly make your single file components hard to read\n- Animations are just javascript so we can move them into their own files \n- provides tree shaking so that we only bundle what we need in the final project\n","date":"2020-09-28T11:46:51.516Z","updated":"2020-09-28T11:46:51.516Z","path":"v2/bytepath/animationreuse.html","_id":"ckfl66gy7000wc2v5jfpv5wo6","comments":1,"layout":"page","content":"<ul>\n<li>animations quickly make your single file components hard to read</li>\n<li>Animations are just javascript so we can move them into their own files </li>\n<li>provides tree shaking so that we only bundle what we need in the final project</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>animations quickly make your single file components hard to read</li>\n<li>Animations are just javascript so we can move them into their own files </li>\n<li>provides tree shaking so that we only bundle what we need in the final project</li>\n</ul>\n"},{"title":"Asset Composition","type":"bytepath","order":3,"_content":"## Asset Composition\nAssets can be composed together in other components to create new assets. \n\n- AFTER YOUR ASSET RUNS ITS ANIMATIONS\n- ANY TRANSFORMATIONS BY PARENT ASSETS AND SVG TAGS WILL BE APPLIED TO YOUR ASSET\n- ALLOWS YOU TO MOVE ASSETS TOGETHER WHILE  \n\n\n## Scene Composition\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n\n## Vehicle Composition\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nIn the example below we import two sample assets, balloon and human. By including human as a slotted component on balloon, and binding the balloon's slot props, The human asset can use the balloon as a \"vehicle\", moving around the screen as a single asset. \nTry moving the sliders below and watch the assets move together. \n \n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return { x: 50, y: 0, angle: 0 };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n            human: Bytepath.samples.assets.human,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"x\" min=\"0\" max=\"100\">X = {{ x }}<br/>\n        <input type=\"range\" v-model.number=\"y\" min=\"0\" max=\"50\">Y = {{ y }}<br/>\n        <input type=\"range\" v-model.number=\"angle\" min=\"0\" max=\"360\">Angle = {{ angle }}<br/>\n\n        <!-- Here human and balloon are two distinct assets -->\n        <human :x=\"0\"  />\n        <balloon :x=\"25\"  />\n\n        <!-- Here balloon and human have been combined to make a single asset -->\n        <balloon :x=\"x\" :y=\"y\" :a=\"angle\" v-slot=\"balloon\">\n            <human :position=\"balloon.position\" :sx=\"2\" :sy=\"2\" aspect=\"xMidYMax meet\"/>\n        </balloon>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"a5\" class=\"demo\">\n    <asset-composition />\n</div>\n<script>\nvar app5 = new window.vueapp({ el: '#a5' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">I</p>\n\n## How This Works\n\n## Asset Slots\n\n## Passing keyframe & slot props To Children components\nThe keyframe value that a component receives can be forwarded along to any child components that you want to animate. \n","source":"v2/bytepath/assetcomposition.md","raw":"---\ntitle: Asset Composition\ntype: bytepath\norder: 3\n---\n## Asset Composition\nAssets can be composed together in other components to create new assets. \n\n- AFTER YOUR ASSET RUNS ITS ANIMATIONS\n- ANY TRANSFORMATIONS BY PARENT ASSETS AND SVG TAGS WILL BE APPLIED TO YOUR ASSET\n- ALLOWS YOU TO MOVE ASSETS TOGETHER WHILE  \n\n\n## Scene Composition\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n\n## Vehicle Composition\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nIn the example below we import two sample assets, balloon and human. By including human as a slotted component on balloon, and binding the balloon's slot props, The human asset can use the balloon as a \"vehicle\", moving around the screen as a single asset. \nTry moving the sliders below and watch the assets move together. \n \n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return { x: 50, y: 0, angle: 0 };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n            human: Bytepath.samples.assets.human,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"x\" min=\"0\" max=\"100\">X = {{ x }}<br/>\n        <input type=\"range\" v-model.number=\"y\" min=\"0\" max=\"50\">Y = {{ y }}<br/>\n        <input type=\"range\" v-model.number=\"angle\" min=\"0\" max=\"360\">Angle = {{ angle }}<br/>\n\n        <!-- Here human and balloon are two distinct assets -->\n        <human :x=\"0\"  />\n        <balloon :x=\"25\"  />\n\n        <!-- Here balloon and human have been combined to make a single asset -->\n        <balloon :x=\"x\" :y=\"y\" :a=\"angle\" v-slot=\"balloon\">\n            <human :position=\"balloon.position\" :sx=\"2\" :sy=\"2\" aspect=\"xMidYMax meet\"/>\n        </balloon>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"a5\" class=\"demo\">\n    <asset-composition />\n</div>\n<script>\nvar app5 = new window.vueapp({ el: '#a5' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">I</p>\n\n## How This Works\n\n## Asset Slots\n\n## Passing keyframe & slot props To Children components\nThe keyframe value that a component receives can be forwarded along to any child components that you want to animate. \n","date":"2020-09-27T13:43:29.068Z","updated":"2020-09-27T13:43:29.068Z","path":"v2/bytepath/assetcomposition.html","comments":1,"layout":"page","_id":"ckfl66gy7000xc2v5fhwvb0i0","content":"<h2 id=\"Asset-Composition\"><a href=\"#Asset-Composition\" class=\"headerlink\" title=\"Asset Composition\"></a>Asset Composition</h2><p>Assets can be composed together in other components to create new assets. </p>\n<ul>\n<li>AFTER YOUR ASSET RUNS ITS ANIMATIONS</li>\n<li>ANY TRANSFORMATIONS BY PARENT ASSETS AND SVG TAGS WILL BE APPLIED TO YOUR ASSET</li>\n<li>ALLOWS YOU TO MOVE ASSETS TOGETHER WHILE  </li>\n</ul>\n<h2 id=\"Scene-Composition\"><a href=\"#Scene-Composition\" class=\"headerlink\" title=\"Scene Composition\"></a>Scene Composition</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n\n<h2 id=\"Vehicle-Composition\"><a href=\"#Vehicle-Composition\" class=\"headerlink\" title=\"Vehicle Composition\"></a>Vehicle Composition</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>In the example below we import two sample assets, balloon and human. By including human as a slotted component on balloon, and binding the balloon’s slot props, The human asset can use the balloon as a “vehicle”, moving around the screen as a single asset.<br>Try moving the sliders below and watch the assets move together. </p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">50</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">angle</span>: <span class=\"hljs-number\">0</span> &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n            <span class=\"hljs-attr\">human</span>: Bytepath.samples.assets.human,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>X = &#123;&#123; x &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"y\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"50\"</span>&gt;</span>Y = &#123;&#123; y &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"angle\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"360\"</span>&gt;</span>Angle = &#123;&#123; angle &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n\n        <span class=\"hljs-comment\">&lt;!-- Here human and balloon are two distinct assets --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">human</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"0\"</span>  /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"25\"</span>  /&gt;</span>\n\n        <span class=\"hljs-comment\">&lt;!-- Here balloon and human have been combined to make a single asset --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"y\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"angle\"</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"balloon\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">human</span> <span class=\"hljs-attr\">:position</span>=<span class=\"hljs-string\">\"balloon.position\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">aspect</span>=<span class=\"hljs-string\">\"xMidYMax meet\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">balloon</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n\n<div id=\"a5\" class=\"demo\">\n    <asset-composition>\n</asset-composition></div>\n<script>\nvar app5 = new window.vueapp({ el: '#a5' })\n</script>\n\n<p class=\"tip success\">I</p>\n\n<h2 id=\"How-This-Works\"><a href=\"#How-This-Works\" class=\"headerlink\" title=\"How This Works\"></a>How This Works</h2><h2 id=\"Asset-Slots\"><a href=\"#Asset-Slots\" class=\"headerlink\" title=\"Asset Slots\"></a>Asset Slots</h2><h2 id=\"Passing-keyframe-amp-slot-props-To-Children-components\"><a href=\"#Passing-keyframe-amp-slot-props-To-Children-components\" class=\"headerlink\" title=\"Passing keyframe &amp; slot props To Children components\"></a>Passing keyframe &amp; slot props To Children components</h2><p>The keyframe value that a component receives can be forwarded along to any child components that you want to animate. </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Asset-Composition\"><a href=\"#Asset-Composition\" class=\"headerlink\" title=\"Asset Composition\"></a>Asset Composition</h2><p>Assets can be composed together in other components to create new assets. </p>\n<ul>\n<li>AFTER YOUR ASSET RUNS ITS ANIMATIONS</li>\n<li>ANY TRANSFORMATIONS BY PARENT ASSETS AND SVG TAGS WILL BE APPLIED TO YOUR ASSET</li>\n<li>ALLOWS YOU TO MOVE ASSETS TOGETHER WHILE  </li>\n</ul>\n<h2 id=\"Scene-Composition\"><a href=\"#Scene-Composition\" class=\"headerlink\" title=\"Scene Composition\"></a>Scene Composition</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n\n<h2 id=\"Vehicle-Composition\"><a href=\"#Vehicle-Composition\" class=\"headerlink\" title=\"Vehicle Composition\"></a>Vehicle Composition</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>In the example below we import two sample assets, balloon and human. By including human as a slotted component on balloon, and binding the balloon’s slot props, The human asset can use the balloon as a “vehicle”, moving around the screen as a single asset.<br>Try moving the sliders below and watch the assets move together. </p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">50</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">angle</span>: <span class=\"hljs-number\">0</span> &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n            <span class=\"hljs-attr\">human</span>: Bytepath.samples.assets.human,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>X = &#123;&#123; x &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"y\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"50\"</span>&gt;</span>Y = &#123;&#123; y &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"angle\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"360\"</span>&gt;</span>Angle = &#123;&#123; angle &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n\n        <span class=\"hljs-comment\">&lt;!-- Here human and balloon are two distinct assets --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">human</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"0\"</span>  /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"25\"</span>  /&gt;</span>\n\n        <span class=\"hljs-comment\">&lt;!-- Here balloon and human have been combined to make a single asset --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"y\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"angle\"</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"balloon\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">human</span> <span class=\"hljs-attr\">:position</span>=<span class=\"hljs-string\">\"balloon.position\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">aspect</span>=<span class=\"hljs-string\">\"xMidYMax meet\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">balloon</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n\n<div id=\"a5\" class=\"demo\">\n    <asset-composition>\n</asset-composition></div>\n<script>\nvar app5 = new window.vueapp({ el: '#a5' })\n</script>\n\n<p class=\"tip success\">I</p>\n\n<h2 id=\"How-This-Works\"><a href=\"#How-This-Works\" class=\"headerlink\" title=\"How This Works\"></a>How This Works</h2><h2 id=\"Asset-Slots\"><a href=\"#Asset-Slots\" class=\"headerlink\" title=\"Asset Slots\"></a>Asset Slots</h2><h2 id=\"Passing-keyframe-amp-slot-props-To-Children-components\"><a href=\"#Passing-keyframe-amp-slot-props-To-Children-components\" class=\"headerlink\" title=\"Passing keyframe &amp; slot props To Children components\"></a>Passing keyframe &amp; slot props To Children components</h2><p>The keyframe value that a component receives can be forwarded along to any child components that you want to animate. </p>\n"},{"title":"Asset Reuse","type":"bytepath","order":7,"_content":"","source":"v2/bytepath/assetreuse.md","raw":"---\ntitle: Asset Reuse\ntype: bytepath\norder: 7\n---\n","date":"2020-09-27T13:46:30.968Z","updated":"2020-09-27T13:46:30.968Z","path":"v2/bytepath/assetreuse.html","comments":1,"layout":"page","_id":"ckfl66gy8000yc2v5978dyfog","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Basic Animations","type":"bytepath","order":2,"_content":"## Prototyping With Inline Animations\n - !!!Quickly try things with props\n - !!!Why this doesnt scale \n\n## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return { x: 1, y: 1 };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"x\" min=\"0\" max=\"100\" />X = {{ x }}<br/>\n        <input type=\"range\" v-model.number=\"y\" min=\"0\" max=\"100\" />Y = {{ y }}<br/>\n        <balloon :x=\"x\" :y=\"y\"/>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"app1\" class=\"demo\">\n    <anim-trans />\n</div>\n<script>\nvar app1 = new window.vueapp({ el: '#app1' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return {\n                sx: 1,\n                sy: 1,\n            };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"sx\" min=\"0\" max=\"4\">Scale X = {{ sx }}<br/>\n        <input type=\"range\" v-model.number=\"sy\" min=\"0\" max=\"4\">Scale Y = {{ sy }}<br/>\n        <balloon :sx=\"sx\" :sy=\"sy\"/>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <anim-scale />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation Around the Z axis\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return { angle: 0 };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"angle\" min=\"0\" max=\"360\">Angle = {{ angle }}\n        <svg width=\"100%\" height=\"100%\">\n            <!-- Rotates in a circle starting at 0 Deg -->\n            <balloon :a=\"angle % 360\"/>\n\n            <!-- Rotates in a circle starting at 45 Deg -->\n            <balloon color=\"blue\" :a=\"(45 + angle) % 360\" :x=\"125\"/>\n\n            <!-- Rotates in a circle starting at 90 Deg -->\n            <balloon color=\"green\" :a=\"(90 + angle) % 360\" :x=\"225\"/>\n\n            <!-- Rotates in a circle starting at 200 Deg -->\n            <balloon color=\"orange\" :a=\"(200 + angle) % 360\" :x=\"325\"/>\n        </svg>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rot-prop\" class=\"demo\">\n    <anim-rotate />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rot-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n<div style=\"height:100px\" />\n","source":"v2/bytepath/basicanimations.md","raw":"---\ntitle: Basic Animations\ntype: bytepath\norder: 2\n---\n## Prototyping With Inline Animations\n - !!!Quickly try things with props\n - !!!Why this doesnt scale \n\n## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return { x: 1, y: 1 };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"x\" min=\"0\" max=\"100\" />X = {{ x }}<br/>\n        <input type=\"range\" v-model.number=\"y\" min=\"0\" max=\"100\" />Y = {{ y }}<br/>\n        <balloon :x=\"x\" :y=\"y\"/>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"app1\" class=\"demo\">\n    <anim-trans />\n</div>\n<script>\nvar app1 = new window.vueapp({ el: '#app1' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return {\n                sx: 1,\n                sy: 1,\n            };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"sx\" min=\"0\" max=\"4\">Scale X = {{ sx }}<br/>\n        <input type=\"range\" v-model.number=\"sy\" min=\"0\" max=\"4\">Scale Y = {{ sy }}<br/>\n        <balloon :sx=\"sx\" :sy=\"sy\"/>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <anim-scale />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation Around the Z axis\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return { angle: 0 };\n        },\n\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        }\n    }\n</script>\n\n<template>\n    <div>\n        <input type=\"range\" v-model.number=\"angle\" min=\"0\" max=\"360\">Angle = {{ angle }}\n        <svg width=\"100%\" height=\"100%\">\n            <!-- Rotates in a circle starting at 0 Deg -->\n            <balloon :a=\"angle % 360\"/>\n\n            <!-- Rotates in a circle starting at 45 Deg -->\n            <balloon color=\"blue\" :a=\"(45 + angle) % 360\" :x=\"125\"/>\n\n            <!-- Rotates in a circle starting at 90 Deg -->\n            <balloon color=\"green\" :a=\"(90 + angle) % 360\" :x=\"225\"/>\n\n            <!-- Rotates in a circle starting at 200 Deg -->\n            <balloon color=\"orange\" :a=\"(200 + angle) % 360\" :x=\"325\"/>\n        </svg>\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rot-prop\" class=\"demo\">\n    <anim-rotate />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rot-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n<div style=\"height:100px\" />\n","date":"2020-09-27T13:28:36.780Z","updated":"2020-09-27T13:28:36.780Z","path":"v2/bytepath/basicanimations.html","comments":1,"layout":"page","_id":"ckfl66gy8000zc2v5z8epcieg","content":"<h2 id=\"Prototyping-With-Inline-Animations\"><a href=\"#Prototyping-With-Inline-Animations\" class=\"headerlink\" title=\"Prototyping With Inline Animations\"></a>Prototyping With Inline Animations</h2><ul>\n<li>!!!Quickly try things with props</li>\n<li>!!!Why this doesnt scale </li>\n</ul>\n<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">1</span> &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"100\"</span> /&gt;</span>X = &#123;&#123; x &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"y\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"100\"</span> /&gt;</span>Y = &#123;&#123; y &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"y\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"app1\" class=\"demo\">\n    <anim-trans>\n</anim-trans></div>\n<script>\nvar app1 = new window.vueapp({ el: '#app1' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123;\n                <span class=\"hljs-attr\">sx</span>: <span class=\"hljs-number\">1</span>,\n                <span class=\"hljs-attr\">sy</span>: <span class=\"hljs-number\">1</span>,\n            &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"sx\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"4\"</span>&gt;</span>Scale X = &#123;&#123; sx &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"sy\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"4\"</span>&gt;</span>Scale Y = &#123;&#123; sy &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"sx\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"sy\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <anim-scale>\n</anim-scale></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation Around the Z axis”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">angle</span>: <span class=\"hljs-number\">0</span> &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"angle\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"360\"</span>&gt;</span>Angle = &#123;&#123; angle &#125;&#125;\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 0 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"angle % 360\"</span>/&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 45 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"blue\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"(45 + angle) % 360\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>/&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 90 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"green\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"(90 + angle) % 360\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>/&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 200 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"orange\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"(200 + angle) % 360\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rot-prop\" class=\"demo\">\n    <anim-rotate>\n</anim-rotate></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rot-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<div style=\"height:100px\">\n</div>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Prototyping-With-Inline-Animations\"><a href=\"#Prototyping-With-Inline-Animations\" class=\"headerlink\" title=\"Prototyping With Inline Animations\"></a>Prototyping With Inline Animations</h2><ul>\n<li>!!!Quickly try things with props</li>\n<li>!!!Why this doesnt scale </li>\n</ul>\n<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">x</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">y</span>: <span class=\"hljs-number\">1</span> &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"100\"</span> /&gt;</span>X = &#123;&#123; x &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"y\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"100\"</span> /&gt;</span>Y = &#123;&#123; y &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"x\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"y\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"app1\" class=\"demo\">\n    <anim-trans>\n</anim-trans></div>\n<script>\nvar app1 = new window.vueapp({ el: '#app1' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123;\n                <span class=\"hljs-attr\">sx</span>: <span class=\"hljs-number\">1</span>,\n                <span class=\"hljs-attr\">sy</span>: <span class=\"hljs-number\">1</span>,\n            &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"sx\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"4\"</span>&gt;</span>Scale X = &#123;&#123; sx &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"sy\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"4\"</span>&gt;</span>Scale Y = &#123;&#123; sy &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"sx\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"sy\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <anim-scale>\n</anim-scale></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation Around the Z axis”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        data() &#123;\n            <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">angle</span>: <span class=\"hljs-number\">0</span> &#125;;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"angle\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"360\"</span>&gt;</span>Angle = &#123;&#123; angle &#125;&#125;\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 0 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"angle % 360\"</span>/&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 45 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"blue\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"(45 + angle) % 360\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>/&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 90 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"green\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"(90 + angle) % 360\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>/&gt;</span>\n\n            <span class=\"hljs-comment\">&lt;!-- Rotates in a circle starting at 200 Deg --&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"orange\"</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"(200 + angle) % 360\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rot-prop\" class=\"demo\">\n    <anim-rotate>\n</anim-rotate></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rot-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<div style=\"height:100px\">\n</div>"},{"title":"Basic Transformations","type":"bytepath","order":1,"_content":"## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <vector>\n            <rect width=\"50\" height=\"50\" fill=\"red\" />\n        </vector>\n        \n        <vector :x=\"100\" :sx=\"2\" :sy=\"2\">\n            <rect width=\"50\" height=\"50\" fill=\"blue\" />\n        </vector>\n        \n        <vector :x=\"275\" :sx=\"4\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"green\" />\n        </vector>\n        \n        <vector :x=\"425\" :sx=\"0.5\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"orange\" />\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <g transform=\"translate(0, 50)\">\n            <vector>\n                <rect width=\"100\" height=\"50\" fill=\"red\"/>\n            </vector>\n            <vector :a=\"45\" :x=\"125\">\n                <rect width=\"100\" height=\"50\" fill=\"blue\"/>\n            </vector>\n\n            <vector :a=\"90\" :x=\"225\">\n                <rect width=\"100\" height=\"50\" fill=\"green\"/>\n            </vector>\n\n            <vector :a=\"200\" :x=\"325\">\n                <rect width=\"100\" height=\"50\" fill=\"orange\"/>\n            </vector>\n        </g>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Width & Height Props\n\n<p class=\"tip\">CURRENTLY BROKEN</p>\n\nModifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"500\" height=\"100\">\n        <vector :width=\"10\" :height=\"10\">\n            <rect width=\"100\" height=\"50\" fill=\"red\"/>\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to \"None\" meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<br />\n","source":"v2/bytepath/basictransformations.md","raw":"---\ntitle: Basic Transformations\ntype: bytepath\norder: 1\n---\n## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <vector>\n            <rect width=\"50\" height=\"50\" fill=\"red\" />\n        </vector>\n        \n        <vector :x=\"100\" :sx=\"2\" :sy=\"2\">\n            <rect width=\"50\" height=\"50\" fill=\"blue\" />\n        </vector>\n        \n        <vector :x=\"275\" :sx=\"4\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"green\" />\n        </vector>\n        \n        <vector :x=\"425\" :sx=\"0.5\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"orange\" />\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <g transform=\"translate(0, 50)\">\n            <vector>\n                <rect width=\"100\" height=\"50\" fill=\"red\"/>\n            </vector>\n            <vector :a=\"45\" :x=\"125\">\n                <rect width=\"100\" height=\"50\" fill=\"blue\"/>\n            </vector>\n\n            <vector :a=\"90\" :x=\"225\">\n                <rect width=\"100\" height=\"50\" fill=\"green\"/>\n            </vector>\n\n            <vector :a=\"200\" :x=\"325\">\n                <rect width=\"100\" height=\"50\" fill=\"orange\"/>\n            </vector>\n        </g>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Width & Height Props\n\n<p class=\"tip\">CURRENTLY BROKEN</p>\n\nModifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"500\" height=\"100\">\n        <vector :width=\"10\" :height=\"10\">\n            <rect width=\"100\" height=\"50\" fill=\"red\"/>\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to \"None\" meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<br />\n","date":"2020-09-27T12:53:22.315Z","updated":"2020-09-27T12:53:22.315Z","path":"v2/bytepath/basictransformations.html","comments":1,"layout":"page","_id":"ckfl66gy80010c2v58x9jbx3f","content":"<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"275\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"4\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"425\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"0.5\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props>\n</vector-rect-scale-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">\"translate(0, 50)\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"45\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"90\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"200\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props>\n</vector-rect-rotate-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Width-amp-Height-Props\"><a href=\"#Width-amp-Height-Props\" class=\"headerlink\" title=\"Width &amp; Height Props\"></a>Width &amp; Height Props</h2><p class=\"tip\">CURRENTLY BROKEN</p>\n\n<p>Modifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"500\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props>\n</vector-wh-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to “None” meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<p><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"275\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"4\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"425\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"0.5\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props>\n</vector-rect-scale-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">\"translate(0, 50)\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"45\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"90\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"200\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props>\n</vector-rect-rotate-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Width-amp-Height-Props\"><a href=\"#Width-amp-Height-Props\" class=\"headerlink\" title=\"Width &amp; Height Props\"></a>Width &amp; Height Props</h2><p class=\"tip\">CURRENTLY BROKEN</p>\n\n<p>Modifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"500\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props>\n</vector-wh-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to “None” meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<p><br></p>\n"},{"title":"Fast Forward and Rewinding","type":"bytepath","order":10,"_content":"\n- we need to ensure that each animation frame has completed before moving on to the next\n\n- to rewind we need to make sure we end up in the exact same state as we were previous\n\n- can do this by fast forwarding and rewinding\n\n- rewind your animation is passed a tween class that forces the current frame to be the START frame of your animation. This will force the tween class to rewind the animation\n- fastforward your animation is passed a tween class that forces the current frame to be the END frame of your animation. This will force the tween class to fast forward the animation\n- reset function that you can call during repeats if you want to \n","source":"v2/bytepath/fastforwardandrewind.md","raw":"---\ntitle: Fast Forward and Rewinding\ntype: bytepath\norder: 10\n---\n\n- we need to ensure that each animation frame has completed before moving on to the next\n\n- to rewind we need to make sure we end up in the exact same state as we were previous\n\n- can do this by fast forwarding and rewinding\n\n- rewind your animation is passed a tween class that forces the current frame to be the START frame of your animation. This will force the tween class to rewind the animation\n- fastforward your animation is passed a tween class that forces the current frame to be the END frame of your animation. This will force the tween class to fast forward the animation\n- reset function that you can call during repeats if you want to \n","date":"2020-09-28T11:43:21.965Z","updated":"2020-09-28T11:43:21.965Z","path":"v2/bytepath/fastforwardandrewind.html","_id":"ckfl66gy90011c2v5i7adg8n3","comments":1,"layout":"page","content":"<ul>\n<li><p>we need to ensure that each animation frame has completed before moving on to the next</p>\n</li>\n<li><p>to rewind we need to make sure we end up in the exact same state as we were previous</p>\n</li>\n<li><p>can do this by fast forwarding and rewinding</p>\n</li>\n<li><p>rewind your animation is passed a tween class that forces the current frame to be the START frame of your animation. This will force the tween class to rewind the animation</p>\n</li>\n<li>fastforward your animation is passed a tween class that forces the current frame to be the END frame of your animation. This will force the tween class to fast forward the animation</li>\n<li>reset function that you can call during repeats if you want to </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>we need to ensure that each animation frame has completed before moving on to the next</p>\n</li>\n<li><p>to rewind we need to make sure we end up in the exact same state as we were previous</p>\n</li>\n<li><p>can do this by fast forwarding and rewinding</p>\n</li>\n<li><p>rewind your animation is passed a tween class that forces the current frame to be the START frame of your animation. This will force the tween class to rewind the animation</p>\n</li>\n<li>fastforward your animation is passed a tween class that forces the current frame to be the END frame of your animation. This will force the tween class to fast forward the animation</li>\n<li>reset function that you can call during repeats if you want to </li>\n</ul>\n"},{"title":"Garbage Dump","type":"bytepath","order":98,"_content":"","source":"v2/bytepath/homeless.md","raw":"---\ntitle: Garbage Dump\ntype: bytepath\norder: 98\n---\n","date":"2020-09-27T12:55:14.652Z","updated":"2020-09-27T12:54:19.727Z","path":"v2/bytepath/homeless.html","comments":1,"layout":"page","_id":"ckfl66gy90012c2v52blyfnmx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Camera Control","type":"bytepath","order":5,"_content":"## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <vector>\n            <rect width=\"50\" height=\"50\" fill=\"red\" />\n        </vector>\n        \n        <vector :x=\"100\" :sx=\"2\" :sy=\"2\">\n            <rect width=\"50\" height=\"50\" fill=\"blue\" />\n        </vector>\n        \n        <vector :x=\"275\" :sx=\"4\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"green\" />\n        </vector>\n        \n        <vector :x=\"425\" :sx=\"0.5\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"orange\" />\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <g transform=\"translate(0, 50)\">\n            <vector>\n                <rect width=\"100\" height=\"50\" fill=\"red\"/>\n            </vector>\n            <vector :a=\"45\" :x=\"125\">\n                <rect width=\"100\" height=\"50\" fill=\"blue\"/>\n            </vector>\n\n            <vector :a=\"90\" :x=\"225\">\n                <rect width=\"100\" height=\"50\" fill=\"green\"/>\n            </vector>\n\n            <vector :a=\"200\" :x=\"325\">\n                <rect width=\"100\" height=\"50\" fill=\"orange\"/>\n            </vector>\n        </g>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Width & Height Props\n\n<p class=\"tip\">CURRENTLY BROKEN</p>\n\nModifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"500\" height=\"100\">\n        <vector :width=\"10\" :height=\"10\">\n            <rect width=\"100\" height=\"50\" fill=\"red\"/>\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to \"None\" meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<br />\n","source":"v2/bytepath/cameracontrol.md","raw":"---\ntitle: Camera Control\ntype: bytepath\norder: 5\n---\n## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <vector>\n            <rect width=\"50\" height=\"50\" fill=\"red\" />\n        </vector>\n        \n        <vector :x=\"100\" :sx=\"2\" :sy=\"2\">\n            <rect width=\"50\" height=\"50\" fill=\"blue\" />\n        </vector>\n        \n        <vector :x=\"275\" :sx=\"4\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"green\" />\n        </vector>\n        \n        <vector :x=\"425\" :sx=\"0.5\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"orange\" />\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <g transform=\"translate(0, 50)\">\n            <vector>\n                <rect width=\"100\" height=\"50\" fill=\"red\"/>\n            </vector>\n            <vector :a=\"45\" :x=\"125\">\n                <rect width=\"100\" height=\"50\" fill=\"blue\"/>\n            </vector>\n\n            <vector :a=\"90\" :x=\"225\">\n                <rect width=\"100\" height=\"50\" fill=\"green\"/>\n            </vector>\n\n            <vector :a=\"200\" :x=\"325\">\n                <rect width=\"100\" height=\"50\" fill=\"orange\"/>\n            </vector>\n        </g>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Width & Height Props\n\n<p class=\"tip\">CURRENTLY BROKEN</p>\n\nModifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"500\" height=\"100\">\n        <vector :width=\"10\" :height=\"10\">\n            <rect width=\"100\" height=\"50\" fill=\"red\"/>\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to \"None\" meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<br />\n","date":"2020-09-27T13:48:43.898Z","updated":"2020-09-27T13:48:43.898Z","path":"v2/bytepath/cameracontrol.html","comments":1,"layout":"page","_id":"ckfl66gy90013c2v5azg3aih8","content":"<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"275\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"4\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"425\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"0.5\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props>\n</vector-rect-scale-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">\"translate(0, 50)\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"45\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"90\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"200\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props>\n</vector-rect-rotate-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Width-amp-Height-Props\"><a href=\"#Width-amp-Height-Props\" class=\"headerlink\" title=\"Width &amp; Height Props\"></a>Width &amp; Height Props</h2><p class=\"tip\">CURRENTLY BROKEN</p>\n\n<p>Modifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"500\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props>\n</vector-wh-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to “None” meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<p><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"275\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"4\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"425\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"0.5\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props>\n</vector-rect-scale-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">\"translate(0, 50)\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"45\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"90\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"200\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props>\n</vector-rect-rotate-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Width-amp-Height-Props\"><a href=\"#Width-amp-Height-Props\" class=\"headerlink\" title=\"Width &amp; Height Props\"></a>Width &amp; Height Props</h2><p class=\"tip\">CURRENTLY BROKEN</p>\n\n<p>Modifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"500\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props>\n</vector-wh-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to “None” meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<p><br></p>\n"},{"title":"DOM Transformations","type":"bytepath","order":100,"_content":"## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <vector>\n            <rect width=\"50\" height=\"50\" fill=\"red\" />\n        </vector>\n        \n        <vector :x=\"100\" :sx=\"2\" :sy=\"2\">\n            <rect width=\"50\" height=\"50\" fill=\"blue\" />\n        </vector>\n        \n        <vector :x=\"275\" :sx=\"4\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"green\" />\n        </vector>\n        \n        <vector :x=\"425\" :sx=\"0.5\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"orange\" />\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <g transform=\"translate(0, 50)\">\n            <vector>\n                <rect width=\"100\" height=\"50\" fill=\"red\"/>\n            </vector>\n            <vector :a=\"45\" :x=\"125\">\n                <rect width=\"100\" height=\"50\" fill=\"blue\"/>\n            </vector>\n\n            <vector :a=\"90\" :x=\"225\">\n                <rect width=\"100\" height=\"50\" fill=\"green\"/>\n            </vector>\n\n            <vector :a=\"200\" :x=\"325\">\n                <rect width=\"100\" height=\"50\" fill=\"orange\"/>\n            </vector>\n        </g>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Width & Height Props\n\n<p class=\"tip\">CURRENTLY BROKEN</p>\n\nModifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"500\" height=\"100\">\n        <vector :width=\"10\" :height=\"10\">\n            <rect width=\"100\" height=\"50\" fill=\"red\"/>\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to \"None\" meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<br />\n","source":"v2/bytepath/domtransformations.md","raw":"---\ntitle: DOM Transformations\ntype: bytepath\norder: 100\n---\n## Translations Along X & Y Axis\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBy modifying the **:X** and **:Y** props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a \"Translation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Scale Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can increase or decrease the size of our &lt;vector&gt; by modifying the **:SX** and **:SY** props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a \"Scale Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <vector>\n            <rect width=\"50\" height=\"50\" fill=\"red\" />\n        </vector>\n        \n        <vector :x=\"100\" :sx=\"2\" :sy=\"2\">\n            <rect width=\"50\" height=\"50\" fill=\"blue\" />\n        </vector>\n        \n        <vector :x=\"275\" :sx=\"4\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"green\" />\n        </vector>\n        \n        <vector :x=\"425\" :sx=\"0.5\" :sy=\"3\">\n            <rect width=\"50\" height=\"50\" fill=\"orange\" />\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Rotation Transformations\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can rotate our &lt;vector&gt; components by modifying the **:A** prop. In the world of computer graphics, changing the position of an element is referred to as a \"Rotation Transformation\"\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"100%\" height=\"100%\">\n        <g transform=\"translate(0, 50)\">\n            <vector>\n                <rect width=\"100\" height=\"50\" fill=\"red\"/>\n            </vector>\n            <vector :a=\"45\" :x=\"125\">\n                <rect width=\"100\" height=\"50\" fill=\"blue\"/>\n            </vector>\n\n            <vector :a=\"90\" :x=\"225\">\n                <rect width=\"100\" height=\"50\" fill=\"green\"/>\n            </vector>\n\n            <vector :a=\"200\" :x=\"325\">\n                <rect width=\"100\" height=\"50\" fill=\"orange\"/>\n            </vector>\n        </g>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<br />\n\n## Width & Height Props\n\n<p class=\"tip\">CURRENTLY BROKEN</p>\n\nModifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <svg width=\"500\" height=\"100\">\n        <vector :width=\"10\" :height=\"10\">\n            <rect width=\"100\" height=\"50\" fill=\"red\"/>\n        </vector>\n    </svg>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to \"None\" meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<br />\n","date":"2020-09-27T13:34:45.618Z","updated":"2020-09-27T13:34:45.618Z","path":"v2/bytepath/domtransformations.html","comments":1,"layout":"page","_id":"ckfl66gy90014c2v5myh16k1j","content":"<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"275\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"4\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"425\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"0.5\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props>\n</vector-rect-scale-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">\"translate(0, 50)\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"45\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"90\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"200\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props>\n</vector-rect-rotate-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Width-amp-Height-Props\"><a href=\"#Width-amp-Height-Props\" class=\"headerlink\" title=\"Width &amp; Height Props\"></a>Width &amp; Height Props</h2><p class=\"tip\">CURRENTLY BROKEN</p>\n\n<p>Modifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"500\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props>\n</vector-wh-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to “None” meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<p><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Translations-Along-X-amp-Y-Axis\"><a href=\"#Translations-Along-X-amp-Y-Axis\" class=\"headerlink\" title=\"Translations Along X &amp; Y Axis\"></a>Translations Along X &amp; Y Axis</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>By modifying the <strong>:X</strong> and <strong>:Y</strong> props of the &lt;vector&gt; we created in the previous example, we can move our rectangle around the screen. In the world of computer graphics, changing the position of an element is referred to as a “Translation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:y</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Scale-Transformations\"><a href=\"#Scale-Transformations\" class=\"headerlink\" title=\"Scale Transformations\"></a>Scale Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can increase or decrease the size of our &lt;vector&gt; by modifying the <strong>:SX</strong> and <strong>:SY</strong> props of the &lt;vector&gt; component. In the world of computer graphics, changing the position of an element is referred to as a “Scale Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"2\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"2\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"275\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"4\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        \n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"425\"</span> <span class=\"hljs-attr\">:sx</span>=<span class=\"hljs-string\">\"0.5\"</span> <span class=\"hljs-attr\">:sy</span>=<span class=\"hljs-string\">\"3\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-scale-prop\" class=\"demo\">\n    <vector-rect-scale-props>\n</vector-rect-scale-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-scale-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Rotation-Transformations\"><a href=\"#Rotation-Transformations\" class=\"headerlink\" title=\"Rotation Transformations\"></a>Rotation Transformations</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can rotate our &lt;vector&gt; components by modifying the <strong>:A</strong> prop. In the world of computer graphics, changing the position of an element is referred to as a “Rotation Transformation”<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100%\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100%\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">g</span> <span class=\"hljs-attr\">transform</span>=<span class=\"hljs-string\">\"translate(0, 50)\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"45\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"125\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"90\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"225\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:a</span>=<span class=\"hljs-string\">\"200\"</span> <span class=\"hljs-attr\">:x</span>=<span class=\"hljs-string\">\"325\"</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span>/&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">g</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-rotate-prop\" class=\"demo\">\n    <vector-rect-rotate-props>\n</vector-rect-rotate-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-rotate-prop' })\n</script>\n\n<p class=\"tip success\">Note that because we are using vector graphics, we can increase the size of our graphics as much as we want without losing detail or increasing our memory footprint.</p> \n\n<p><br></p>\n<h2 id=\"Width-amp-Height-Props\"><a href=\"#Width-amp-Height-Props\" class=\"headerlink\" title=\"Width &amp; Height Props\"></a>Width &amp; Height Props</h2><p class=\"tip\">CURRENTLY BROKEN</p>\n\n<p>Modifying the :width and :height props of a vector will override its internal size and force the image to be the provided dimensions.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"500\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"100\"</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span> <span class=\"hljs-attr\">:width</span>=<span class=\"hljs-string\">\"10\"</span> <span class=\"hljs-attr\">:height</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"100\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect-eh-prop\" class=\"demo\">\n    <vector-wh-props>\n</vector-wh-props></div>\n<script>\nvar app4 = new window.vueapp({ el: '#vector-rect-eh-prop' })\n</script>\n\n<p class=\"tip\">When manually setting width and height props, the preserveAspectRatio value of the SVGElement is set to “None” meaning you can and will end up with some strangely scaled images if you just enter random values here</p> \n\n<p><br></p>\n"},{"title":"Importing Art Assets","type":"bytepath","order":6,"_content":"## Loading SVG Files\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can import art assets from normal SVG files created by any illustration program. Just profile a path to the file to the :src prop of the &lt;vector&gt; component and bytepath will handle loading this file for you\n```\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Files loaded only once\nBytepath will only make a request for an individual file once then cache the returned result. This means that if multiple assets in your application use the same image, we dont need to make multiple requests to the server\n\n## Loading Individual layers\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBytepath can pull individual layers out of your SVG files to use as discrete assets. just pass the XML tag id of the layer you want to load to the :layer prop of the vector component.\nThis means that artists can simply draw all the assets for your animation in a single file, with each piece of the scene being it's own layer. \nExample: If you were making a highway scene you could draw all of the different cars in a single file, then pull out each car as individual assets.  \n\n## Use Webpack to manage your image files\n- If you are using webpack (if you used the suggested vue CLI package to create your site then yes, you are) the suggested way of loading files is to import them in your vue files, then pass the \nimported file to the src attribute. By doing it this way not only is your code cleaner but webpack will \"tree shake\" your images, meaning your final bundle only includes what you need\n\n\n## Notes about loading files\n    - vector does not load the file instead emitting a request to someone else to handle this\n    - vector does not make a copy of the file instead, uses the SVG &lt;use&gt; and &lt;symbol&gt;tag to handle making a clone of an asset in the shadow root of the DOM\n    - if you don't have an asset loader middleware files wont load  \n","source":"v2/bytepath/importingassets.md","raw":"---\ntitle: Importing Art Assets\ntype: bytepath\norder: 6\n---\n## Loading SVG Files\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nWe can import art assets from normal SVG files created by any illustration program. Just profile a path to the file to the :src prop of the &lt;vector&gt; component and bytepath will handle loading this file for you\n```\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector :x=\"100\" :y=\"100\">\n        <rect width=\"50\" height=\"50\" fill=\"red\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props />\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n{% endraw %}\n\n<br />\n\n## Files loaded only once\nBytepath will only make a request for an individual file once then cache the returned result. This means that if multiple assets in your application use the same image, we dont need to make multiple requests to the server\n\n## Loading Individual layers\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nBytepath can pull individual layers out of your SVG files to use as discrete assets. just pass the XML tag id of the layer you want to load to the :layer prop of the vector component.\nThis means that artists can simply draw all the assets for your animation in a single file, with each piece of the scene being it's own layer. \nExample: If you were making a highway scene you could draw all of the different cars in a single file, then pull out each car as individual assets.  \n\n## Use Webpack to manage your image files\n- If you are using webpack (if you used the suggested vue CLI package to create your site then yes, you are) the suggested way of loading files is to import them in your vue files, then pass the \nimported file to the src attribute. By doing it this way not only is your code cleaner but webpack will \"tree shake\" your images, meaning your final bundle only includes what you need\n\n\n## Notes about loading files\n    - vector does not load the file instead emitting a request to someone else to handle this\n    - vector does not make a copy of the file instead, uses the SVG &lt;use&gt; and &lt;symbol&gt;tag to handle making a clone of an asset in the shadow root of the DOM\n    - if you don't have an asset loader middleware files wont load  \n","date":"2020-09-28T11:46:51.513Z","updated":"2020-09-28T11:46:51.513Z","path":"v2/bytepath/importingassets.html","_id":"ckfl66gya0015c2v580p84mjw","comments":1,"layout":"page","content":"<h2 id=\"Loading-SVG-Files\"><a href=\"#Loading-SVG-Files\" class=\"headerlink\" title=\"Loading SVG Files\"></a>Loading SVG Files</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can import art assets from normal SVG files created by any illustration program. Just profile a path to the file to the :src prop of the &lt;vector&gt; component and bytepath will handle loading this file for you<br><pre><code class=\"hljs undefined\">&lt;script&gt;\n    import Bytepath from &quot;bytepath&quot;;\n\n    export default &#123;\n        components: &#123;\n            vector: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;vector :x=&quot;100&quot; :y=&quot;100&quot;&gt;\n        &lt;rect width=&quot;50&quot; height=&quot;50&quot; fill=&quot;red&quot; /&gt;\n    &lt;/vector&gt;\n&lt;/template&gt;</code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Files-loaded-only-once\"><a href=\"#Files-loaded-only-once\" class=\"headerlink\" title=\"Files loaded only once\"></a>Files loaded only once</h2><p>Bytepath will only make a request for an individual file once then cache the returned result. This means that if multiple assets in your application use the same image, we dont need to make multiple requests to the server</p>\n<h2 id=\"Loading-Individual-layers\"><a href=\"#Loading-Individual-layers\" class=\"headerlink\" title=\"Loading Individual layers\"></a>Loading Individual layers</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>Bytepath can pull individual layers out of your SVG files to use as discrete assets. just pass the XML tag id of the layer you want to load to the :layer prop of the vector component.<br>This means that artists can simply draw all the assets for your animation in a single file, with each piece of the scene being it’s own layer.<br>Example: If you were making a highway scene you could draw all of the different cars in a single file, then pull out each car as individual assets.  </p>\n<h2 id=\"Use-Webpack-to-manage-your-image-files\"><a href=\"#Use-Webpack-to-manage-your-image-files\" class=\"headerlink\" title=\"Use Webpack to manage your image files\"></a>Use Webpack to manage your image files</h2><ul>\n<li>If you are using webpack (if you used the suggested vue CLI package to create your site then yes, you are) the suggested way of loading files is to import them in your vue files, then pass the<br>imported file to the src attribute. By doing it this way not only is your code cleaner but webpack will “tree shake” your images, meaning your final bundle only includes what you need</li>\n</ul>\n<h2 id=\"Notes-about-loading-files\"><a href=\"#Notes-about-loading-files\" class=\"headerlink\" title=\"Notes about loading files\"></a>Notes about loading files</h2><pre><code>- vector does not load the file instead emitting a request to someone else to handle this\n- vector does not make a copy of the file instead, uses the SVG &amp;lt;use&amp;gt; and &amp;lt;symbol&amp;gt;tag to handle making a clone of an asset in the shadow root of the DOM\n- if you don&apos;t have an asset loader middleware files wont load  \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Loading-SVG-Files\"><a href=\"#Loading-SVG-Files\" class=\"headerlink\" title=\"Loading SVG Files\"></a>Loading SVG Files</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>We can import art assets from normal SVG files created by any illustration program. Just profile a path to the file to the :src prop of the &lt;vector&gt; component and bytepath will handle loading this file for you<br><pre><code class=\"hljs undefined\">&lt;script&gt;\n    import Bytepath from &quot;bytepath&quot;;\n\n    export default &#123;\n        components: &#123;\n            vector: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n&lt;/script&gt;\n\n&lt;template&gt;\n    &lt;vector :x=&quot;100&quot; :y=&quot;100&quot;&gt;\n        &lt;rect width=&quot;50&quot; height=&quot;50&quot; fill=&quot;red&quot; /&gt;\n    &lt;/vector&gt;\n&lt;/template&gt;</code></pre></p>\n\n<div id=\"vector-rect-xy-prop\" class=\"demo\">\n    <svg>\n        <vector-rect-xy-props/>\n    </svg>\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#vector-rect-xy-prop' })\n</script>\n\n<p><br></p>\n<h2 id=\"Files-loaded-only-once\"><a href=\"#Files-loaded-only-once\" class=\"headerlink\" title=\"Files loaded only once\"></a>Files loaded only once</h2><p>Bytepath will only make a request for an individual file once then cache the returned result. This means that if multiple assets in your application use the same image, we dont need to make multiple requests to the server</p>\n<h2 id=\"Loading-Individual-layers\"><a href=\"#Loading-Individual-layers\" class=\"headerlink\" title=\"Loading Individual layers\"></a>Loading Individual layers</h2><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>Bytepath can pull individual layers out of your SVG files to use as discrete assets. just pass the XML tag id of the layer you want to load to the :layer prop of the vector component.<br>This means that artists can simply draw all the assets for your animation in a single file, with each piece of the scene being it’s own layer.<br>Example: If you were making a highway scene you could draw all of the different cars in a single file, then pull out each car as individual assets.  </p>\n<h2 id=\"Use-Webpack-to-manage-your-image-files\"><a href=\"#Use-Webpack-to-manage-your-image-files\" class=\"headerlink\" title=\"Use Webpack to manage your image files\"></a>Use Webpack to manage your image files</h2><ul>\n<li>If you are using webpack (if you used the suggested vue CLI package to create your site then yes, you are) the suggested way of loading files is to import them in your vue files, then pass the<br>imported file to the src attribute. By doing it this way not only is your code cleaner but webpack will “tree shake” your images, meaning your final bundle only includes what you need</li>\n</ul>\n<h2 id=\"Notes-about-loading-files\"><a href=\"#Notes-about-loading-files\" class=\"headerlink\" title=\"Notes about loading files\"></a>Notes about loading files</h2><pre><code>- vector does not load the file instead emitting a request to someone else to handle this\n- vector does not make a copy of the file instead, uses the SVG &amp;lt;use&amp;gt; and &amp;lt;symbol&amp;gt;tag to handle making a clone of an asset in the shadow root of the DOM\n- if you don&apos;t have an asset loader middleware files wont load  \n</code></pre>"},{"type":"bytepath","_content":"\n\n","source":"v2/bytepath/index.md","raw":"---\ntype: bytepath\n---\n\n\n","date":"2020-09-25T23:55:41.101Z","updated":"2020-09-25T23:55:41.101Z","path":"v2/bytepath/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gya0016c2v5ztgoscxp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Introduction","type":"bytepath","order":0,"_content":"\n## What is BytePath?\n\nBytepath is a framework for building vector graphics and animations in your web development projects. BytePath was designed with the goal that is has to be ***FUN*** meaning has been designed from the ground up to be as simple as possible, allowing you to use the skills and tools you already have to build interactive scenes that are only limited by your imagination.   \n\n- **For Artists/Creatives** \n    - Art assets are created using the tools you already know how to use. If you are familiar with Adobe Illustrator, Affinity Designer, or any other program that can output SVG files, You know everything you need to start creating and sharing your ideas with the world\n\n    - Animations are created using simple declarative steps that anyone can use and understand. Bytepath will handle the hard work for you allowing you can focus on the creative process. \n\n    - Build once, reuse forever. Bytepath assets are designed to be modular and reusable in future projects. Share your creations with the community allowing others to build new creations using assets built by you. \n        \n- **For Developers** \n    - Bytepath has been designed to be used by web developers and makes the assumption that you have no experience with computer graphics.\n\n    - BytePath is built on top of <a href=\"https://www.vuejs.org\">Vue.js</a>. The same skills you've perfected to make awesome websites can now be used to create computer graphics. Anything you can do in vue, you can do here (slots, $emit, Mouse/Keyboard Events, props, mixins, etc) \n    \n    - Art assets are single file Vue.js components allowing you to store your art, code, and animations in a single reusable module. \n    \n    - Rotate, Scale, and reposition on screen graphics by modifying prop values. Art assets will automatically redraw after any change of position\n\n    - Animate scenes with dead simple javascript objects you already know how to write. Animations will automatically update when the :keyframe prop of a component changes \n    \n    - No art skills? Use NPM, Yarn, etc to install community made assets that you can re-purpose for use in your own projects. \n   \n     \n\n    \n\n\t\t\n\n\n## Getting Started\n<a class=\"button\" href=\"installation.html\">Installation</a>\n<p class=\"tip\">The official guide assumes an intermediate level knowledge of HTML, CSS, and JavaScript, and the Vue.js framework. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</p>\n\n## Rendering Our First Vector Graphic\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nLets start by rendering a simple rectangle using the included the &lt;vector&gt; component.\nInternally, &lt;vector&gt; is just a really fancy &lt;svg&gt;, so any valid &lt;svg&gt; syntax can be written inside. \n``` html\n<!-- Rectangle.vue -->\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        props: {\n            color: {\n                type: String,\n                default: \"red\",\n            }\n        },\n\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector>\n        <rect width=\"50\" height=\"50\" :fill=\"color\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect\" class=\"demo\">\n    <vector-rect />\n</div>\n<script>\nvar app2 = new window.vueapp({ el: '#vector-rect' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">It's helpful to be familiar with the &lt;svg&gt; tag, but if you aren't, dont worry! You won't be manually building assets like this in real projects unless you have a specific reason to do so.</p>\n\n## Component Based Assets\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nSince the rectangle we just created is just a normal single file Vue component, we can now use it over and over again without having to re write any ugly XML syntax by importing Rectangle.vue into another component, just like we can do in any Vue.js based app.\nBy changing the :color prop we added to the &lt;rectangle&gt; component, we can now create an unlimited number of unique graphical assets simply by changing the color.   \n\n``` html\n<!-- Rectangle.vue -->\n<script>\n    import Rectangle from \"./Rectangle\";\n\n    export default {\n        components: { Rectangle },\n    }\n</script>\n\n<template>\n    <div>\n        <rectangle fill=\"red\" />\n        <rectangle fill=\"blue\" />\n        <rectangle fill=\"green\" />\n        <rectangle fill=\"orange\" />\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"cb\" class=\"demo\">\n    <component-based />\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#cb' })\n</script>\n{% endraw %}\n\n\n## Sample Assets\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nBytepath ships with sample assets you can use right out of the box. Lets try importing the bytepath balloon logo.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        },\n    }\n</script>\n\n<template>\n    <div>\n        <balloon color=\"red\" />\n        <balloon color=\"blue\" />\n        <balloon color=\"green\" />\n        <balloon color=\"orange\" />\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"a4\" class=\"demo\">\n    <balloon-sample />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#a4' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Check out the full list of assets available HERE</p>\n\n","source":"v2/bytepath/introduction.md","raw":"---\ntitle: Introduction\ntype: bytepath\norder: 0\n---\n\n## What is BytePath?\n\nBytepath is a framework for building vector graphics and animations in your web development projects. BytePath was designed with the goal that is has to be ***FUN*** meaning has been designed from the ground up to be as simple as possible, allowing you to use the skills and tools you already have to build interactive scenes that are only limited by your imagination.   \n\n- **For Artists/Creatives** \n    - Art assets are created using the tools you already know how to use. If you are familiar with Adobe Illustrator, Affinity Designer, or any other program that can output SVG files, You know everything you need to start creating and sharing your ideas with the world\n\n    - Animations are created using simple declarative steps that anyone can use and understand. Bytepath will handle the hard work for you allowing you can focus on the creative process. \n\n    - Build once, reuse forever. Bytepath assets are designed to be modular and reusable in future projects. Share your creations with the community allowing others to build new creations using assets built by you. \n        \n- **For Developers** \n    - Bytepath has been designed to be used by web developers and makes the assumption that you have no experience with computer graphics.\n\n    - BytePath is built on top of <a href=\"https://www.vuejs.org\">Vue.js</a>. The same skills you've perfected to make awesome websites can now be used to create computer graphics. Anything you can do in vue, you can do here (slots, $emit, Mouse/Keyboard Events, props, mixins, etc) \n    \n    - Art assets are single file Vue.js components allowing you to store your art, code, and animations in a single reusable module. \n    \n    - Rotate, Scale, and reposition on screen graphics by modifying prop values. Art assets will automatically redraw after any change of position\n\n    - Animate scenes with dead simple javascript objects you already know how to write. Animations will automatically update when the :keyframe prop of a component changes \n    \n    - No art skills? Use NPM, Yarn, etc to install community made assets that you can re-purpose for use in your own projects. \n   \n     \n\n    \n\n\t\t\n\n\n## Getting Started\n<a class=\"button\" href=\"installation.html\">Installation</a>\n<p class=\"tip\">The official guide assumes an intermediate level knowledge of HTML, CSS, and JavaScript, and the Vue.js framework. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</p>\n\n## Rendering Our First Vector Graphic\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nLets start by rendering a simple rectangle using the included the &lt;vector&gt; component.\nInternally, &lt;vector&gt; is just a really fancy &lt;svg&gt;, so any valid &lt;svg&gt; syntax can be written inside. \n``` html\n<!-- Rectangle.vue -->\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        props: {\n            color: {\n                type: String,\n                default: \"red\",\n            }\n        },\n\n        components: {\n            vector: Bytepath.graphics.vector,\n        }\n    }\n</script>\n\n<template>\n    <vector>\n        <rect width=\"50\" height=\"50\" :fill=\"color\" />\n    </vector>\n</template>\n```\n{% raw %}\n<div id=\"vector-rect\" class=\"demo\">\n    <vector-rect />\n</div>\n<script>\nvar app2 = new window.vueapp({ el: '#vector-rect' })\n</script>\n{% endraw %}\n\n<p class=\"tip\">It's helpful to be familiar with the &lt;svg&gt; tag, but if you aren't, dont worry! You won't be manually building assets like this in real projects unless you have a specific reason to do so.</p>\n\n## Component Based Assets\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nSince the rectangle we just created is just a normal single file Vue component, we can now use it over and over again without having to re write any ugly XML syntax by importing Rectangle.vue into another component, just like we can do in any Vue.js based app.\nBy changing the :color prop we added to the &lt;rectangle&gt; component, we can now create an unlimited number of unique graphical assets simply by changing the color.   \n\n``` html\n<!-- Rectangle.vue -->\n<script>\n    import Rectangle from \"./Rectangle\";\n\n    export default {\n        components: { Rectangle },\n    }\n</script>\n\n<template>\n    <div>\n        <rectangle fill=\"red\" />\n        <rectangle fill=\"blue\" />\n        <rectangle fill=\"green\" />\n        <rectangle fill=\"orange\" />\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"cb\" class=\"demo\">\n    <component-based />\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#cb' })\n</script>\n{% endraw %}\n\n\n## Sample Assets\n<div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\nBytepath ships with sample assets you can use right out of the box. Lets try importing the bytepath balloon logo.\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            balloon: Bytepath.samples.assets.balloon,\n        },\n    }\n</script>\n\n<template>\n    <div>\n        <balloon color=\"red\" />\n        <balloon color=\"blue\" />\n        <balloon color=\"green\" />\n        <balloon color=\"orange\" />\n    </div>\n</template>\n```\n{% raw %}\n<div id=\"a4\" class=\"demo\">\n    <balloon-sample />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#a4' })\n</script>\n{% endraw %}\n\n<p class=\"tip success\">Check out the full list of assets available HERE</p>\n\n","date":"2020-09-27T12:43:13.655Z","updated":"2020-09-27T12:43:13.655Z","path":"v2/bytepath/introduction.html","comments":1,"layout":"page","_id":"ckfl66gya0017c2v5u0rd4rsp","content":"<h2 id=\"What-is-BytePath\"><a href=\"#What-is-BytePath\" class=\"headerlink\" title=\"What is BytePath?\"></a>What is BytePath?</h2><p>Bytepath is a framework for building vector graphics and animations in your web development projects. BytePath was designed with the goal that is has to be <strong><em>FUN</em></strong> meaning has been designed from the ground up to be as simple as possible, allowing you to use the skills and tools you already have to build interactive scenes that are only limited by your imagination.   </p>\n<ul>\n<li><p><strong>For Artists/Creatives</strong> </p>\n<ul>\n<li><p>Art assets are created using the tools you already know how to use. If you are familiar with Adobe Illustrator, Affinity Designer, or any other program that can output SVG files, You know everything you need to start creating and sharing your ideas with the world</p>\n</li>\n<li><p>Animations are created using simple declarative steps that anyone can use and understand. Bytepath will handle the hard work for you allowing you can focus on the creative process. </p>\n</li>\n<li><p>Build once, reuse forever. Bytepath assets are designed to be modular and reusable in future projects. Share your creations with the community allowing others to build new creations using assets built by you. </p>\n</li>\n</ul>\n</li>\n<li><p><strong>For Developers</strong> </p>\n<ul>\n<li><p>Bytepath has been designed to be used by web developers and makes the assumption that you have no experience with computer graphics.</p>\n</li>\n<li><p>BytePath is built on top of <a href=\"https://www.vuejs.org\" target=\"_blank\" rel=\"noopener\">Vue.js</a>. The same skills you’ve perfected to make awesome websites can now be used to create computer graphics. Anything you can do in vue, you can do here (slots, $emit, Mouse/Keyboard Events, props, mixins, etc) </p>\n</li>\n<li><p>Art assets are single file Vue.js components allowing you to store your art, code, and animations in a single reusable module. </p>\n</li>\n<li><p>Rotate, Scale, and reposition on screen graphics by modifying prop values. Art assets will automatically redraw after any change of position</p>\n</li>\n<li><p>Animate scenes with dead simple javascript objects you already know how to write. Animations will automatically update when the :keyframe prop of a component changes </p>\n</li>\n<li><p>No art skills? Use NPM, Yarn, etc to install community made assets that you can re-purpose for use in your own projects. </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p><a class=\"button\" href=\"installation.html\">Installation</a></p>\n<p class=\"tip\">The official guide assumes an intermediate level knowledge of HTML, CSS, and JavaScript, and the Vue.js framework. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</p>\n\n<h2 id=\"Rendering-Our-First-Vector-Graphic\"><a href=\"#Rendering-Our-First-Vector-Graphic\" class=\"headerlink\" title=\"Rendering Our First Vector Graphic\"></a>Rendering Our First Vector Graphic</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>Lets start by rendering a simple rectangle using the included the &lt;vector&gt; component.<br>Internally, &lt;vector&gt; is just a really fancy &lt;svg&gt;, so any valid &lt;svg&gt; syntax can be written inside.<br><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Rectangle.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">props</span>: &#123;\n            <span class=\"hljs-attr\">color</span>: &#123;\n                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n                <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">\"red\"</span>,\n            &#125;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">:fill</span>=<span class=\"hljs-string\">\"color\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect\" class=\"demo\">\n    <vector-rect>\n</vector-rect></div>\n<script>\nvar app2 = new window.vueapp({ el: '#vector-rect' })\n</script>\n\n<p class=\"tip\">It’s helpful to be familiar with the &lt;svg&gt; tag, but if you aren’t, dont worry! You won’t be manually building assets like this in real projects unless you have a specific reason to do so.</p>\n\n<h2 id=\"Component-Based-Assets\"><a href=\"#Component-Based-Assets\" class=\"headerlink\" title=\"Component Based Assets\"></a>Component Based Assets</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>Since the rectangle we just created is just a normal single file Vue component, we can now use it over and over again without having to re write any ugly XML syntax by importing Rectangle.vue into another component, just like we can do in any Vue.js based app.<br>By changing the :color prop we added to the &lt;rectangle&gt; component, we can now create an unlimited number of unique graphical assets simply by changing the color.   </p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Rectangle.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Rectangle <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Rectangle\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123; Rectangle &#125;,\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n\n<div id=\"cb\" class=\"demo\">\n    <component-based>\n</component-based></div>\n<script>\nvar app3 = new window.vueapp({ el: '#cb' })\n</script>\n\n<h2 id=\"Sample-Assets\"><a href=\"#Sample-Assets\" class=\"headerlink\" title=\"Sample Assets\"></a>Sample Assets</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>Bytepath ships with sample assets you can use right out of the box. Lets try importing the bytepath balloon logo.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;,\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"a4\" class=\"demo\">\n    <balloon-sample>\n</balloon-sample></div>\n<script>\nvar app4 = new window.vueapp({ el: '#a4' })\n</script>\n\n<p class=\"tip success\">Check out the full list of assets available HERE</p>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"What-is-BytePath\"><a href=\"#What-is-BytePath\" class=\"headerlink\" title=\"What is BytePath?\"></a>What is BytePath?</h2><p>Bytepath is a framework for building vector graphics and animations in your web development projects. BytePath was designed with the goal that is has to be <strong><em>FUN</em></strong> meaning has been designed from the ground up to be as simple as possible, allowing you to use the skills and tools you already have to build interactive scenes that are only limited by your imagination.   </p>\n<ul>\n<li><p><strong>For Artists/Creatives</strong> </p>\n<ul>\n<li><p>Art assets are created using the tools you already know how to use. If you are familiar with Adobe Illustrator, Affinity Designer, or any other program that can output SVG files, You know everything you need to start creating and sharing your ideas with the world</p>\n</li>\n<li><p>Animations are created using simple declarative steps that anyone can use and understand. Bytepath will handle the hard work for you allowing you can focus on the creative process. </p>\n</li>\n<li><p>Build once, reuse forever. Bytepath assets are designed to be modular and reusable in future projects. Share your creations with the community allowing others to build new creations using assets built by you. </p>\n</li>\n</ul>\n</li>\n<li><p><strong>For Developers</strong> </p>\n<ul>\n<li><p>Bytepath has been designed to be used by web developers and makes the assumption that you have no experience with computer graphics.</p>\n</li>\n<li><p>BytePath is built on top of <a href=\"https://www.vuejs.org\" target=\"_blank\" rel=\"noopener\">Vue.js</a>. The same skills you’ve perfected to make awesome websites can now be used to create computer graphics. Anything you can do in vue, you can do here (slots, $emit, Mouse/Keyboard Events, props, mixins, etc) </p>\n</li>\n<li><p>Art assets are single file Vue.js components allowing you to store your art, code, and animations in a single reusable module. </p>\n</li>\n<li><p>Rotate, Scale, and reposition on screen graphics by modifying prop values. Art assets will automatically redraw after any change of position</p>\n</li>\n<li><p>Animate scenes with dead simple javascript objects you already know how to write. Animations will automatically update when the :keyframe prop of a component changes </p>\n</li>\n<li><p>No art skills? Use NPM, Yarn, etc to install community made assets that you can re-purpose for use in your own projects. </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p><a class=\"button\" href=\"installation.html\">Installation</a></p>\n<p class=\"tip\">The official guide assumes an intermediate level knowledge of HTML, CSS, and JavaScript, and the Vue.js framework. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required.</p>\n\n<h2 id=\"Rendering-Our-First-Vector-Graphic\"><a href=\"#Rendering-Our-First-Vector-Graphic\" class=\"headerlink\" title=\"Rendering Our First Vector Graphic\"></a>Rendering Our First Vector Graphic</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>Lets start by rendering a simple rectangle using the included the &lt;vector&gt; component.<br>Internally, &lt;vector&gt; is just a really fancy &lt;svg&gt;, so any valid &lt;svg&gt; syntax can be written inside.<br><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Rectangle.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">props</span>: &#123;\n            <span class=\"hljs-attr\">color</span>: &#123;\n                <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n                <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">\"red\"</span>,\n            &#125;\n        &#125;,\n\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">vector</span>: Bytepath.graphics.vector,\n        &#125;\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">vector</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rect</span> <span class=\"hljs-attr\">width</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">height</span>=<span class=\"hljs-string\">\"50\"</span> <span class=\"hljs-attr\">:fill</span>=<span class=\"hljs-string\">\"color\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">vector</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"vector-rect\" class=\"demo\">\n    <vector-rect>\n</vector-rect></div>\n<script>\nvar app2 = new window.vueapp({ el: '#vector-rect' })\n</script>\n\n<p class=\"tip\">It’s helpful to be familiar with the &lt;svg&gt; tag, but if you aren’t, dont worry! You won’t be manually building assets like this in real projects unless you have a specific reason to do so.</p>\n\n<h2 id=\"Component-Based-Assets\"><a href=\"#Component-Based-Assets\" class=\"headerlink\" title=\"Component Based Assets\"></a>Component Based Assets</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>Since the rectangle we just created is just a normal single file Vue component, we can now use it over and over again without having to re write any ugly XML syntax by importing Rectangle.vue into another component, just like we can do in any Vue.js based app.<br>By changing the :color prop we added to the &lt;rectangle&gt; component, we can now create an unlimited number of unique graphical assets simply by changing the color.   </p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Rectangle.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Rectangle <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./Rectangle\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123; Rectangle &#125;,\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">rectangle</span> <span class=\"hljs-attr\">fill</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n\n<div id=\"cb\" class=\"demo\">\n    <component-based>\n</component-based></div>\n<script>\nvar app3 = new window.vueapp({ el: '#cb' })\n</script>\n\n<h2 id=\"Sample-Assets\"><a href=\"#Sample-Assets\" class=\"headerlink\" title=\"Sample Assets\"></a>Sample Assets</h2><div class=\"scrimba\"><a href=\"https://scrimba.com/p/pXKqta/cEQe4SJ\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n\n<p>Bytepath ships with sample assets you can use right out of the box. Lets try importing the bytepath balloon logo.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> Bytepath <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bytepath\"</span>;\n\n    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n        <span class=\"hljs-attr\">components</span>: &#123;\n            <span class=\"hljs-attr\">balloon</span>: Bytepath.samples.assets.balloon,\n        &#125;,\n    &#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"red\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"blue\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"green\"</span> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">balloon</span> <span class=\"hljs-attr\">color</span>=<span class=\"hljs-string\">\"orange\"</span> /&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"a4\" class=\"demo\">\n    <balloon-sample>\n</balloon-sample></div>\n<script>\nvar app4 = new window.vueapp({ el: '#a4' })\n</script>\n\n<p class=\"tip success\">Check out the full list of assets available HERE</p>\n\n"},{"title":"Keyboard Input","type":"bytepath","order":13,"_content":"","source":"v2/bytepath/keyboardinput.md","raw":"---\ntitle: Keyboard Input\ntype: bytepath\norder: 13\n---\n","date":"2020-09-27T13:47:47.414Z","updated":"2020-09-27T13:47:47.414Z","path":"v2/bytepath/keyboardinput.html","comments":1,"layout":"page","_id":"ckfl66gya0018c2v5p5iqchze","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Keyframe Animations","type":"bytepath","order":8,"_content":"## :keyframe Prop\n\n## Creating Keyframe Animations\n\n## Repeating animations\n\n## Timers\n### Scroll Timer\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nThe Scroll timer component will output a keyframe value based on the scroll position of the page. \n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            scroll: Bytepath.timers.scroll\n        }\n    }\n</script>\n\n<template>\n    <scroll v-slot=\"{ keyframe }\">\n        Current Keyframe: {{ keyframe }}\n    </scroll>\n</template>\n```\n{% raw %}\n<div id=\"using-scroll\" class=\"demo\">\n    <using-scroll />\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#using-scroll' })\n</script>\n{% endraw %}\n\n<br />\n\n### Clock Timer\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n- The Clock timer works the way you traditionally expect a timer to work. It outputs an integer value that gets larger over time.\n\n- If you are concerned about performance, you can control the animation tick rate using the :fps prop\n\n- If you are concerned about performance, you can control the animation tick rate using the :fps prop\n\n- :fps= 0 will pause the timer\n\n<p class=\"tip\"> No matter what FPS is set to, &lt;clock-timer&gt; will output a number at a rate of 1000 frames = 1 second. This means that by modifying the FPS value your animations wont slow down, they will just be less smooth. \nYou can verify this by moving the slider value in the example below. </p>\n\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return {\n                fps: 60,\n            };\n        },\n\n        components: {\n            clock: Bytepath.timers.clock\n        }\n    }\n</script>\n\n<template>\n    <clock :fps=\"fps\" v-slot=\"{ keyframe }\">\n    <div>\n        Current Keyframe: {{ keyframe }}<br/>\n        <input type=\"range\" v-model.number=\"fps\" min=\"0\" max=\"60\" > {{ fps }} FPS\n    </div>\n    </clock>\n</template>\n```\n{% raw %}\n<div id=\"using-clock\" class=\"demo\">\n    <using-clock />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#using-clock' })\n</script>\n{% endraw %}\n\n<br />\n","source":"v2/bytepath/keyframeanimations.md","raw":"---\ntitle: Keyframe Animations\ntype: bytepath\norder: 8\n---\n## :keyframe Prop\n\n## Creating Keyframe Animations\n\n## Repeating animations\n\n## Timers\n### Scroll Timer\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\nThe Scroll timer component will output a keyframe value based on the scroll position of the page. \n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        components: {\n            scroll: Bytepath.timers.scroll\n        }\n    }\n</script>\n\n<template>\n    <scroll v-slot=\"{ keyframe }\">\n        Current Keyframe: {{ keyframe }}\n    </scroll>\n</template>\n```\n{% raw %}\n<div id=\"using-scroll\" class=\"demo\">\n    <using-scroll />\n</div>\n<script>\nvar app3 = new window.vueapp({ el: '#using-scroll' })\n</script>\n{% endraw %}\n\n<br />\n\n### Clock Timer\n\n<div class=\"scrimba\"><a href=\"\" target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div>\n- The Clock timer works the way you traditionally expect a timer to work. It outputs an integer value that gets larger over time.\n\n- If you are concerned about performance, you can control the animation tick rate using the :fps prop\n\n- If you are concerned about performance, you can control the animation tick rate using the :fps prop\n\n- :fps= 0 will pause the timer\n\n<p class=\"tip\"> No matter what FPS is set to, &lt;clock-timer&gt; will output a number at a rate of 1000 frames = 1 second. This means that by modifying the FPS value your animations wont slow down, they will just be less smooth. \nYou can verify this by moving the slider value in the example below. </p>\n\n``` html\n<script>\n    import Bytepath from \"bytepath\";\n\n    export default {\n        data() {\n            return {\n                fps: 60,\n            };\n        },\n\n        components: {\n            clock: Bytepath.timers.clock\n        }\n    }\n</script>\n\n<template>\n    <clock :fps=\"fps\" v-slot=\"{ keyframe }\">\n    <div>\n        Current Keyframe: {{ keyframe }}<br/>\n        <input type=\"range\" v-model.number=\"fps\" min=\"0\" max=\"60\" > {{ fps }} FPS\n    </div>\n    </clock>\n</template>\n```\n{% raw %}\n<div id=\"using-clock\" class=\"demo\">\n    <using-clock />\n</div>\n<script>\nvar app4 = new window.vueapp({ el: '#using-clock' })\n</script>\n{% endraw %}\n\n<br />\n","date":"2020-09-28T11:43:01.600Z","updated":"2020-09-28T11:43:01.600Z","path":"v2/bytepath/keyframeanimations.html","_id":"ckfl66gyb0019c2v507ifoucp","comments":1,"layout":"page","content":"<h2 id=\"keyframe-Prop\"><a href=\"#keyframe-Prop\" class=\"headerlink\" title=\":keyframe Prop\"></a>:keyframe Prop</h2><h2 id=\"Creating-Keyframe-Animations\"><a href=\"#Creating-Keyframe-Animations\" class=\"headerlink\" title=\"Creating Keyframe Animations\"></a>Creating Keyframe Animations</h2><h2 id=\"Repeating-animations\"><a href=\"#Repeating-animations\" class=\"headerlink\" title=\"Repeating animations\"></a>Repeating animations</h2><h2 id=\"Timers\"><a href=\"#Timers\" class=\"headerlink\" title=\"Timers\"></a>Timers</h2><h3 id=\"Scroll-Timer\"><a href=\"#Scroll-Timer\" class=\"headerlink\" title=\"Scroll Timer\"></a>Scroll Timer</h3><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>The Scroll timer component will output a keyframe value based on the scroll position of the page.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n    import Bytepath from \"bytepath\";\n\n    export default &#123;\n        components: &#123;\n            scroll: Bytepath.timers.scroll\n        &#125;\n    &#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scroll</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; keyframe &#125;\"</span>&gt;</span>\n        Current Keyframe: &#123;&#123; keyframe &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scroll</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"using-scroll\" class=\"demo\">\n    <using-scroll>\n</using-scroll></div>\n<script>\nvar app3 = new window.vueapp({ el: '#using-scroll' })\n</script>\n\n<p><br></p>\n<h3 id=\"Clock-Timer\"><a href=\"#Clock-Timer\" class=\"headerlink\" title=\"Clock Timer\"></a>Clock Timer</h3><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div></p>\n<ul>\n<li><p>The Clock timer works the way you traditionally expect a timer to work. It outputs an integer value that gets larger over time.</p>\n</li>\n<li><p>If you are concerned about performance, you can control the animation tick rate using the :fps prop</p>\n</li>\n<li><p>If you are concerned about performance, you can control the animation tick rate using the :fps prop</p>\n</li>\n<li><p>:fps= 0 will pause the timer</p>\n</li>\n</ul>\n<p class=\"tip\"> No matter what FPS is set to, &lt;clock-timer&gt; will output a number at a rate of 1000 frames = 1 second. This means that by modifying the FPS value your animations wont slow down, they will just be less smooth.<br>You can verify this by moving the slider value in the example below. </p>\n\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n    import Bytepath from \"bytepath\";\n\n    export default &#123;\n        data() &#123;\n            return &#123;\n                fps: 60,\n            &#125;;\n        &#125;,\n\n        components: &#123;\n            clock: Bytepath.timers.clock\n        &#125;\n    &#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clock</span> <span class=\"hljs-attr\">:fps</span>=<span class=\"hljs-string\">\"fps\"</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; keyframe &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        Current Keyframe: &#123;&#123; keyframe &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"fps\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"60\"</span> &gt;</span> &#123;&#123; fps &#125;&#125; FPS\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clock</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n\n<div id=\"using-clock\" class=\"demo\">\n    <using-clock>\n</using-clock></div>\n<script>\nvar app4 = new window.vueapp({ el: '#using-clock' })\n</script>\n\n<p><br></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"keyframe-Prop\"><a href=\"#keyframe-Prop\" class=\"headerlink\" title=\":keyframe Prop\"></a>:keyframe Prop</h2><h2 id=\"Creating-Keyframe-Animations\"><a href=\"#Creating-Keyframe-Animations\" class=\"headerlink\" title=\"Creating Keyframe Animations\"></a>Creating Keyframe Animations</h2><h2 id=\"Repeating-animations\"><a href=\"#Repeating-animations\" class=\"headerlink\" title=\"Repeating animations\"></a>Repeating animations</h2><h2 id=\"Timers\"><a href=\"#Timers\" class=\"headerlink\" title=\"Timers\"></a>Timers</h2><h3 id=\"Scroll-Timer\"><a href=\"#Scroll-Timer\" class=\"headerlink\" title=\"Scroll Timer\"></a>Scroll Timer</h3><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div><br>The Scroll timer component will output a keyframe value based on the scroll position of the page.<br><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n    import Bytepath from \"bytepath\";\n\n    export default &#123;\n        components: &#123;\n            scroll: Bytepath.timers.scroll\n        &#125;\n    &#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scroll</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; keyframe &#125;\"</span>&gt;</span>\n        Current Keyframe: &#123;&#123; keyframe &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scroll</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre></p>\n\n<div id=\"using-scroll\" class=\"demo\">\n    <using-scroll>\n</using-scroll></div>\n<script>\nvar app3 = new window.vueapp({ el: '#using-scroll' })\n</script>\n\n<p><br></p>\n<h3 id=\"Clock-Timer\"><a href=\"#Clock-Timer\" class=\"headerlink\" title=\"Clock Timer\"></a>Clock Timer</h3><p><div class=\"scrimba\"><a href target=\"_blank\" rel=\"noopener noreferrer\">Try this lesson on Scrimba</a></div></p>\n<ul>\n<li><p>The Clock timer works the way you traditionally expect a timer to work. It outputs an integer value that gets larger over time.</p>\n</li>\n<li><p>If you are concerned about performance, you can control the animation tick rate using the :fps prop</p>\n</li>\n<li><p>If you are concerned about performance, you can control the animation tick rate using the :fps prop</p>\n</li>\n<li><p>:fps= 0 will pause the timer</p>\n</li>\n</ul>\n<p class=\"tip\"> No matter what FPS is set to, &lt;clock-timer&gt; will output a number at a rate of 1000 frames = 1 second. This means that by modifying the FPS value your animations wont slow down, they will just be less smooth.<br>You can verify this by moving the slider value in the example below. </p>\n\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span>\n    import Bytepath from \"bytepath\";\n\n    export default &#123;\n        data() &#123;\n            return &#123;\n                fps: 60,\n            &#125;;\n        &#125;,\n\n        components: &#123;\n            clock: Bytepath.timers.clock\n        &#125;\n    &#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">clock</span> <span class=\"hljs-attr\">:fps</span>=<span class=\"hljs-string\">\"fps\"</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; keyframe &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n        Current Keyframe: &#123;&#123; keyframe &#125;&#125;<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>/&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"range\"</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"fps\"</span> <span class=\"hljs-attr\">min</span>=<span class=\"hljs-string\">\"0\"</span> <span class=\"hljs-attr\">max</span>=<span class=\"hljs-string\">\"60\"</span> &gt;</span> &#123;&#123; fps &#125;&#125; FPS\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">clock</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n\n<div id=\"using-clock\" class=\"demo\">\n    <using-clock>\n</using-clock></div>\n<script>\nvar app4 = new window.vueapp({ el: '#using-clock' })\n</script>\n\n<p><br></p>\n"},{"title":"Matrix Prop","type":"bytepath","order":99,"_content":"","source":"v2/bytepath/matrixprop.md","raw":"---\ntitle: Matrix Prop\ntype: bytepath\norder: 99\n---\n","date":"2020-09-27T12:58:16.334Z","updated":"2020-09-27T12:58:16.334Z","path":"v2/bytepath/matrixprop.html","comments":1,"layout":"page","_id":"ckfl66gyb001ac2v5h20nrvki","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Position Class","type":"bytepath","order":99,"_content":"","source":"v2/bytepath/positionclass.md","raw":"---\ntitle: Position Class\ntype: bytepath\norder: 99\n---\n","date":"2020-09-27T12:57:27.770Z","updated":"2020-09-27T12:57:27.770Z","path":"v2/bytepath/positionclass.html","comments":1,"layout":"page","_id":"ckfl66gyb001bc2v5yn80tuoo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Transformation Mutators","type":"bytepath","order":99,"_content":"","source":"v2/bytepath/transformationmutators.md","raw":"---\ntitle: Transformation Mutators\ntype: bytepath\norder: 99\n---\n","date":"2020-09-27T13:00:32.371Z","updated":"2020-09-27T13:00:32.371Z","path":"v2/bytepath/transformationmutators.html","comments":1,"layout":"page","_id":"ckfl66gyc001cc2v5hwu7ph2u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Mouse Input","type":"bytepath","order":12,"_content":"","source":"v2/bytepath/mouseinput.md","raw":"---\ntitle: Mouse Input\ntype: bytepath\norder: 12\n---\n","date":"2020-09-27T13:47:42.091Z","updated":"2020-09-27T13:47:42.091Z","path":"v2/bytepath/mouseinput.html","comments":1,"layout":"page","_id":"ckfl66gyc001dc2v5dgcgrgwc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Sample Assets","type":"bytepath","order":99,"_content":"","source":"v2/bytepath/sampleassets.md","raw":"---\ntitle: Sample Assets\ntype: bytepath\norder: 99\n---\n","date":"2020-09-27T12:57:58.137Z","updated":"2020-09-27T12:57:58.137Z","path":"v2/bytepath/sampleassets.html","comments":1,"layout":"page","_id":"ckfl66gyc001ec2v5eiesyeqk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Renderless Animations","type":"bytepath","order":12,"_content":"","source":"v2/bytepath/renderlessanimations.md","raw":"---\ntitle: Renderless Animations\ntype: bytepath\norder: 12\n---\n","date":"2020-09-27T13:39:36.310Z","updated":"2020-09-27T13:39:36.310Z","path":"v2/bytepath/renderlessanimations.html","comments":1,"layout":"page","_id":"ckfl66gyc001fc2v5acn0p40l","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Realtime with deepstreamHub","type":"examples","order":9,"_content":"\n> This example uses [deepstreamHub](https://deepstreamhub.com/) to synchronize realtime data, send events and make remote procedure calls between clients (you can try opening it in multiple browser windows).\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-realtime-with-deepstreamhub?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/deepstream.md","raw":"---\ntitle: Realtime with deepstreamHub\ntype: examples\norder: 9\n---\n\n> This example uses [deepstreamHub](https://deepstreamhub.com/) to synchronize realtime data, send events and make remote procedure calls between clients (you can try opening it in multiple browser windows).\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-realtime-with-deepstreamhub?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.109Z","updated":"2020-09-25T23:55:41.109Z","path":"v2/examples/deepstream.html","comments":1,"layout":"page","_id":"ckfl66gyd001gc2v5g9si4t8i","content":"<blockquote>\n<p>This example uses <a href=\"https://deepstreamhub.com/\" target=\"_blank\" rel=\"noopener\">deepstreamHub</a> to synchronize realtime data, send events and make remote procedure calls between clients (you can try opening it in multiple browser windows).</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-realtime-with-deepstreamhub?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This example uses <a href=\"https://deepstreamhub.com/\" target=\"_blank\" rel=\"noopener\">deepstreamHub</a> to synchronize realtime data, send events and make remote procedure calls between clients (you can try opening it in multiple browser windows).</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-realtime-with-deepstreamhub?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Firebase + Validation","type":"examples","order":10,"_content":"\n> This example uses [Firebase](https://firebase.google.com/) as the data persistence backend and syncs between clients in real time (you can try opening it in multiple browser tabs). In addition, it performs instant validation using computed properties and triggers CSS transitions when adding/removing items.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-firebase-validation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/firebase.md","raw":"---\ntitle: Firebase + Validation\ntype: examples\norder: 10\n---\n\n> This example uses [Firebase](https://firebase.google.com/) as the data persistence backend and syncs between clients in real time (you can try opening it in multiple browser tabs). In addition, it performs instant validation using computed properties and triggers CSS transitions when adding/removing items.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-firebase-validation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.109Z","updated":"2020-09-25T23:55:41.109Z","path":"v2/examples/firebase.html","comments":1,"layout":"page","_id":"ckfl66gyd001hc2v5yqgrp3yv","content":"<blockquote>\n<p>This example uses <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener\">Firebase</a> as the data persistence backend and syncs between clients in real time (you can try opening it in multiple browser tabs). In addition, it performs instant validation using computed properties and triggers CSS transitions when adding/removing items.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-firebase-validation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This example uses <a href=\"https://firebase.google.com/\" target=\"_blank\" rel=\"noopener\">Firebase</a> as the data persistence backend and syncs between clients in real time (you can try opening it in multiple browser tabs). In addition, it performs instant validation using computed properties and triggers CSS transitions when adding/removing items.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-firebase-validation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Elastic Header","type":"examples","order":7,"_content":"\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-elastic-header?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/elastic-header.md","raw":"---\ntitle: Elastic Header\ntype: examples\norder: 7\n---\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-elastic-header?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.109Z","updated":"2020-09-25T23:55:41.109Z","path":"v2/examples/elastic-header.html","comments":1,"layout":"page","_id":"ckfl66gyd001ic2v5yu7bilu7","content":"<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-elastic-header?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-elastic-header?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"GitHub Commits","type":"examples","order":1,"_content":"\n> This example fetches latest Vue.js commits data from GitHub's API and displays them as a list. You can switch between the master and dev branches.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-github-commits?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/commits.md","raw":"---\ntitle: GitHub Commits\ntype: examples\norder: 1\n---\n\n> This example fetches latest Vue.js commits data from GitHub's API and displays them as a list. You can switch between the master and dev branches.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-github-commits?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.108Z","updated":"2020-09-25T23:55:41.108Z","path":"v2/examples/commits.html","comments":1,"layout":"page","_id":"ckfl66gyd001jc2v50plkaefv","content":"<blockquote>\n<p>This example fetches latest Vue.js commits data from GitHub’s API and displays them as a list. You can switch between the master and dev branches.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-github-commits?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This example fetches latest Vue.js commits data from GitHub’s API and displays them as a list. You can switch between the master and dev branches.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-github-commits?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Grid Component","type":"examples","order":3,"_content":"\n> This is an example of creating a reusable grid component and using it with external data.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-grid-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/grid-component.md","raw":"---\ntitle: Grid Component\ntype: examples\norder: 3\n---\n\n> This is an example of creating a reusable grid component and using it with external data.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-grid-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.109Z","updated":"2020-09-25T23:55:41.109Z","path":"v2/examples/grid-component.html","comments":1,"layout":"page","_id":"ckfl66gye001kc2v5aaxmzov8","content":"<blockquote>\n<p>This is an example of creating a reusable grid component and using it with external data.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-grid-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This is an example of creating a reusable grid component and using it with external data.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-grid-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"HackerNews Clone","type":"examples","order":12,"_content":"\n> This is a HackerNews clone built upon HN's official Firebase API, Vue 2.0 + Vue Router + Vuex, with server-side rendering.\n\n{% raw %}\n<div style=\"max-width: 600px;\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"noopener noreferrer\">\n    <img style=\"width: 100%;\" src=\"../../images/hn.png\">\n  </a>\n</div>\n{% endraw %}\n\n> [Live Demo](https://vue-hn.herokuapp.com/)\n> Note: the demo may need some spin up time if nobody has accessed it for a certain period.\n>\n> [[Source](https://github.com/vuejs/vue-hackernews-2.0)]\n\n## Features\n\n- Server Side Rendering\n  - Vue + Vue Router + Vuex working together\n  - Server-side data pre-fetching\n  - Client-side state & DOM hydration\n- Single-file Vue Components\n  - Hot-reload in development\n  - CSS extraction for production\n- Real-time List Updates with FLIP Animation\n\n## Architecture Overview\n\n<img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"../../images/hn-architecture.png\">\n","source":"v2/examples/hackernews.md","raw":"---\ntitle: HackerNews Clone\ntype: examples\norder: 12\n---\n\n> This is a HackerNews clone built upon HN's official Firebase API, Vue 2.0 + Vue Router + Vuex, with server-side rendering.\n\n{% raw %}\n<div style=\"max-width: 600px;\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"noopener noreferrer\">\n    <img style=\"width: 100%;\" src=\"../../images/hn.png\">\n  </a>\n</div>\n{% endraw %}\n\n> [Live Demo](https://vue-hn.herokuapp.com/)\n> Note: the demo may need some spin up time if nobody has accessed it for a certain period.\n>\n> [[Source](https://github.com/vuejs/vue-hackernews-2.0)]\n\n## Features\n\n- Server Side Rendering\n  - Vue + Vue Router + Vuex working together\n  - Server-side data pre-fetching\n  - Client-side state & DOM hydration\n- Single-file Vue Components\n  - Hot-reload in development\n  - CSS extraction for production\n- Real-time List Updates with FLIP Animation\n\n## Architecture Overview\n\n<img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"../../images/hn-architecture.png\">\n","date":"2020-09-25T23:55:41.109Z","updated":"2020-09-25T23:55:41.109Z","path":"v2/examples/hackernews.html","comments":1,"layout":"page","_id":"ckfl66gye001lc2v5j81p0bnz","content":"<blockquote>\n<p>This is a HackerNews clone built upon HN’s official Firebase API, Vue 2.0 + Vue Router + Vuex, with server-side rendering.</p>\n</blockquote>\n\n<div style=\"max-width: 600px;\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"noopener noreferrer\">\n    <img style=\"width: 100%;\" src=\"../../images/hn.png\">\n  </a>\n</div>\n\n<blockquote>\n<p><a href=\"https://vue-hn.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">Live Demo</a><br>Note: the demo may need some spin up time if nobody has accessed it for a certain period.</p>\n<p>[<a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"noopener\">Source</a>]</p>\n</blockquote>\n<h2 id=\"Features\"><a href=\"#Features\" class=\"headerlink\" title=\"Features\"></a>Features</h2><ul>\n<li>Server Side Rendering<ul>\n<li>Vue + Vue Router + Vuex working together</li>\n<li>Server-side data pre-fetching</li>\n<li>Client-side state &amp; DOM hydration</li>\n</ul>\n</li>\n<li>Single-file Vue Components<ul>\n<li>Hot-reload in development</li>\n<li>CSS extraction for production</li>\n</ul>\n</li>\n<li>Real-time List Updates with FLIP Animation</li>\n</ul>\n<h2 id=\"Architecture-Overview\"><a href=\"#Architecture-Overview\" class=\"headerlink\" title=\"Architecture Overview\"></a>Architecture Overview</h2><p><img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"../../images/hn-architecture.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This is a HackerNews clone built upon HN’s official Firebase API, Vue 2.0 + Vue Router + Vuex, with server-side rendering.</p>\n</blockquote>\n\n<div style=\"max-width: 600px;\">\n  <a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"noopener noreferrer\">\n    <img style=\"width: 100%;\" src=\"../../images/hn.png\">\n  </a>\n</div>\n\n<blockquote>\n<p><a href=\"https://vue-hn.herokuapp.com/\" target=\"_blank\" rel=\"noopener\">Live Demo</a><br>Note: the demo may need some spin up time if nobody has accessed it for a certain period.</p>\n<p>[<a href=\"https://github.com/vuejs/vue-hackernews-2.0\" target=\"_blank\" rel=\"noopener\">Source</a>]</p>\n</blockquote>\n<h2 id=\"Features\"><a href=\"#Features\" class=\"headerlink\" title=\"Features\"></a>Features</h2><ul>\n<li>Server Side Rendering<ul>\n<li>Vue + Vue Router + Vuex working together</li>\n<li>Server-side data pre-fetching</li>\n<li>Client-side state &amp; DOM hydration</li>\n</ul>\n</li>\n<li>Single-file Vue Components<ul>\n<li>Hot-reload in development</li>\n<li>CSS extraction for production</li>\n</ul>\n</li>\n<li>Real-time List Updates with FLIP Animation</li>\n</ul>\n<h2 id=\"Architecture-Overview\"><a href=\"#Architecture-Overview\" class=\"headerlink\" title=\"Architecture Overview\"></a>Architecture Overview</h2><p><img width=\"973\" alt=\"Hackernew clone architecture overview\" src=\"../../images/hn-architecture.png\"></p>\n"},{"title":"Markdown Editor","type":"examples","order":0,"_content":"\n> Dead simple Markdown editor.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-markdown-editor?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/index.md","raw":"---\ntitle: Markdown Editor\ntype: examples\norder: 0\n---\n\n> Dead simple Markdown editor.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-markdown-editor?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.110Z","updated":"2020-09-25T23:55:41.110Z","path":"v2/examples/index.html","comments":1,"layout":"page","_id":"ckfl66gye001mc2v5oiml9ql9","content":"<blockquote>\n<p>Dead simple Markdown editor.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-markdown-editor?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Dead simple Markdown editor.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-markdown-editor?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Modal Component","type":"examples","order":6,"_content":"\n> Features used: component, prop passing, content insertion, transitions.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-modal-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/modal.md","raw":"---\ntitle: Modal Component\ntype: examples\norder: 6\n---\n\n> Features used: component, prop passing, content insertion, transitions.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-modal-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.110Z","updated":"2020-09-25T23:55:41.110Z","path":"v2/examples/modal.html","comments":1,"layout":"page","_id":"ckfl66gyf001nc2v5dazh6m2m","content":"<blockquote>\n<p>Features used: component, prop passing, content insertion, transitions.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-modal-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Features used: component, prop passing, content insertion, transitions.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-modal-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Wrapper Component","type":"examples","order":8,"_content":"\n> In this example we are integrating a 3rd party jQuery plugin (select2) by wrapping it inside a custom component.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-wrapper-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/select2.md","raw":"---\ntitle: Wrapper Component\ntype: examples\norder: 8\n---\n\n> In this example we are integrating a 3rd party jQuery plugin (select2) by wrapping it inside a custom component.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-wrapper-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.110Z","updated":"2020-09-25T23:55:41.110Z","path":"v2/examples/select2.html","comments":1,"layout":"page","_id":"ckfl66gyf001oc2v5msomjyl2","content":"<blockquote>\n<p>In this example we are integrating a 3rd party jQuery plugin (select2) by wrapping it inside a custom component.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-wrapper-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>In this example we are integrating a 3rd party jQuery plugin (select2) by wrapping it inside a custom component.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-wrapper-component?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"TodoMVC","type":"examples","order":11,"_content":"\n> This is a fully spec-compliant TodoMVC implementation in under 120 effective lines of JavaScript (excluding comments and blank lines).\n\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the `localStorage` data will fail to be saved. You'll have to click on `Open Sandbox` to see the live result.</p>\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-todomvc?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/todomvc.md","raw":"---\ntitle: TodoMVC\ntype: examples\norder: 11\n---\n\n> This is a fully spec-compliant TodoMVC implementation in under 120 effective lines of JavaScript (excluding comments and blank lines).\n\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the `localStorage` data will fail to be saved. You'll have to click on `Open Sandbox` to see the live result.</p>\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-todomvc?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.110Z","updated":"2020-09-25T23:55:41.110Z","path":"v2/examples/todomvc.html","comments":1,"layout":"page","_id":"ckfl66gyf001pc2v5p66qvst4","content":"<blockquote>\n<p>This is a fully spec-compliant TodoMVC implementation in under 120 effective lines of JavaScript (excluding comments and blank lines).</p>\n</blockquote>\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the <code>localStorage</code> data will fail to be saved. You’ll have to click on <code>Open Sandbox</code> to see the live result.</p>\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-todomvc?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This is a fully spec-compliant TodoMVC implementation in under 120 effective lines of JavaScript (excluding comments and blank lines).</p>\n</blockquote>\n<p class=\"tip\">Note that if your web browser is configured to block 3rd-party data/cookies, the example below will not work, as the <code>localStorage</code> data will fail to be saved. You’ll have to click on <code>Open Sandbox</code> to see the live result.</p>\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-todomvc?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"SVG Graph","type":"examples","order":5,"_content":"\n> This example showcases a combination of custom component, computed property, two-way binding and SVG support.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-svg-graph?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/svg.md","raw":"---\ntitle: SVG Graph\ntype: examples\norder: 5\n---\n\n> This example showcases a combination of custom component, computed property, two-way binding and SVG support.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-svg-graph?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.110Z","updated":"2020-09-25T23:55:41.110Z","path":"v2/examples/svg.html","comments":1,"layout":"page","_id":"ckfl66gyg001qc2v5nwewpdch","content":"<blockquote>\n<p>This example showcases a combination of custom component, computed property, two-way binding and SVG support.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-svg-graph?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This example showcases a combination of custom component, computed property, two-way binding and SVG support.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-svg-graph?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Tree View","type":"examples","order":4,"_content":"\n> Example of a simple tree view implementation showcasing recursive usage of components.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-tree-view?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/examples/tree-view.md","raw":"---\ntitle: Tree View\ntype: examples\norder: 4\n---\n\n> Example of a simple tree view implementation showcasing recursive usage of components.\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-tree-view?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.111Z","updated":"2020-09-25T23:55:41.111Z","path":"v2/examples/tree-view.html","comments":1,"layout":"page","_id":"ckfl66gyg001rc2v5a0roaif9","content":"<blockquote>\n<p>Example of a simple tree view implementation showcasing recursive usage of components.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-tree-view?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Example of a simple tree view implementation showcasing recursive usage of components.</p>\n</blockquote>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-tree-view?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Search Vue.js","type":"search","search":true,"_content":"","source":"v2/search/index.md","raw":"---\ntitle: Search Vue.js\ntype: search\nsearch: true\n---","date":"2020-09-25T23:55:41.141Z","updated":"2020-09-25T23:55:41.141Z","path":"v2/search/index.html","comments":1,"layout":"page","_id":"ckfl66gyg001sc2v51tbrbsr5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Class and Style Bindings","type":"guide","order":6,"_content":"\nA common need for data binding is manipulating an element's class list and its inline styles. Since they are both attributes, we can use `v-bind` to handle them: we only need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when `v-bind` is used with `class` and `style`. In addition to strings, the expressions can also evaluate to objects or arrays.\n\n## Binding HTML Classes\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-dynamic-classes?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Dynamic Classes Lesson\">Watch a free video lesson on Vue School</a></div>\n\n### Object Syntax\n\nWe can pass an object to `v-bind:class` to dynamically toggle classes:\n\n``` html\n<div v-bind:class=\"{ active: isActive }\"></div>\n```\n\nThe above syntax means the presence of the `active` class will be determined by the [truthiness](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) of the data property `isActive`.\n\nYou can have multiple classes toggled by having more fields in the object. In addition, the `v-bind:class` directive can also co-exist with the plain `class` attribute. So given the following template:\n\n``` html\n<div\n  class=\"static\"\n  v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n```\n\nAnd the following data:\n\n``` js\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\nIt will render:\n\n``` html\n<div class=\"static active\"></div>\n```\n\nWhen `isActive` or `hasError` changes, the class list will be updated accordingly. For example, if `hasError` becomes `true`, the class list will become `\"static active text-danger\"`.\n\nThe bound object doesn't have to be inline:\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n\nThis will render the same result. We can also bind to a [computed property](computed.html) that returns an object. This is a common and powerful pattern:\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n```\n\n### Array Syntax\n\nWe can pass an array to `v-bind:class` to apply a list of classes:\n\n``` html\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n```\n``` js\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n\nWhich will render:\n\n``` html\n<div class=\"active text-danger\"></div>\n```\n\nIf you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:\n\n``` html\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\nThis will always apply `errorClass`, but will only apply `activeClass` when `isActive` is truthy.\n\nHowever, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:\n\n``` html\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n\n### With Components\n\n> This section assumes knowledge of [Vue Components](components.html). Feel free to skip it and come back later.\n\nWhen you use the `class` attribute on a custom component, those classes will be added to the component's root element. Existing classes on this element will not be overwritten.\n\nFor example, if you declare this component:\n\n``` js\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n```\n\nThen add some classes when using it:\n\n``` html\n<my-component class=\"baz boo\"></my-component>\n```\n\nThe rendered HTML will be:\n\n``` html\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\nThe same is true for class bindings:\n\n``` html\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n```\n\nWhen `isActive` is truthy, the rendered HTML will be:\n\n``` html\n<p class=\"foo bar active\">Hi</p>\n```\n\n## Binding Inline Styles\n\n### Object Syntax\n\nThe object syntax for `v-bind:style` is pretty straightforward - it looks almost like CSS, except it's a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:\n\n``` html\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n```\n``` js\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n```\n\nIt is often a good idea to bind to a style object directly so that the template is cleaner:\n\n``` html\n<div v-bind:style=\"styleObject\"></div>\n```\n``` js\ndata: {\n  styleObject: {\n    color: 'red',\n    fontSize: '13px'\n  }\n}\n```\n\nAgain, the object syntax is often used in conjunction with computed properties that return objects.\n\n### Array Syntax\n\nThe array syntax for `v-bind:style` allows you to apply multiple style objects to the same element:\n\n``` html\n<div v-bind:style=\"[baseStyles, overridingStyles]\"></div>\n```\n\n### Auto-prefixing\n\nWhen you use a CSS property that requires [vendor prefixes](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix) in `v-bind:style`, for example `transform`, Vue will automatically detect and add appropriate prefixes to the applied styles.\n\n### Multiple Values\n\n> 2.3.0+\n\nStarting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:\n\n``` html\n<div v-bind:style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n```\n\nThis will only render the last value in the array which the browser supports. In this example, it will render `display: flex` for browsers that support the unprefixed version of flexbox.\n","source":"v2/guide/class-and-style.md","raw":"---\ntitle: Class and Style Bindings\ntype: guide\norder: 6\n---\n\nA common need for data binding is manipulating an element's class list and its inline styles. Since they are both attributes, we can use `v-bind` to handle them: we only need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when `v-bind` is used with `class` and `style`. In addition to strings, the expressions can also evaluate to objects or arrays.\n\n## Binding HTML Classes\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-dynamic-classes?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Dynamic Classes Lesson\">Watch a free video lesson on Vue School</a></div>\n\n### Object Syntax\n\nWe can pass an object to `v-bind:class` to dynamically toggle classes:\n\n``` html\n<div v-bind:class=\"{ active: isActive }\"></div>\n```\n\nThe above syntax means the presence of the `active` class will be determined by the [truthiness](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) of the data property `isActive`.\n\nYou can have multiple classes toggled by having more fields in the object. In addition, the `v-bind:class` directive can also co-exist with the plain `class` attribute. So given the following template:\n\n``` html\n<div\n  class=\"static\"\n  v-bind:class=\"{ active: isActive, 'text-danger': hasError }\"\n></div>\n```\n\nAnd the following data:\n\n``` js\ndata: {\n  isActive: true,\n  hasError: false\n}\n```\n\nIt will render:\n\n``` html\n<div class=\"static active\"></div>\n```\n\nWhen `isActive` or `hasError` changes, the class list will be updated accordingly. For example, if `hasError` becomes `true`, the class list will become `\"static active text-danger\"`.\n\nThe bound object doesn't have to be inline:\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  classObject: {\n    active: true,\n    'text-danger': false\n  }\n}\n```\n\nThis will render the same result. We can also bind to a [computed property](computed.html) that returns an object. This is a common and powerful pattern:\n\n``` html\n<div v-bind:class=\"classObject\"></div>\n```\n``` js\ndata: {\n  isActive: true,\n  error: null\n},\ncomputed: {\n  classObject: function () {\n    return {\n      active: this.isActive && !this.error,\n      'text-danger': this.error && this.error.type === 'fatal'\n    }\n  }\n}\n```\n\n### Array Syntax\n\nWe can pass an array to `v-bind:class` to apply a list of classes:\n\n``` html\n<div v-bind:class=\"[activeClass, errorClass]\"></div>\n```\n``` js\ndata: {\n  activeClass: 'active',\n  errorClass: 'text-danger'\n}\n```\n\nWhich will render:\n\n``` html\n<div class=\"active text-danger\"></div>\n```\n\nIf you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:\n\n``` html\n<div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"></div>\n```\n\nThis will always apply `errorClass`, but will only apply `activeClass` when `isActive` is truthy.\n\nHowever, this can be a bit verbose if you have multiple conditional classes. That's why it's also possible to use the object syntax inside array syntax:\n\n``` html\n<div v-bind:class=\"[{ active: isActive }, errorClass]\"></div>\n```\n\n### With Components\n\n> This section assumes knowledge of [Vue Components](components.html). Feel free to skip it and come back later.\n\nWhen you use the `class` attribute on a custom component, those classes will be added to the component's root element. Existing classes on this element will not be overwritten.\n\nFor example, if you declare this component:\n\n``` js\nVue.component('my-component', {\n  template: '<p class=\"foo bar\">Hi</p>'\n})\n```\n\nThen add some classes when using it:\n\n``` html\n<my-component class=\"baz boo\"></my-component>\n```\n\nThe rendered HTML will be:\n\n``` html\n<p class=\"foo bar baz boo\">Hi</p>\n```\n\nThe same is true for class bindings:\n\n``` html\n<my-component v-bind:class=\"{ active: isActive }\"></my-component>\n```\n\nWhen `isActive` is truthy, the rendered HTML will be:\n\n``` html\n<p class=\"foo bar active\">Hi</p>\n```\n\n## Binding Inline Styles\n\n### Object Syntax\n\nThe object syntax for `v-bind:style` is pretty straightforward - it looks almost like CSS, except it's a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:\n\n``` html\n<div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"></div>\n```\n``` js\ndata: {\n  activeColor: 'red',\n  fontSize: 30\n}\n```\n\nIt is often a good idea to bind to a style object directly so that the template is cleaner:\n\n``` html\n<div v-bind:style=\"styleObject\"></div>\n```\n``` js\ndata: {\n  styleObject: {\n    color: 'red',\n    fontSize: '13px'\n  }\n}\n```\n\nAgain, the object syntax is often used in conjunction with computed properties that return objects.\n\n### Array Syntax\n\nThe array syntax for `v-bind:style` allows you to apply multiple style objects to the same element:\n\n``` html\n<div v-bind:style=\"[baseStyles, overridingStyles]\"></div>\n```\n\n### Auto-prefixing\n\nWhen you use a CSS property that requires [vendor prefixes](https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix) in `v-bind:style`, for example `transform`, Vue will automatically detect and add appropriate prefixes to the applied styles.\n\n### Multiple Values\n\n> 2.3.0+\n\nStarting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:\n\n``` html\n<div v-bind:style=\"{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }\"></div>\n```\n\nThis will only render the last value in the array which the browser supports. In this example, it will render `display: flex` for browsers that support the unprefixed version of flexbox.\n","date":"2020-09-25T23:55:41.133Z","updated":"2020-09-25T23:55:41.133Z","path":"v2/guide/class-and-style.html","comments":1,"layout":"page","_id":"ckfl66gyh001tc2v5mnno4enh","content":"<p>A common need for data binding is manipulating an element’s class list and its inline styles. Since they are both attributes, we can use <code>v-bind</code> to handle them: we only need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when <code>v-bind</code> is used with <code>class</code> and <code>style</code>. In addition to strings, the expressions can also evaluate to objects or arrays.</p>\n<h2 id=\"Binding-HTML-Classes\"><a href=\"#Binding-HTML-Classes\" class=\"headerlink\" title=\"Binding HTML Classes\"></a>Binding HTML Classes</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-dynamic-classes?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Dynamic Classes Lesson\">Watch a free video lesson on Vue School</a></div>\n\n<h3 id=\"Object-Syntax\"><a href=\"#Object-Syntax\" class=\"headerlink\" title=\"Object Syntax\"></a>Object Syntax</h3><p>We can pass an object to <code>v-bind:class</code> to dynamically toggle classes:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The above syntax means the presence of the <code>active</code> class will be determined by the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\" target=\"_blank\" rel=\"noopener\">truthiness</a> of the data property <code>isActive</code>.</p>\n<p>You can have multiple classes toggled by having more fields in the object. In addition, the <code>v-bind:class</code> directive can also co-exist with the plain <code>class</code> attribute. So given the following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"static\"</span>\n  <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"&#123; active: isActive, 'text-danger': hasError &#125;\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>And the following data:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">isActive</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span>\n&#125;</code></pre>\n<p>It will render:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"static active\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>When <code>isActive</code> or <code>hasError</code> changes, the class list will be updated accordingly. For example, if <code>hasError</code> becomes <code>true</code>, the class list will become <code>&quot;static active text-danger&quot;</code>.</p>\n<p>The bound object doesn’t have to be inline:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"classObject\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">classObject</span>: &#123;\n    <span class=\"hljs-attr\">active</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">'text-danger'</span>: <span class=\"hljs-literal\">false</span>\n  &#125;\n&#125;</code></pre>\n<p>This will render the same result. We can also bind to a <a href=\"computed.html\">computed property</a> that returns an object. This is a common and powerful pattern:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"classObject\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">isActive</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-literal\">null</span>\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">classObject</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">active</span>: <span class=\"hljs-keyword\">this</span>.isActive &amp;&amp; !<span class=\"hljs-keyword\">this</span>.error,\n      <span class=\"hljs-string\">'text-danger'</span>: <span class=\"hljs-keyword\">this</span>.error &amp;&amp; <span class=\"hljs-keyword\">this</span>.error.type === <span class=\"hljs-string\">'fatal'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Array-Syntax\"><a href=\"#Array-Syntax\" class=\"headerlink\" title=\"Array Syntax\"></a>Array Syntax</h3><p>We can pass an array to <code>v-bind:class</code> to apply a list of classes:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"[activeClass, errorClass]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">activeClass</span>: <span class=\"hljs-string\">'active'</span>,\n  <span class=\"hljs-attr\">errorClass</span>: <span class=\"hljs-string\">'text-danger'</span>\n&#125;</code></pre>\n<p>Which will render:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"active text-danger\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"[isActive ? activeClass : '', errorClass]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This will always apply <code>errorClass</code>, but will only apply <code>activeClass</code> when <code>isActive</code> is truthy.</p>\n<p>However, this can be a bit verbose if you have multiple conditional classes. That’s why it’s also possible to use the object syntax inside array syntax:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"[&#123; active: isActive &#125;, errorClass]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h3 id=\"With-Components\"><a href=\"#With-Components\" class=\"headerlink\" title=\"With Components\"></a>With Components</h3><blockquote>\n<p>This section assumes knowledge of <a href=\"components.html\">Vue Components</a>. Feel free to skip it and come back later.</p>\n</blockquote>\n<p>When you use the <code>class</code> attribute on a custom component, those classes will be added to the component’s root element. Existing classes on this element will not be overwritten.</p>\n<p>For example, if you declare this component:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'</span>\n&#125;)</code></pre>\n<p>Then add some classes when using it:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"baz boo\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>The rendered HTML will be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"foo bar baz boo\"</span>&gt;</span>Hi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>The same is true for class bindings:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>When <code>isActive</code> is truthy, the rendered HTML will be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"foo bar active\"</span>&gt;</span>Hi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<h2 id=\"Binding-Inline-Styles\"><a href=\"#Binding-Inline-Styles\" class=\"headerlink\" title=\"Binding Inline Styles\"></a>Binding Inline Styles</h2><h3 id=\"Object-Syntax-1\"><a href=\"#Object-Syntax-1\" class=\"headerlink\" title=\"Object Syntax\"></a>Object Syntax</h3><p>The object syntax for <code>v-bind:style</code> is pretty straightforward - it looks almost like CSS, except it’s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">activeColor</span>: <span class=\"hljs-string\">'red'</span>,\n  <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">30</span>\n&#125;</code></pre>\n<p>It is often a good idea to bind to a style object directly so that the template is cleaner:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"styleObject\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">styleObject</span>: &#123;\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span>,\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">'13px'</span>\n  &#125;\n&#125;</code></pre>\n<p>Again, the object syntax is often used in conjunction with computed properties that return objects.</p>\n<h3 id=\"Array-Syntax-1\"><a href=\"#Array-Syntax-1\" class=\"headerlink\" title=\"Array Syntax\"></a>Array Syntax</h3><p>The array syntax for <code>v-bind:style</code> allows you to apply multiple style objects to the same element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"[baseStyles, overridingStyles]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h3 id=\"Auto-prefixing\"><a href=\"#Auto-prefixing\" class=\"headerlink\" title=\"Auto-prefixing\"></a>Auto-prefixing</h3><p>When you use a CSS property that requires <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\" target=\"_blank\" rel=\"noopener\">vendor prefixes</a> in <code>v-bind:style</code>, for example <code>transform</code>, Vue will automatically detect and add appropriate prefixes to the applied styles.</p>\n<h3 id=\"Multiple-Values\"><a href=\"#Multiple-Values\" class=\"headerlink\" title=\"Multiple Values\"></a>Multiple Values</h3><blockquote>\n<p>2.3.0+</p>\n</blockquote>\n<p>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This will only render the last value in the array which the browser supports. In this example, it will render <code>display: flex</code> for browsers that support the unprefixed version of flexbox.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>A common need for data binding is manipulating an element’s class list and its inline styles. Since they are both attributes, we can use <code>v-bind</code> to handle them: we only need to calculate a final string with our expressions. However, meddling with string concatenation is annoying and error-prone. For this reason, Vue provides special enhancements when <code>v-bind</code> is used with <code>class</code> and <code>style</code>. In addition to strings, the expressions can also evaluate to objects or arrays.</p>\n<h2 id=\"Binding-HTML-Classes\"><a href=\"#Binding-HTML-Classes\" class=\"headerlink\" title=\"Binding HTML Classes\"></a>Binding HTML Classes</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-dynamic-classes?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Dynamic Classes Lesson\">Watch a free video lesson on Vue School</a></div>\n\n<h3 id=\"Object-Syntax\"><a href=\"#Object-Syntax\" class=\"headerlink\" title=\"Object Syntax\"></a>Object Syntax</h3><p>We can pass an object to <code>v-bind:class</code> to dynamically toggle classes:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The above syntax means the presence of the <code>active</code> class will be determined by the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Truthy\" target=\"_blank\" rel=\"noopener\">truthiness</a> of the data property <code>isActive</code>.</p>\n<p>You can have multiple classes toggled by having more fields in the object. In addition, the <code>v-bind:class</code> directive can also co-exist with the plain <code>class</code> attribute. So given the following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"static\"</span>\n  <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"&#123; active: isActive, 'text-danger': hasError &#125;\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>And the following data:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">isActive</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">hasError</span>: <span class=\"hljs-literal\">false</span>\n&#125;</code></pre>\n<p>It will render:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"static active\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>When <code>isActive</code> or <code>hasError</code> changes, the class list will be updated accordingly. For example, if <code>hasError</code> becomes <code>true</code>, the class list will become <code>&quot;static active text-danger&quot;</code>.</p>\n<p>The bound object doesn’t have to be inline:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"classObject\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">classObject</span>: &#123;\n    <span class=\"hljs-attr\">active</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">'text-danger'</span>: <span class=\"hljs-literal\">false</span>\n  &#125;\n&#125;</code></pre>\n<p>This will render the same result. We can also bind to a <a href=\"computed.html\">computed property</a> that returns an object. This is a common and powerful pattern:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"classObject\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">isActive</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-literal\">null</span>\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">classObject</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">active</span>: <span class=\"hljs-keyword\">this</span>.isActive &amp;&amp; !<span class=\"hljs-keyword\">this</span>.error,\n      <span class=\"hljs-string\">'text-danger'</span>: <span class=\"hljs-keyword\">this</span>.error &amp;&amp; <span class=\"hljs-keyword\">this</span>.error.type === <span class=\"hljs-string\">'fatal'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Array-Syntax\"><a href=\"#Array-Syntax\" class=\"headerlink\" title=\"Array Syntax\"></a>Array Syntax</h3><p>We can pass an array to <code>v-bind:class</code> to apply a list of classes:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"[activeClass, errorClass]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">activeClass</span>: <span class=\"hljs-string\">'active'</span>,\n  <span class=\"hljs-attr\">errorClass</span>: <span class=\"hljs-string\">'text-danger'</span>\n&#125;</code></pre>\n<p>Which will render:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"active text-danger\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>If you would like to also toggle a class in the list conditionally, you can do it with a ternary expression:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"[isActive ? activeClass : '', errorClass]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This will always apply <code>errorClass</code>, but will only apply <code>activeClass</code> when <code>isActive</code> is truthy.</p>\n<p>However, this can be a bit verbose if you have multiple conditional classes. That’s why it’s also possible to use the object syntax inside array syntax:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"[&#123; active: isActive &#125;, errorClass]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h3 id=\"With-Components\"><a href=\"#With-Components\" class=\"headerlink\" title=\"With Components\"></a>With Components</h3><blockquote>\n<p>This section assumes knowledge of <a href=\"components.html\">Vue Components</a>. Feel free to skip it and come back later.</p>\n</blockquote>\n<p>When you use the <code>class</code> attribute on a custom component, those classes will be added to the component’s root element. Existing classes on this element will not be overwritten.</p>\n<p>For example, if you declare this component:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'</span>\n&#125;)</code></pre>\n<p>Then add some classes when using it:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"baz boo\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>The rendered HTML will be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"foo bar baz boo\"</span>&gt;</span>Hi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>The same is true for class bindings:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-bind:class</span>=<span class=\"hljs-string\">\"&#123; active: isActive &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>When <code>isActive</code> is truthy, the rendered HTML will be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"foo bar active\"</span>&gt;</span>Hi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<h2 id=\"Binding-Inline-Styles\"><a href=\"#Binding-Inline-Styles\" class=\"headerlink\" title=\"Binding Inline Styles\"></a>Binding Inline Styles</h2><h3 id=\"Object-Syntax-1\"><a href=\"#Object-Syntax-1\" class=\"headerlink\" title=\"Object Syntax\"></a>Object Syntax</h3><p>The object syntax for <code>v-bind:style</code> is pretty straightforward - it looks almost like CSS, except it’s a JavaScript object. You can use either camelCase or kebab-case (use quotes with kebab-case) for the CSS property names:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">activeColor</span>: <span class=\"hljs-string\">'red'</span>,\n  <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-number\">30</span>\n&#125;</code></pre>\n<p>It is often a good idea to bind to a style object directly so that the template is cleaner:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"styleObject\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">styleObject</span>: &#123;\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span>,\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">'13px'</span>\n  &#125;\n&#125;</code></pre>\n<p>Again, the object syntax is often used in conjunction with computed properties that return objects.</p>\n<h3 id=\"Array-Syntax-1\"><a href=\"#Array-Syntax-1\" class=\"headerlink\" title=\"Array Syntax\"></a>Array Syntax</h3><p>The array syntax for <code>v-bind:style</code> allows you to apply multiple style objects to the same element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"[baseStyles, overridingStyles]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h3 id=\"Auto-prefixing\"><a href=\"#Auto-prefixing\" class=\"headerlink\" title=\"Auto-prefixing\"></a>Auto-prefixing</h3><p>When you use a CSS property that requires <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\" target=\"_blank\" rel=\"noopener\">vendor prefixes</a> in <code>v-bind:style</code>, for example <code>transform</code>, Vue will automatically detect and add appropriate prefixes to the applied styles.</p>\n<h3 id=\"Multiple-Values\"><a href=\"#Multiple-Values\" class=\"headerlink\" title=\"Multiple Values\"></a>Multiple Values</h3><blockquote>\n<p>2.3.0+</p>\n</blockquote>\n<p>Starting in 2.3.0+ you can provide an array of multiple (prefixed) values to a style property, for example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:style</span>=<span class=\"hljs-string\">\"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This will only render the last value in the array which the browser supports. In this example, it will render <code>display: flex</code> for browsers that support the unprefixed version of flexbox.</p>\n"},{"title":"Custom Events","type":"guide","order":103,"_content":"\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/communication-between-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to work with custom events on Vue School\">Learn how to work with custom events in a free Vue School lesson</a></div>\n\n## Event Names\n\nUnlike components and props, event names don't provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:\n\n```js\nthis.$emit('myEvent')\n```\n\nListening to the kebab-cased version will have no effect:\n\n```html\n<!-- Won't work -->\n<my-component v-on:my-event=\"doSomething\"></my-component>\n```\n\nUnlike components and props, event names will never be used as variable or property names in JavaScript, so there's no reason to use camelCase or PascalCase. Additionally, `v-on` event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML's case-insensitivity), so `v-on:myEvent` would become `v-on:myevent` -- making `myEvent` impossible to listen to.\n\nFor these reasons, we recommend you **always use kebab-case for event names**.\n\n## Customizing Component `v-model`\n\n> New in 2.2.0+\n\nBy default, `v-model` on a component uses `value` as the prop and `input` as the event, but some input types such as checkboxes and radio buttons may want to use the `value` attribute for a [different purpose](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value). Using the `model` option can avoid a conflict in such cases:\n\n```js\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >\n  `\n})\n```\n\nNow when using `v-model` on this component:\n\n```html\n<base-checkbox v-model=\"lovingVue\"></base-checkbox>\n```\n\nthe value of `lovingVue` will be passed to the `checked` prop. The `lovingVue` property will then be updated when `<base-checkbox>` emits a `change` event with a new value.\n\n<p class=\"tip\">Note that you still have to declare the <code>checked</code> prop in the component's <code>props</code> option.</p>\n\n## Binding Native Events to Components\n\nThere may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the `.native` modifier for `v-on`:\n\n```html\n<base-input v-on:focus.native=\"onFocus\"></base-input>\n```\n\nThis can be useful sometimes, but it's not a good idea when you're trying to listen on a very specific element, like an `<input>`. For example, the `<base-input>` component above might refactor so that the root element is actually a `<label>` element:\n\n```html\n<label>\n  {{ label }}\n  <input\n    v-bind=\"$attrs\"\n    v-bind:value=\"value\"\n    v-on:input=\"$emit('input', $event.target.value)\"\n  >\n</label>\n```\n\nIn that case, the `.native` listener in the parent would silently break. There would be no errors, but the `onFocus` handler wouldn't be called when we expected it to.\n\nTo solve this problem, Vue provides a `$listeners` property containing an object of listeners being used on the component. For example:\n\n```js\n{\n  focus: function (event) { /* ... */ }\n  input: function (value) { /* ... */ },\n}\n```\n\nUsing the `$listeners` property, you can forward all event listeners on the component to a specific child element with `v-on=\"$listeners\"`. For elements like `<input>`, that you also want to work with `v-model`, it's often useful to create a new computed property for listeners, like `inputListeners` below:\n\n```js\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  computed: {\n    inputListeners: function () {\n      var vm = this\n      // `Object.assign` merges objects together to form a new object\n      return Object.assign({},\n        // We add all the listeners from the parent\n        this.$listeners,\n        // Then we can add custom listeners or override the\n        // behavior of some listeners.\n        {\n          // This ensures that the component works with v-model\n          input: function (event) {\n            vm.$emit('input', event.target.value)\n          }\n        }\n      )\n    }\n  },\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on=\"inputListeners\"\n      >\n    </label>\n  `\n})\n```\n\nNow the `<base-input>` component is a **fully transparent wrapper**, meaning it can be used exactly like a normal `<input>` element: all the same attributes and listeners will work, without the `.native` modifier.\n\n## `.sync` Modifier\n\n> New in 2.3.0+\n\nIn some cases, we may need \"two-way binding\" for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.\n\nThat's why instead, we recommend emitting events in the pattern of `update:myPropName`. For example, in a hypothetical component with a `title` prop, we could communicate the intent of assigning a new value with:\n\n```js\nthis.$emit('update:title', newTitle)\n```\n\nThen the parent can listen to that event and update a local data property, if it wants to. For example:\n\n```html\n<text-document\n  v-bind:title=\"doc.title\"\n  v-on:update:title=\"doc.title = $event\"\n></text-document>\n```\n\nFor convenience, we offer a shorthand for this pattern with the `.sync` modifier:\n\n```html\n<text-document v-bind:title.sync=\"doc.title\"></text-document>\n```\n\n<p class=\"tip\">Note that <code>v-bind</code> with the <code>.sync</code> modifier does <strong>not</strong> work with expressions (e.g. <code>v-bind:title.sync=\"doc.title + '!'\"</code> is invalid). Instead, you must only provide the name of the property you want to bind, similar to <code>v-model</code>.</p>\n\nThe `.sync` modifier can also be used with `v-bind` when using an object to set multiple props at once:\n\n```html\n<text-document v-bind.sync=\"doc\"></text-document>\n```\n\nThis passes each property in the `doc` object (e.g. `title`) as an individual prop, then adds `v-on` update listeners for each one.\n\n<p class=\"tip\">Using <code>v-bind.sync</code> with a literal object, such as in <code>v-bind.sync=\"{ title: doc.title }\"</code>, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</p>\n","source":"v2/guide/components-custom-events.md","raw":"---\ntitle: Custom Events\ntype: guide\norder: 103\n---\n\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/communication-between-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to work with custom events on Vue School\">Learn how to work with custom events in a free Vue School lesson</a></div>\n\n## Event Names\n\nUnlike components and props, event names don't provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:\n\n```js\nthis.$emit('myEvent')\n```\n\nListening to the kebab-cased version will have no effect:\n\n```html\n<!-- Won't work -->\n<my-component v-on:my-event=\"doSomething\"></my-component>\n```\n\nUnlike components and props, event names will never be used as variable or property names in JavaScript, so there's no reason to use camelCase or PascalCase. Additionally, `v-on` event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML's case-insensitivity), so `v-on:myEvent` would become `v-on:myevent` -- making `myEvent` impossible to listen to.\n\nFor these reasons, we recommend you **always use kebab-case for event names**.\n\n## Customizing Component `v-model`\n\n> New in 2.2.0+\n\nBy default, `v-model` on a component uses `value` as the prop and `input` as the event, but some input types such as checkboxes and radio buttons may want to use the `value` attribute for a [different purpose](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value). Using the `model` option can avoid a conflict in such cases:\n\n```js\nVue.component('base-checkbox', {\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n  props: {\n    checked: Boolean\n  },\n  template: `\n    <input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    >\n  `\n})\n```\n\nNow when using `v-model` on this component:\n\n```html\n<base-checkbox v-model=\"lovingVue\"></base-checkbox>\n```\n\nthe value of `lovingVue` will be passed to the `checked` prop. The `lovingVue` property will then be updated when `<base-checkbox>` emits a `change` event with a new value.\n\n<p class=\"tip\">Note that you still have to declare the <code>checked</code> prop in the component's <code>props</code> option.</p>\n\n## Binding Native Events to Components\n\nThere may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the `.native` modifier for `v-on`:\n\n```html\n<base-input v-on:focus.native=\"onFocus\"></base-input>\n```\n\nThis can be useful sometimes, but it's not a good idea when you're trying to listen on a very specific element, like an `<input>`. For example, the `<base-input>` component above might refactor so that the root element is actually a `<label>` element:\n\n```html\n<label>\n  {{ label }}\n  <input\n    v-bind=\"$attrs\"\n    v-bind:value=\"value\"\n    v-on:input=\"$emit('input', $event.target.value)\"\n  >\n</label>\n```\n\nIn that case, the `.native` listener in the parent would silently break. There would be no errors, but the `onFocus` handler wouldn't be called when we expected it to.\n\nTo solve this problem, Vue provides a `$listeners` property containing an object of listeners being used on the component. For example:\n\n```js\n{\n  focus: function (event) { /* ... */ }\n  input: function (value) { /* ... */ },\n}\n```\n\nUsing the `$listeners` property, you can forward all event listeners on the component to a specific child element with `v-on=\"$listeners\"`. For elements like `<input>`, that you also want to work with `v-model`, it's often useful to create a new computed property for listeners, like `inputListeners` below:\n\n```js\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  computed: {\n    inputListeners: function () {\n      var vm = this\n      // `Object.assign` merges objects together to form a new object\n      return Object.assign({},\n        // We add all the listeners from the parent\n        this.$listeners,\n        // Then we can add custom listeners or override the\n        // behavior of some listeners.\n        {\n          // This ensures that the component works with v-model\n          input: function (event) {\n            vm.$emit('input', event.target.value)\n          }\n        }\n      )\n    }\n  },\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on=\"inputListeners\"\n      >\n    </label>\n  `\n})\n```\n\nNow the `<base-input>` component is a **fully transparent wrapper**, meaning it can be used exactly like a normal `<input>` element: all the same attributes and listeners will work, without the `.native` modifier.\n\n## `.sync` Modifier\n\n> New in 2.3.0+\n\nIn some cases, we may need \"two-way binding\" for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.\n\nThat's why instead, we recommend emitting events in the pattern of `update:myPropName`. For example, in a hypothetical component with a `title` prop, we could communicate the intent of assigning a new value with:\n\n```js\nthis.$emit('update:title', newTitle)\n```\n\nThen the parent can listen to that event and update a local data property, if it wants to. For example:\n\n```html\n<text-document\n  v-bind:title=\"doc.title\"\n  v-on:update:title=\"doc.title = $event\"\n></text-document>\n```\n\nFor convenience, we offer a shorthand for this pattern with the `.sync` modifier:\n\n```html\n<text-document v-bind:title.sync=\"doc.title\"></text-document>\n```\n\n<p class=\"tip\">Note that <code>v-bind</code> with the <code>.sync</code> modifier does <strong>not</strong> work with expressions (e.g. <code>v-bind:title.sync=\"doc.title + '!'\"</code> is invalid). Instead, you must only provide the name of the property you want to bind, similar to <code>v-model</code>.</p>\n\nThe `.sync` modifier can also be used with `v-bind` when using an object to set multiple props at once:\n\n```html\n<text-document v-bind.sync=\"doc\"></text-document>\n```\n\nThis passes each property in the `doc` object (e.g. `title`) as an individual prop, then adds `v-on` update listeners for each one.\n\n<p class=\"tip\">Using <code>v-bind.sync</code> with a literal object, such as in <code>v-bind.sync=\"{ title: doc.title }\"</code>, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</p>\n","date":"2020-09-25T23:55:41.133Z","updated":"2020-09-25T23:55:41.133Z","path":"v2/guide/components-custom-events.html","comments":1,"layout":"page","_id":"ckfl66gyh001uc2v5pbwnxp4e","content":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/communication-between-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to work with custom events on Vue School\">Learn how to work with custom events in a free Vue School lesson</a></div>\n\n<h2 id=\"Event-Names\"><a href=\"#Event-Names\" class=\"headerlink\" title=\"Event Names\"></a>Event Names</h2><p>Unlike components and props, event names don’t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'myEvent'</span>)</code></pre>\n<p>Listening to the kebab-cased version will have no effect:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Won't work --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-on:my-event</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there’s no reason to use camelCase or PascalCase. Additionally, <code>v-on</code> event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML’s case-insensitivity), so <code>v-on:myEvent</code> would become <code>v-on:myevent</code> – making <code>myEvent</code> impossible to listen to.</p>\n<p>For these reasons, we recommend you <strong>always use kebab-case for event names</strong>.</p>\n<h2 id=\"Customizing-Component-v-model\"><a href=\"#Customizing-Component-v-model\" class=\"headerlink\" title=\"Customizing Component v-model\"></a>Customizing Component <code>v-model</code></h2><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<p>By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> attribute for a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value\" target=\"_blank\" rel=\"noopener\">different purpose</a>. Using the <code>model</code> option can avoid a conflict in such cases:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'base-checkbox'</span>, &#123;\n  <span class=\"hljs-attr\">model</span>: &#123;\n    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">'checked'</span>,\n    <span class=\"hljs-attr\">event</span>: <span class=\"hljs-string\">'change'</span>\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">checked</span>: <span class=\"hljs-built_in\">Boolean</span>\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<p>Now when using <code>v-model</code> on this component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-checkbox</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"lovingVue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-checkbox</span>&gt;</span></code></pre>\n<p>the value of <code>lovingVue</code> will be passed to the <code>checked</code> prop. The <code>lovingVue</code> property will then be updated when <code>&lt;base-checkbox&gt;</code> emits a <code>change</code> event with a new value.</p>\n<p class=\"tip\">Note that you still have to declare the <code>checked</code> prop in the component’s <code>props</code> option.</p>\n\n<h2 id=\"Binding-Native-Events-to-Components\"><a href=\"#Binding-Native-Events-to-Components\" class=\"headerlink\" title=\"Binding Native Events to Components\"></a>Binding Native Events to Components</h2><p>There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the <code>.native</code> modifier for <code>v-on</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-input</span> <span class=\"hljs-attr\">v-on:focus.native</span>=<span class=\"hljs-string\">\"onFocus\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-input</span>&gt;</span></code></pre>\n<p>This can be useful sometimes, but it’s not a good idea when you’re trying to listen on a very specific element, like an <code>&lt;input&gt;</code>. For example, the <code>&lt;base-input&gt;</code> component above might refactor so that the root element is actually a <code>&lt;label&gt;</code> element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>\n  &#123;&#123; label &#125;&#125;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n    <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"$attrs\"</span>\n    <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"value\"</span>\n    <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"$emit('input', $event.target.value)\"</span>\n  &gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></code></pre>\n<p>In that case, the <code>.native</code> listener in the parent would silently break. There would be no errors, but the <code>onFocus</code> handler wouldn’t be called when we expected it to.</p>\n<p>To solve this problem, Vue provides a <code>$listeners</code> property containing an object of listeners being used on the component. For example:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n&#125;</code></pre>\n<p>Using the <code>$listeners</code> property, you can forward all event listeners on the component to a specific child element with <code>v-on=&quot;$listeners&quot;</code>. For elements like <code>&lt;input&gt;</code>, that you also want to work with <code>v-model</code>, it’s often useful to create a new computed property for listeners, like <code>inputListeners</code> below:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'base-input'</span>, &#123;\n  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'label'</span>, <span class=\"hljs-string\">'value'</span>],\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-attr\">inputListeners</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      <span class=\"hljs-comment\">// `Object.assign` merges objects together to form a new object</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.assign(&#123;&#125;,\n        <span class=\"hljs-comment\">// We add all the listeners from the parent</span>\n        <span class=\"hljs-keyword\">this</span>.$listeners,\n        <span class=\"hljs-comment\">// Then we can add custom listeners or override the</span>\n        <span class=\"hljs-comment\">// behavior of some listeners.</span>\n        &#123;\n          <span class=\"hljs-comment\">// This ensures that the component works with v-model</span>\n          <span class=\"hljs-attr\">input</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n            vm.$emit(<span class=\"hljs-string\">'input'</span>, event.target.value)\n          &#125;\n        &#125;\n      )\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;label&gt;\n      &#123;&#123; label &#125;&#125;\n      &lt;input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on=\"inputListeners\"\n      &gt;\n    &lt;/label&gt;\n  `</span>\n&#125;)</code></pre>\n<p>Now the <code>&lt;base-input&gt;</code> component is a <strong>fully transparent wrapper</strong>, meaning it can be used exactly like a normal <code>&lt;input&gt;</code> element: all the same attributes and listeners will work, without the <code>.native</code> modifier.</p>\n<h2 id=\"sync-Modifier\"><a href=\"#sync-Modifier\" class=\"headerlink\" title=\".sync Modifier\"></a><code>.sync</code> Modifier</h2><blockquote>\n<p>New in 2.3.0+</p>\n</blockquote>\n<p>In some cases, we may need “two-way binding” for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</p>\n<p>That’s why instead, we recommend emitting events in the pattern of <code>update:myPropName</code>. For example, in a hypothetical component with a <code>title</code> prop, we could communicate the intent of assigning a new value with:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'update:title'</span>, newTitle)</code></pre>\n<p>Then the parent can listen to that event and update a local data property, if it wants to. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text-document</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"doc.title\"</span>\n  <span class=\"hljs-attr\">v-on:update:title</span>=<span class=\"hljs-string\">\"doc.title = $event\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text-document</span>&gt;</span></code></pre>\n<p>For convenience, we offer a shorthand for this pattern with the <code>.sync</code> modifier:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text-document</span> <span class=\"hljs-attr\">v-bind:title.sync</span>=<span class=\"hljs-string\">\"doc.title\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text-document</span>&gt;</span></code></pre>\n<p class=\"tip\">Note that <code>v-bind</code> with the <code>.sync</code> modifier does <strong>not</strong> work with expressions (e.g. <code>v-bind:title.sync=”doc.title + ‘!’”</code> is invalid). Instead, you must only provide the name of the property you want to bind, similar to <code>v-model</code>.</p>\n\n<p>The <code>.sync</code> modifier can also be used with <code>v-bind</code> when using an object to set multiple props at once:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text-document</span> <span class=\"hljs-attr\">v-bind.sync</span>=<span class=\"hljs-string\">\"doc\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text-document</span>&gt;</span></code></pre>\n<p>This passes each property in the <code>doc</code> object (e.g. <code>title</code>) as an individual prop, then adds <code>v-on</code> update listeners for each one.</p>\n<p class=\"tip\">Using <code>v-bind.sync</code> with a literal object, such as in <code>v-bind.sync=”{ title: doc.title }”</code>, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/communication-between-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to work with custom events on Vue School\">Learn how to work with custom events in a free Vue School lesson</a></div>\n\n<h2 id=\"Event-Names\"><a href=\"#Event-Names\" class=\"headerlink\" title=\"Event Names\"></a>Event Names</h2><p>Unlike components and props, event names don’t provide any automatic case transformation. Instead, the name of an emitted event must exactly match the name used to listen to that event. For example, if emitting a camelCased event name:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'myEvent'</span>)</code></pre>\n<p>Listening to the kebab-cased version will have no effect:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Won't work --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-on:my-event</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>Unlike components and props, event names will never be used as variable or property names in JavaScript, so there’s no reason to use camelCase or PascalCase. Additionally, <code>v-on</code> event listeners inside DOM templates will be automatically transformed to lowercase (due to HTML’s case-insensitivity), so <code>v-on:myEvent</code> would become <code>v-on:myevent</code> – making <code>myEvent</code> impossible to listen to.</p>\n<p>For these reasons, we recommend you <strong>always use kebab-case for event names</strong>.</p>\n<h2 id=\"Customizing-Component-v-model\"><a href=\"#Customizing-Component-v-model\" class=\"headerlink\" title=\"Customizing Component v-model\"></a>Customizing Component <code>v-model</code></h2><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<p>By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> attribute for a <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value\" target=\"_blank\" rel=\"noopener\">different purpose</a>. Using the <code>model</code> option can avoid a conflict in such cases:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'base-checkbox'</span>, &#123;\n  <span class=\"hljs-attr\">model</span>: &#123;\n    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">'checked'</span>,\n    <span class=\"hljs-attr\">event</span>: <span class=\"hljs-string\">'change'</span>\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">checked</span>: <span class=\"hljs-built_in\">Boolean</span>\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      type=\"checkbox\"\n      v-bind:checked=\"checked\"\n      v-on:change=\"$emit('change', $event.target.checked)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<p>Now when using <code>v-model</code> on this component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-checkbox</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"lovingVue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-checkbox</span>&gt;</span></code></pre>\n<p>the value of <code>lovingVue</code> will be passed to the <code>checked</code> prop. The <code>lovingVue</code> property will then be updated when <code>&lt;base-checkbox&gt;</code> emits a <code>change</code> event with a new value.</p>\n<p class=\"tip\">Note that you still have to declare the <code>checked</code> prop in the component’s <code>props</code> option.</p>\n\n<h2 id=\"Binding-Native-Events-to-Components\"><a href=\"#Binding-Native-Events-to-Components\" class=\"headerlink\" title=\"Binding Native Events to Components\"></a>Binding Native Events to Components</h2><p>There may be times when you want to listen directly to a native event on the root element of a component. In these cases, you can use the <code>.native</code> modifier for <code>v-on</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-input</span> <span class=\"hljs-attr\">v-on:focus.native</span>=<span class=\"hljs-string\">\"onFocus\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-input</span>&gt;</span></code></pre>\n<p>This can be useful sometimes, but it’s not a good idea when you’re trying to listen on a very specific element, like an <code>&lt;input&gt;</code>. For example, the <code>&lt;base-input&gt;</code> component above might refactor so that the root element is actually a <code>&lt;label&gt;</code> element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>\n  &#123;&#123; label &#125;&#125;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n    <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"$attrs\"</span>\n    <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"value\"</span>\n    <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"$emit('input', $event.target.value)\"</span>\n  &gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></code></pre>\n<p>In that case, the <code>.native</code> listener in the parent would silently break. There would be no errors, but the <code>onFocus</code> handler wouldn’t be called when we expected it to.</p>\n<p>To solve this problem, Vue provides a <code>$listeners</code> property containing an object of listeners being used on the component. For example:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  <span class=\"hljs-attr\">input</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n&#125;</code></pre>\n<p>Using the <code>$listeners</code> property, you can forward all event listeners on the component to a specific child element with <code>v-on=&quot;$listeners&quot;</code>. For elements like <code>&lt;input&gt;</code>, that you also want to work with <code>v-model</code>, it’s often useful to create a new computed property for listeners, like <code>inputListeners</code> below:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'base-input'</span>, &#123;\n  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'label'</span>, <span class=\"hljs-string\">'value'</span>],\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-attr\">inputListeners</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      <span class=\"hljs-comment\">// `Object.assign` merges objects together to form a new object</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.assign(&#123;&#125;,\n        <span class=\"hljs-comment\">// We add all the listeners from the parent</span>\n        <span class=\"hljs-keyword\">this</span>.$listeners,\n        <span class=\"hljs-comment\">// Then we can add custom listeners or override the</span>\n        <span class=\"hljs-comment\">// behavior of some listeners.</span>\n        &#123;\n          <span class=\"hljs-comment\">// This ensures that the component works with v-model</span>\n          <span class=\"hljs-attr\">input</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n            vm.$emit(<span class=\"hljs-string\">'input'</span>, event.target.value)\n          &#125;\n        &#125;\n      )\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;label&gt;\n      &#123;&#123; label &#125;&#125;\n      &lt;input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on=\"inputListeners\"\n      &gt;\n    &lt;/label&gt;\n  `</span>\n&#125;)</code></pre>\n<p>Now the <code>&lt;base-input&gt;</code> component is a <strong>fully transparent wrapper</strong>, meaning it can be used exactly like a normal <code>&lt;input&gt;</code> element: all the same attributes and listeners will work, without the <code>.native</code> modifier.</p>\n<h2 id=\"sync-Modifier\"><a href=\"#sync-Modifier\" class=\"headerlink\" title=\".sync Modifier\"></a><code>.sync</code> Modifier</h2><blockquote>\n<p>New in 2.3.0+</p>\n</blockquote>\n<p>In some cases, we may need “two-way binding” for a prop. Unfortunately, true two-way binding can create maintenance issues, because child components can mutate the parent without the source of that mutation being obvious in both the parent and the child.</p>\n<p>That’s why instead, we recommend emitting events in the pattern of <code>update:myPropName</code>. For example, in a hypothetical component with a <code>title</code> prop, we could communicate the intent of assigning a new value with:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'update:title'</span>, newTitle)</code></pre>\n<p>Then the parent can listen to that event and update a local data property, if it wants to. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text-document</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"doc.title\"</span>\n  <span class=\"hljs-attr\">v-on:update:title</span>=<span class=\"hljs-string\">\"doc.title = $event\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text-document</span>&gt;</span></code></pre>\n<p>For convenience, we offer a shorthand for this pattern with the <code>.sync</code> modifier:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text-document</span> <span class=\"hljs-attr\">v-bind:title.sync</span>=<span class=\"hljs-string\">\"doc.title\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text-document</span>&gt;</span></code></pre>\n<p class=\"tip\">Note that <code>v-bind</code> with the <code>.sync</code> modifier does <strong>not</strong> work with expressions (e.g. <code>v-bind:title.sync=”doc.title + ‘!’”</code> is invalid). Instead, you must only provide the name of the property you want to bind, similar to <code>v-model</code>.</p>\n\n<p>The <code>.sync</code> modifier can also be used with <code>v-bind</code> when using an object to set multiple props at once:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">text-document</span> <span class=\"hljs-attr\">v-bind.sync</span>=<span class=\"hljs-string\">\"doc\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">text-document</span>&gt;</span></code></pre>\n<p>This passes each property in the <code>doc</code> object (e.g. <code>title</code>) as an individual prop, then adds <code>v-on</code> update listeners for each one.</p>\n<p class=\"tip\">Using <code>v-bind.sync</code> with a literal object, such as in <code>v-bind.sync=”{ title: doc.title }”</code>, will not work, because there are too many edge cases to consider in parsing a complex expression like this.</p>\n"},{"title":"Dynamic & Async Components","type":"guide","order":105,"_content":"\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n## `keep-alive` with Dynamic Components\n\nEarlier, we used the `is` attribute to switch between components in a tabbed interface:\n\n{% codeblock lang:html %}\n<component v-bind:is=\"currentTabComponent\"></component>\n{% endcodeblock %}\n\nWhen switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:\n\n{% raw %}\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button\n    v-for=\"tab in tabs\"\n    v-bind:key=\"tab\"\n    v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\"\n    v-on:click=\"currentTab = tab\"\n  >{{ tab }}</button>\n  <component\n    v-bind:is=\"currentTabComponent\"\n    class=\"dynamic-component-demo-tab\"\n  ></component>\n</div>\n<script>\nVue.component('tab-posts', {\n  data: function () {\n    return {\n      posts: [\n        {\n          id: 1,\n          title: 'Cat Ipsum',\n          content: '<p>Dont wait for the storm to pass, dance in the rain kick up litter decide to want nothing to do with my owner today demand to be let outside at once, and expect owner to wait for me as i think about it cat cat moo moo lick ears lick paws so make meme, make cute face but lick the other cats. Kitty poochy chase imaginary bugs, but stand in front of the computer screen. Sweet beast cat dog hate mouse eat string barf pillow no baths hate everything stare at guinea pigs. My left donut is missing, as is my right loved it, hated it, loved it, hated it scoot butt on the rug cat not kitten around</p>'\n        },\n        {\n          id: 2,\n          title: 'Hipster Ipsum',\n          content: '<p>Bushwick blue bottle scenester helvetica ugh, meh four loko. Put a bird on it lumbersexual franzen shabby chic, street art knausgaard trust fund shaman scenester live-edge mixtape taxidermy viral yuccie succulents. Keytar poke bicycle rights, crucifix street art neutra air plant PBR&B hoodie plaid venmo. Tilde swag art party fanny pack vinyl letterpress venmo jean shorts offal mumblecore. Vice blog gentrify mlkshk tattooed occupy snackwave, hoodie craft beer next level migas 8-bit chartreuse. Trust fund food truck drinking vinegar gochujang.</p>'\n        },\n        {\n          id: 3,\n          title: 'Cupcake Ipsum',\n          content: '<p>Icing dessert soufflé lollipop chocolate bar sweet tart cake chupa chups. Soufflé marzipan jelly beans croissant toffee marzipan cupcake icing fruitcake. Muffin cake pudding soufflé wafer jelly bear claw sesame snaps marshmallow. Marzipan soufflé croissant lemon drops gingerbread sugar plum lemon drops apple pie gummies. Sweet roll donut oat cake toffee cake. Liquorice candy macaroon toffee cookie marzipan.</p>'\n        }\n      ],\n      selectedPost: null\n    }\n  },\n  template: '\\\n    <div class=\"dynamic-component-demo-posts-tab\">\\\n      <ul class=\"dynamic-component-demo-posts-sidebar\">\\\n        <li\\\n          v-for=\"post in posts\"\\\n          v-bind:key=\"post.id\"\\\n          v-bind:class=\"{ \\'dynamic-component-demo-active\\': post === selectedPost }\"\\\n          v-on:click=\"selectedPost = post\"\\\n        >\\\n          {{ post.title }}\\\n        </li>\\\n      </ul>\\\n      <div class=\"dynamic-component-demo-post-container\">\\\n        <div \\\n          v-if=\"selectedPost\"\\\n          class=\"dynamic-component-demo-post\"\\\n        >\\\n          <h3>{{ selectedPost.title }}</h3>\\\n          <div v-html=\"selectedPost.content\"></div>\\\n        </div>\\\n        <strong v-else>\\\n          Click on a blog title to the left to view it.\\\n        </strong>\\\n      </div>\\\n    </div>\\\n  '\n})\nVue.component('tab-archive', {\n  template: '<div>Archive component</div>'\n})\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n  overflow-anchor: none;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button.dynamic-component-demo-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n.dynamic-component-demo-posts-tab {\n  display: flex;\n}\n.dynamic-component-demo-posts-sidebar {\n  max-width: 40vw;\n  margin: 0 !important;\n  padding: 0 10px 0 0 !important;\n  list-style-type: none;\n  border-right: 1px solid #ccc;\n}\n.dynamic-component-demo-posts-sidebar li {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  cursor: pointer;\n}\n.dynamic-component-demo-posts-sidebar li:hover {\n  background: #eee;\n}\n.dynamic-component-demo-posts-sidebar li.dynamic-component-demo-active {\n  background: lightblue;\n}\n.dynamic-component-demo-post-container {\n  padding-left: 10px;\n}\n.dynamic-component-demo-post > :first-child {\n  margin-top: 0 !important;\n  padding-top: 0 !important;\n}\n</style>\n{% endraw %}\n\nYou'll notice that if you select a post, switch to the _Archive_ tab, then switch back to _Posts_, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the `currentTabComponent`.\n\nRecreating dynamic components is normally useful behavior, but in this case, we'd really like those tab component instances to be cached once they're created for the first time. To solve this problem, we can wrap our dynamic component with a `<keep-alive>` element:\n\n``` html\n<!-- Inactive components will be cached! -->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\nCheck out the result below:\n\n{% raw %}\n<div id=\"dynamic-component-keep-alive-demo\" class=\"demo\">\n  <button\n    v-for=\"tab in tabs\"\n    v-bind:key=\"tab\"\n    v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\"\n    v-on:click=\"currentTab = tab\"\n  >{{ tab }}</button>\n  <keep-alive>\n    <component\n      v-bind:is=\"currentTabComponent\"\n      class=\"dynamic-component-demo-tab\"\n    ></component>\n  </keep-alive>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-component-keep-alive-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n{% endraw %}\n\nNow the _Posts_ tab maintains its state (the selected post) even when it's not rendered. See [this example](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components) for the complete code.\n\n<p class=\"tip\">Note that `<keep-alive>` requires the components being switched between to all have names, either using the `name` option on a component, or through local/global registration.</p>\n\nCheck out more details on `<keep-alive>` in the [API reference](../api/#keep-alive).\n\n## Async Components\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/dynamically-load-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Async Components lesson\">Watch a free video lesson on Vue School</a></div>\n\nIn large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // Pass the component definition to the resolve callback\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\nAs you can see, the factory function receives a `resolve` callback, which should be called when you have retrieved your component definition from the server. You can also call `reject(reason)` to indicate the load has failed. The `setTimeout` here is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with [Webpack's code-splitting feature](https://webpack.js.org/guides/code-splitting/):\n\n``` js\nVue.component('async-webpack-example', function (resolve) {\n  // This special require syntax will instruct Webpack to\n  // automatically split your built code into bundles which\n  // are loaded over Ajax requests.\n  require(['./my-async-component'], resolve)\n})\n```\n\nYou can also return a `Promise` in the factory function, so with Webpack 2 and ES2015 syntax you can make use of dynamic imports:\n\n``` js\nVue.component(\n  'async-webpack-example',\n  // A dynamic import returns a Promise.\n  () => import('./my-async-component')\n)\n```\n\nWhen using [local registration](components-registration.html#Local-Registration), you can also directly provide a function that returns a `Promise`:\n\n``` js\nnew Vue({\n  // ...\n  components: {\n    'my-component': () => import('./my-async-component')\n  }\n})\n```\n\n<p class=\"tip\">If you're a <strong>Browserify</strong> user that would like to use async components, its creator has unfortunately [made it clear](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224) that async loading \"is not something that Browserify will ever support.\" Officially, at least. The Browserify community has found [some workarounds](https://github.com/vuejs/vuejs.org/issues/620), which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</p>\n\n### Handling Loading State\n\n> New in 2.3.0+\n\nThe async component factory can also return an object of the following format:\n\n``` js\nconst AsyncComponent = () => ({\n  // The component to load (should be a Promise)\n  component: import('./MyComponent.vue'),\n  // A component to use while the async component is loading\n  loading: LoadingComponent,\n  // A component to use if the load fails\n  error: ErrorComponent,\n  // Delay before showing the loading component. Default: 200ms.\n  delay: 200,\n  // The error component will be displayed if a timeout is\n  // provided and exceeded. Default: Infinity.\n  timeout: 3000\n})\n```\n\n> Note that you must use [Vue Router](https://github.com/vuejs/vue-router) 2.4.0+ if you wish to use the above syntax for route components.\n","source":"v2/guide/components-dynamic-async.md","raw":"---\ntitle: Dynamic & Async Components\ntype: guide\norder: 105\n---\n\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n## `keep-alive` with Dynamic Components\n\nEarlier, we used the `is` attribute to switch between components in a tabbed interface:\n\n{% codeblock lang:html %}\n<component v-bind:is=\"currentTabComponent\"></component>\n{% endcodeblock %}\n\nWhen switching between these components though, you'll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:\n\n{% raw %}\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button\n    v-for=\"tab in tabs\"\n    v-bind:key=\"tab\"\n    v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\"\n    v-on:click=\"currentTab = tab\"\n  >{{ tab }}</button>\n  <component\n    v-bind:is=\"currentTabComponent\"\n    class=\"dynamic-component-demo-tab\"\n  ></component>\n</div>\n<script>\nVue.component('tab-posts', {\n  data: function () {\n    return {\n      posts: [\n        {\n          id: 1,\n          title: 'Cat Ipsum',\n          content: '<p>Dont wait for the storm to pass, dance in the rain kick up litter decide to want nothing to do with my owner today demand to be let outside at once, and expect owner to wait for me as i think about it cat cat moo moo lick ears lick paws so make meme, make cute face but lick the other cats. Kitty poochy chase imaginary bugs, but stand in front of the computer screen. Sweet beast cat dog hate mouse eat string barf pillow no baths hate everything stare at guinea pigs. My left donut is missing, as is my right loved it, hated it, loved it, hated it scoot butt on the rug cat not kitten around</p>'\n        },\n        {\n          id: 2,\n          title: 'Hipster Ipsum',\n          content: '<p>Bushwick blue bottle scenester helvetica ugh, meh four loko. Put a bird on it lumbersexual franzen shabby chic, street art knausgaard trust fund shaman scenester live-edge mixtape taxidermy viral yuccie succulents. Keytar poke bicycle rights, crucifix street art neutra air plant PBR&B hoodie plaid venmo. Tilde swag art party fanny pack vinyl letterpress venmo jean shorts offal mumblecore. Vice blog gentrify mlkshk tattooed occupy snackwave, hoodie craft beer next level migas 8-bit chartreuse. Trust fund food truck drinking vinegar gochujang.</p>'\n        },\n        {\n          id: 3,\n          title: 'Cupcake Ipsum',\n          content: '<p>Icing dessert soufflé lollipop chocolate bar sweet tart cake chupa chups. Soufflé marzipan jelly beans croissant toffee marzipan cupcake icing fruitcake. Muffin cake pudding soufflé wafer jelly bear claw sesame snaps marshmallow. Marzipan soufflé croissant lemon drops gingerbread sugar plum lemon drops apple pie gummies. Sweet roll donut oat cake toffee cake. Liquorice candy macaroon toffee cookie marzipan.</p>'\n        }\n      ],\n      selectedPost: null\n    }\n  },\n  template: '\\\n    <div class=\"dynamic-component-demo-posts-tab\">\\\n      <ul class=\"dynamic-component-demo-posts-sidebar\">\\\n        <li\\\n          v-for=\"post in posts\"\\\n          v-bind:key=\"post.id\"\\\n          v-bind:class=\"{ \\'dynamic-component-demo-active\\': post === selectedPost }\"\\\n          v-on:click=\"selectedPost = post\"\\\n        >\\\n          {{ post.title }}\\\n        </li>\\\n      </ul>\\\n      <div class=\"dynamic-component-demo-post-container\">\\\n        <div \\\n          v-if=\"selectedPost\"\\\n          class=\"dynamic-component-demo-post\"\\\n        >\\\n          <h3>{{ selectedPost.title }}</h3>\\\n          <div v-html=\"selectedPost.content\"></div>\\\n        </div>\\\n        <strong v-else>\\\n          Click on a blog title to the left to view it.\\\n        </strong>\\\n      </div>\\\n    </div>\\\n  '\n})\nVue.component('tab-archive', {\n  template: '<div>Archive component</div>'\n})\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n  overflow-anchor: none;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button.dynamic-component-demo-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n.dynamic-component-demo-posts-tab {\n  display: flex;\n}\n.dynamic-component-demo-posts-sidebar {\n  max-width: 40vw;\n  margin: 0 !important;\n  padding: 0 10px 0 0 !important;\n  list-style-type: none;\n  border-right: 1px solid #ccc;\n}\n.dynamic-component-demo-posts-sidebar li {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  cursor: pointer;\n}\n.dynamic-component-demo-posts-sidebar li:hover {\n  background: #eee;\n}\n.dynamic-component-demo-posts-sidebar li.dynamic-component-demo-active {\n  background: lightblue;\n}\n.dynamic-component-demo-post-container {\n  padding-left: 10px;\n}\n.dynamic-component-demo-post > :first-child {\n  margin-top: 0 !important;\n  padding-top: 0 !important;\n}\n</style>\n{% endraw %}\n\nYou'll notice that if you select a post, switch to the _Archive_ tab, then switch back to _Posts_, it's no longer showing the post you selected. That's because each time you switch to a new tab, Vue creates a new instance of the `currentTabComponent`.\n\nRecreating dynamic components is normally useful behavior, but in this case, we'd really like those tab component instances to be cached once they're created for the first time. To solve this problem, we can wrap our dynamic component with a `<keep-alive>` element:\n\n``` html\n<!-- Inactive components will be cached! -->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\nCheck out the result below:\n\n{% raw %}\n<div id=\"dynamic-component-keep-alive-demo\" class=\"demo\">\n  <button\n    v-for=\"tab in tabs\"\n    v-bind:key=\"tab\"\n    v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\"\n    v-on:click=\"currentTab = tab\"\n  >{{ tab }}</button>\n  <keep-alive>\n    <component\n      v-bind:is=\"currentTabComponent\"\n      class=\"dynamic-component-demo-tab\"\n    ></component>\n  </keep-alive>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-component-keep-alive-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n{% endraw %}\n\nNow the _Posts_ tab maintains its state (the selected post) even when it's not rendered. See [this example](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components) for the complete code.\n\n<p class=\"tip\">Note that `<keep-alive>` requires the components being switched between to all have names, either using the `name` option on a component, or through local/global registration.</p>\n\nCheck out more details on `<keep-alive>` in the [API reference](../api/#keep-alive).\n\n## Async Components\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/dynamically-load-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Async Components lesson\">Watch a free video lesson on Vue School</a></div>\n\nIn large applications, we may need to divide the app into smaller chunks and only load a component from the server when it's needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    // Pass the component definition to the resolve callback\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\nAs you can see, the factory function receives a `resolve` callback, which should be called when you have retrieved your component definition from the server. You can also call `reject(reason)` to indicate the load has failed. The `setTimeout` here is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with [Webpack's code-splitting feature](https://webpack.js.org/guides/code-splitting/):\n\n``` js\nVue.component('async-webpack-example', function (resolve) {\n  // This special require syntax will instruct Webpack to\n  // automatically split your built code into bundles which\n  // are loaded over Ajax requests.\n  require(['./my-async-component'], resolve)\n})\n```\n\nYou can also return a `Promise` in the factory function, so with Webpack 2 and ES2015 syntax you can make use of dynamic imports:\n\n``` js\nVue.component(\n  'async-webpack-example',\n  // A dynamic import returns a Promise.\n  () => import('./my-async-component')\n)\n```\n\nWhen using [local registration](components-registration.html#Local-Registration), you can also directly provide a function that returns a `Promise`:\n\n``` js\nnew Vue({\n  // ...\n  components: {\n    'my-component': () => import('./my-async-component')\n  }\n})\n```\n\n<p class=\"tip\">If you're a <strong>Browserify</strong> user that would like to use async components, its creator has unfortunately [made it clear](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224) that async loading \"is not something that Browserify will ever support.\" Officially, at least. The Browserify community has found [some workarounds](https://github.com/vuejs/vuejs.org/issues/620), which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</p>\n\n### Handling Loading State\n\n> New in 2.3.0+\n\nThe async component factory can also return an object of the following format:\n\n``` js\nconst AsyncComponent = () => ({\n  // The component to load (should be a Promise)\n  component: import('./MyComponent.vue'),\n  // A component to use while the async component is loading\n  loading: LoadingComponent,\n  // A component to use if the load fails\n  error: ErrorComponent,\n  // Delay before showing the loading component. Default: 200ms.\n  delay: 200,\n  // The error component will be displayed if a timeout is\n  // provided and exceeded. Default: Infinity.\n  timeout: 3000\n})\n```\n\n> Note that you must use [Vue Router](https://github.com/vuejs/vue-router) 2.4.0+ if you wish to use the above syntax for route components.\n","date":"2020-09-25T23:55:41.133Z","updated":"2020-09-25T23:55:41.133Z","path":"v2/guide/components-dynamic-async.html","comments":1,"layout":"page","_id":"ckfl66gyi001vc2v5bs1pxd2d","content":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<h2 id=\"keep-alive-with-Dynamic-Components\"><a href=\"#keep-alive-with-Dynamic-Components\" class=\"headerlink\" title=\"keep-alive with Dynamic Components\"></a><code>keep-alive</code> with Dynamic Components</h2><p>Earlier, we used the <code>is</code> attribute to switch between components in a tabbed interface:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentTabComponent\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n<p>When switching between these components though, you’ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</p>\n\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button v-for=\"tab in tabs\" v-bind:key=\"tab\" v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\" v-on:click=\"currentTab = tab\">{{ tab }}</button>\n  <component v-bind:is=\"currentTabComponent\" class=\"dynamic-component-demo-tab\"></component>\n</div>\n<script>\nVue.component('tab-posts', {\n  data: function () {\n    return {\n      posts: [\n        {\n          id: 1,\n          title: 'Cat Ipsum',\n          content: '<p>Dont wait for the storm to pass, dance in the rain kick up litter decide to want nothing to do with my owner today demand to be let outside at once, and expect owner to wait for me as i think about it cat cat moo moo lick ears lick paws so make meme, make cute face but lick the other cats. Kitty poochy chase imaginary bugs, but stand in front of the computer screen. Sweet beast cat dog hate mouse eat string barf pillow no baths hate everything stare at guinea pigs. My left donut is missing, as is my right loved it, hated it, loved it, hated it scoot butt on the rug cat not kitten around</p>'\n        },\n        {\n          id: 2,\n          title: 'Hipster Ipsum',\n          content: '<p>Bushwick blue bottle scenester helvetica ugh, meh four loko. Put a bird on it lumbersexual franzen shabby chic, street art knausgaard trust fund shaman scenester live-edge mixtape taxidermy viral yuccie succulents. Keytar poke bicycle rights, crucifix street art neutra air plant PBR&B hoodie plaid venmo. Tilde swag art party fanny pack vinyl letterpress venmo jean shorts offal mumblecore. Vice blog gentrify mlkshk tattooed occupy snackwave, hoodie craft beer next level migas 8-bit chartreuse. Trust fund food truck drinking vinegar gochujang.</p>'\n        },\n        {\n          id: 3,\n          title: 'Cupcake Ipsum',\n          content: '<p>Icing dessert soufflé lollipop chocolate bar sweet tart cake chupa chups. Soufflé marzipan jelly beans croissant toffee marzipan cupcake icing fruitcake. Muffin cake pudding soufflé wafer jelly bear claw sesame snaps marshmallow. Marzipan soufflé croissant lemon drops gingerbread sugar plum lemon drops apple pie gummies. Sweet roll donut oat cake toffee cake. Liquorice candy macaroon toffee cookie marzipan.</p>'\n        }\n      ],\n      selectedPost: null\n    }\n  },\n  template: '\\\n    <div class=\"dynamic-component-demo-posts-tab\">\\\n      <ul class=\"dynamic-component-demo-posts-sidebar\">\\\n        <li\\\n          v-for=\"post in posts\"\\\n          v-bind:key=\"post.id\"\\\n          v-bind:class=\"{ \\'dynamic-component-demo-active\\': post === selectedPost }\"\\\n          v-on:click=\"selectedPost = post\"\\\n        >\\\n          {{ post.title }}\\\n        </li>\\\n      </ul>\\\n      <div class=\"dynamic-component-demo-post-container\">\\\n        <div \\\n          v-if=\"selectedPost\"\\\n          class=\"dynamic-component-demo-post\"\\\n        >\\\n          <h3>{{ selectedPost.title }}</h3>\\\n          <div v-html=\"selectedPost.content\"></div>\\\n        </div>\\\n        <strong v-else>\\\n          Click on a blog title to the left to view it.\\\n        </strong>\\\n      </div>\\\n    </div>\\\n  '\n})\nVue.component('tab-archive', {\n  template: '<div>Archive component</div>'\n})\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n  overflow-anchor: none;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button.dynamic-component-demo-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n.dynamic-component-demo-posts-tab {\n  display: flex;\n}\n.dynamic-component-demo-posts-sidebar {\n  max-width: 40vw;\n  margin: 0 !important;\n  padding: 0 10px 0 0 !important;\n  list-style-type: none;\n  border-right: 1px solid #ccc;\n}\n.dynamic-component-demo-posts-sidebar li {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  cursor: pointer;\n}\n.dynamic-component-demo-posts-sidebar li:hover {\n  background: #eee;\n}\n.dynamic-component-demo-posts-sidebar li.dynamic-component-demo-active {\n  background: lightblue;\n}\n.dynamic-component-demo-post-container {\n  padding-left: 10px;\n}\n.dynamic-component-demo-post > :first-child {\n  margin-top: 0 !important;\n  padding-top: 0 !important;\n}\n</style>\n\n<p>You’ll notice that if you select a post, switch to the <em>Archive</em> tab, then switch back to <em>Posts</em>, it’s no longer showing the post you selected. That’s because each time you switch to a new tab, Vue creates a new instance of the <code>currentTabComponent</code>.</p>\n<p>Recreating dynamic components is normally useful behavior, but in this case, we’d really like those tab component instances to be cached once they’re created for the first time. To solve this problem, we can wrap our dynamic component with a <code>&lt;keep-alive&gt;</code> element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Inactive components will be cached! --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentTabComponent\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>Check out the result below:</p>\n\n<div id=\"dynamic-component-keep-alive-demo\" class=\"demo\">\n  <button v-for=\"tab in tabs\" v-bind:key=\"tab\" v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\" v-on:click=\"currentTab = tab\">{{ tab }}</button>\n  <keep-alive>\n    <component v-bind:is=\"currentTabComponent\" class=\"dynamic-component-demo-tab\"></component>\n  </keep-alive>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-component-keep-alive-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n\n<p>Now the <em>Posts</em> tab maintains its state (the selected post) even when it’s not rendered. See <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components\" target=\"_blank\" rel=\"noopener\">this example</a> for the complete code.</p>\n<p class=\"tip\">Note that <code>&lt;keep-alive&gt;</code> requires the components being switched between to all have names, either using the <code>name</code> option on a component, or through local/global registration.</p>\n\n<p>Check out more details on <code>&lt;keep-alive&gt;</code> in the <a href=\"../api/#keep-alive\">API reference</a>.</p>\n<h2 id=\"Async-Components\"><a href=\"#Async-Components\" class=\"headerlink\" title=\"Async Components\"></a>Async Components</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/dynamically-load-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Async Components lesson\">Watch a free video lesson on Vue School</a></div>\n\n<p>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it’s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Pass the component definition to the resolve callback</span>\n    resolve(&#123;\n      <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span>\n    &#125;)\n  &#125;, <span class=\"hljs-number\">1000</span>)\n&#125;)</code></pre>\n<p>As you can see, the factory function receives a <code>resolve</code> callback, which should be called when you have retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the load has failed. The <code>setTimeout</code> here is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with <a href=\"https://webpack.js.org/guides/code-splitting/\" target=\"_blank\" rel=\"noopener\">Webpack’s code-splitting feature</a>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-webpack-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>&#123;\n  <span class=\"hljs-comment\">// This special require syntax will instruct Webpack to</span>\n  <span class=\"hljs-comment\">// automatically split your built code into bundles which</span>\n  <span class=\"hljs-comment\">// are loaded over Ajax requests.</span>\n  <span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">'./my-async-component'</span>], resolve)\n&#125;)</code></pre>\n<p>You can also return a <code>Promise</code> in the factory function, so with Webpack 2 and ES2015 syntax you can make use of dynamic imports:</p>\n<pre><code class=\"hljs js\">Vue.component(\n  <span class=\"hljs-string\">'async-webpack-example'</span>,\n  <span class=\"hljs-comment\">// A dynamic import returns a Promise.</span>\n  () =&gt; <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./my-async-component'</span>)\n)</code></pre>\n<p>When using <a href=\"components-registration.html#Local-Registration\">local registration</a>, you can also directly provide a function that returns a <code>Promise</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">components</span>: &#123;\n    <span class=\"hljs-string\">'my-component'</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./my-async-component'</span>)\n  &#125;\n&#125;)</code></pre>\n<p class=\"tip\">If you’re a <strong>Browserify</strong> user that would like to use async components, its creator has unfortunately <a href=\"https://github.com/substack/node-browserify/issues/58#issuecomment-21978224\" target=\"_blank\" rel=\"noopener\">made it clear</a> that async loading “is not something that Browserify will ever support.” Officially, at least. The Browserify community has found <a href=\"https://github.com/vuejs/vuejs.org/issues/620\" target=\"_blank\" rel=\"noopener\">some workarounds</a>, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</p>\n\n<h3 id=\"Handling-Loading-State\"><a href=\"#Handling-Loading-State\" class=\"headerlink\" title=\"Handling Loading State\"></a>Handling Loading State</h3><blockquote>\n<p>New in 2.3.0+</p>\n</blockquote>\n<p>The async component factory can also return an object of the following format:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> AsyncComponent = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> (&#123;\n  <span class=\"hljs-comment\">// The component to load (should be a Promise)</span>\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./MyComponent.vue'</span>),\n  <span class=\"hljs-comment\">// A component to use while the async component is loading</span>\n  <span class=\"hljs-attr\">loading</span>: LoadingComponent,\n  <span class=\"hljs-comment\">// A component to use if the load fails</span>\n  <span class=\"hljs-attr\">error</span>: ErrorComponent,\n  <span class=\"hljs-comment\">// Delay before showing the loading component. Default: 200ms.</span>\n  <span class=\"hljs-attr\">delay</span>: <span class=\"hljs-number\">200</span>,\n  <span class=\"hljs-comment\">// The error component will be displayed if a timeout is</span>\n  <span class=\"hljs-comment\">// provided and exceeded. Default: Infinity.</span>\n  <span class=\"hljs-attr\">timeout</span>: <span class=\"hljs-number\">3000</span>\n&#125;)</code></pre>\n<blockquote>\n<p>Note that you must use <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">Vue Router</a> 2.4.0+ if you wish to use the above syntax for route components.</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<h2 id=\"keep-alive-with-Dynamic-Components\"><a href=\"#keep-alive-with-Dynamic-Components\" class=\"headerlink\" title=\"keep-alive with Dynamic Components\"></a><code>keep-alive</code> with Dynamic Components</h2><p>Earlier, we used the <code>is</code> attribute to switch between components in a tabbed interface:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentTabComponent\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n<p>When switching between these components though, you’ll sometimes want to maintain their state or avoid re-rendering for performance reasons. For example, when expanding our tabbed interface a little:</p>\n\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button v-for=\"tab in tabs\" v-bind:key=\"tab\" v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\" v-on:click=\"currentTab = tab\">{{ tab }}</button>\n  <component v-bind:is=\"currentTabComponent\" class=\"dynamic-component-demo-tab\"></component>\n</div>\n<script>\nVue.component('tab-posts', {\n  data: function () {\n    return {\n      posts: [\n        {\n          id: 1,\n          title: 'Cat Ipsum',\n          content: '<p>Dont wait for the storm to pass, dance in the rain kick up litter decide to want nothing to do with my owner today demand to be let outside at once, and expect owner to wait for me as i think about it cat cat moo moo lick ears lick paws so make meme, make cute face but lick the other cats. Kitty poochy chase imaginary bugs, but stand in front of the computer screen. Sweet beast cat dog hate mouse eat string barf pillow no baths hate everything stare at guinea pigs. My left donut is missing, as is my right loved it, hated it, loved it, hated it scoot butt on the rug cat not kitten around</p>'\n        },\n        {\n          id: 2,\n          title: 'Hipster Ipsum',\n          content: '<p>Bushwick blue bottle scenester helvetica ugh, meh four loko. Put a bird on it lumbersexual franzen shabby chic, street art knausgaard trust fund shaman scenester live-edge mixtape taxidermy viral yuccie succulents. Keytar poke bicycle rights, crucifix street art neutra air plant PBR&B hoodie plaid venmo. Tilde swag art party fanny pack vinyl letterpress venmo jean shorts offal mumblecore. Vice blog gentrify mlkshk tattooed occupy snackwave, hoodie craft beer next level migas 8-bit chartreuse. Trust fund food truck drinking vinegar gochujang.</p>'\n        },\n        {\n          id: 3,\n          title: 'Cupcake Ipsum',\n          content: '<p>Icing dessert soufflé lollipop chocolate bar sweet tart cake chupa chups. Soufflé marzipan jelly beans croissant toffee marzipan cupcake icing fruitcake. Muffin cake pudding soufflé wafer jelly bear claw sesame snaps marshmallow. Marzipan soufflé croissant lemon drops gingerbread sugar plum lemon drops apple pie gummies. Sweet roll donut oat cake toffee cake. Liquorice candy macaroon toffee cookie marzipan.</p>'\n        }\n      ],\n      selectedPost: null\n    }\n  },\n  template: '\\\n    <div class=\"dynamic-component-demo-posts-tab\">\\\n      <ul class=\"dynamic-component-demo-posts-sidebar\">\\\n        <li\\\n          v-for=\"post in posts\"\\\n          v-bind:key=\"post.id\"\\\n          v-bind:class=\"{ \\'dynamic-component-demo-active\\': post === selectedPost }\"\\\n          v-on:click=\"selectedPost = post\"\\\n        >\\\n          {{ post.title }}\\\n        </li>\\\n      </ul>\\\n      <div class=\"dynamic-component-demo-post-container\">\\\n        <div \\\n          v-if=\"selectedPost\"\\\n          class=\"dynamic-component-demo-post\"\\\n        >\\\n          <h3>{{ selectedPost.title }}</h3>\\\n          <div v-html=\"selectedPost.content\"></div>\\\n        </div>\\\n        <strong v-else>\\\n          Click on a blog title to the left to view it.\\\n        </strong>\\\n      </div>\\\n    </div>\\\n  '\n})\nVue.component('tab-archive', {\n  template: '<div>Archive component</div>'\n})\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n  overflow-anchor: none;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button.dynamic-component-demo-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n.dynamic-component-demo-posts-tab {\n  display: flex;\n}\n.dynamic-component-demo-posts-sidebar {\n  max-width: 40vw;\n  margin: 0 !important;\n  padding: 0 10px 0 0 !important;\n  list-style-type: none;\n  border-right: 1px solid #ccc;\n}\n.dynamic-component-demo-posts-sidebar li {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  cursor: pointer;\n}\n.dynamic-component-demo-posts-sidebar li:hover {\n  background: #eee;\n}\n.dynamic-component-demo-posts-sidebar li.dynamic-component-demo-active {\n  background: lightblue;\n}\n.dynamic-component-demo-post-container {\n  padding-left: 10px;\n}\n.dynamic-component-demo-post > :first-child {\n  margin-top: 0 !important;\n  padding-top: 0 !important;\n}\n</style>\n\n<p>You’ll notice that if you select a post, switch to the <em>Archive</em> tab, then switch back to <em>Posts</em>, it’s no longer showing the post you selected. That’s because each time you switch to a new tab, Vue creates a new instance of the <code>currentTabComponent</code>.</p>\n<p>Recreating dynamic components is normally useful behavior, but in this case, we’d really like those tab component instances to be cached once they’re created for the first time. To solve this problem, we can wrap our dynamic component with a <code>&lt;keep-alive&gt;</code> element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Inactive components will be cached! --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentTabComponent\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>Check out the result below:</p>\n\n<div id=\"dynamic-component-keep-alive-demo\" class=\"demo\">\n  <button v-for=\"tab in tabs\" v-bind:key=\"tab\" v-bind:class=\"['dynamic-component-demo-tab-button', { 'dynamic-component-demo-active': currentTab === tab }]\" v-on:click=\"currentTab = tab\">{{ tab }}</button>\n  <keep-alive>\n    <component v-bind:is=\"currentTabComponent\" class=\"dynamic-component-demo-tab\"></component>\n  </keep-alive>\n</div>\n<script>\nnew Vue({\n  el: '#dynamic-component-keep-alive-demo',\n  data: {\n    currentTab: 'Posts',\n    tabs: ['Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n\n<p>Now the <em>Posts</em> tab maintains its state (the selected post) even when it’s not rendered. See <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-keep-alive-with-dynamic-components\" target=\"_blank\" rel=\"noopener\">this example</a> for the complete code.</p>\n<p class=\"tip\">Note that <code>&lt;keep-alive&gt;</code> requires the components being switched between to all have names, either using the <code>name</code> option on a component, or through local/global registration.</p>\n\n<p>Check out more details on <code>&lt;keep-alive&gt;</code> in the <a href=\"../api/#keep-alive\">API reference</a>.</p>\n<h2 id=\"Async-Components\"><a href=\"#Async-Components\" class=\"headerlink\" title=\"Async Components\"></a>Async Components</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/dynamically-load-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Async Components lesson\">Watch a free video lesson on Vue School</a></div>\n\n<p>In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it’s needed. To make that easier, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. Vue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Pass the component definition to the resolve callback</span>\n    resolve(&#123;\n      <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span>\n    &#125;)\n  &#125;, <span class=\"hljs-number\">1000</span>)\n&#125;)</code></pre>\n<p>As you can see, the factory function receives a <code>resolve</code> callback, which should be called when you have retrieved your component definition from the server. You can also call <code>reject(reason)</code> to indicate the load has failed. The <code>setTimeout</code> here is for demonstration; how to retrieve the component is up to you. One recommended approach is to use async components together with <a href=\"https://webpack.js.org/guides/code-splitting/\" target=\"_blank\" rel=\"noopener\">Webpack’s code-splitting feature</a>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-webpack-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>&#123;\n  <span class=\"hljs-comment\">// This special require syntax will instruct Webpack to</span>\n  <span class=\"hljs-comment\">// automatically split your built code into bundles which</span>\n  <span class=\"hljs-comment\">// are loaded over Ajax requests.</span>\n  <span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">'./my-async-component'</span>], resolve)\n&#125;)</code></pre>\n<p>You can also return a <code>Promise</code> in the factory function, so with Webpack 2 and ES2015 syntax you can make use of dynamic imports:</p>\n<pre><code class=\"hljs js\">Vue.component(\n  <span class=\"hljs-string\">'async-webpack-example'</span>,\n  <span class=\"hljs-comment\">// A dynamic import returns a Promise.</span>\n  () =&gt; <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./my-async-component'</span>)\n)</code></pre>\n<p>When using <a href=\"components-registration.html#Local-Registration\">local registration</a>, you can also directly provide a function that returns a <code>Promise</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">components</span>: &#123;\n    <span class=\"hljs-string\">'my-component'</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./my-async-component'</span>)\n  &#125;\n&#125;)</code></pre>\n<p class=\"tip\">If you’re a <strong>Browserify</strong> user that would like to use async components, its creator has unfortunately <a href=\"https://github.com/substack/node-browserify/issues/58#issuecomment-21978224\" target=\"_blank\" rel=\"noopener\">made it clear</a> that async loading “is not something that Browserify will ever support.” Officially, at least. The Browserify community has found <a href=\"https://github.com/vuejs/vuejs.org/issues/620\" target=\"_blank\" rel=\"noopener\">some workarounds</a>, which may be helpful for existing and complex applications. For all other scenarios, we recommend using Webpack for built-in, first-class async support.</p>\n\n<h3 id=\"Handling-Loading-State\"><a href=\"#Handling-Loading-State\" class=\"headerlink\" title=\"Handling Loading State\"></a>Handling Loading State</h3><blockquote>\n<p>New in 2.3.0+</p>\n</blockquote>\n<p>The async component factory can also return an object of the following format:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> AsyncComponent = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> (&#123;\n  <span class=\"hljs-comment\">// The component to load (should be a Promise)</span>\n  <span class=\"hljs-attr\">component</span>: <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./MyComponent.vue'</span>),\n  <span class=\"hljs-comment\">// A component to use while the async component is loading</span>\n  <span class=\"hljs-attr\">loading</span>: LoadingComponent,\n  <span class=\"hljs-comment\">// A component to use if the load fails</span>\n  <span class=\"hljs-attr\">error</span>: ErrorComponent,\n  <span class=\"hljs-comment\">// Delay before showing the loading component. Default: 200ms.</span>\n  <span class=\"hljs-attr\">delay</span>: <span class=\"hljs-number\">200</span>,\n  <span class=\"hljs-comment\">// The error component will be displayed if a timeout is</span>\n  <span class=\"hljs-comment\">// provided and exceeded. Default: Infinity.</span>\n  <span class=\"hljs-attr\">timeout</span>: <span class=\"hljs-number\">3000</span>\n&#125;)</code></pre>\n<blockquote>\n<p>Note that you must use <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">Vue Router</a> 2.4.0+ if you wish to use the above syntax for route components.</p>\n</blockquote>\n"},{"title":"Handling Edge Cases","type":"guide","order":106,"_content":"\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<p class=\"tip\">All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue's rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.</p>\n\n## Element & Component Access\n\nIn most cases, it's best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.\n\n### Accessing the Root Instance\n\nIn every subcomponent of a `new Vue` instance, this root instance can be accessed with the `$root` property. For example, in this root instance:\n\n```js\n// The root Vue instance\nnew Vue({\n  data: {\n    foo: 1\n  },\n  computed: {\n    bar: function () { /* ... */ }\n  },\n  methods: {\n    baz: function () { /* ... */ }\n  }\n})\n```\n\nAll subcomponents will now be able to access this instance and use it as a global store:\n\n```js\n// Get root data\nthis.$root.foo\n\n// Set root data\nthis.$root.foo = 2\n\n// Access root computed properties\nthis.$root.bar\n\n// Call root methods\nthis.$root.baz()\n```\n\n<p class=\"tip\">This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using <a href=\"https://github.com/vuejs/vuex\">Vuex</a> to manage state in most cases.</p>\n\n### Accessing the Parent Component Instance\n\nSimilar to `$root`, the `$parent` property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.\n\n<p class=\"tip\">In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</p>\n\nThere are cases however, particularly shared component libraries, when this _might_ be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:\n\n```html\n<google-map>\n  <google-map-markers v-bind:places=\"iceCreamShops\"></google-map-markers>\n</google-map>\n```\n\nThe `<google-map>` component might define a `map` property that all subcomponents need access to. In this case `<google-map-markers>` might want to access that map with something like `this.$parent.getMap`, in order to add a set of markers to it. You can see this pattern [in action here](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-accessing-parent-component-instance).\n\nKeep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new `<google-map-region>` component and when `<google-map-markers>` appears within that, it should only render markers that fall within that region:\n\n```html\n<google-map>\n  <google-map-region v-bind:shape=\"cityBoundaries\">\n    <google-map-markers v-bind:places=\"iceCreamShops\"></google-map-markers>\n  </google-map-region>\n</google-map>\n```\n\nThen inside `<google-map-markers>` you might find yourself reaching for a hack like this:\n\n```js\nvar map = this.$parent.map || this.$parent.$parent.map\n```\n\nThis has quickly gotten out of hand. That's why to provide context information to descendent components arbitrarily deep, we instead recommend [dependency injection](#Dependency-Injection).\n\n### Accessing Child Component Instances & Child Elements\n\nDespite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the `ref` attribute. For example:\n\n```html\n<base-input ref=\"usernameInput\"></base-input>\n```\n\nNow in the component where you've defined this `ref`, you can use:\n\n```js\nthis.$refs.usernameInput\n```\n\nto access the `<base-input>` instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the `<base-input>` component may similarly use a `ref` to provide access to specific elements inside it, such as:\n\n```html\n<input ref=\"input\">\n```\n\nAnd even define methods for use by the parent:\n\n```js\nmethods: {\n  // Used to focus the input from the parent\n  focus: function () {\n    this.$refs.input.focus()\n  }\n}\n```\n\nThus allowing the parent component to focus the input inside `<base-input>` with:\n\n```js\nthis.$refs.usernameInput.focus()\n```\n\nWhen `ref` is used together with `v-for`, the ref you get will be an array containing the child components mirroring the data source.\n\n<p class=\"tip\"><code>$refs</code> are only populated after the component has been rendered, and they are not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid accessing <code>$refs</code> from within templates or computed properties.</p>\n\n### Dependency Injection\n\nEarlier, when we described [Accessing the Parent Component Instance](#Accessing-the-Parent-Component-Instance), we showed an example like this:\n\n```html\n<google-map>\n  <google-map-region v-bind:shape=\"cityBoundaries\">\n    <google-map-markers v-bind:places=\"iceCreamShops\"></google-map-markers>\n  </google-map-region>\n</google-map>\n```\n\nIn this component, all descendants of `<google-map>` needed access to a `getMap` method, in order to know which map to interact with. Unfortunately, using the `$parent` property didn't scale well to more deeply nested components. That's where dependency injection can be useful, using two new instance options: `provide` and `inject`.\n\nThe `provide` options allows us to specify the data/methods we want to **provide** to descendent components. In this case, that's the `getMap` method inside `<google-map>`:\n\n```js\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n\nThen in any descendants, we can use the `inject` option to receive specific properties we'd like to add to that instance:\n\n```js\ninject: ['getMap']\n```\n\nYou can see the [full example here](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dependency-injection). The advantage over using `$parent` is that we can access `getMap` in _any_ descendant component, without exposing the entire instance of `<google-map>`. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with `props`.\n\nIn fact, you can think of dependency injection as sort of \"long-range props\", except:\n\n* ancestor components don't need to know which descendants use the properties it provides\n* descendant components don't need to know where injected properties are coming from\n\n<p class=\"tip\">However, there are downsides to dependency injection. It couples components in your application to the way they're currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as <a href=\"#Accessing-the-Root-Instance\">using <code>$root</code></a> for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that's a good sign that you probably need a real state management solution like <a href=\"https://github.com/vuejs/vuex\">Vuex</a> instead.</p>\n\nLearn more about dependency injection in [the API doc](https://vuejs.org/v2/api/#provide-inject).\n\n## Programmatic Event Listeners\n\nSo far, you've seen uses of `$emit`, listened to with `v-on`, but Vue instances also offer other methods in its events interface. We can:\n\n- Listen for an event with `$on(eventName, eventHandler)`\n- Listen for an event only once with `$once(eventName, eventHandler)`\n- Stop listening for an event with `$off(eventName, eventHandler)`\n\nYou normally won't have to use these, but they're available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:\n\n```js\n// Attach the datepicker to an input once\n// it's mounted to the DOM.\nmounted: function () {\n  // Pikaday is a 3rd-party datepicker library\n  this.picker = new Pikaday({\n    field: this.$refs.input,\n    format: 'YYYY-MM-DD'\n  })\n},\n// Right before the component is destroyed,\n// also destroy the datepicker.\nbeforeDestroy: function () {\n  this.picker.destroy()\n}\n```\n\nThis has two potential issues:\n\n- It requires saving the `picker` to the component instance, when it's possible that only lifecycle hooks need access to it. This isn't terrible, but it could be considered clutter.\n- Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.\n\nYou could resolve both issues with a programmatic listener:\n\n```js\nmounted: function () {\n  var picker = new Pikaday({\n    field: this.$refs.input,\n    format: 'YYYY-MM-DD'\n  })\n\n  this.$once('hook:beforeDestroy', function () {\n    picker.destroy()\n  })\n}\n```\n\nUsing this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:\n\n```js\nmounted: function () {\n  this.attachDatepicker('startDateInput')\n  this.attachDatepicker('endDateInput')\n},\nmethods: {\n  attachDatepicker: function (refName) {\n    var picker = new Pikaday({\n      field: this.$refs[refName],\n      format: 'YYYY-MM-DD'\n    })\n\n    this.$once('hook:beforeDestroy', function () {\n      picker.destroy()\n    })\n  }\n}\n```\n\nSee [this example](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners) for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we'd recommend creating a reusable `<input-datepicker>` component.\n\nTo learn more about programmatic listeners, check out the API for [Events Instance Methods](https://vuejs.org/v2/api/#Instance-Methods-Events).\n\n<p class=\"tip\">Note that Vue's event system is different from the browser's <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\">EventTarget API</a>. Though they work similarly, <code>$emit</code>, <code>$on</code>, and <code>$off</code> are <strong>not</strong> aliases for <code>dispatchEvent</code>, <code>addEventListener</code>, and <code>removeEventListener</code>.</p>\n\n## Circular References\n\n### Recursive Components\n\nComponents can recursively invoke themselves in their own template. However, they can only do so with the `name` option:\n\n``` js\nname: 'unique-name-of-my-component'\n```\n\nWhen you register a component globally using `Vue.component`, the global ID is automatically set as the component's `name` option.\n\n``` js\nVue.component('unique-name-of-my-component', {\n  // ...\n})\n```\n\nIf you're not careful, recursive components can also lead to infinite loops:\n\n``` js\nname: 'stack-overflow',\ntemplate: '<div><stack-overflow></stack-overflow></div>'\n```\n\nA component like the above will result in a \"max stack size exceeded\" error, so make sure recursive invocation is conditional (i.e. uses a `v-if` that will eventually be `false`).\n\n### Circular References Between Components\n\nLet's say you're building a file directory tree, like in Finder or File Explorer. You might have a `tree-folder` component with this template:\n\n``` html\n<p>\n  <span>{{ folder.name }}</span>\n  <tree-folder-contents :children=\"folder.children\"/>\n</p>\n```\n\nThen a `tree-folder-contents` component with this template:\n\n``` html\n<ul>\n  <li v-for=\"child in children\">\n    <tree-folder v-if=\"child.children\" :folder=\"child\"/>\n    <span v-else>{{ child.name }}</span>\n  </li>\n</ul>\n```\n\nWhen you look closely, you'll see that these components will actually be each other's descendent _and_ ancestor in the render tree - a paradox! When registering components globally with `Vue.component`, this paradox is resolved for you automatically. If that's you, you can stop reading here.\n\nHowever, if you're requiring/importing components using a __module system__, e.g. via Webpack or Browserify, you'll get an error:\n\n```\nFailed to mount component: template or render function not defined.\n```\n\nTo explain what's happening, let's call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It's stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, \"A needs B _eventually_, but there's no need to resolve B first.\"\n\nIn our case, let's make that point the `tree-folder` component. We know the child that creates the paradox is the `tree-folder-contents` component, so we'll wait until the `beforeCreate` lifecycle hook to register it:\n\n``` js\nbeforeCreate: function () {\n  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default\n}\n```\n\nOr alternatively, you could use Webpack's asynchronous `import` when you register the component locally:\n\n``` js\ncomponents: {\n  TreeFolderContents: () => import('./tree-folder-contents.vue')\n}\n```\n\nProblem solved!\n\n## Alternate Template Definitions\n\n### Inline Templates\n\nWhen the `inline-template` special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.\n\n``` html\n<my-component inline-template>\n  <div>\n    <p>These are compiled as the component's own template.</p>\n    <p>Not parent's transclusion content.</p>\n  </div>\n</my-component>\n```\n\nYour inline template needs to be defined inside the DOM element to which Vue is attached.\n\n<p class=\"tip\">However, <code>inline-template</code> makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the <code>template</code> option or in a <code>&lt;template&gt;</code> element in a <code>.vue</code> file.</p>\n\n### X-Templates\n\nAnother way to define templates is inside of a script element with the type `text/x-template`, then referencing the template by an id. For example:\n\n``` html\n<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n</script>\n```\n\n``` js\nVue.component('hello-world', {\n  template: '#hello-world-template'\n})\n```\n\nYour x-template needs to be defined outside the DOM element to which Vue is attached.\n\n<p class=\"tip\">These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</p>\n\n## Controlling Updates\n\nThanks to Vue's Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.\n\n### Forcing an Update\n\n<p class=\"tip\">If you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere.</p>\n\nYou may not have accounted for change detection caveats [with arrays](https://vuejs.org/v2/guide/list.html#Caveats) or [objects](https://vuejs.org/v2/guide/list.html#Object-Change-Detection-Caveats), or you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with `data`.\n\nHowever, if you've ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with [`$forceUpdate`](../api/#vm-forceUpdate).\n\n### Cheap Static Components with `v-once`\n\nRendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains **a lot** of static content. In these cases, you can ensure that it's only evaluated once and then cached by adding the `v-once` directive to the root element, like this:\n\n``` js\nVue.component('terms-of-service', {\n  template: `\n    <div v-once>\n      <h1>Terms of Service</h1>\n      ... a lot of static content ...\n    </div>\n  `\n})\n```\n\n<p class=\"tip\">Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering -- plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with <code>v-once</code> or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.</p>\n","source":"v2/guide/components-edge-cases.md","raw":"---\ntitle: Handling Edge Cases\ntype: guide\norder: 106\n---\n\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<p class=\"tip\">All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue's rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.</p>\n\n## Element & Component Access\n\nIn most cases, it's best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.\n\n### Accessing the Root Instance\n\nIn every subcomponent of a `new Vue` instance, this root instance can be accessed with the `$root` property. For example, in this root instance:\n\n```js\n// The root Vue instance\nnew Vue({\n  data: {\n    foo: 1\n  },\n  computed: {\n    bar: function () { /* ... */ }\n  },\n  methods: {\n    baz: function () { /* ... */ }\n  }\n})\n```\n\nAll subcomponents will now be able to access this instance and use it as a global store:\n\n```js\n// Get root data\nthis.$root.foo\n\n// Set root data\nthis.$root.foo = 2\n\n// Access root computed properties\nthis.$root.bar\n\n// Call root methods\nthis.$root.baz()\n```\n\n<p class=\"tip\">This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using <a href=\"https://github.com/vuejs/vuex\">Vuex</a> to manage state in most cases.</p>\n\n### Accessing the Parent Component Instance\n\nSimilar to `$root`, the `$parent` property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.\n\n<p class=\"tip\">In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</p>\n\nThere are cases however, particularly shared component libraries, when this _might_ be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:\n\n```html\n<google-map>\n  <google-map-markers v-bind:places=\"iceCreamShops\"></google-map-markers>\n</google-map>\n```\n\nThe `<google-map>` component might define a `map` property that all subcomponents need access to. In this case `<google-map-markers>` might want to access that map with something like `this.$parent.getMap`, in order to add a set of markers to it. You can see this pattern [in action here](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-accessing-parent-component-instance).\n\nKeep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new `<google-map-region>` component and when `<google-map-markers>` appears within that, it should only render markers that fall within that region:\n\n```html\n<google-map>\n  <google-map-region v-bind:shape=\"cityBoundaries\">\n    <google-map-markers v-bind:places=\"iceCreamShops\"></google-map-markers>\n  </google-map-region>\n</google-map>\n```\n\nThen inside `<google-map-markers>` you might find yourself reaching for a hack like this:\n\n```js\nvar map = this.$parent.map || this.$parent.$parent.map\n```\n\nThis has quickly gotten out of hand. That's why to provide context information to descendent components arbitrarily deep, we instead recommend [dependency injection](#Dependency-Injection).\n\n### Accessing Child Component Instances & Child Elements\n\nDespite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the `ref` attribute. For example:\n\n```html\n<base-input ref=\"usernameInput\"></base-input>\n```\n\nNow in the component where you've defined this `ref`, you can use:\n\n```js\nthis.$refs.usernameInput\n```\n\nto access the `<base-input>` instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the `<base-input>` component may similarly use a `ref` to provide access to specific elements inside it, such as:\n\n```html\n<input ref=\"input\">\n```\n\nAnd even define methods for use by the parent:\n\n```js\nmethods: {\n  // Used to focus the input from the parent\n  focus: function () {\n    this.$refs.input.focus()\n  }\n}\n```\n\nThus allowing the parent component to focus the input inside `<base-input>` with:\n\n```js\nthis.$refs.usernameInput.focus()\n```\n\nWhen `ref` is used together with `v-for`, the ref you get will be an array containing the child components mirroring the data source.\n\n<p class=\"tip\"><code>$refs</code> are only populated after the component has been rendered, and they are not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid accessing <code>$refs</code> from within templates or computed properties.</p>\n\n### Dependency Injection\n\nEarlier, when we described [Accessing the Parent Component Instance](#Accessing-the-Parent-Component-Instance), we showed an example like this:\n\n```html\n<google-map>\n  <google-map-region v-bind:shape=\"cityBoundaries\">\n    <google-map-markers v-bind:places=\"iceCreamShops\"></google-map-markers>\n  </google-map-region>\n</google-map>\n```\n\nIn this component, all descendants of `<google-map>` needed access to a `getMap` method, in order to know which map to interact with. Unfortunately, using the `$parent` property didn't scale well to more deeply nested components. That's where dependency injection can be useful, using two new instance options: `provide` and `inject`.\n\nThe `provide` options allows us to specify the data/methods we want to **provide** to descendent components. In this case, that's the `getMap` method inside `<google-map>`:\n\n```js\nprovide: function () {\n  return {\n    getMap: this.getMap\n  }\n}\n```\n\nThen in any descendants, we can use the `inject` option to receive specific properties we'd like to add to that instance:\n\n```js\ninject: ['getMap']\n```\n\nYou can see the [full example here](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dependency-injection). The advantage over using `$parent` is that we can access `getMap` in _any_ descendant component, without exposing the entire instance of `<google-map>`. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with `props`.\n\nIn fact, you can think of dependency injection as sort of \"long-range props\", except:\n\n* ancestor components don't need to know which descendants use the properties it provides\n* descendant components don't need to know where injected properties are coming from\n\n<p class=\"tip\">However, there are downsides to dependency injection. It couples components in your application to the way they're currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as <a href=\"#Accessing-the-Root-Instance\">using <code>$root</code></a> for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that's a good sign that you probably need a real state management solution like <a href=\"https://github.com/vuejs/vuex\">Vuex</a> instead.</p>\n\nLearn more about dependency injection in [the API doc](https://vuejs.org/v2/api/#provide-inject).\n\n## Programmatic Event Listeners\n\nSo far, you've seen uses of `$emit`, listened to with `v-on`, but Vue instances also offer other methods in its events interface. We can:\n\n- Listen for an event with `$on(eventName, eventHandler)`\n- Listen for an event only once with `$once(eventName, eventHandler)`\n- Stop listening for an event with `$off(eventName, eventHandler)`\n\nYou normally won't have to use these, but they're available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:\n\n```js\n// Attach the datepicker to an input once\n// it's mounted to the DOM.\nmounted: function () {\n  // Pikaday is a 3rd-party datepicker library\n  this.picker = new Pikaday({\n    field: this.$refs.input,\n    format: 'YYYY-MM-DD'\n  })\n},\n// Right before the component is destroyed,\n// also destroy the datepicker.\nbeforeDestroy: function () {\n  this.picker.destroy()\n}\n```\n\nThis has two potential issues:\n\n- It requires saving the `picker` to the component instance, when it's possible that only lifecycle hooks need access to it. This isn't terrible, but it could be considered clutter.\n- Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.\n\nYou could resolve both issues with a programmatic listener:\n\n```js\nmounted: function () {\n  var picker = new Pikaday({\n    field: this.$refs.input,\n    format: 'YYYY-MM-DD'\n  })\n\n  this.$once('hook:beforeDestroy', function () {\n    picker.destroy()\n  })\n}\n```\n\nUsing this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:\n\n```js\nmounted: function () {\n  this.attachDatepicker('startDateInput')\n  this.attachDatepicker('endDateInput')\n},\nmethods: {\n  attachDatepicker: function (refName) {\n    var picker = new Pikaday({\n      field: this.$refs[refName],\n      format: 'YYYY-MM-DD'\n    })\n\n    this.$once('hook:beforeDestroy', function () {\n      picker.destroy()\n    })\n  }\n}\n```\n\nSee [this example](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners) for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we'd recommend creating a reusable `<input-datepicker>` component.\n\nTo learn more about programmatic listeners, check out the API for [Events Instance Methods](https://vuejs.org/v2/api/#Instance-Methods-Events).\n\n<p class=\"tip\">Note that Vue's event system is different from the browser's <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\">EventTarget API</a>. Though they work similarly, <code>$emit</code>, <code>$on</code>, and <code>$off</code> are <strong>not</strong> aliases for <code>dispatchEvent</code>, <code>addEventListener</code>, and <code>removeEventListener</code>.</p>\n\n## Circular References\n\n### Recursive Components\n\nComponents can recursively invoke themselves in their own template. However, they can only do so with the `name` option:\n\n``` js\nname: 'unique-name-of-my-component'\n```\n\nWhen you register a component globally using `Vue.component`, the global ID is automatically set as the component's `name` option.\n\n``` js\nVue.component('unique-name-of-my-component', {\n  // ...\n})\n```\n\nIf you're not careful, recursive components can also lead to infinite loops:\n\n``` js\nname: 'stack-overflow',\ntemplate: '<div><stack-overflow></stack-overflow></div>'\n```\n\nA component like the above will result in a \"max stack size exceeded\" error, so make sure recursive invocation is conditional (i.e. uses a `v-if` that will eventually be `false`).\n\n### Circular References Between Components\n\nLet's say you're building a file directory tree, like in Finder or File Explorer. You might have a `tree-folder` component with this template:\n\n``` html\n<p>\n  <span>{{ folder.name }}</span>\n  <tree-folder-contents :children=\"folder.children\"/>\n</p>\n```\n\nThen a `tree-folder-contents` component with this template:\n\n``` html\n<ul>\n  <li v-for=\"child in children\">\n    <tree-folder v-if=\"child.children\" :folder=\"child\"/>\n    <span v-else>{{ child.name }}</span>\n  </li>\n</ul>\n```\n\nWhen you look closely, you'll see that these components will actually be each other's descendent _and_ ancestor in the render tree - a paradox! When registering components globally with `Vue.component`, this paradox is resolved for you automatically. If that's you, you can stop reading here.\n\nHowever, if you're requiring/importing components using a __module system__, e.g. via Webpack or Browserify, you'll get an error:\n\n```\nFailed to mount component: template or render function not defined.\n```\n\nTo explain what's happening, let's call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It's stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, \"A needs B _eventually_, but there's no need to resolve B first.\"\n\nIn our case, let's make that point the `tree-folder` component. We know the child that creates the paradox is the `tree-folder-contents` component, so we'll wait until the `beforeCreate` lifecycle hook to register it:\n\n``` js\nbeforeCreate: function () {\n  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default\n}\n```\n\nOr alternatively, you could use Webpack's asynchronous `import` when you register the component locally:\n\n``` js\ncomponents: {\n  TreeFolderContents: () => import('./tree-folder-contents.vue')\n}\n```\n\nProblem solved!\n\n## Alternate Template Definitions\n\n### Inline Templates\n\nWhen the `inline-template` special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.\n\n``` html\n<my-component inline-template>\n  <div>\n    <p>These are compiled as the component's own template.</p>\n    <p>Not parent's transclusion content.</p>\n  </div>\n</my-component>\n```\n\nYour inline template needs to be defined inside the DOM element to which Vue is attached.\n\n<p class=\"tip\">However, <code>inline-template</code> makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the <code>template</code> option or in a <code>&lt;template&gt;</code> element in a <code>.vue</code> file.</p>\n\n### X-Templates\n\nAnother way to define templates is inside of a script element with the type `text/x-template`, then referencing the template by an id. For example:\n\n``` html\n<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n</script>\n```\n\n``` js\nVue.component('hello-world', {\n  template: '#hello-world-template'\n})\n```\n\nYour x-template needs to be defined outside the DOM element to which Vue is attached.\n\n<p class=\"tip\">These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</p>\n\n## Controlling Updates\n\nThanks to Vue's Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.\n\n### Forcing an Update\n\n<p class=\"tip\">If you find yourself needing to force an update in Vue, in 99.99% of cases, you've made a mistake somewhere.</p>\n\nYou may not have accounted for change detection caveats [with arrays](https://vuejs.org/v2/guide/list.html#Caveats) or [objects](https://vuejs.org/v2/guide/list.html#Object-Change-Detection-Caveats), or you may be relying on state that isn't tracked by Vue's reactivity system, e.g. with `data`.\n\nHowever, if you've ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with [`$forceUpdate`](../api/#vm-forceUpdate).\n\n### Cheap Static Components with `v-once`\n\nRendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains **a lot** of static content. In these cases, you can ensure that it's only evaluated once and then cached by adding the `v-once` directive to the root element, like this:\n\n``` js\nVue.component('terms-of-service', {\n  template: `\n    <div v-once>\n      <h1>Terms of Service</h1>\n      ... a lot of static content ...\n    </div>\n  `\n})\n```\n\n<p class=\"tip\">Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it's simply not necessary unless you actually notice slow rendering -- plus, it could cause a lot of confusion later. For example, imagine another developer who's not familiar with <code>v-once</code> or simply misses it in the template. They might spend hours trying to figure out why the template isn't updating correctly.</p>\n","date":"2020-09-25T23:55:41.134Z","updated":"2020-09-25T23:55:41.134Z","path":"v2/guide/components-edge-cases.html","comments":1,"layout":"page","_id":"ckfl66gyi001wc2v5ynd7igpb","content":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<p class=\"tip\">All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue’s rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.</p>\n\n<h2 id=\"Element-amp-Component-Access\"><a href=\"#Element-amp-Component-Access\" class=\"headerlink\" title=\"Element &amp; Component Access\"></a>Element &amp; Component Access</h2><p>In most cases, it’s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</p>\n<h3 id=\"Accessing-the-Root-Instance\"><a href=\"#Accessing-the-Root-Instance\" class=\"headerlink\" title=\"Accessing the Root Instance\"></a>Accessing the Root Instance</h3><p>In every subcomponent of a <code>new Vue</code> instance, this root instance can be accessed with the <code>$root</code> property. For example, in this root instance:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// The root Vue instance</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;\n&#125;)</code></pre>\n<p>All subcomponents will now be able to access this instance and use it as a global store:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Get root data</span>\n<span class=\"hljs-keyword\">this</span>.$root.foo\n\n<span class=\"hljs-comment\">// Set root data</span>\n<span class=\"hljs-keyword\">this</span>.$root.foo = <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-comment\">// Access root computed properties</span>\n<span class=\"hljs-keyword\">this</span>.$root.bar\n\n<span class=\"hljs-comment\">// Call root methods</span>\n<span class=\"hljs-keyword\">this</span>.$root.baz()</code></pre>\n<p class=\"tip\">This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> to manage state in most cases.</p>\n\n<h3 id=\"Accessing-the-Parent-Component-Instance\"><a href=\"#Accessing-the-Parent-Component-Instance\" class=\"headerlink\" title=\"Accessing the Parent Component Instance\"></a>Accessing the Parent Component Instance</h3><p>Similar to <code>$root</code>, the <code>$parent</code> property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</p>\n<p class=\"tip\">In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</p>\n\n<p>There are cases however, particularly shared component libraries, when this <em>might</em> be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-markers</span> <span class=\"hljs-attr\">v-bind:places</span>=<span class=\"hljs-string\">\"iceCreamShops\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-markers</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map</span>&gt;</span></code></pre>\n<p>The <code>&lt;google-map&gt;</code> component might define a <code>map</code> property that all subcomponents need access to. In this case <code>&lt;google-map-markers&gt;</code> might want to access that map with something like <code>this.$parent.getMap</code>, in order to add a set of markers to it. You can see this pattern <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-accessing-parent-component-instance\" target=\"_blank\" rel=\"noopener\">in action here</a>.</p>\n<p>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new <code>&lt;google-map-region&gt;</code> component and when <code>&lt;google-map-markers&gt;</code> appears within that, it should only render markers that fall within that region:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-region</span> <span class=\"hljs-attr\">v-bind:shape</span>=<span class=\"hljs-string\">\"cityBoundaries\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-markers</span> <span class=\"hljs-attr\">v-bind:places</span>=<span class=\"hljs-string\">\"iceCreamShops\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-markers</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-region</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map</span>&gt;</span></code></pre>\n<p>Then inside <code>&lt;google-map-markers&gt;</code> you might find yourself reaching for a hack like this:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">this</span>.$parent.map || <span class=\"hljs-keyword\">this</span>.$parent.$parent.map</code></pre>\n<p>This has quickly gotten out of hand. That’s why to provide context information to descendent components arbitrarily deep, we instead recommend <a href=\"#Dependency-Injection\">dependency injection</a>.</p>\n<h3 id=\"Accessing-Child-Component-Instances-amp-Child-Elements\"><a href=\"#Accessing-Child-Component-Instances-amp-Child-Elements\" class=\"headerlink\" title=\"Accessing Child Component Instances &amp; Child Elements\"></a>Accessing Child Component Instances &amp; Child Elements</h3><p>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the <code>ref</code> attribute. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"usernameInput\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-input</span>&gt;</span></code></pre>\n<p>Now in the component where you’ve defined this <code>ref</code>, you can use:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$refs.usernameInput</code></pre>\n<p>to access the <code>&lt;base-input&gt;</code> instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the <code>&lt;base-input&gt;</code> component may similarly use a <code>ref</code> to provide access to specific elements inside it, such as:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"input\"</span>&gt;</span></code></pre>\n<p>And even define methods for use by the parent:</p>\n<pre><code class=\"hljs js\">methods: &#123;\n  <span class=\"hljs-comment\">// Used to focus the input from the parent</span>\n  <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.$refs.input.focus()\n  &#125;\n&#125;</code></pre>\n<p>Thus allowing the parent component to focus the input inside <code>&lt;base-input&gt;</code> with:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$refs.usernameInput.focus()</code></pre>\n<p>When <code>ref</code> is used together with <code>v-for</code>, the ref you get will be an array containing the child components mirroring the data source.</p>\n<p class=\"tip\"><code>$refs</code> are only populated after the component has been rendered, and they are not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid accessing <code>$refs</code> from within templates or computed properties.</p>\n\n<h3 id=\"Dependency-Injection\"><a href=\"#Dependency-Injection\" class=\"headerlink\" title=\"Dependency Injection\"></a>Dependency Injection</h3><p>Earlier, when we described <a href=\"#Accessing-the-Parent-Component-Instance\">Accessing the Parent Component Instance</a>, we showed an example like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-region</span> <span class=\"hljs-attr\">v-bind:shape</span>=<span class=\"hljs-string\">\"cityBoundaries\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-markers</span> <span class=\"hljs-attr\">v-bind:places</span>=<span class=\"hljs-string\">\"iceCreamShops\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-markers</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-region</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map</span>&gt;</span></code></pre>\n<p>In this component, all descendants of <code>&lt;google-map&gt;</code> needed access to a <code>getMap</code> method, in order to know which map to interact with. Unfortunately, using the <code>$parent</code> property didn’t scale well to more deeply nested components. That’s where dependency injection can be useful, using two new instance options: <code>provide</code> and <code>inject</code>.</p>\n<p>The <code>provide</code> options allows us to specify the data/methods we want to <strong>provide</strong> to descendent components. In this case, that’s the <code>getMap</code> method inside <code>&lt;google-map&gt;</code>:</p>\n<pre><code class=\"hljs js\">provide: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">getMap</span>: <span class=\"hljs-keyword\">this</span>.getMap\n  &#125;\n&#125;</code></pre>\n<p>Then in any descendants, we can use the <code>inject</code> option to receive specific properties we’d like to add to that instance:</p>\n<pre><code class=\"hljs js\">inject: [<span class=\"hljs-string\">'getMap'</span>]</code></pre>\n<p>You can see the <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dependency-injection\" target=\"_blank\" rel=\"noopener\">full example here</a>. The advantage over using <code>$parent</code> is that we can access <code>getMap</code> in <em>any</em> descendant component, without exposing the entire instance of <code>&lt;google-map&gt;</code>. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with <code>props</code>.</p>\n<p>In fact, you can think of dependency injection as sort of “long-range props”, except:</p>\n<ul>\n<li>ancestor components don’t need to know which descendants use the properties it provides</li>\n<li>descendant components don’t need to know where injected properties are coming from</li>\n</ul>\n<p class=\"tip\">However, there are downsides to dependency injection. It couples components in your application to the way they’re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as <a href=\"#Accessing-the-Root-Instance\">using <code>$root</code></a> for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that’s a good sign that you probably need a real state management solution like <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> instead.</p>\n\n<p>Learn more about dependency injection in <a href=\"https://vuejs.org/v2/api/#provide-inject\">the API doc</a>.</p>\n<h2 id=\"Programmatic-Event-Listeners\"><a href=\"#Programmatic-Event-Listeners\" class=\"headerlink\" title=\"Programmatic Event Listeners\"></a>Programmatic Event Listeners</h2><p>So far, you’ve seen uses of <code>$emit</code>, listened to with <code>v-on</code>, but Vue instances also offer other methods in its events interface. We can:</p>\n<ul>\n<li>Listen for an event with <code>$on(eventName, eventHandler)</code></li>\n<li>Listen for an event only once with <code>$once(eventName, eventHandler)</code></li>\n<li>Stop listening for an event with <code>$off(eventName, eventHandler)</code></li>\n</ul>\n<p>You normally won’t have to use these, but they’re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Attach the datepicker to an input once</span>\n<span class=\"hljs-comment\">// it's mounted to the DOM.</span>\n<span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// Pikaday is a 3rd-party datepicker library</span>\n  <span class=\"hljs-keyword\">this</span>.picker = <span class=\"hljs-keyword\">new</span> Pikaday(&#123;\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-keyword\">this</span>.$refs.input,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'YYYY-MM-DD'</span>\n  &#125;)\n&#125;,\n<span class=\"hljs-comment\">// Right before the component is destroyed,</span>\n<span class=\"hljs-comment\">// also destroy the datepicker.</span>\n<span class=\"hljs-attr\">beforeDestroy</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.picker.destroy()\n&#125;</code></pre>\n<p>This has two potential issues:</p>\n<ul>\n<li>It requires saving the <code>picker</code> to the component instance, when it’s possible that only lifecycle hooks need access to it. This isn’t terrible, but it could be considered clutter.</li>\n<li>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</li>\n</ul>\n<p>You could resolve both issues with a programmatic listener:</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> picker = <span class=\"hljs-keyword\">new</span> Pikaday(&#123;\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-keyword\">this</span>.$refs.input,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'YYYY-MM-DD'</span>\n  &#125;)\n\n  <span class=\"hljs-keyword\">this</span>.$once(<span class=\"hljs-string\">'hook:beforeDestroy'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    picker.destroy()\n  &#125;)\n&#125;</code></pre>\n<p>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.attachDatepicker(<span class=\"hljs-string\">'startDateInput'</span>)\n  <span class=\"hljs-keyword\">this</span>.attachDatepicker(<span class=\"hljs-string\">'endDateInput'</span>)\n&#125;,\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">attachDatepicker</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">refName</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> picker = <span class=\"hljs-keyword\">new</span> Pikaday(&#123;\n      <span class=\"hljs-attr\">field</span>: <span class=\"hljs-keyword\">this</span>.$refs[refName],\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'YYYY-MM-DD'</span>\n    &#125;)\n\n    <span class=\"hljs-keyword\">this</span>.$once(<span class=\"hljs-string\">'hook:beforeDestroy'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      picker.destroy()\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p>See <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners\" target=\"_blank\" rel=\"noopener\">this example</a> for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we’d recommend creating a reusable <code>&lt;input-datepicker&gt;</code> component.</p>\n<p>To learn more about programmatic listeners, check out the API for <a href=\"https://vuejs.org/v2/api/#Instance-Methods-Events\">Events Instance Methods</a>.</p>\n<p class=\"tip\">Note that Vue’s event system is different from the browser’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\" target=\"_blank\" rel=\"noopener\">EventTarget API</a>. Though they work similarly, <code>$emit</code>, <code>$on</code>, and <code>$off</code> are <strong>not</strong> aliases for <code>dispatchEvent</code>, <code>addEventListener</code>, and <code>removeEventListener</code>.</p>\n\n<h2 id=\"Circular-References\"><a href=\"#Circular-References\" class=\"headerlink\" title=\"Circular References\"></a>Circular References</h2><h3 id=\"Recursive-Components\"><a href=\"#Recursive-Components\" class=\"headerlink\" title=\"Recursive Components\"></a>Recursive Components</h3><p>Components can recursively invoke themselves in their own template. However, they can only do so with the <code>name</code> option:</p>\n<pre><code class=\"hljs js\">name: <span class=\"hljs-string\">'unique-name-of-my-component'</span></code></pre>\n<p>When you register a component globally using <code>Vue.component</code>, the global ID is automatically set as the component’s <code>name</code> option.</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'unique-name-of-my-component'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<p>If you’re not careful, recursive components can also lead to infinite loops:</p>\n<pre><code class=\"hljs js\">name: <span class=\"hljs-string\">'stack-overflow'</span>,\n<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></code></pre>\n<p>A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional (i.e. uses a <code>v-if</code> that will eventually be <code>false</code>).</p>\n<h3 id=\"Circular-References-Between-Components\"><a href=\"#Circular-References-Between-Components\" class=\"headerlink\" title=\"Circular References Between Components\"></a>Circular References Between Components</h3><p>Let’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a <code>tree-folder</code> component with this template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tree-folder-contents</span> <span class=\"hljs-attr\">:children</span>=<span class=\"hljs-string\">\"folder.children\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>Then a <code>tree-folder-contents</code> component with this template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"child in children\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tree-folder</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"child.children\"</span> <span class=\"hljs-attr\">:folder</span>=<span class=\"hljs-string\">\"child\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>When you look closely, you’ll see that these components will actually be each other’s descendent <em>and</em> ancestor in the render tree - a paradox! When registering components globally with <code>Vue.component</code>, this paradox is resolved for you automatically. If that’s you, you can stop reading here.</p>\n<p>However, if you’re requiring/importing components using a <strong>module system</strong>, e.g. via Webpack or Browserify, you’ll get an error:</p>\n<pre><code class=\"hljs undefined\">Failed to mount component: template or render function not defined.</code></pre>\n<p>To explain what’s happening, let’s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B <em>eventually</em>, but there’s no need to resolve B first.”</p>\n<p>In our case, let’s make that point the <code>tree-folder</code> component. We know the child that creates the paradox is the <code>tree-folder-contents</code> component, so we’ll wait until the <code>beforeCreate</code> lifecycle hook to register it:</p>\n<pre><code class=\"hljs js\">beforeCreate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$options.components.TreeFolderContents = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./tree-folder-contents.vue'</span>).default\n&#125;</code></pre>\n<p>Or alternatively, you could use Webpack’s asynchronous <code>import</code> when you register the component locally:</p>\n<pre><code class=\"hljs js\">components: &#123;\n  <span class=\"hljs-attr\">TreeFolderContents</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./tree-folder-contents.vue'</span>)\n&#125;</code></pre>\n<p>Problem solved!</p>\n<h2 id=\"Alternate-Template-Definitions\"><a href=\"#Alternate-Template-Definitions\" class=\"headerlink\" title=\"Alternate Template Definitions\"></a>Alternate Template Definitions</h2><h3 id=\"Inline-Templates\"><a href=\"#Inline-Templates\" class=\"headerlink\" title=\"Inline Templates\"></a>Inline Templates</h3><p>When the <code>inline-template</code> special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">inline-template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>These are compiled as the component's own template.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Not parent's transclusion content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>Your inline template needs to be defined inside the DOM element to which Vue is attached.</p>\n<p class=\"tip\">However, <code>inline-template</code> makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the <code>template</code> option or in a <code>&lt;template&gt;</code> element in a <code>.vue</code> file.</p>\n\n<h3 id=\"X-Templates\"><a href=\"#X-Templates\" class=\"headerlink\" title=\"X-Templates\"></a>X-Templates</h3><p>Another way to define templates is inside of a script element with the type <code>text/x-template</code>, then referencing the template by an id. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/x-template\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"hello-world-template\"</span>&gt;</span><span class=\"xml\">\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello hello hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'hello-world'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'#hello-world-template'</span>\n&#125;)</code></pre>\n<p>Your x-template needs to be defined outside the DOM element to which Vue is attached.</p>\n<p class=\"tip\">These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</p>\n\n<h2 id=\"Controlling-Updates\"><a href=\"#Controlling-Updates\" class=\"headerlink\" title=\"Controlling Updates\"></a>Controlling Updates</h2><p>Thanks to Vue’s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.</p>\n<h3 id=\"Forcing-an-Update\"><a href=\"#Forcing-an-Update\" class=\"headerlink\" title=\"Forcing an Update\"></a>Forcing an Update</h3><p class=\"tip\">If you find yourself needing to force an update in Vue, in 99.99% of cases, you’ve made a mistake somewhere.</p>\n\n<p>You may not have accounted for change detection caveats <a href=\"https://vuejs.org/v2/guide/list.html#Caveats\">with arrays</a> or <a href=\"https://vuejs.org/v2/guide/list.html#Object-Change-Detection-Caveats\">objects</a>, or you may be relying on state that isn’t tracked by Vue’s reactivity system, e.g. with <code>data</code>.</p>\n<p>However, if you’ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with <a href=\"../api/#vm-forceUpdate\"><code>$forceUpdate</code></a>.</p>\n<h3 id=\"Cheap-Static-Components-with-v-once\"><a href=\"#Cheap-Static-Components-with-v-once\" class=\"headerlink\" title=\"Cheap Static Components with v-once\"></a>Cheap Static Components with <code>v-once</code></h3><p>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains <strong>a lot</strong> of static content. In these cases, you can ensure that it’s only evaluated once and then cached by adding the <code>v-once</code> directive to the root element, like this:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'terms-of-service'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div v-once&gt;\n      &lt;h1&gt;Terms of Service&lt;/h1&gt;\n      ... a lot of static content ...\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p class=\"tip\">Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it’s simply not necessary unless you actually notice slow rendering – plus, it could cause a lot of confusion later. For example, imagine another developer who’s not familiar with <code>v-once</code> or simply misses it in the template. They might spend hours trying to figure out why the template isn’t updating correctly.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<p class=\"tip\">All the features on this page document the handling of edge cases, meaning unusual situations that sometimes require bending Vue’s rules a little. Note however, that they all have disadvantages or situations where they could be dangerous. These are noted in each case, so keep them in mind when deciding to use each feature.</p>\n\n<h2 id=\"Element-amp-Component-Access\"><a href=\"#Element-amp-Component-Access\" class=\"headerlink\" title=\"Element &amp; Component Access\"></a>Element &amp; Component Access</h2><p>In most cases, it’s best to avoid reaching into other component instances or manually manipulating DOM elements. There are cases, however, when it can be appropriate.</p>\n<h3 id=\"Accessing-the-Root-Instance\"><a href=\"#Accessing-the-Root-Instance\" class=\"headerlink\" title=\"Accessing the Root Instance\"></a>Accessing the Root Instance</h3><p>In every subcomponent of a <code>new Vue</code> instance, this root instance can be accessed with the <code>$root</code> property. For example, in this root instance:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// The root Vue instance</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-number\">1</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;\n&#125;)</code></pre>\n<p>All subcomponents will now be able to access this instance and use it as a global store:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Get root data</span>\n<span class=\"hljs-keyword\">this</span>.$root.foo\n\n<span class=\"hljs-comment\">// Set root data</span>\n<span class=\"hljs-keyword\">this</span>.$root.foo = <span class=\"hljs-number\">2</span>\n\n<span class=\"hljs-comment\">// Access root computed properties</span>\n<span class=\"hljs-keyword\">this</span>.$root.bar\n\n<span class=\"hljs-comment\">// Call root methods</span>\n<span class=\"hljs-keyword\">this</span>.$root.baz()</code></pre>\n<p class=\"tip\">This can be convenient for demos or very small apps with a handful of components. However, the pattern does not scale well to medium or large-scale applications, so we strongly recommend using <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> to manage state in most cases.</p>\n\n<h3 id=\"Accessing-the-Parent-Component-Instance\"><a href=\"#Accessing-the-Parent-Component-Instance\" class=\"headerlink\" title=\"Accessing the Parent Component Instance\"></a>Accessing the Parent Component Instance</h3><p>Similar to <code>$root</code>, the <code>$parent</code> property can be used to access the parent instance from a child. This can be tempting to reach for as a lazy alternative to passing data with a prop.</p>\n<p class=\"tip\">In most cases, reaching into the parent makes your application more difficult to debug and understand, especially if you mutate data in the parent. When looking at that component later, it will be very difficult to figure out where that mutation came from.</p>\n\n<p>There are cases however, particularly shared component libraries, when this <em>might</em> be appropriate. For example, in abstract components that interact with JavaScript APIs instead of rendering HTML, like these hypothetical Google Maps components:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-markers</span> <span class=\"hljs-attr\">v-bind:places</span>=<span class=\"hljs-string\">\"iceCreamShops\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-markers</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map</span>&gt;</span></code></pre>\n<p>The <code>&lt;google-map&gt;</code> component might define a <code>map</code> property that all subcomponents need access to. In this case <code>&lt;google-map-markers&gt;</code> might want to access that map with something like <code>this.$parent.getMap</code>, in order to add a set of markers to it. You can see this pattern <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-accessing-parent-component-instance\" target=\"_blank\" rel=\"noopener\">in action here</a>.</p>\n<p>Keep in mind, however, that components built with this pattern are still inherently fragile. For example, imagine we add a new <code>&lt;google-map-region&gt;</code> component and when <code>&lt;google-map-markers&gt;</code> appears within that, it should only render markers that fall within that region:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-region</span> <span class=\"hljs-attr\">v-bind:shape</span>=<span class=\"hljs-string\">\"cityBoundaries\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-markers</span> <span class=\"hljs-attr\">v-bind:places</span>=<span class=\"hljs-string\">\"iceCreamShops\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-markers</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-region</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map</span>&gt;</span></code></pre>\n<p>Then inside <code>&lt;google-map-markers&gt;</code> you might find yourself reaching for a hack like this:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> map = <span class=\"hljs-keyword\">this</span>.$parent.map || <span class=\"hljs-keyword\">this</span>.$parent.$parent.map</code></pre>\n<p>This has quickly gotten out of hand. That’s why to provide context information to descendent components arbitrarily deep, we instead recommend <a href=\"#Dependency-Injection\">dependency injection</a>.</p>\n<h3 id=\"Accessing-Child-Component-Instances-amp-Child-Elements\"><a href=\"#Accessing-Child-Component-Instances-amp-Child-Elements\" class=\"headerlink\" title=\"Accessing Child Component Instances &amp; Child Elements\"></a>Accessing Child Component Instances &amp; Child Elements</h3><p>Despite the existence of props and events, sometimes you might still need to directly access a child component in JavaScript. To achieve this you can assign a reference ID to the child component using the <code>ref</code> attribute. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"usernameInput\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-input</span>&gt;</span></code></pre>\n<p>Now in the component where you’ve defined this <code>ref</code>, you can use:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$refs.usernameInput</code></pre>\n<p>to access the <code>&lt;base-input&gt;</code> instance. This may be useful when you want to, for example, programmatically focus this input from a parent. In that case, the <code>&lt;base-input&gt;</code> component may similarly use a <code>ref</code> to provide access to specific elements inside it, such as:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"input\"</span>&gt;</span></code></pre>\n<p>And even define methods for use by the parent:</p>\n<pre><code class=\"hljs js\">methods: &#123;\n  <span class=\"hljs-comment\">// Used to focus the input from the parent</span>\n  <span class=\"hljs-attr\">focus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.$refs.input.focus()\n  &#125;\n&#125;</code></pre>\n<p>Thus allowing the parent component to focus the input inside <code>&lt;base-input&gt;</code> with:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$refs.usernameInput.focus()</code></pre>\n<p>When <code>ref</code> is used together with <code>v-for</code>, the ref you get will be an array containing the child components mirroring the data source.</p>\n<p class=\"tip\"><code>$refs</code> are only populated after the component has been rendered, and they are not reactive. It is only meant as an escape hatch for direct child manipulation - you should avoid accessing <code>$refs</code> from within templates or computed properties.</p>\n\n<h3 id=\"Dependency-Injection\"><a href=\"#Dependency-Injection\" class=\"headerlink\" title=\"Dependency Injection\"></a>Dependency Injection</h3><p>Earlier, when we described <a href=\"#Accessing-the-Parent-Component-Instance\">Accessing the Parent Component Instance</a>, we showed an example like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-region</span> <span class=\"hljs-attr\">v-bind:shape</span>=<span class=\"hljs-string\">\"cityBoundaries\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">google-map-markers</span> <span class=\"hljs-attr\">v-bind:places</span>=<span class=\"hljs-string\">\"iceCreamShops\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-markers</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map-region</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">google-map</span>&gt;</span></code></pre>\n<p>In this component, all descendants of <code>&lt;google-map&gt;</code> needed access to a <code>getMap</code> method, in order to know which map to interact with. Unfortunately, using the <code>$parent</code> property didn’t scale well to more deeply nested components. That’s where dependency injection can be useful, using two new instance options: <code>provide</code> and <code>inject</code>.</p>\n<p>The <code>provide</code> options allows us to specify the data/methods we want to <strong>provide</strong> to descendent components. In this case, that’s the <code>getMap</code> method inside <code>&lt;google-map&gt;</code>:</p>\n<pre><code class=\"hljs js\">provide: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">getMap</span>: <span class=\"hljs-keyword\">this</span>.getMap\n  &#125;\n&#125;</code></pre>\n<p>Then in any descendants, we can use the <code>inject</code> option to receive specific properties we’d like to add to that instance:</p>\n<pre><code class=\"hljs js\">inject: [<span class=\"hljs-string\">'getMap'</span>]</code></pre>\n<p>You can see the <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dependency-injection\" target=\"_blank\" rel=\"noopener\">full example here</a>. The advantage over using <code>$parent</code> is that we can access <code>getMap</code> in <em>any</em> descendant component, without exposing the entire instance of <code>&lt;google-map&gt;</code>. This allows us to more safely keep developing that component, without fear that we might change/remove something that a child component is relying on. The interface between these components remains clearly defined, just as with <code>props</code>.</p>\n<p>In fact, you can think of dependency injection as sort of “long-range props”, except:</p>\n<ul>\n<li>ancestor components don’t need to know which descendants use the properties it provides</li>\n<li>descendant components don’t need to know where injected properties are coming from</li>\n</ul>\n<p class=\"tip\">However, there are downsides to dependency injection. It couples components in your application to the way they’re currently organized, making refactoring more difficult. Provided properties are also not reactive. This is by design, because using them to create a central data store scales just as poorly as <a href=\"#Accessing-the-Root-Instance\">using <code>$root</code></a> for the same purpose. If the properties you want to share are specific to your app, rather than generic, or if you ever want to update provided data inside ancestors, then that’s a good sign that you probably need a real state management solution like <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> instead.</p>\n\n<p>Learn more about dependency injection in <a href=\"https://vuejs.org/v2/api/#provide-inject\">the API doc</a>.</p>\n<h2 id=\"Programmatic-Event-Listeners\"><a href=\"#Programmatic-Event-Listeners\" class=\"headerlink\" title=\"Programmatic Event Listeners\"></a>Programmatic Event Listeners</h2><p>So far, you’ve seen uses of <code>$emit</code>, listened to with <code>v-on</code>, but Vue instances also offer other methods in its events interface. We can:</p>\n<ul>\n<li>Listen for an event with <code>$on(eventName, eventHandler)</code></li>\n<li>Listen for an event only once with <code>$once(eventName, eventHandler)</code></li>\n<li>Stop listening for an event with <code>$off(eventName, eventHandler)</code></li>\n</ul>\n<p>You normally won’t have to use these, but they’re available for cases when you need to manually listen for events on a component instance. They can also be useful as a code organization tool. For example, you may often see this pattern for integrating a 3rd-party library:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Attach the datepicker to an input once</span>\n<span class=\"hljs-comment\">// it's mounted to the DOM.</span>\n<span class=\"hljs-attr\">mounted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// Pikaday is a 3rd-party datepicker library</span>\n  <span class=\"hljs-keyword\">this</span>.picker = <span class=\"hljs-keyword\">new</span> Pikaday(&#123;\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-keyword\">this</span>.$refs.input,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'YYYY-MM-DD'</span>\n  &#125;)\n&#125;,\n<span class=\"hljs-comment\">// Right before the component is destroyed,</span>\n<span class=\"hljs-comment\">// also destroy the datepicker.</span>\n<span class=\"hljs-attr\">beforeDestroy</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.picker.destroy()\n&#125;</code></pre>\n<p>This has two potential issues:</p>\n<ul>\n<li>It requires saving the <code>picker</code> to the component instance, when it’s possible that only lifecycle hooks need access to it. This isn’t terrible, but it could be considered clutter.</li>\n<li>Our setup code is kept separate from our cleanup code, making it more difficult to programmatically clean up anything we set up.</li>\n</ul>\n<p>You could resolve both issues with a programmatic listener:</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> picker = <span class=\"hljs-keyword\">new</span> Pikaday(&#123;\n    <span class=\"hljs-attr\">field</span>: <span class=\"hljs-keyword\">this</span>.$refs.input,\n    <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'YYYY-MM-DD'</span>\n  &#125;)\n\n  <span class=\"hljs-keyword\">this</span>.$once(<span class=\"hljs-string\">'hook:beforeDestroy'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    picker.destroy()\n  &#125;)\n&#125;</code></pre>\n<p>Using this strategy, we could even use Pikaday with several input elements, with each new instance automatically cleaning up after itself:</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.attachDatepicker(<span class=\"hljs-string\">'startDateInput'</span>)\n  <span class=\"hljs-keyword\">this</span>.attachDatepicker(<span class=\"hljs-string\">'endDateInput'</span>)\n&#125;,\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">attachDatepicker</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">refName</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> picker = <span class=\"hljs-keyword\">new</span> Pikaday(&#123;\n      <span class=\"hljs-attr\">field</span>: <span class=\"hljs-keyword\">this</span>.$refs[refName],\n      <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">'YYYY-MM-DD'</span>\n    &#125;)\n\n    <span class=\"hljs-keyword\">this</span>.$once(<span class=\"hljs-string\">'hook:beforeDestroy'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      picker.destroy()\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p>See <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners\" target=\"_blank\" rel=\"noopener\">this example</a> for the full code. Note, however, that if you find yourself having to do a lot of setup and cleanup within a single component, the best solution will usually be to create more modular components. In this case, we’d recommend creating a reusable <code>&lt;input-datepicker&gt;</code> component.</p>\n<p>To learn more about programmatic listeners, check out the API for <a href=\"https://vuejs.org/v2/api/#Instance-Methods-Events\">Events Instance Methods</a>.</p>\n<p class=\"tip\">Note that Vue’s event system is different from the browser’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget\" target=\"_blank\" rel=\"noopener\">EventTarget API</a>. Though they work similarly, <code>$emit</code>, <code>$on</code>, and <code>$off</code> are <strong>not</strong> aliases for <code>dispatchEvent</code>, <code>addEventListener</code>, and <code>removeEventListener</code>.</p>\n\n<h2 id=\"Circular-References\"><a href=\"#Circular-References\" class=\"headerlink\" title=\"Circular References\"></a>Circular References</h2><h3 id=\"Recursive-Components\"><a href=\"#Recursive-Components\" class=\"headerlink\" title=\"Recursive Components\"></a>Recursive Components</h3><p>Components can recursively invoke themselves in their own template. However, they can only do so with the <code>name</code> option:</p>\n<pre><code class=\"hljs js\">name: <span class=\"hljs-string\">'unique-name-of-my-component'</span></code></pre>\n<p>When you register a component globally using <code>Vue.component</code>, the global ID is automatically set as the component’s <code>name</code> option.</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'unique-name-of-my-component'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<p>If you’re not careful, recursive components can also lead to infinite loops:</p>\n<pre><code class=\"hljs js\">name: <span class=\"hljs-string\">'stack-overflow'</span>,\n<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></code></pre>\n<p>A component like the above will result in a “max stack size exceeded” error, so make sure recursive invocation is conditional (i.e. uses a <code>v-if</code> that will eventually be <code>false</code>).</p>\n<h3 id=\"Circular-References-Between-Components\"><a href=\"#Circular-References-Between-Components\" class=\"headerlink\" title=\"Circular References Between Components\"></a>Circular References Between Components</h3><p>Let’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a <code>tree-folder</code> component with this template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tree-folder-contents</span> <span class=\"hljs-attr\">:children</span>=<span class=\"hljs-string\">\"folder.children\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>Then a <code>tree-folder-contents</code> component with this template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"child in children\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tree-folder</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"child.children\"</span> <span class=\"hljs-attr\">:folder</span>=<span class=\"hljs-string\">\"child\"</span>/&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>When you look closely, you’ll see that these components will actually be each other’s descendent <em>and</em> ancestor in the render tree - a paradox! When registering components globally with <code>Vue.component</code>, this paradox is resolved for you automatically. If that’s you, you can stop reading here.</p>\n<p>However, if you’re requiring/importing components using a <strong>module system</strong>, e.g. via Webpack or Browserify, you’ll get an error:</p>\n<pre><code class=\"hljs undefined\">Failed to mount component: template or render function not defined.</code></pre>\n<p>To explain what’s happening, let’s call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B <em>eventually</em>, but there’s no need to resolve B first.”</p>\n<p>In our case, let’s make that point the <code>tree-folder</code> component. We know the child that creates the paradox is the <code>tree-folder-contents</code> component, so we’ll wait until the <code>beforeCreate</code> lifecycle hook to register it:</p>\n<pre><code class=\"hljs js\">beforeCreate: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$options.components.TreeFolderContents = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./tree-folder-contents.vue'</span>).default\n&#125;</code></pre>\n<p>Or alternatively, you could use Webpack’s asynchronous <code>import</code> when you register the component locally:</p>\n<pre><code class=\"hljs js\">components: &#123;\n  <span class=\"hljs-attr\">TreeFolderContents</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">'./tree-folder-contents.vue'</span>)\n&#125;</code></pre>\n<p>Problem solved!</p>\n<h2 id=\"Alternate-Template-Definitions\"><a href=\"#Alternate-Template-Definitions\" class=\"headerlink\" title=\"Alternate Template Definitions\"></a>Alternate Template Definitions</h2><h3 id=\"Inline-Templates\"><a href=\"#Inline-Templates\" class=\"headerlink\" title=\"Inline Templates\"></a>Inline Templates</h3><p>When the <code>inline-template</code> special attribute is present on a child component, the component will use its inner content as its template, rather than treating it as distributed content. This allows more flexible template-authoring.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">inline-template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>These are compiled as the component's own template.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Not parent's transclusion content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>Your inline template needs to be defined inside the DOM element to which Vue is attached.</p>\n<p class=\"tip\">However, <code>inline-template</code> makes the scope of your templates harder to reason about. As a best practice, prefer defining templates inside the component using the <code>template</code> option or in a <code>&lt;template&gt;</code> element in a <code>.vue</code> file.</p>\n\n<h3 id=\"X-Templates\"><a href=\"#X-Templates\" class=\"headerlink\" title=\"X-Templates\"></a>X-Templates</h3><p>Another way to define templates is inside of a script element with the type <code>text/x-template</code>, then referencing the template by an id. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/x-template\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"hello-world-template\"</span>&gt;</span><span class=\"xml\">\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Hello hello hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'hello-world'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'#hello-world-template'</span>\n&#125;)</code></pre>\n<p>Your x-template needs to be defined outside the DOM element to which Vue is attached.</p>\n<p class=\"tip\">These can be useful for demos with large templates or in extremely small applications, but should otherwise be avoided, because they separate templates from the rest of the component definition.</p>\n\n<h2 id=\"Controlling-Updates\"><a href=\"#Controlling-Updates\" class=\"headerlink\" title=\"Controlling Updates\"></a>Controlling Updates</h2><p>Thanks to Vue’s Reactivity system, it always knows when to update (if you use it correctly). There are edge cases, however, when you might want to force an update, despite the fact that no reactive data has changed. Then there are other cases when you might want to prevent unnecessary updates.</p>\n<h3 id=\"Forcing-an-Update\"><a href=\"#Forcing-an-Update\" class=\"headerlink\" title=\"Forcing an Update\"></a>Forcing an Update</h3><p class=\"tip\">If you find yourself needing to force an update in Vue, in 99.99% of cases, you’ve made a mistake somewhere.</p>\n\n<p>You may not have accounted for change detection caveats <a href=\"https://vuejs.org/v2/guide/list.html#Caveats\">with arrays</a> or <a href=\"https://vuejs.org/v2/guide/list.html#Object-Change-Detection-Caveats\">objects</a>, or you may be relying on state that isn’t tracked by Vue’s reactivity system, e.g. with <code>data</code>.</p>\n<p>However, if you’ve ruled out the above and find yourself in this extremely rare situation of having to manually force an update, you can do so with <a href=\"../api/#vm-forceUpdate\"><code>$forceUpdate</code></a>.</p>\n<h3 id=\"Cheap-Static-Components-with-v-once\"><a href=\"#Cheap-Static-Components-with-v-once\" class=\"headerlink\" title=\"Cheap Static Components with v-once\"></a>Cheap Static Components with <code>v-once</code></h3><p>Rendering plain HTML elements is very fast in Vue, but sometimes you might have a component that contains <strong>a lot</strong> of static content. In these cases, you can ensure that it’s only evaluated once and then cached by adding the <code>v-once</code> directive to the root element, like this:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'terms-of-service'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div v-once&gt;\n      &lt;h1&gt;Terms of Service&lt;/h1&gt;\n      ... a lot of static content ...\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p class=\"tip\">Once again, try not to overuse this pattern. While convenient in those rare cases when you have to render a lot of static content, it’s simply not necessary unless you actually notice slow rendering – plus, it could cause a lot of confusion later. For example, imagine another developer who’s not familiar with <code>v-once</code> or simply misses it in the template. They might spend hours trying to figure out why the template isn’t updating correctly.</p>\n"},{"title":"Props","type":"guide","order":102,"_content":"\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how component props work with Vue School\">Learn how component props work with a free lesson on Vue School</a></div>\n\n## Prop Casing (camelCase vs kebab-case)\n\nHTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you're using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:\n\n``` js\nVue.component('blog-post', {\n  // camelCase in JavaScript\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n```\n\n``` html\n<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\"></blog-post>\n```\n\nAgain, if you're using string templates, this limitation does not apply.\n\n## Prop Types\n\nSo far, we've only seen props listed as an array of strings:\n\n```js\nprops: ['title', 'likes', 'isPublished', 'commentIds', 'author']\n```\n\nUsually though, you'll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties' names and values contain the prop names and types, respectively:\n\n```js\nprops: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n```\n\nThis not only documents your component, but will also warn users in the browser's JavaScript console if they pass the wrong type. You'll learn much more about [type checks and other prop validations](#Prop-Validation) further down this page.\n\n## Passing Static or Dynamic Props\n\nSo far, you've seen props passed a static value, like in:\n\n```html\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n\nYou've also seen props assigned dynamically with `v-bind`, such as in:\n\n```html\n<!-- Dynamically assign the value of a variable -->\n<blog-post v-bind:title=\"post.title\"></blog-post>\n\n<!-- Dynamically assign the value of a complex expression -->\n<blog-post\n  v-bind:title=\"post.title + ' by ' + post.author.name\"\n></blog-post>\n```\n\nIn the two examples above, we happen to pass string values, but _any_ type of value can actually be passed to a prop.\n\n### Passing a Number\n\n```html\n<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<blog-post v-bind:likes=\"42\"></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:likes=\"post.likes\"></blog-post>\n```\n\n### Passing a Boolean\n\n```html\n<!-- Including the prop with no value will imply `true`. -->\n<blog-post is-published></blog-post>\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<blog-post v-bind:is-published=\"false\"></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:is-published=\"post.isPublished\"></blog-post>\n```\n\n### Passing an Array\n\n```html\n<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<blog-post v-bind:comment-ids=\"[234, 266, 273]\"></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:comment-ids=\"post.commentIds\"></blog-post>\n```\n\n### Passing an Object\n\n```html\n<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<blog-post\n  v-bind:author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:author=\"post.author\"></blog-post>\n```\n\n### Passing the Properties of an Object\n\nIf you want to pass all the properties of an object as props, you can use `v-bind` without an argument (`v-bind` instead of `v-bind:prop-name`). For example, given a `post` object:\n\n``` js\npost: {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n```\n\nThe following template:\n\n``` html\n<blog-post v-bind=\"post\"></blog-post>\n```\n\nWill be equivalent to:\n\n``` html\n<blog-post\n  v-bind:id=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\n## One-Way Data Flow\n\nAll props form a **one-way-down binding** between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should **not** attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.\n\nThere are usually two cases where it's tempting to mutate a prop:\n\n1. **The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.** In this case, it's best to define a local data property that uses the prop as its initial value:\n\n  ``` js\n  props: ['initialCounter'],\n  data: function () {\n    return {\n      counter: this.initialCounter\n    }\n  }\n  ```\n\n2. **The prop is passed in as a raw value that needs to be transformed.** In this case, it's best to define a computed property using the prop's value:\n\n  ``` js\n  props: ['size'],\n  computed: {\n    normalizedSize: function () {\n      return this.size.trim().toLowerCase()\n    }\n  }\n  ```\n\n<p class=\"tip\">Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component **will** affect parent state.</p>\n\n## Prop Validation\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement isn't met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that's intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the value of `props`, instead of an array of strings. For example:\n\n``` js\nVue.component('my-component', {\n  props: {\n    // Basic type check (`null` and `undefined` values will pass any type validation)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Number with a default value\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propE: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    propF: {\n      validator: function (value) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n```\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\n<p class=\"tip\">Note that props are validated **before** a component instance is created, so instance properties (e.g. `data`, `computed`, etc) will not be available inside `default` or `validator` functions.</p>\n\n### Type Checks\n\nThe `type` can be one of the following native constructors:\n\n- String\n- Number\n- Boolean\n- Array\n- Object\n- Date\n- Function\n- Symbol\n\nIn addition, `type` can also be a custom constructor function and the assertion will be made with an `instanceof` check. For example, given the following constructor function exists:\n\n```js\nfunction Person (firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\n```\n\nYou could use:\n\n```js\nVue.component('blog-post', {\n  props: {\n    author: Person\n  }\n})\n```\n\nto validate that the value of the `author` prop was created with `new Person`.\n\n## Non-Prop Attributes\n\nA non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.\n\nWhile explicitly defined props are preferred for passing information to a child component, authors of component libraries can't always foresee the contexts in which their components might be used. That's why components can accept arbitrary attributes, which are added to the component's root element.\n\nFor example, imagine we're using a 3rd-party `bootstrap-date-input` component with a Bootstrap plugin that requires a `data-date-picker` attribute on the `input`. We can add this attribute to our component instance:\n\n``` html\n<bootstrap-date-input data-date-picker=\"activated\"></bootstrap-date-input>\n```\n\nAnd the `data-date-picker=\"activated\"` attribute will automatically be added to the root element of `bootstrap-date-input`.\n\n### Replacing/Merging with Existing Attributes\n\nImagine this is the template for `bootstrap-date-input`:\n\n``` html\n<input type=\"date\" class=\"form-control\">\n```\n\nTo specify a theme for our date picker plugin, we might need to add a specific class, like this:\n\n``` html\n<bootstrap-date-input\n  data-date-picker=\"activated\"\n  class=\"date-picker-theme-dark\"\n></bootstrap-date-input>\n```\n\nIn this case, two different values for `class` are defined:\n\n- `form-control`, which is set by the component in its template\n- `date-picker-theme-dark`, which is passed to the component by its parent\n\nFor most attributes, the value provided to the component will replace the value set by the component. So for example, passing `type=\"text\"` will replace `type=\"date\"` and probably break it! Fortunately, the `class` and `style` attributes are a little smarter, so both values are merged, making the final value: `form-control date-picker-theme-dark`.\n\n### Disabling Attribute Inheritance\n\nIf you do **not** want the root element of a component to inherit attributes, you can set `inheritAttrs: false` in the component's options. For example:\n\n```js\nVue.component('my-component', {\n  inheritAttrs: false,\n  // ...\n})\n```\n\nThis can be especially useful in combination with the `$attrs` instance property, which contains the attribute names and values passed to a component, such as:\n\n```js\n{\n  required: true,\n  placeholder: 'Enter your username'\n}\n```\n\nWith `inheritAttrs: false` and `$attrs`, you can manually decide which element you want to forward attributes to, which is often desirable for [base components](../style-guide/#Base-component-names-strongly-recommended):\n\n```js\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      >\n    </label>\n  `\n})\n```\n\n<p class=\"tip\">Note that `inheritAttrs: false` option does **not** affect `style` and `class` bindings.</p>\n\nThis pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:\n\n```html\n<base-input\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n","source":"v2/guide/components-props.md","raw":"---\ntitle: Props\ntype: guide\norder: 102\n---\n\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how component props work with Vue School\">Learn how component props work with a free lesson on Vue School</a></div>\n\n## Prop Casing (camelCase vs kebab-case)\n\nHTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you're using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:\n\n``` js\nVue.component('blog-post', {\n  // camelCase in JavaScript\n  props: ['postTitle'],\n  template: '<h3>{{ postTitle }}</h3>'\n})\n```\n\n``` html\n<!-- kebab-case in HTML -->\n<blog-post post-title=\"hello!\"></blog-post>\n```\n\nAgain, if you're using string templates, this limitation does not apply.\n\n## Prop Types\n\nSo far, we've only seen props listed as an array of strings:\n\n```js\nprops: ['title', 'likes', 'isPublished', 'commentIds', 'author']\n```\n\nUsually though, you'll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties' names and values contain the prop names and types, respectively:\n\n```js\nprops: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n```\n\nThis not only documents your component, but will also warn users in the browser's JavaScript console if they pass the wrong type. You'll learn much more about [type checks and other prop validations](#Prop-Validation) further down this page.\n\n## Passing Static or Dynamic Props\n\nSo far, you've seen props passed a static value, like in:\n\n```html\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n\nYou've also seen props assigned dynamically with `v-bind`, such as in:\n\n```html\n<!-- Dynamically assign the value of a variable -->\n<blog-post v-bind:title=\"post.title\"></blog-post>\n\n<!-- Dynamically assign the value of a complex expression -->\n<blog-post\n  v-bind:title=\"post.title + ' by ' + post.author.name\"\n></blog-post>\n```\n\nIn the two examples above, we happen to pass string values, but _any_ type of value can actually be passed to a prop.\n\n### Passing a Number\n\n```html\n<!-- Even though `42` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.       -->\n<blog-post v-bind:likes=\"42\"></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:likes=\"post.likes\"></blog-post>\n```\n\n### Passing a Boolean\n\n```html\n<!-- Including the prop with no value will imply `true`. -->\n<blog-post is-published></blog-post>\n\n<!-- Even though `false` is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.          -->\n<blog-post v-bind:is-published=\"false\"></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:is-published=\"post.isPublished\"></blog-post>\n```\n\n### Passing an Array\n\n```html\n<!-- Even though the array is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.            -->\n<blog-post v-bind:comment-ids=\"[234, 266, 273]\"></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:comment-ids=\"post.commentIds\"></blog-post>\n```\n\n### Passing an Object\n\n```html\n<!-- Even though the object is static, we need v-bind to tell Vue that -->\n<!-- this is a JavaScript expression rather than a string.             -->\n<blog-post\n  v-bind:author=\"{\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  }\"\n></blog-post>\n\n<!-- Dynamically assign to the value of a variable. -->\n<blog-post v-bind:author=\"post.author\"></blog-post>\n```\n\n### Passing the Properties of an Object\n\nIf you want to pass all the properties of an object as props, you can use `v-bind` without an argument (`v-bind` instead of `v-bind:prop-name`). For example, given a `post` object:\n\n``` js\npost: {\n  id: 1,\n  title: 'My Journey with Vue'\n}\n```\n\nThe following template:\n\n``` html\n<blog-post v-bind=\"post\"></blog-post>\n```\n\nWill be equivalent to:\n\n``` html\n<blog-post\n  v-bind:id=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\n## One-Way Data Flow\n\nAll props form a **one-way-down binding** between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent's state, which can make your app's data flow harder to understand.\n\nIn addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should **not** attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.\n\nThere are usually two cases where it's tempting to mutate a prop:\n\n1. **The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.** In this case, it's best to define a local data property that uses the prop as its initial value:\n\n  ``` js\n  props: ['initialCounter'],\n  data: function () {\n    return {\n      counter: this.initialCounter\n    }\n  }\n  ```\n\n2. **The prop is passed in as a raw value that needs to be transformed.** In this case, it's best to define a computed property using the prop's value:\n\n  ``` js\n  props: ['size'],\n  computed: {\n    normalizedSize: function () {\n      return this.size.trim().toLowerCase()\n    }\n  }\n  ```\n\n<p class=\"tip\">Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component **will** affect parent state.</p>\n\n## Prop Validation\n\nComponents can specify requirements for their props, such as the types you've already seen. If a requirement isn't met, Vue will warn you in the browser's JavaScript console. This is especially useful when developing a component that's intended to be used by others.\n\nTo specify prop validations, you can provide an object with validation requirements to the value of `props`, instead of an array of strings. For example:\n\n``` js\nVue.component('my-component', {\n  props: {\n    // Basic type check (`null` and `undefined` values will pass any type validation)\n    propA: Number,\n    // Multiple possible types\n    propB: [String, Number],\n    // Required string\n    propC: {\n      type: String,\n      required: true\n    },\n    // Number with a default value\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // Object with a default value\n    propE: {\n      type: Object,\n      // Object or array defaults must be returned from\n      // a factory function\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // Custom validator function\n    propF: {\n      validator: function (value) {\n        // The value must match one of these strings\n        return ['success', 'warning', 'danger'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n```\n\nWhen prop validation fails, Vue will produce a console warning (if using the development build).\n\n<p class=\"tip\">Note that props are validated **before** a component instance is created, so instance properties (e.g. `data`, `computed`, etc) will not be available inside `default` or `validator` functions.</p>\n\n### Type Checks\n\nThe `type` can be one of the following native constructors:\n\n- String\n- Number\n- Boolean\n- Array\n- Object\n- Date\n- Function\n- Symbol\n\nIn addition, `type` can also be a custom constructor function and the assertion will be made with an `instanceof` check. For example, given the following constructor function exists:\n\n```js\nfunction Person (firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\n```\n\nYou could use:\n\n```js\nVue.component('blog-post', {\n  props: {\n    author: Person\n  }\n})\n```\n\nto validate that the value of the `author` prop was created with `new Person`.\n\n## Non-Prop Attributes\n\nA non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.\n\nWhile explicitly defined props are preferred for passing information to a child component, authors of component libraries can't always foresee the contexts in which their components might be used. That's why components can accept arbitrary attributes, which are added to the component's root element.\n\nFor example, imagine we're using a 3rd-party `bootstrap-date-input` component with a Bootstrap plugin that requires a `data-date-picker` attribute on the `input`. We can add this attribute to our component instance:\n\n``` html\n<bootstrap-date-input data-date-picker=\"activated\"></bootstrap-date-input>\n```\n\nAnd the `data-date-picker=\"activated\"` attribute will automatically be added to the root element of `bootstrap-date-input`.\n\n### Replacing/Merging with Existing Attributes\n\nImagine this is the template for `bootstrap-date-input`:\n\n``` html\n<input type=\"date\" class=\"form-control\">\n```\n\nTo specify a theme for our date picker plugin, we might need to add a specific class, like this:\n\n``` html\n<bootstrap-date-input\n  data-date-picker=\"activated\"\n  class=\"date-picker-theme-dark\"\n></bootstrap-date-input>\n```\n\nIn this case, two different values for `class` are defined:\n\n- `form-control`, which is set by the component in its template\n- `date-picker-theme-dark`, which is passed to the component by its parent\n\nFor most attributes, the value provided to the component will replace the value set by the component. So for example, passing `type=\"text\"` will replace `type=\"date\"` and probably break it! Fortunately, the `class` and `style` attributes are a little smarter, so both values are merged, making the final value: `form-control date-picker-theme-dark`.\n\n### Disabling Attribute Inheritance\n\nIf you do **not** want the root element of a component to inherit attributes, you can set `inheritAttrs: false` in the component's options. For example:\n\n```js\nVue.component('my-component', {\n  inheritAttrs: false,\n  // ...\n})\n```\n\nThis can be especially useful in combination with the `$attrs` instance property, which contains the attribute names and values passed to a component, such as:\n\n```js\n{\n  required: true,\n  placeholder: 'Enter your username'\n}\n```\n\nWith `inheritAttrs: false` and `$attrs`, you can manually decide which element you want to forward attributes to, which is often desirable for [base components](../style-guide/#Base-component-names-strongly-recommended):\n\n```js\nVue.component('base-input', {\n  inheritAttrs: false,\n  props: ['label', 'value'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      >\n    </label>\n  `\n})\n```\n\n<p class=\"tip\">Note that `inheritAttrs: false` option does **not** affect `style` and `class` bindings.</p>\n\nThis pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:\n\n```html\n<base-input\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n","date":"2020-09-25T23:55:41.134Z","updated":"2020-09-25T23:55:41.134Z","path":"v2/guide/components-props.html","comments":1,"layout":"page","_id":"ckfl66gyi001xc2v5xgfgu7sh","content":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how component props work with Vue School\">Learn how component props work with a free lesson on Vue School</a></div>\n\n<h2 id=\"Prop-Casing-camelCase-vs-kebab-case\"><a href=\"#Prop-Casing-camelCase-vs-kebab-case\" class=\"headerlink\" title=\"Prop Casing (camelCase vs kebab-case)\"></a>Prop Casing (camelCase vs kebab-case)</h2><p>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-comment\">// camelCase in JavaScript</span>\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'postTitle'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- kebab-case in HTML --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">post-title</span>=<span class=\"hljs-string\">\"hello!\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Again, if you’re using string templates, this limitation does not apply.</p>\n<h2 id=\"Prop-Types\"><a href=\"#Prop-Types\" class=\"headerlink\" title=\"Prop Types\"></a>Prop Types</h2><p>So far, we’ve only seen props listed as an array of strings:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">'likes'</span>, <span class=\"hljs-string\">'isPublished'</span>, <span class=\"hljs-string\">'commentIds'</span>, <span class=\"hljs-string\">'author'</span>]</code></pre>\n<p>Usually though, you’ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties’ names and values contain the prop names and types, respectively:</p>\n<pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">likes</span>: <span class=\"hljs-built_in\">Number</span>,\n  <span class=\"hljs-attr\">isPublished</span>: <span class=\"hljs-built_in\">Boolean</span>,\n  <span class=\"hljs-attr\">commentIds</span>: <span class=\"hljs-built_in\">Array</span>,\n  <span class=\"hljs-attr\">author</span>: <span class=\"hljs-built_in\">Object</span>,\n  <span class=\"hljs-attr\">callback</span>: <span class=\"hljs-built_in\">Function</span>,\n  <span class=\"hljs-attr\">contactsPromise</span>: <span class=\"hljs-built_in\">Promise</span> <span class=\"hljs-comment\">// or any other constructor</span>\n&#125;</code></pre>\n<p>This not only documents your component, but will also warn users in the browser’s JavaScript console if they pass the wrong type. You’ll learn much more about <a href=\"#Prop-Validation\">type checks and other prop validations</a> further down this page.</p>\n<h2 id=\"Passing-Static-or-Dynamic-Props\"><a href=\"#Passing-Static-or-Dynamic-Props\" class=\"headerlink\" title=\"Passing Static or Dynamic Props\"></a>Passing Static or Dynamic Props</h2><p>So far, you’ve seen props passed a static value, like in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"My journey with Vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>You’ve also seen props assigned dynamically with <code>v-bind</code>, such as in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Dynamically assign the value of a variable --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign the value of a complex expression --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title + ' by ' + post.author.name\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>In the two examples above, we happen to pass string values, but <em>any</em> type of value can actually be passed to a prop.</p>\n<h3 id=\"Passing-a-Number\"><a href=\"#Passing-a-Number\" class=\"headerlink\" title=\"Passing a Number\"></a>Passing a Number</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Even though `42` is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.       --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:likes</span>=<span class=\"hljs-string\">\"42\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:likes</span>=<span class=\"hljs-string\">\"post.likes\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-a-Boolean\"><a href=\"#Passing-a-Boolean\" class=\"headerlink\" title=\"Passing a Boolean\"></a>Passing a Boolean</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Including the prop with no value will imply `true`. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">is-published</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Even though `false` is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.          --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:is-published</span>=<span class=\"hljs-string\">\"false\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:is-published</span>=<span class=\"hljs-string\">\"post.isPublished\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-an-Array\"><a href=\"#Passing-an-Array\" class=\"headerlink\" title=\"Passing an Array\"></a>Passing an Array</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Even though the array is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.            --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:comment-ids</span>=<span class=\"hljs-string\">\"[234, 266, 273]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:comment-ids</span>=<span class=\"hljs-string\">\"post.commentIds\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-an-Object\"><a href=\"#Passing-an-Object\" class=\"headerlink\" title=\"Passing an Object\"></a>Passing an Object</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Even though the object is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.             --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-bind:author</span>=<span class=\"hljs-string\">\"&#123;\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  &#125;\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:author</span>=<span class=\"hljs-string\">\"post.author\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-the-Properties-of-an-Object\"><a href=\"#Passing-the-Properties-of-an-Object\" class=\"headerlink\" title=\"Passing the Properties of an Object\"></a>Passing the Properties of an Object</h3><p>If you want to pass all the properties of an object as props, you can use <code>v-bind</code> without an argument (<code>v-bind</code> instead of <code>v-bind:prop-name</code>). For example, given a <code>post</code> object:</p>\n<pre><code class=\"hljs js\">post: &#123;\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'My Journey with Vue'</span>\n&#125;</code></pre>\n<p>The following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"post\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Will be equivalent to:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h2 id=\"One-Way-Data-Flow\"><a href=\"#One-Way-Data-Flow\" class=\"headerlink\" title=\"One-Way Data Flow\"></a>One-Way Data Flow</h2><p>All props form a <strong>one-way-down binding</strong> between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to understand.</p>\n<p>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should <strong>not</strong> attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</p>\n<p>There are usually two cases where it’s tempting to mutate a prop:</p>\n<ol>\n<li><p><strong>The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.</strong> In this case, it’s best to define a local data property that uses the prop as its initial value:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'initialCounter'</span>],\n<span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-keyword\">this</span>.initialCounter\n  &#125;\n&#125;</code></pre>\n</li>\n<li><p><strong>The prop is passed in as a raw value that needs to be transformed.</strong> In this case, it’s best to define a computed property using the prop’s value:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'size'</span>],\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">normalizedSize</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.size.trim().toLowerCase()\n  &#125;\n&#125;</code></pre>\n</li>\n</ol>\n<p class=\"tip\">Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component <strong>will</strong> affect parent state.</p>\n\n<h2 id=\"Prop-Validation\"><a href=\"#Prop-Validation\" class=\"headerlink\" title=\"Prop Validation\"></a>Prop Validation</h2><p>Components can specify requirements for their props, such as the types you’ve already seen. If a requirement isn’t met, Vue will warn you in the browser’s JavaScript console. This is especially useful when developing a component that’s intended to be used by others.</p>\n<p>To specify prop validations, you can provide an object with validation requirements to the value of <code>props</code>, instead of an array of strings. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// Basic type check (`null` and `undefined` values will pass any type validation)</span>\n    <span class=\"hljs-attr\">propA</span>: <span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-comment\">// Multiple possible types</span>\n    <span class=\"hljs-attr\">propB</span>: [<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Number</span>],\n    <span class=\"hljs-comment\">// Required string</span>\n    <span class=\"hljs-attr\">propC</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// Number with a default value</span>\n    <span class=\"hljs-attr\">propD</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">100</span>\n    &#125;,\n    <span class=\"hljs-comment\">// Object with a default value</span>\n    <span class=\"hljs-attr\">propE</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-comment\">// Object or array defaults must be returned from</span>\n      <span class=\"hljs-comment\">// a factory function</span>\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'hello'</span> &#125;\n      &#125;\n    &#125;,\n    <span class=\"hljs-comment\">// Custom validator function</span>\n    <span class=\"hljs-attr\">propF</span>: &#123;\n      <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n        <span class=\"hljs-comment\">// The value must match one of these strings</span>\n        <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">'success'</span>, <span class=\"hljs-string\">'warning'</span>, <span class=\"hljs-string\">'danger'</span>].indexOf(value) !== <span class=\"hljs-number\">-1</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>When prop validation fails, Vue will produce a console warning (if using the development build).</p>\n<p class=\"tip\">Note that props are validated <strong>before</strong> a component instance is created, so instance properties (e.g. <code>data</code>, <code>computed</code>, etc) will not be available inside <code>default</code> or <code>validator</code> functions.</p>\n\n<h3 id=\"Type-Checks\"><a href=\"#Type-Checks\" class=\"headerlink\" title=\"Type Checks\"></a>Type Checks</h3><p>The <code>type</code> can be one of the following native constructors:</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Array</li>\n<li>Object</li>\n<li>Date</li>\n<li>Function</li>\n<li>Symbol</li>\n</ul>\n<p>In addition, <code>type</code> can also be a custom constructor function and the assertion will be made with an <code>instanceof</code> check. For example, given the following constructor function exists:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> (<span class=\"hljs-params\">firstName, lastName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.firstName = firstName\n  <span class=\"hljs-keyword\">this</span>.lastName = lastName\n&#125;</code></pre>\n<p>You could use:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">author</span>: Person\n  &#125;\n&#125;)</code></pre>\n<p>to validate that the value of the <code>author</code> prop was created with <code>new Person</code>.</p>\n<h2 id=\"Non-Prop-Attributes\"><a href=\"#Non-Prop-Attributes\" class=\"headerlink\" title=\"Non-Prop Attributes\"></a>Non-Prop Attributes</h2><p>A non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.</p>\n<p>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can’t always foresee the contexts in which their components might be used. That’s why components can accept arbitrary attributes, which are added to the component’s root element.</p>\n<p>For example, imagine we’re using a 3rd-party <code>bootstrap-date-input</code> component with a Bootstrap plugin that requires a <code>data-date-picker</code> attribute on the <code>input</code>. We can add this attribute to our component instance:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bootstrap-date-input</span> <span class=\"hljs-attr\">data-date-picker</span>=<span class=\"hljs-string\">\"activated\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bootstrap-date-input</span>&gt;</span></code></pre>\n<p>And the <code>data-date-picker=&quot;activated&quot;</code> attribute will automatically be added to the root element of <code>bootstrap-date-input</code>.</p>\n<h3 id=\"Replacing-Merging-with-Existing-Attributes\"><a href=\"#Replacing-Merging-with-Existing-Attributes\" class=\"headerlink\" title=\"Replacing/Merging with Existing Attributes\"></a>Replacing/Merging with Existing Attributes</h3><p>Imagine this is the template for <code>bootstrap-date-input</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"date\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"form-control\"</span>&gt;</span></code></pre>\n<p>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bootstrap-date-input</span>\n  <span class=\"hljs-attr\">data-date-picker</span>=<span class=\"hljs-string\">\"activated\"</span>\n  <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"date-picker-theme-dark\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bootstrap-date-input</span>&gt;</span></code></pre>\n<p>In this case, two different values for <code>class</code> are defined:</p>\n<ul>\n<li><code>form-control</code>, which is set by the component in its template</li>\n<li><code>date-picker-theme-dark</code>, which is passed to the component by its parent</li>\n</ul>\n<p>For most attributes, the value provided to the component will replace the value set by the component. So for example, passing <code>type=&quot;text&quot;</code> will replace <code>type=&quot;date&quot;</code> and probably break it! Fortunately, the <code>class</code> and <code>style</code> attributes are a little smarter, so both values are merged, making the final value: <code>form-control date-picker-theme-dark</code>.</p>\n<h3 id=\"Disabling-Attribute-Inheritance\"><a href=\"#Disabling-Attribute-Inheritance\" class=\"headerlink\" title=\"Disabling Attribute Inheritance\"></a>Disabling Attribute Inheritance</h3><p>If you do <strong>not</strong> want the root element of a component to inherit attributes, you can set <code>inheritAttrs: false</code> in the component’s options. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<p>This can be especially useful in combination with the <code>$attrs</code> instance property, which contains the attribute names and values passed to a component, such as:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">placeholder</span>: <span class=\"hljs-string\">'Enter your username'</span>\n&#125;</code></pre>\n<p>With <code>inheritAttrs: false</code> and <code>$attrs</code>, you can manually decide which element you want to forward attributes to, which is often desirable for <a href=\"../style-guide/#Base-component-names-strongly-recommended\">base components</a>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'base-input'</span>, &#123;\n  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'label'</span>, <span class=\"hljs-string\">'value'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;label&gt;\n      &#123;&#123; label &#125;&#125;\n      &lt;input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      &gt;\n    &lt;/label&gt;\n  `</span>\n&#125;)</code></pre>\n<p class=\"tip\">Note that <code>inheritAttrs: false</code> option does <strong>not</strong> affect <code>style</code> and <code>class</code> bindings.</p>\n\n<p>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-input</span>\n  <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"username\"</span>\n  <span class=\"hljs-attr\">required</span>\n  <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your username\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-input</span>&gt;</span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/reusable-components-with-props?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how component props work with Vue School\">Learn how component props work with a free lesson on Vue School</a></div>\n\n<h2 id=\"Prop-Casing-camelCase-vs-kebab-case\"><a href=\"#Prop-Casing-camelCase-vs-kebab-case\" class=\"headerlink\" title=\"Prop Casing (camelCase vs kebab-case)\"></a>Prop Casing (camelCase vs kebab-case)</h2><p>HTML attribute names are case-insensitive, so browsers will interpret any uppercase characters as lowercase. That means when you’re using in-DOM templates, camelCased prop names need to use their kebab-cased (hyphen-delimited) equivalents:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-comment\">// camelCase in JavaScript</span>\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'postTitle'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- kebab-case in HTML --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">post-title</span>=<span class=\"hljs-string\">\"hello!\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Again, if you’re using string templates, this limitation does not apply.</p>\n<h2 id=\"Prop-Types\"><a href=\"#Prop-Types\" class=\"headerlink\" title=\"Prop Types\"></a>Prop Types</h2><p>So far, we’ve only seen props listed as an array of strings:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">'likes'</span>, <span class=\"hljs-string\">'isPublished'</span>, <span class=\"hljs-string\">'commentIds'</span>, <span class=\"hljs-string\">'author'</span>]</code></pre>\n<p>Usually though, you’ll want every prop to be a specific type of value. In these cases, you can list props as an object, where the properties’ names and values contain the prop names and types, respectively:</p>\n<pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">likes</span>: <span class=\"hljs-built_in\">Number</span>,\n  <span class=\"hljs-attr\">isPublished</span>: <span class=\"hljs-built_in\">Boolean</span>,\n  <span class=\"hljs-attr\">commentIds</span>: <span class=\"hljs-built_in\">Array</span>,\n  <span class=\"hljs-attr\">author</span>: <span class=\"hljs-built_in\">Object</span>,\n  <span class=\"hljs-attr\">callback</span>: <span class=\"hljs-built_in\">Function</span>,\n  <span class=\"hljs-attr\">contactsPromise</span>: <span class=\"hljs-built_in\">Promise</span> <span class=\"hljs-comment\">// or any other constructor</span>\n&#125;</code></pre>\n<p>This not only documents your component, but will also warn users in the browser’s JavaScript console if they pass the wrong type. You’ll learn much more about <a href=\"#Prop-Validation\">type checks and other prop validations</a> further down this page.</p>\n<h2 id=\"Passing-Static-or-Dynamic-Props\"><a href=\"#Passing-Static-or-Dynamic-Props\" class=\"headerlink\" title=\"Passing Static or Dynamic Props\"></a>Passing Static or Dynamic Props</h2><p>So far, you’ve seen props passed a static value, like in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"My journey with Vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>You’ve also seen props assigned dynamically with <code>v-bind</code>, such as in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Dynamically assign the value of a variable --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign the value of a complex expression --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title + ' by ' + post.author.name\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>In the two examples above, we happen to pass string values, but <em>any</em> type of value can actually be passed to a prop.</p>\n<h3 id=\"Passing-a-Number\"><a href=\"#Passing-a-Number\" class=\"headerlink\" title=\"Passing a Number\"></a>Passing a Number</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Even though `42` is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.       --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:likes</span>=<span class=\"hljs-string\">\"42\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:likes</span>=<span class=\"hljs-string\">\"post.likes\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-a-Boolean\"><a href=\"#Passing-a-Boolean\" class=\"headerlink\" title=\"Passing a Boolean\"></a>Passing a Boolean</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Including the prop with no value will imply `true`. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">is-published</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Even though `false` is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.          --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:is-published</span>=<span class=\"hljs-string\">\"false\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:is-published</span>=<span class=\"hljs-string\">\"post.isPublished\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-an-Array\"><a href=\"#Passing-an-Array\" class=\"headerlink\" title=\"Passing an Array\"></a>Passing an Array</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Even though the array is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.            --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:comment-ids</span>=<span class=\"hljs-string\">\"[234, 266, 273]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:comment-ids</span>=<span class=\"hljs-string\">\"post.commentIds\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-an-Object\"><a href=\"#Passing-an-Object\" class=\"headerlink\" title=\"Passing an Object\"></a>Passing an Object</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Even though the object is static, we need v-bind to tell Vue that --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- this is a JavaScript expression rather than a string.             --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-bind:author</span>=<span class=\"hljs-string\">\"&#123;\n    name: 'Veronica',\n    company: 'Veridian Dynamics'\n  &#125;\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Dynamically assign to the value of a variable. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind:author</span>=<span class=\"hljs-string\">\"post.author\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h3 id=\"Passing-the-Properties-of-an-Object\"><a href=\"#Passing-the-Properties-of-an-Object\" class=\"headerlink\" title=\"Passing the Properties of an Object\"></a>Passing the Properties of an Object</h3><p>If you want to pass all the properties of an object as props, you can use <code>v-bind</code> without an argument (<code>v-bind</code> instead of <code>v-bind:prop-name</code>). For example, given a <code>post</code> object:</p>\n<pre><code class=\"hljs js\">post: &#123;\n  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n  <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'My Journey with Vue'</span>\n&#125;</code></pre>\n<p>The following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"post\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Will be equivalent to:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<h2 id=\"One-Way-Data-Flow\"><a href=\"#One-Way-Data-Flow\" class=\"headerlink\" title=\"One-Way Data Flow\"></a>One-Way Data Flow</h2><p>All props form a <strong>one-way-down binding</strong> between the child property and the parent one: when the parent property updates, it will flow down to the child, but not the other way around. This prevents child components from accidentally mutating the parent’s state, which can make your app’s data flow harder to understand.</p>\n<p>In addition, every time the parent component is updated, all props in the child component will be refreshed with the latest value. This means you should <strong>not</strong> attempt to mutate a prop inside a child component. If you do, Vue will warn you in the console.</p>\n<p>There are usually two cases where it’s tempting to mutate a prop:</p>\n<ol>\n<li><p><strong>The prop is used to pass in an initial value; the child component wants to use it as a local data property afterwards.</strong> In this case, it’s best to define a local data property that uses the prop as its initial value:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'initialCounter'</span>],\n<span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-keyword\">this</span>.initialCounter\n  &#125;\n&#125;</code></pre>\n</li>\n<li><p><strong>The prop is passed in as a raw value that needs to be transformed.</strong> In this case, it’s best to define a computed property using the prop’s value:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'size'</span>],\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">normalizedSize</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.size.trim().toLowerCase()\n  &#125;\n&#125;</code></pre>\n</li>\n</ol>\n<p class=\"tip\">Note that objects and arrays in JavaScript are passed by reference, so if the prop is an array or object, mutating the object or array itself inside the child component <strong>will</strong> affect parent state.</p>\n\n<h2 id=\"Prop-Validation\"><a href=\"#Prop-Validation\" class=\"headerlink\" title=\"Prop Validation\"></a>Prop Validation</h2><p>Components can specify requirements for their props, such as the types you’ve already seen. If a requirement isn’t met, Vue will warn you in the browser’s JavaScript console. This is especially useful when developing a component that’s intended to be used by others.</p>\n<p>To specify prop validations, you can provide an object with validation requirements to the value of <code>props</code>, instead of an array of strings. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// Basic type check (`null` and `undefined` values will pass any type validation)</span>\n    <span class=\"hljs-attr\">propA</span>: <span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-comment\">// Multiple possible types</span>\n    <span class=\"hljs-attr\">propB</span>: [<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Number</span>],\n    <span class=\"hljs-comment\">// Required string</span>\n    <span class=\"hljs-attr\">propC</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// Number with a default value</span>\n    <span class=\"hljs-attr\">propD</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">100</span>\n    &#125;,\n    <span class=\"hljs-comment\">// Object with a default value</span>\n    <span class=\"hljs-attr\">propE</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-comment\">// Object or array defaults must be returned from</span>\n      <span class=\"hljs-comment\">// a factory function</span>\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'hello'</span> &#125;\n      &#125;\n    &#125;,\n    <span class=\"hljs-comment\">// Custom validator function</span>\n    <span class=\"hljs-attr\">propF</span>: &#123;\n      <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n        <span class=\"hljs-comment\">// The value must match one of these strings</span>\n        <span class=\"hljs-keyword\">return</span> [<span class=\"hljs-string\">'success'</span>, <span class=\"hljs-string\">'warning'</span>, <span class=\"hljs-string\">'danger'</span>].indexOf(value) !== <span class=\"hljs-number\">-1</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>When prop validation fails, Vue will produce a console warning (if using the development build).</p>\n<p class=\"tip\">Note that props are validated <strong>before</strong> a component instance is created, so instance properties (e.g. <code>data</code>, <code>computed</code>, etc) will not be available inside <code>default</code> or <code>validator</code> functions.</p>\n\n<h3 id=\"Type-Checks\"><a href=\"#Type-Checks\" class=\"headerlink\" title=\"Type Checks\"></a>Type Checks</h3><p>The <code>type</code> can be one of the following native constructors:</p>\n<ul>\n<li>String</li>\n<li>Number</li>\n<li>Boolean</li>\n<li>Array</li>\n<li>Object</li>\n<li>Date</li>\n<li>Function</li>\n<li>Symbol</li>\n</ul>\n<p>In addition, <code>type</code> can also be a custom constructor function and the assertion will be made with an <code>instanceof</code> check. For example, given the following constructor function exists:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Person</span> (<span class=\"hljs-params\">firstName, lastName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.firstName = firstName\n  <span class=\"hljs-keyword\">this</span>.lastName = lastName\n&#125;</code></pre>\n<p>You could use:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">author</span>: Person\n  &#125;\n&#125;)</code></pre>\n<p>to validate that the value of the <code>author</code> prop was created with <code>new Person</code>.</p>\n<h2 id=\"Non-Prop-Attributes\"><a href=\"#Non-Prop-Attributes\" class=\"headerlink\" title=\"Non-Prop Attributes\"></a>Non-Prop Attributes</h2><p>A non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.</p>\n<p>While explicitly defined props are preferred for passing information to a child component, authors of component libraries can’t always foresee the contexts in which their components might be used. That’s why components can accept arbitrary attributes, which are added to the component’s root element.</p>\n<p>For example, imagine we’re using a 3rd-party <code>bootstrap-date-input</code> component with a Bootstrap plugin that requires a <code>data-date-picker</code> attribute on the <code>input</code>. We can add this attribute to our component instance:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bootstrap-date-input</span> <span class=\"hljs-attr\">data-date-picker</span>=<span class=\"hljs-string\">\"activated\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bootstrap-date-input</span>&gt;</span></code></pre>\n<p>And the <code>data-date-picker=&quot;activated&quot;</code> attribute will automatically be added to the root element of <code>bootstrap-date-input</code>.</p>\n<h3 id=\"Replacing-Merging-with-Existing-Attributes\"><a href=\"#Replacing-Merging-with-Existing-Attributes\" class=\"headerlink\" title=\"Replacing/Merging with Existing Attributes\"></a>Replacing/Merging with Existing Attributes</h3><p>Imagine this is the template for <code>bootstrap-date-input</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"date\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"form-control\"</span>&gt;</span></code></pre>\n<p>To specify a theme for our date picker plugin, we might need to add a specific class, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">bootstrap-date-input</span>\n  <span class=\"hljs-attr\">data-date-picker</span>=<span class=\"hljs-string\">\"activated\"</span>\n  <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"date-picker-theme-dark\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">bootstrap-date-input</span>&gt;</span></code></pre>\n<p>In this case, two different values for <code>class</code> are defined:</p>\n<ul>\n<li><code>form-control</code>, which is set by the component in its template</li>\n<li><code>date-picker-theme-dark</code>, which is passed to the component by its parent</li>\n</ul>\n<p>For most attributes, the value provided to the component will replace the value set by the component. So for example, passing <code>type=&quot;text&quot;</code> will replace <code>type=&quot;date&quot;</code> and probably break it! Fortunately, the <code>class</code> and <code>style</code> attributes are a little smarter, so both values are merged, making the final value: <code>form-control date-picker-theme-dark</code>.</p>\n<h3 id=\"Disabling-Attribute-Inheritance\"><a href=\"#Disabling-Attribute-Inheritance\" class=\"headerlink\" title=\"Disabling Attribute Inheritance\"></a>Disabling Attribute Inheritance</h3><p>If you do <strong>not</strong> want the root element of a component to inherit attributes, you can set <code>inheritAttrs: false</code> in the component’s options. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<p>This can be especially useful in combination with the <code>$attrs</code> instance property, which contains the attribute names and values passed to a component, such as:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">placeholder</span>: <span class=\"hljs-string\">'Enter your username'</span>\n&#125;</code></pre>\n<p>With <code>inheritAttrs: false</code> and <code>$attrs</code>, you can manually decide which element you want to forward attributes to, which is often desirable for <a href=\"../style-guide/#Base-component-names-strongly-recommended\">base components</a>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'base-input'</span>, &#123;\n  <span class=\"hljs-attr\">inheritAttrs</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'label'</span>, <span class=\"hljs-string\">'value'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;label&gt;\n      &#123;&#123; label &#125;&#125;\n      &lt;input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit('input', $event.target.value)\"\n      &gt;\n    &lt;/label&gt;\n  `</span>\n&#125;)</code></pre>\n<p class=\"tip\">Note that <code>inheritAttrs: false</code> option does <strong>not</strong> affect <code>style</code> and <code>class</code> bindings.</p>\n\n<p>This pattern allows you to use base components more like raw HTML elements, without having to care about which element is actually at its root:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-input</span>\n  <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"username\"</span>\n  <span class=\"hljs-attr\">required</span>\n  <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your username\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-input</span>&gt;</span></code></pre>\n"},{"title":"Component Registration","type":"guide","order":101,"_content":"\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/global-vs-local-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Component Registration lesson\">Watch a free video lesson on Vue School</a></div>\n\n## Component Names\n\nWhen registering a component, it will always be given a name. For example, in the global registration we've seen so far:\n\n```js\nVue.component('my-component-name', { /* ... */ })\n```\n\nThe component's name is the first argument of `Vue.component`.\n\nThe name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or [single-file component](single-file-components.html)), we strongly recommend following the [W3C rules](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name) for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.\n\nYou can see other recommendations for component names in the [Style Guide](../style-guide/#Base-component-names-strongly-recommended).\n\n### Name Casing\n\nYou have two options when defining component names:\n\n#### With kebab-case\n\n```js\nVue.component('my-component-name', { /* ... */ })\n```\n\nWhen defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in `<my-component-name>`.\n\n#### With PascalCase\n\n```js\nVue.component('MyComponentName', { /* ... */ })\n```\n\nWhen defining a component with PascalCase, you can use either case when referencing its custom element. That means both `<my-component-name>` and `<MyComponentName>` are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).\n\n## Global Registration\n\nSo far, we've only created components using `Vue.component`:\n\n```js\nVue.component('my-component-name', {\n  // ... options ...\n})\n```\n\nThese components are **globally registered**. That means they can be used in the template of any root Vue instance (`new Vue`) created after registration. For example:\n\n```js\nVue.component('component-a', { /* ... */ })\nVue.component('component-b', { /* ... */ })\nVue.component('component-c', { /* ... */ })\n\nnew Vue({ el: '#app' })\n```\n\n```html\n<div id=\"app\">\n  <component-a></component-a>\n  <component-b></component-b>\n  <component-c></component-c>\n</div>\n```\n\nThis even applies to all subcomponents, meaning all three of these components will also be available _inside each other_.\n\n## Local Registration\n\nGlobal registration often isn't ideal. For example, if you're using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.\n\nIn these cases, you can define your components as plain JavaScript objects:\n\n```js\nvar ComponentA = { /* ... */ }\nvar ComponentB = { /* ... */ }\nvar ComponentC = { /* ... */ }\n```\n\nThen define the components you'd like to use in a `components` option:\n\n```js\nnew Vue({\n  el: '#app',\n  components: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n  }\n})\n```\n\nFor each property in the `components` object, the key will be the name of the custom element, while the value will contain the options object for the component.\n\nNote that **locally registered components are _not_ also available in subcomponents**. For example, if you wanted `ComponentA` to be available in `ComponentB`, you'd have to use:\n\n```js\nvar ComponentA = { /* ... */ }\n\nvar ComponentB = {\n  components: {\n    'component-a': ComponentA\n  },\n  // ...\n}\n```\n\nOr if you're using ES2015 modules, such as through Babel and Webpack, that might look more like:\n\n```js\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  // ...\n}\n```\n\nNote that in ES2015+, placing a variable name like `ComponentA` inside an object is shorthand for `ComponentA: ComponentA`, meaning the name of the variable is both:\n\n- the custom element name to use in the template, and\n- the name of the variable containing the component options\n\n## Module Systems\n\nIf you're not using a module system with `import`/`require`, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.\n\n### Local Registration in a Module System\n\nIf you're still here, then it's likely you're using a module system, such as with Babel and Webpack. In these cases, we recommend creating a `components` directory, with each component in its own file.\n\nThen you'll need to import each component you'd like to use, before you locally register it. For example, in a hypothetical `ComponentB.js` or `ComponentB.vue` file:\n\n```js\nimport ComponentA from './ComponentA'\nimport ComponentC from './ComponentC'\n\nexport default {\n  components: {\n    ComponentA,\n    ComponentC\n  },\n  // ...\n}\n```\n\nNow both `ComponentA` and `ComponentC` can be used inside `ComponentB`'s template.\n\n### Automatic Global Registration of Base Components\n\nMany of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as [base components](../style-guide/#Base-component-names-strongly-recommended) and they tend to be used very frequently across your components.\n\nThe result is that many components may include long lists of base components:\n\n```js\nimport BaseButton from './BaseButton.vue'\nimport BaseIcon from './BaseIcon.vue'\nimport BaseInput from './BaseInput.vue'\n\nexport default {\n  components: {\n    BaseButton,\n    BaseIcon,\n    BaseInput\n  }\n}\n```\n\nJust to support relatively little markup in a template:\n\n```html\n<BaseInput\n  v-model=\"searchText\"\n  @keydown.enter=\"search\"\n/>\n<BaseButton @click=\"search\">\n  <BaseIcon name=\"search\"/>\n</BaseButton>\n```\n\nFortunately, if you're using Webpack (or [Vue CLI 3+](https://github.com/vuejs/vue-cli), which uses Webpack internally), you can use `require.context` to globally register only these very common base components. Here's an example of the code you might use to globally import base components in your app's entry file (e.g. `src/main.js`):\n\n```js\nimport Vue from 'vue'\nimport upperFirst from 'lodash/upperFirst'\nimport camelCase from 'lodash/camelCase'\n\nconst requireComponent = require.context(\n  // The relative path of the components folder\n  './components',\n  // Whether or not to look in subfolders\n  false,\n  // The regular expression used to match base component filenames\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(fileName => {\n  // Get component config\n  const componentConfig = requireComponent(fileName)\n\n  // Get PascalCase name of component\n  const componentName = upperFirst(\n    camelCase(\n      // Gets the file name regardless of folder depth\n      fileName\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n\n  // Register component globally\n  Vue.component(\n    componentName,\n    // Look for the component options on `.default`, which will\n    // exist if the component was exported with `export default`,\n    // otherwise fall back to module's root.\n    componentConfig.default || componentConfig\n  )\n})\n```\n\nRemember that **global registration must take place before the root Vue instance is created (with `new Vue`)**. [Here's an example](https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js) of this pattern in a real project context.\n","source":"v2/guide/components-registration.md","raw":"---\ntitle: Component Registration\ntype: guide\norder: 101\n---\n\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/global-vs-local-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Component Registration lesson\">Watch a free video lesson on Vue School</a></div>\n\n## Component Names\n\nWhen registering a component, it will always be given a name. For example, in the global registration we've seen so far:\n\n```js\nVue.component('my-component-name', { /* ... */ })\n```\n\nThe component's name is the first argument of `Vue.component`.\n\nThe name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or [single-file component](single-file-components.html)), we strongly recommend following the [W3C rules](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name) for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.\n\nYou can see other recommendations for component names in the [Style Guide](../style-guide/#Base-component-names-strongly-recommended).\n\n### Name Casing\n\nYou have two options when defining component names:\n\n#### With kebab-case\n\n```js\nVue.component('my-component-name', { /* ... */ })\n```\n\nWhen defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in `<my-component-name>`.\n\n#### With PascalCase\n\n```js\nVue.component('MyComponentName', { /* ... */ })\n```\n\nWhen defining a component with PascalCase, you can use either case when referencing its custom element. That means both `<my-component-name>` and `<MyComponentName>` are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).\n\n## Global Registration\n\nSo far, we've only created components using `Vue.component`:\n\n```js\nVue.component('my-component-name', {\n  // ... options ...\n})\n```\n\nThese components are **globally registered**. That means they can be used in the template of any root Vue instance (`new Vue`) created after registration. For example:\n\n```js\nVue.component('component-a', { /* ... */ })\nVue.component('component-b', { /* ... */ })\nVue.component('component-c', { /* ... */ })\n\nnew Vue({ el: '#app' })\n```\n\n```html\n<div id=\"app\">\n  <component-a></component-a>\n  <component-b></component-b>\n  <component-c></component-c>\n</div>\n```\n\nThis even applies to all subcomponents, meaning all three of these components will also be available _inside each other_.\n\n## Local Registration\n\nGlobal registration often isn't ideal. For example, if you're using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.\n\nIn these cases, you can define your components as plain JavaScript objects:\n\n```js\nvar ComponentA = { /* ... */ }\nvar ComponentB = { /* ... */ }\nvar ComponentC = { /* ... */ }\n```\n\nThen define the components you'd like to use in a `components` option:\n\n```js\nnew Vue({\n  el: '#app',\n  components: {\n    'component-a': ComponentA,\n    'component-b': ComponentB\n  }\n})\n```\n\nFor each property in the `components` object, the key will be the name of the custom element, while the value will contain the options object for the component.\n\nNote that **locally registered components are _not_ also available in subcomponents**. For example, if you wanted `ComponentA` to be available in `ComponentB`, you'd have to use:\n\n```js\nvar ComponentA = { /* ... */ }\n\nvar ComponentB = {\n  components: {\n    'component-a': ComponentA\n  },\n  // ...\n}\n```\n\nOr if you're using ES2015 modules, such as through Babel and Webpack, that might look more like:\n\n```js\nimport ComponentA from './ComponentA.vue'\n\nexport default {\n  components: {\n    ComponentA\n  },\n  // ...\n}\n```\n\nNote that in ES2015+, placing a variable name like `ComponentA` inside an object is shorthand for `ComponentA: ComponentA`, meaning the name of the variable is both:\n\n- the custom element name to use in the template, and\n- the name of the variable containing the component options\n\n## Module Systems\n\nIf you're not using a module system with `import`/`require`, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.\n\n### Local Registration in a Module System\n\nIf you're still here, then it's likely you're using a module system, such as with Babel and Webpack. In these cases, we recommend creating a `components` directory, with each component in its own file.\n\nThen you'll need to import each component you'd like to use, before you locally register it. For example, in a hypothetical `ComponentB.js` or `ComponentB.vue` file:\n\n```js\nimport ComponentA from './ComponentA'\nimport ComponentC from './ComponentC'\n\nexport default {\n  components: {\n    ComponentA,\n    ComponentC\n  },\n  // ...\n}\n```\n\nNow both `ComponentA` and `ComponentC` can be used inside `ComponentB`'s template.\n\n### Automatic Global Registration of Base Components\n\nMany of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as [base components](../style-guide/#Base-component-names-strongly-recommended) and they tend to be used very frequently across your components.\n\nThe result is that many components may include long lists of base components:\n\n```js\nimport BaseButton from './BaseButton.vue'\nimport BaseIcon from './BaseIcon.vue'\nimport BaseInput from './BaseInput.vue'\n\nexport default {\n  components: {\n    BaseButton,\n    BaseIcon,\n    BaseInput\n  }\n}\n```\n\nJust to support relatively little markup in a template:\n\n```html\n<BaseInput\n  v-model=\"searchText\"\n  @keydown.enter=\"search\"\n/>\n<BaseButton @click=\"search\">\n  <BaseIcon name=\"search\"/>\n</BaseButton>\n```\n\nFortunately, if you're using Webpack (or [Vue CLI 3+](https://github.com/vuejs/vue-cli), which uses Webpack internally), you can use `require.context` to globally register only these very common base components. Here's an example of the code you might use to globally import base components in your app's entry file (e.g. `src/main.js`):\n\n```js\nimport Vue from 'vue'\nimport upperFirst from 'lodash/upperFirst'\nimport camelCase from 'lodash/camelCase'\n\nconst requireComponent = require.context(\n  // The relative path of the components folder\n  './components',\n  // Whether or not to look in subfolders\n  false,\n  // The regular expression used to match base component filenames\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(fileName => {\n  // Get component config\n  const componentConfig = requireComponent(fileName)\n\n  // Get PascalCase name of component\n  const componentName = upperFirst(\n    camelCase(\n      // Gets the file name regardless of folder depth\n      fileName\n        .split('/')\n        .pop()\n        .replace(/\\.\\w+$/, '')\n    )\n  )\n\n\n  // Register component globally\n  Vue.component(\n    componentName,\n    // Look for the component options on `.default`, which will\n    // exist if the component was exported with `export default`,\n    // otherwise fall back to module's root.\n    componentConfig.default || componentConfig\n  )\n})\n```\n\nRemember that **global registration must take place before the root Vue instance is created (with `new Vue`)**. [Here's an example](https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js) of this pattern in a real project context.\n","date":"2020-09-25T23:55:41.134Z","updated":"2020-09-25T23:55:41.134Z","path":"v2/guide/components-registration.html","comments":1,"layout":"page","_id":"ckfl66gyi001yc2v5vhlt0cmk","content":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/global-vs-local-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Component Registration lesson\">Watch a free video lesson on Vue School</a></div>\n\n<h2 id=\"Component-Names\"><a href=\"#Component-Names\" class=\"headerlink\" title=\"Component Names\"></a>Component Names</h2><p>When registering a component, it will always be given a name. For example, in the global registration we’ve seen so far:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)</code></pre>\n<p>The component’s name is the first argument of <code>Vue.component</code>.</p>\n<p>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or <a href=\"single-file-components.html\">single-file component</a>), we strongly recommend following the <a href=\"https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\" target=\"_blank\" rel=\"noopener\">W3C rules</a> for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.</p>\n<p>You can see other recommendations for component names in the <a href=\"../style-guide/#Base-component-names-strongly-recommended\">Style Guide</a>.</p>\n<h3 id=\"Name-Casing\"><a href=\"#Name-Casing\" class=\"headerlink\" title=\"Name Casing\"></a>Name Casing</h3><p>You have two options when defining component names:</p>\n<h4 id=\"With-kebab-case\"><a href=\"#With-kebab-case\" class=\"headerlink\" title=\"With kebab-case\"></a>With kebab-case</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)</code></pre>\n<p>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in <code>&lt;my-component-name&gt;</code>.</p>\n<h4 id=\"With-PascalCase\"><a href=\"#With-PascalCase\" class=\"headerlink\" title=\"With PascalCase\"></a>With PascalCase</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'MyComponentName'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)</code></pre>\n<p>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both <code>&lt;my-component-name&gt;</code> and <code>&lt;MyComponentName&gt;</code> are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</p>\n<h2 id=\"Global-Registration\"><a href=\"#Global-Registration\" class=\"headerlink\" title=\"Global Registration\"></a>Global Registration</h2><p>So far, we’ve only created components using <code>Vue.component</code>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123;\n  <span class=\"hljs-comment\">// ... options ...</span>\n&#125;)</code></pre>\n<p>These components are <strong>globally registered</strong>. That means they can be used in the template of any root Vue instance (<code>new Vue</code>) created after registration. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'component-a'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\nVue.component(<span class=\"hljs-string\">'component-b'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\nVue.component(<span class=\"hljs-string\">'component-c'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span> &#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component-a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component-a</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component-b</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component-b</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component-c</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component-c</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This even applies to all subcomponents, meaning all three of these components will also be available <em>inside each other</em>.</p>\n<h2 id=\"Local-Registration\"><a href=\"#Local-Registration\" class=\"headerlink\" title=\"Local Registration\"></a>Local Registration</h2><p>Global registration often isn’t ideal. For example, if you’re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</p>\n<p>In these cases, you can define your components as plain JavaScript objects:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> ComponentA = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> ComponentB = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> ComponentC = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;</code></pre>\n<p>Then define the components you’d like to use in a <code>components</code> option:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">components</span>: &#123;\n    <span class=\"hljs-string\">'component-a'</span>: ComponentA,\n    <span class=\"hljs-string\">'component-b'</span>: ComponentB\n  &#125;\n&#125;)</code></pre>\n<p>For each property in the <code>components</code> object, the key will be the name of the custom element, while the value will contain the options object for the component.</p>\n<p>Note that <strong>locally registered components are <em>not</em> also available in subcomponents</strong>. For example, if you wanted <code>ComponentA</code> to be available in <code>ComponentB</code>, you’d have to use:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> ComponentA = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n\n<span class=\"hljs-keyword\">var</span> ComponentB = &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    <span class=\"hljs-string\">'component-a'</span>: ComponentA\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>Or if you’re using ES2015 modules, such as through Babel and Webpack, that might look more like:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> ComponentA <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ComponentA.vue'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    ComponentA\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>Note that in ES2015+, placing a variable name like <code>ComponentA</code> inside an object is shorthand for <code>ComponentA: ComponentA</code>, meaning the name of the variable is both:</p>\n<ul>\n<li>the custom element name to use in the template, and</li>\n<li>the name of the variable containing the component options</li>\n</ul>\n<h2 id=\"Module-Systems\"><a href=\"#Module-Systems\" class=\"headerlink\" title=\"Module Systems\"></a>Module Systems</h2><p>If you’re not using a module system with <code>import</code>/<code>require</code>, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</p>\n<h3 id=\"Local-Registration-in-a-Module-System\"><a href=\"#Local-Registration-in-a-Module-System\" class=\"headerlink\" title=\"Local Registration in a Module System\"></a>Local Registration in a Module System</h3><p>If you’re still here, then it’s likely you’re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a <code>components</code> directory, with each component in its own file.</p>\n<p>Then you’ll need to import each component you’d like to use, before you locally register it. For example, in a hypothetical <code>ComponentB.js</code> or <code>ComponentB.vue</code> file:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> ComponentA <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ComponentA'</span>\n<span class=\"hljs-keyword\">import</span> ComponentC <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ComponentC'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    ComponentA,\n    ComponentC\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>Now both <code>ComponentA</code> and <code>ComponentC</code> can be used inside <code>ComponentB</code>‘s template.</p>\n<h3 id=\"Automatic-Global-Registration-of-Base-Components\"><a href=\"#Automatic-Global-Registration-of-Base-Components\" class=\"headerlink\" title=\"Automatic Global Registration of Base Components\"></a>Automatic Global Registration of Base Components</h3><p>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as <a href=\"../style-guide/#Base-component-names-strongly-recommended\">base components</a> and they tend to be used very frequently across your components.</p>\n<p>The result is that many components may include long lists of base components:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> BaseButton <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./BaseButton.vue'</span>\n<span class=\"hljs-keyword\">import</span> BaseIcon <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./BaseIcon.vue'</span>\n<span class=\"hljs-keyword\">import</span> BaseInput <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./BaseInput.vue'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    BaseButton,\n    BaseIcon,\n    BaseInput\n  &#125;\n&#125;</code></pre>\n<p>Just to support relatively little markup in a template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BaseInput</span>\n  <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"searchText\"</span>\n  @<span class=\"hljs-attr\">keydown.enter</span>=<span class=\"hljs-string\">\"search\"</span>\n/&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BaseButton</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"search\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BaseIcon</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"search\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">BaseButton</span>&gt;</span></code></pre>\n<p>Fortunately, if you’re using Webpack (or <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">Vue CLI 3+</a>, which uses Webpack internally), you can use <code>require.context</code> to globally register only these very common base components. Here’s an example of the code you might use to globally import base components in your app’s entry file (e.g. <code>src/main.js</code>):</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> upperFirst <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash/upperFirst'</span>\n<span class=\"hljs-keyword\">import</span> camelCase <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash/camelCase'</span>\n\n<span class=\"hljs-keyword\">const</span> requireComponent = <span class=\"hljs-built_in\">require</span>.context(\n  <span class=\"hljs-comment\">// The relative path of the components folder</span>\n  <span class=\"hljs-string\">'./components'</span>,\n  <span class=\"hljs-comment\">// Whether or not to look in subfolders</span>\n  <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-comment\">// The regular expression used to match base component filenames</span>\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">fileName</span> =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// Get component config</span>\n  <span class=\"hljs-keyword\">const</span> componentConfig = requireComponent(fileName)\n\n  <span class=\"hljs-comment\">// Get PascalCase name of component</span>\n  <span class=\"hljs-keyword\">const</span> componentName = upperFirst(\n    camelCase(\n      <span class=\"hljs-comment\">// Gets the file name regardless of folder depth</span>\n      fileName\n        .split(<span class=\"hljs-string\">'/'</span>)\n        .pop()\n        .replace(<span class=\"hljs-regexp\">/\\.\\w+$/</span>, <span class=\"hljs-string\">''</span>)\n    )\n  )\n\n\n  <span class=\"hljs-comment\">// Register component globally</span>\n  Vue.component(\n    componentName,\n    <span class=\"hljs-comment\">// Look for the component options on `.default`, which will</span>\n    <span class=\"hljs-comment\">// exist if the component was exported with `export default`,</span>\n    <span class=\"hljs-comment\">// otherwise fall back to module's root.</span>\n    componentConfig.default || componentConfig\n  )\n&#125;)</code></pre>\n<p>Remember that <strong>global registration must take place before the root Vue instance is created (with <code>new Vue</code>)</strong>. <a href=\"https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js\" target=\"_blank\" rel=\"noopener\">Here’s an example</a> of this pattern in a real project context.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/global-vs-local-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Component Registration lesson\">Watch a free video lesson on Vue School</a></div>\n\n<h2 id=\"Component-Names\"><a href=\"#Component-Names\" class=\"headerlink\" title=\"Component Names\"></a>Component Names</h2><p>When registering a component, it will always be given a name. For example, in the global registration we’ve seen so far:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)</code></pre>\n<p>The component’s name is the first argument of <code>Vue.component</code>.</p>\n<p>The name you give a component may depend on where you intend to use it. When using a component directly in the DOM (as opposed to in a string template or <a href=\"single-file-components.html\">single-file component</a>), we strongly recommend following the <a href=\"https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\" target=\"_blank\" rel=\"noopener\">W3C rules</a> for custom tag names (all-lowercase, must contain a hyphen). This helps you avoid conflicts with current and future HTML elements.</p>\n<p>You can see other recommendations for component names in the <a href=\"../style-guide/#Base-component-names-strongly-recommended\">Style Guide</a>.</p>\n<h3 id=\"Name-Casing\"><a href=\"#Name-Casing\" class=\"headerlink\" title=\"Name Casing\"></a>Name Casing</h3><p>You have two options when defining component names:</p>\n<h4 id=\"With-kebab-case\"><a href=\"#With-kebab-case\" class=\"headerlink\" title=\"With kebab-case\"></a>With kebab-case</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)</code></pre>\n<p>When defining a component with kebab-case, you must also use kebab-case when referencing its custom element, such as in <code>&lt;my-component-name&gt;</code>.</p>\n<h4 id=\"With-PascalCase\"><a href=\"#With-PascalCase\" class=\"headerlink\" title=\"With PascalCase\"></a>With PascalCase</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'MyComponentName'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)</code></pre>\n<p>When defining a component with PascalCase, you can use either case when referencing its custom element. That means both <code>&lt;my-component-name&gt;</code> and <code>&lt;MyComponentName&gt;</code> are acceptable. Note, however, that only kebab-case names are valid directly in the DOM (i.e. non-string templates).</p>\n<h2 id=\"Global-Registration\"><a href=\"#Global-Registration\" class=\"headerlink\" title=\"Global Registration\"></a>Global Registration</h2><p>So far, we’ve only created components using <code>Vue.component</code>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123;\n  <span class=\"hljs-comment\">// ... options ...</span>\n&#125;)</code></pre>\n<p>These components are <strong>globally registered</strong>. That means they can be used in the template of any root Vue instance (<code>new Vue</code>) created after registration. For example:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'component-a'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\nVue.component(<span class=\"hljs-string\">'component-b'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\nVue.component(<span class=\"hljs-string\">'component-c'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span> &#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component-a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component-a</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component-b</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component-b</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component-c</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component-c</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>This even applies to all subcomponents, meaning all three of these components will also be available <em>inside each other</em>.</p>\n<h2 id=\"Local-Registration\"><a href=\"#Local-Registration\" class=\"headerlink\" title=\"Local Registration\"></a>Local Registration</h2><p>Global registration often isn’t ideal. For example, if you’re using a build system like Webpack, globally registering all components means that even if you stop using a component, it could still be included in your final build. This unnecessarily increases the amount of JavaScript your users have to download.</p>\n<p>In these cases, you can define your components as plain JavaScript objects:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> ComponentA = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> ComponentB = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> ComponentC = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;</code></pre>\n<p>Then define the components you’d like to use in a <code>components</code> option:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">components</span>: &#123;\n    <span class=\"hljs-string\">'component-a'</span>: ComponentA,\n    <span class=\"hljs-string\">'component-b'</span>: ComponentB\n  &#125;\n&#125;)</code></pre>\n<p>For each property in the <code>components</code> object, the key will be the name of the custom element, while the value will contain the options object for the component.</p>\n<p>Note that <strong>locally registered components are <em>not</em> also available in subcomponents</strong>. For example, if you wanted <code>ComponentA</code> to be available in <code>ComponentB</code>, you’d have to use:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> ComponentA = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n\n<span class=\"hljs-keyword\">var</span> ComponentB = &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    <span class=\"hljs-string\">'component-a'</span>: ComponentA\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>Or if you’re using ES2015 modules, such as through Babel and Webpack, that might look more like:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> ComponentA <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ComponentA.vue'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    ComponentA\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>Note that in ES2015+, placing a variable name like <code>ComponentA</code> inside an object is shorthand for <code>ComponentA: ComponentA</code>, meaning the name of the variable is both:</p>\n<ul>\n<li>the custom element name to use in the template, and</li>\n<li>the name of the variable containing the component options</li>\n</ul>\n<h2 id=\"Module-Systems\"><a href=\"#Module-Systems\" class=\"headerlink\" title=\"Module Systems\"></a>Module Systems</h2><p>If you’re not using a module system with <code>import</code>/<code>require</code>, you can probably skip this section for now. If you are, we have some special instructions and tips just for you.</p>\n<h3 id=\"Local-Registration-in-a-Module-System\"><a href=\"#Local-Registration-in-a-Module-System\" class=\"headerlink\" title=\"Local Registration in a Module System\"></a>Local Registration in a Module System</h3><p>If you’re still here, then it’s likely you’re using a module system, such as with Babel and Webpack. In these cases, we recommend creating a <code>components</code> directory, with each component in its own file.</p>\n<p>Then you’ll need to import each component you’d like to use, before you locally register it. For example, in a hypothetical <code>ComponentB.js</code> or <code>ComponentB.vue</code> file:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> ComponentA <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ComponentA'</span>\n<span class=\"hljs-keyword\">import</span> ComponentC <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./ComponentC'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    ComponentA,\n    ComponentC\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>Now both <code>ComponentA</code> and <code>ComponentC</code> can be used inside <code>ComponentB</code>‘s template.</p>\n<h3 id=\"Automatic-Global-Registration-of-Base-Components\"><a href=\"#Automatic-Global-Registration-of-Base-Components\" class=\"headerlink\" title=\"Automatic Global Registration of Base Components\"></a>Automatic Global Registration of Base Components</h3><p>Many of your components will be relatively generic, possibly only wrapping an element like an input or a button. We sometimes refer to these as <a href=\"../style-guide/#Base-component-names-strongly-recommended\">base components</a> and they tend to be used very frequently across your components.</p>\n<p>The result is that many components may include long lists of base components:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> BaseButton <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./BaseButton.vue'</span>\n<span class=\"hljs-keyword\">import</span> BaseIcon <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./BaseIcon.vue'</span>\n<span class=\"hljs-keyword\">import</span> BaseInput <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./BaseInput.vue'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">components</span>: &#123;\n    BaseButton,\n    BaseIcon,\n    BaseInput\n  &#125;\n&#125;</code></pre>\n<p>Just to support relatively little markup in a template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BaseInput</span>\n  <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"searchText\"</span>\n  @<span class=\"hljs-attr\">keydown.enter</span>=<span class=\"hljs-string\">\"search\"</span>\n/&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BaseButton</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"search\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">BaseIcon</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"search\"</span>/&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">BaseButton</span>&gt;</span></code></pre>\n<p>Fortunately, if you’re using Webpack (or <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">Vue CLI 3+</a>, which uses Webpack internally), you can use <code>require.context</code> to globally register only these very common base components. Here’s an example of the code you might use to globally import base components in your app’s entry file (e.g. <code>src/main.js</code>):</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> upperFirst <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash/upperFirst'</span>\n<span class=\"hljs-keyword\">import</span> camelCase <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'lodash/camelCase'</span>\n\n<span class=\"hljs-keyword\">const</span> requireComponent = <span class=\"hljs-built_in\">require</span>.context(\n  <span class=\"hljs-comment\">// The relative path of the components folder</span>\n  <span class=\"hljs-string\">'./components'</span>,\n  <span class=\"hljs-comment\">// Whether or not to look in subfolders</span>\n  <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-comment\">// The regular expression used to match base component filenames</span>\n  /Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">fileName</span> =&gt;</span> &#123;\n  <span class=\"hljs-comment\">// Get component config</span>\n  <span class=\"hljs-keyword\">const</span> componentConfig = requireComponent(fileName)\n\n  <span class=\"hljs-comment\">// Get PascalCase name of component</span>\n  <span class=\"hljs-keyword\">const</span> componentName = upperFirst(\n    camelCase(\n      <span class=\"hljs-comment\">// Gets the file name regardless of folder depth</span>\n      fileName\n        .split(<span class=\"hljs-string\">'/'</span>)\n        .pop()\n        .replace(<span class=\"hljs-regexp\">/\\.\\w+$/</span>, <span class=\"hljs-string\">''</span>)\n    )\n  )\n\n\n  <span class=\"hljs-comment\">// Register component globally</span>\n  Vue.component(\n    componentName,\n    <span class=\"hljs-comment\">// Look for the component options on `.default`, which will</span>\n    <span class=\"hljs-comment\">// exist if the component was exported with `export default`,</span>\n    <span class=\"hljs-comment\">// otherwise fall back to module's root.</span>\n    componentConfig.default || componentConfig\n  )\n&#125;)</code></pre>\n<p>Remember that <strong>global registration must take place before the root Vue instance is created (with <code>new Vue</code>)</strong>. <a href=\"https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js\" target=\"_blank\" rel=\"noopener\">Here’s an example</a> of this pattern in a real project context.</p>\n"},{"title":"Slots","type":"guide","order":104,"_content":"\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n> In 2.6.0, we introduced a new unified syntax (the `v-slot` directive) for named and scoped slots. It replaces the `slot` and `slot-scope` attributes, which are now deprecated, but have _not_ been removed and are still documented [here](#Deprecated-Syntax). The rationale for introducing the new syntax is described in this [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md).\n\n## Slot Content\n\nVue implements a content distribution API inspired by the [Web Components spec draft](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md), using the `<slot>` element to serve as distribution outlets for content.\n\nThis allows you to compose components like this:\n\n``` html\n<navigation-link url=\"/profile\">\n  Your Profile\n</navigation-link>\n```\n\nThen in the template for `<navigation-link>`, you might have:\n\n``` html\n<a\n  v-bind:href=\"url\"\n  class=\"nav-link\"\n>\n  <slot></slot>\n</a>\n```\n\nWhen the component renders, `<slot></slot>` will be replaced by \"Your Profile\". Slots can contain any template code, including HTML:\n\n``` html\n<navigation-link url=\"/profile\">\n  <!-- Add a Font Awesome icon -->\n  <span class=\"fa fa-user\"></span>\n  Your Profile\n</navigation-link>\n```\n\nOr even other components:\n\n``` html\n<navigation-link url=\"/profile\">\n  <!-- Use a component to add an icon -->\n  <font-awesome-icon name=\"user\"></font-awesome-icon>\n  Your Profile\n</navigation-link>\n```\n\nIf `<navigation-link>`'s template did **not** contain a `<slot>` element, any content provided between its opening and closing tag would be discarded.\n\n## Compilation Scope\n\nWhen you want to use data inside a slot, such as in:\n\n``` html\n<navigation-link url=\"/profile\">\n  Logged in as {{ user.name }}\n</navigation-link>\n```\n\nThat slot has access to the same instance properties (i.e. the same \"scope\") as the rest of the template. The slot does **not** have access to `<navigation-link>`'s scope. For example, trying to access `url` would not work:\n\n``` html\n<navigation-link url=\"/profile\">\n  Clicking here will send you to: {{ url }}\n  <!--\n  The `url` will be undefined, because this content is passed\n  _to_ <navigation-link>, rather than defined _inside_ the\n  <navigation-link> component.\n  -->\n</navigation-link>\n```\n\nAs a rule, remember that:\n\n> Everything in the parent template is compiled in parent scope; everything in the child template is compiled in the child scope.\n\n## Fallback Content\n\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a `<submit-button>` component:\n\n```html\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\nWe might want the text \"Submit\" to be rendered inside the `<button>` most of the time. To make \"Submit\" the fallback content, we can place it in between the `<slot>` tags:\n\n```html\n<button type=\"submit\">\n  <slot>Submit</slot>\n</button>\n```\n\nNow when we use `<submit-button>` in a parent component, providing no content for the slot:\n\n```html\n<submit-button></submit-button>\n```\n\nwill render the fallback content, \"Submit\":\n\n```html\n<button type=\"submit\">\n  Submit\n</button>\n```\n\nBut if we provide content:\n\n```html\n<submit-button>\n  Save\n</submit-button>\n```\n\nThen the provided content will be rendered instead:\n\n```html\n<button type=\"submit\">\n  Save\n</button>\n```\n\n## Named Slots\n\n> Updated in 2.6.0+. [See here](#Deprecated-Syntax) for the deprecated syntax using the `slot` attribute.\n\nThere are times when it's useful to have multiple slots. For example, in a `<base-layout>` component with the following template:\n\n``` html\n<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>\n```\n\nFor these cases, the `<slot>` element has a special attribute, `name`, which can be used to define additional slots:\n\n``` html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\nA `<slot>` outlet without `name` implicitly has the name \"default\".\n\nTo provide content to named slots, we can use the `v-slot` directive on a `<template>`, providing the name of the slot as `v-slot`'s argument:\n\n```html\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nNow everything inside the `<template>` elements will be passed to the corresponding slots. Any content not wrapped in a `<template>` using `v-slot` is assumed to be for the default slot.\n\nHowever, you can still wrap default slot content in a `<template>` if you wish to be explicit:\n\n```html\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template v-slot:default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nEither way, the rendered HTML will be:\n\n``` html\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\nNote that **`v-slot` can only be added to a `<template>`** (with [one exception](#Abbreviated-Syntax-for-Lone-Default-Slots)), unlike the deprecated [`slot` attribute](#Deprecated-Syntax).\n\n## Scoped Slots\n\n> Updated in 2.6.0+. [See here](#Deprecated-Syntax) for the deprecated syntax using the `slot-scope` attribute.\n\nSometimes, it's useful for slot content to have access to data only available in the child component. For example, imagine a `<current-user>` component with the following template:\n\n```html\n<span>\n  <slot>{{ user.lastName }}</slot>\n</span>\n```\n\nWe might want to replace this fallback content to display the user's first name, instead of last, like this:\n\n``` html\n<current-user>\n  {{ user.firstName }}\n</current-user>\n```\n\nThat won't work, however, because only the `<current-user>` component has access to the `user` and the content we're providing is rendered in the parent.\n\nTo make `user` available to the slot content in the parent, we can bind `user` as an attribute to the `<slot>` element:\n\n``` html\n<span>\n  <slot v-bind:user=\"user\">\n    {{ user.lastName }}\n  </slot>\n</span>\n```\n\nAttributes bound to a `<slot>` element are called **slot props**. Now, in the parent scope, we can use `v-slot` with a value to define a name for the slot props we've been provided:\n\n``` html\n<current-user>\n  <template v-slot:default=\"slotProps\">\n    {{ slotProps.user.firstName }}\n  </template>\n</current-user>\n```\n\nIn this example, we've chosen to name the object containing all our slot props `slotProps`, but you can use any name you like.\n\n### Abbreviated Syntax for Lone Default Slots\n\nIn cases like above, when _only_ the default slot is provided content, the component's tags can be used as the slot's template. This allows us to use `v-slot` directly on the component:\n\n``` html\n<current-user v-slot:default=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\nThis can be shortened even further. Just as non-specified content is assumed to be for the default slot, `v-slot` without an argument is assumed to refer to the default slot:\n\n``` html\n<current-user v-slot=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\nNote that the abbreviated syntax for default slot **cannot** be mixed with named slots, as it would lead to scope ambiguity:\n\n``` html\n<!-- INVALID, will result in warning -->\n<current-user v-slot=\"slotProps\">\n  {{ slotProps.user.firstName }}\n  <template v-slot:other=\"otherSlotProps\">\n    slotProps is NOT available here\n  </template>\n</current-user>\n```\n\nWhenever there are multiple slots, use the full `<template>` based syntax for _all_ slots:\n\n``` html\n<current-user>\n  <template v-slot:default=\"slotProps\">\n    {{ slotProps.user.firstName }}\n  </template>\n\n  <template v-slot:other=\"otherSlotProps\">\n    ...\n  </template>\n</current-user>\n```\n\n### Destructuring Slot Props\n\nInternally, scoped slots work by wrapping your slot content in a function passed a single argument:\n\n```js\nfunction (slotProps) {\n  // ... slot content ...\n}\n```\n\nThat means the value of `v-slot` can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments ([single-file components](single-file-components.html) or [modern browsers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility)), you can also use [ES2015 destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring) to pull out specific slot props, like so:\n\n``` html\n<current-user v-slot=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\nThis can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. `user` to `person`:\n\n``` html\n<current-user v-slot=\"{ user: person }\">\n  {{ person.firstName }}\n</current-user>\n```\n\nYou can even define fallbacks, to be used in case a slot prop is undefined:\n\n``` html\n<current-user v-slot=\"{ user = { firstName: 'Guest' } }\">\n  {{ user.firstName }}\n</current-user>\n```\n\n## Dynamic Slot Names\n\n> New in 2.6.0+\n\n[Dynamic directive arguments](syntax.html#Dynamic-Arguments) also work on `v-slot`, allowing the definition of dynamic slot names:\n\n``` html\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\n## Named Slots Shorthand\n\n> New in 2.6.0+\n\nSimilar to `v-on` and `v-bind`, `v-slot` also has a shorthand, replacing everything before the argument (`v-slot:`) with the special symbol `#`. For example, `v-slot:header` can be rewritten as `#header`:\n\n```html\n<base-layout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nHowever, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:\n\n``` html\n<!-- This will trigger a warning -->\n<current-user #=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\nInstead, you must always specify the name of the slot if you wish to use the shorthand:\n\n``` html\n<current-user #default=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\n## Other Examples\n\n**Slot props allow us to turn slots into reusable templates that can render different content based on input props.** This is most useful when you are designing a reusable component that encapsulates data logic while allowing the consuming parent component to customize part of its layout.\n\nFor example, we are implementing a `<todo-list>` component that contains the layout and filtering logic for a list:\n\n```html\n<ul>\n  <li\n    v-for=\"todo in filteredTodos\"\n    v-bind:key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n\nInstead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding `todo` as a slot prop:\n\n```html\n<ul>\n  <li\n    v-for=\"todo in filteredTodos\"\n    v-bind:key=\"todo.id\"\n  >\n    <!--\n    We have a slot for each todo, passing it the\n    `todo` object as a slot prop.\n    -->\n    <slot name=\"todo\" v-bind:todo=\"todo\">\n      <!-- Fallback content -->\n      {{ todo.text }}\n    </slot>\n  </li>\n</ul>\n```\n\nNow when we use the `<todo-list>` component, we can optionally define an alternative `<template>` for todo items, but with access to data from the child:\n\n```html\n<todo-list v-bind:todos=\"todos\">\n  <template v-slot:todo=\"{ todo }\">\n    <span v-if=\"todo.isComplete\">✓</span>\n    {{ todo.text }}\n  </template>\n</todo-list>\n```\n\nHowever, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as [Vue Virtual Scroller](https://github.com/Akryum/vue-virtual-scroller), [Vue Promised](https://github.com/posva/vue-promised), and [Portal Vue](https://github.com/LinusBorg/portal-vue).\n\n## Deprecated Syntax\n\n> The `v-slot` directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported `slot` and `slot-scope` attributes. The full rationale for introducing `v-slot` is described in this [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md). The `slot` and `slot-scope` attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.\n\n### Named Slots with the `slot` Attribute\n\n> <abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See [here](#Named-Slots) for the new, recommended syntax.\n\nTo pass content to named slots from the parent, use the special `slot` attribute on `<template>` (using the `<base-layout>` component described [here](#Named-Slots) as example):\n\n```html\n<base-layout>\n  <template slot=\"header\">\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template slot=\"footer\">\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nOr, the `slot` attribute can also be used directly on a normal element:\n\n``` html\n<base-layout>\n  <h1 slot=\"header\">Here might be a page title</h1>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <p slot=\"footer\">Here's some contact info</p>\n</base-layout>\n```\n\nThere can still be one unnamed slot, which is the **default slot** that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:\n\n``` html\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\n### Scoped Slots with the `slot-scope` Attribute\n\n> <abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See [here](#Scoped-Slots) for the new, recommended syntax.\n\nTo receive props passed to a slot, the parent component can use `<template>` with the `slot-scope` attribute (using the `<slot-example>` described [here](#Scoped-Slots) as example):\n\n``` html\n<slot-example>\n  <template slot=\"default\" slot-scope=\"slotProps\">\n    {{ slotProps.msg }}\n  </template>\n</slot-example>\n```\n\nHere, `slot-scope` declares the received props object as the `slotProps` variable, and makes it available inside the `<template>` scope. You can name `slotProps` anything you like similar to naming function arguments in JavaScript.\n\nHere `slot=\"default\"` can be omitted as it is implied:\n\n``` html\n<slot-example>\n  <template slot-scope=\"slotProps\">\n    {{ slotProps.msg }}\n  </template>\n</slot-example>\n```\n\nThe `slot-scope` attribute can also be used directly on a non-`<template>` element (including components):\n\n``` html\n<slot-example>\n  <span slot-scope=\"slotProps\">\n    {{ slotProps.msg }}\n  </span>\n</slot-example>\n```\n\nThe value of `slot-scope` can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments ([single-file components](single-file-components.html) or [modern browsers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility)) you can also use [ES2015 destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring) in the expression, like so:\n\n``` html\n<slot-example>\n  <span slot-scope=\"{ msg }\">\n    {{ msg }}\n  </span>\n</slot-example>\n```\n\nUsing the `<todo-list>` described [here](#Other-Examples) as an example, here's the equivalent usage using `slot-scope`:\n\n``` html\n<todo-list v-bind:todos=\"todos\">\n  <template slot=\"todo\" slot-scope=\"{ todo }\">\n    <span v-if=\"todo.isComplete\">✓</span>\n    {{ todo.text }}\n  </template>\n</todo-list>\n```\n","source":"v2/guide/components-slots.md","raw":"---\ntitle: Slots\ntype: guide\norder: 104\n---\n\n> This page assumes you've already read the [Components Basics](components.html). Read that first if you are new to components.\n\n> In 2.6.0, we introduced a new unified syntax (the `v-slot` directive) for named and scoped slots. It replaces the `slot` and `slot-scope` attributes, which are now deprecated, but have _not_ been removed and are still documented [here](#Deprecated-Syntax). The rationale for introducing the new syntax is described in this [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md).\n\n## Slot Content\n\nVue implements a content distribution API inspired by the [Web Components spec draft](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md), using the `<slot>` element to serve as distribution outlets for content.\n\nThis allows you to compose components like this:\n\n``` html\n<navigation-link url=\"/profile\">\n  Your Profile\n</navigation-link>\n```\n\nThen in the template for `<navigation-link>`, you might have:\n\n``` html\n<a\n  v-bind:href=\"url\"\n  class=\"nav-link\"\n>\n  <slot></slot>\n</a>\n```\n\nWhen the component renders, `<slot></slot>` will be replaced by \"Your Profile\". Slots can contain any template code, including HTML:\n\n``` html\n<navigation-link url=\"/profile\">\n  <!-- Add a Font Awesome icon -->\n  <span class=\"fa fa-user\"></span>\n  Your Profile\n</navigation-link>\n```\n\nOr even other components:\n\n``` html\n<navigation-link url=\"/profile\">\n  <!-- Use a component to add an icon -->\n  <font-awesome-icon name=\"user\"></font-awesome-icon>\n  Your Profile\n</navigation-link>\n```\n\nIf `<navigation-link>`'s template did **not** contain a `<slot>` element, any content provided between its opening and closing tag would be discarded.\n\n## Compilation Scope\n\nWhen you want to use data inside a slot, such as in:\n\n``` html\n<navigation-link url=\"/profile\">\n  Logged in as {{ user.name }}\n</navigation-link>\n```\n\nThat slot has access to the same instance properties (i.e. the same \"scope\") as the rest of the template. The slot does **not** have access to `<navigation-link>`'s scope. For example, trying to access `url` would not work:\n\n``` html\n<navigation-link url=\"/profile\">\n  Clicking here will send you to: {{ url }}\n  <!--\n  The `url` will be undefined, because this content is passed\n  _to_ <navigation-link>, rather than defined _inside_ the\n  <navigation-link> component.\n  -->\n</navigation-link>\n```\n\nAs a rule, remember that:\n\n> Everything in the parent template is compiled in parent scope; everything in the child template is compiled in the child scope.\n\n## Fallback Content\n\nThere are cases when it's useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a `<submit-button>` component:\n\n```html\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\nWe might want the text \"Submit\" to be rendered inside the `<button>` most of the time. To make \"Submit\" the fallback content, we can place it in between the `<slot>` tags:\n\n```html\n<button type=\"submit\">\n  <slot>Submit</slot>\n</button>\n```\n\nNow when we use `<submit-button>` in a parent component, providing no content for the slot:\n\n```html\n<submit-button></submit-button>\n```\n\nwill render the fallback content, \"Submit\":\n\n```html\n<button type=\"submit\">\n  Submit\n</button>\n```\n\nBut if we provide content:\n\n```html\n<submit-button>\n  Save\n</submit-button>\n```\n\nThen the provided content will be rendered instead:\n\n```html\n<button type=\"submit\">\n  Save\n</button>\n```\n\n## Named Slots\n\n> Updated in 2.6.0+. [See here](#Deprecated-Syntax) for the deprecated syntax using the `slot` attribute.\n\nThere are times when it's useful to have multiple slots. For example, in a `<base-layout>` component with the following template:\n\n``` html\n<div class=\"container\">\n  <header>\n    <!-- We want header content here -->\n  </header>\n  <main>\n    <!-- We want main content here -->\n  </main>\n  <footer>\n    <!-- We want footer content here -->\n  </footer>\n</div>\n```\n\nFor these cases, the `<slot>` element has a special attribute, `name`, which can be used to define additional slots:\n\n``` html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\nA `<slot>` outlet without `name` implicitly has the name \"default\".\n\nTo provide content to named slots, we can use the `v-slot` directive on a `<template>`, providing the name of the slot as `v-slot`'s argument:\n\n```html\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nNow everything inside the `<template>` elements will be passed to the corresponding slots. Any content not wrapped in a `<template>` using `v-slot` is assumed to be for the default slot.\n\nHowever, you can still wrap default slot content in a `<template>` if you wish to be explicit:\n\n```html\n<base-layout>\n  <template v-slot:header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <template v-slot:default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template v-slot:footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nEither way, the rendered HTML will be:\n\n``` html\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\nNote that **`v-slot` can only be added to a `<template>`** (with [one exception](#Abbreviated-Syntax-for-Lone-Default-Slots)), unlike the deprecated [`slot` attribute](#Deprecated-Syntax).\n\n## Scoped Slots\n\n> Updated in 2.6.0+. [See here](#Deprecated-Syntax) for the deprecated syntax using the `slot-scope` attribute.\n\nSometimes, it's useful for slot content to have access to data only available in the child component. For example, imagine a `<current-user>` component with the following template:\n\n```html\n<span>\n  <slot>{{ user.lastName }}</slot>\n</span>\n```\n\nWe might want to replace this fallback content to display the user's first name, instead of last, like this:\n\n``` html\n<current-user>\n  {{ user.firstName }}\n</current-user>\n```\n\nThat won't work, however, because only the `<current-user>` component has access to the `user` and the content we're providing is rendered in the parent.\n\nTo make `user` available to the slot content in the parent, we can bind `user` as an attribute to the `<slot>` element:\n\n``` html\n<span>\n  <slot v-bind:user=\"user\">\n    {{ user.lastName }}\n  </slot>\n</span>\n```\n\nAttributes bound to a `<slot>` element are called **slot props**. Now, in the parent scope, we can use `v-slot` with a value to define a name for the slot props we've been provided:\n\n``` html\n<current-user>\n  <template v-slot:default=\"slotProps\">\n    {{ slotProps.user.firstName }}\n  </template>\n</current-user>\n```\n\nIn this example, we've chosen to name the object containing all our slot props `slotProps`, but you can use any name you like.\n\n### Abbreviated Syntax for Lone Default Slots\n\nIn cases like above, when _only_ the default slot is provided content, the component's tags can be used as the slot's template. This allows us to use `v-slot` directly on the component:\n\n``` html\n<current-user v-slot:default=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\nThis can be shortened even further. Just as non-specified content is assumed to be for the default slot, `v-slot` without an argument is assumed to refer to the default slot:\n\n``` html\n<current-user v-slot=\"slotProps\">\n  {{ slotProps.user.firstName }}\n</current-user>\n```\n\nNote that the abbreviated syntax for default slot **cannot** be mixed with named slots, as it would lead to scope ambiguity:\n\n``` html\n<!-- INVALID, will result in warning -->\n<current-user v-slot=\"slotProps\">\n  {{ slotProps.user.firstName }}\n  <template v-slot:other=\"otherSlotProps\">\n    slotProps is NOT available here\n  </template>\n</current-user>\n```\n\nWhenever there are multiple slots, use the full `<template>` based syntax for _all_ slots:\n\n``` html\n<current-user>\n  <template v-slot:default=\"slotProps\">\n    {{ slotProps.user.firstName }}\n  </template>\n\n  <template v-slot:other=\"otherSlotProps\">\n    ...\n  </template>\n</current-user>\n```\n\n### Destructuring Slot Props\n\nInternally, scoped slots work by wrapping your slot content in a function passed a single argument:\n\n```js\nfunction (slotProps) {\n  // ... slot content ...\n}\n```\n\nThat means the value of `v-slot` can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments ([single-file components](single-file-components.html) or [modern browsers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility)), you can also use [ES2015 destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring) to pull out specific slot props, like so:\n\n``` html\n<current-user v-slot=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\nThis can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. `user` to `person`:\n\n``` html\n<current-user v-slot=\"{ user: person }\">\n  {{ person.firstName }}\n</current-user>\n```\n\nYou can even define fallbacks, to be used in case a slot prop is undefined:\n\n``` html\n<current-user v-slot=\"{ user = { firstName: 'Guest' } }\">\n  {{ user.firstName }}\n</current-user>\n```\n\n## Dynamic Slot Names\n\n> New in 2.6.0+\n\n[Dynamic directive arguments](syntax.html#Dynamic-Arguments) also work on `v-slot`, allowing the definition of dynamic slot names:\n\n``` html\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\n## Named Slots Shorthand\n\n> New in 2.6.0+\n\nSimilar to `v-on` and `v-bind`, `v-slot` also has a shorthand, replacing everything before the argument (`v-slot:`) with the special symbol `#`. For example, `v-slot:header` can be rewritten as `#header`:\n\n```html\n<base-layout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template #footer>\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nHowever, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:\n\n``` html\n<!-- This will trigger a warning -->\n<current-user #=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\nInstead, you must always specify the name of the slot if you wish to use the shorthand:\n\n``` html\n<current-user #default=\"{ user }\">\n  {{ user.firstName }}\n</current-user>\n```\n\n## Other Examples\n\n**Slot props allow us to turn slots into reusable templates that can render different content based on input props.** This is most useful when you are designing a reusable component that encapsulates data logic while allowing the consuming parent component to customize part of its layout.\n\nFor example, we are implementing a `<todo-list>` component that contains the layout and filtering logic for a list:\n\n```html\n<ul>\n  <li\n    v-for=\"todo in filteredTodos\"\n    v-bind:key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n\nInstead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding `todo` as a slot prop:\n\n```html\n<ul>\n  <li\n    v-for=\"todo in filteredTodos\"\n    v-bind:key=\"todo.id\"\n  >\n    <!--\n    We have a slot for each todo, passing it the\n    `todo` object as a slot prop.\n    -->\n    <slot name=\"todo\" v-bind:todo=\"todo\">\n      <!-- Fallback content -->\n      {{ todo.text }}\n    </slot>\n  </li>\n</ul>\n```\n\nNow when we use the `<todo-list>` component, we can optionally define an alternative `<template>` for todo items, but with access to data from the child:\n\n```html\n<todo-list v-bind:todos=\"todos\">\n  <template v-slot:todo=\"{ todo }\">\n    <span v-if=\"todo.isComplete\">✓</span>\n    {{ todo.text }}\n  </template>\n</todo-list>\n```\n\nHowever, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as [Vue Virtual Scroller](https://github.com/Akryum/vue-virtual-scroller), [Vue Promised](https://github.com/posva/vue-promised), and [Portal Vue](https://github.com/LinusBorg/portal-vue).\n\n## Deprecated Syntax\n\n> The `v-slot` directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported `slot` and `slot-scope` attributes. The full rationale for introducing `v-slot` is described in this [RFC](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md). The `slot` and `slot-scope` attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.\n\n### Named Slots with the `slot` Attribute\n\n> <abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See [here](#Named-Slots) for the new, recommended syntax.\n\nTo pass content to named slots from the parent, use the special `slot` attribute on `<template>` (using the `<base-layout>` component described [here](#Named-Slots) as example):\n\n```html\n<base-layout>\n  <template slot=\"header\">\n    <h1>Here might be a page title</h1>\n  </template>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <template slot=\"footer\">\n    <p>Here's some contact info</p>\n  </template>\n</base-layout>\n```\n\nOr, the `slot` attribute can also be used directly on a normal element:\n\n``` html\n<base-layout>\n  <h1 slot=\"header\">Here might be a page title</h1>\n\n  <p>A paragraph for the main content.</p>\n  <p>And another one.</p>\n\n  <p slot=\"footer\">Here's some contact info</p>\n</base-layout>\n```\n\nThere can still be one unnamed slot, which is the **default slot** that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:\n\n``` html\n<div class=\"container\">\n  <header>\n    <h1>Here might be a page title</h1>\n  </header>\n  <main>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </main>\n  <footer>\n    <p>Here's some contact info</p>\n  </footer>\n</div>\n```\n\n### Scoped Slots with the `slot-scope` Attribute\n\n> <abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See [here](#Scoped-Slots) for the new, recommended syntax.\n\nTo receive props passed to a slot, the parent component can use `<template>` with the `slot-scope` attribute (using the `<slot-example>` described [here](#Scoped-Slots) as example):\n\n``` html\n<slot-example>\n  <template slot=\"default\" slot-scope=\"slotProps\">\n    {{ slotProps.msg }}\n  </template>\n</slot-example>\n```\n\nHere, `slot-scope` declares the received props object as the `slotProps` variable, and makes it available inside the `<template>` scope. You can name `slotProps` anything you like similar to naming function arguments in JavaScript.\n\nHere `slot=\"default\"` can be omitted as it is implied:\n\n``` html\n<slot-example>\n  <template slot-scope=\"slotProps\">\n    {{ slotProps.msg }}\n  </template>\n</slot-example>\n```\n\nThe `slot-scope` attribute can also be used directly on a non-`<template>` element (including components):\n\n``` html\n<slot-example>\n  <span slot-scope=\"slotProps\">\n    {{ slotProps.msg }}\n  </span>\n</slot-example>\n```\n\nThe value of `slot-scope` can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments ([single-file components](single-file-components.html) or [modern browsers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility)) you can also use [ES2015 destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring) in the expression, like so:\n\n``` html\n<slot-example>\n  <span slot-scope=\"{ msg }\">\n    {{ msg }}\n  </span>\n</slot-example>\n```\n\nUsing the `<todo-list>` described [here](#Other-Examples) as an example, here's the equivalent usage using `slot-scope`:\n\n``` html\n<todo-list v-bind:todos=\"todos\">\n  <template slot=\"todo\" slot-scope=\"{ todo }\">\n    <span v-if=\"todo.isComplete\">✓</span>\n    {{ todo.text }}\n  </template>\n</todo-list>\n```\n","date":"2020-09-25T23:55:41.135Z","updated":"2020-09-25T23:55:41.135Z","path":"v2/guide/components-slots.html","comments":1,"layout":"page","_id":"ckfl66gyj001zc2v5m03yud48","content":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<blockquote>\n<p>In 2.6.0, we introduced a new unified syntax (the <code>v-slot</code> directive) for named and scoped slots. It replaces the <code>slot</code> and <code>slot-scope</code> attributes, which are now deprecated, but have <em>not</em> been removed and are still documented <a href=\"#Deprecated-Syntax\">here</a>. The rationale for introducing the new syntax is described in this <a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC</a>.</p>\n</blockquote>\n<h2 id=\"Slot-Content\"><a href=\"#Slot-Content\" class=\"headerlink\" title=\"Slot Content\"></a>Slot Content</h2><p>Vue implements a content distribution API inspired by the <a href=\"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\" target=\"_blank\" rel=\"noopener\">Web Components spec draft</a>, using the <code>&lt;slot&gt;</code> element to serve as distribution outlets for content.</p>\n<p>This allows you to compose components like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  Your Profile\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>Then in the template for <code>&lt;navigation-link&gt;</code>, you might have:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>\n  <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>\n  <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"nav-link\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>When the component renders, <code>&lt;slot&gt;&lt;/slot&gt;</code> will be replaced by “Your Profile”. Slots can contain any template code, including HTML:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Add a Font Awesome icon --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"fa fa-user\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  Your Profile\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>Or even other components:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Use a component to add an icon --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font-awesome-icon</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"user\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font-awesome-icon</span>&gt;</span>\n  Your Profile\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>If <code>&lt;navigation-link&gt;</code>‘s template did <strong>not</strong> contain a <code>&lt;slot&gt;</code> element, any content provided between its opening and closing tag would be discarded.</p>\n<h2 id=\"Compilation-Scope\"><a href=\"#Compilation-Scope\" class=\"headerlink\" title=\"Compilation Scope\"></a>Compilation Scope</h2><p>When you want to use data inside a slot, such as in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  Logged in as &#123;&#123; user.name &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>That slot has access to the same instance properties (i.e. the same “scope”) as the rest of the template. The slot does <strong>not</strong> have access to <code>&lt;navigation-link&gt;</code>‘s scope. For example, trying to access <code>url</code> would not work:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  Clicking here will send you to: &#123;&#123; url &#125;&#125;\n  <span class=\"hljs-comment\">&lt;!--\n  The `url` will be undefined, because this content is passed\n  _to_ &lt;navigation-link&gt;, rather than defined _inside_ the\n  &lt;navigation-link&gt; component.\n  --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>As a rule, remember that:</p>\n<blockquote>\n<p>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in the child scope.</p>\n</blockquote>\n<h2 id=\"Fallback-Content\"><a href=\"#Fallback-Content\" class=\"headerlink\" title=\"Fallback Content\"></a>Fallback Content</h2><p>There are cases when it’s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a <code>&lt;submit-button&gt;</code> component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>We might want the text “Submit” to be rendered inside the <code>&lt;button&gt;</code> most of the time. To make “Submit” the fallback content, we can place it in between the <code>&lt;slot&gt;</code> tags:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Now when we use <code>&lt;submit-button&gt;</code> in a parent component, providing no content for the slot:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">submit-button</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">submit-button</span>&gt;</span></code></pre>\n<p>will render the fallback content, “Submit”:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  Submit\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>But if we provide content:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">submit-button</span>&gt;</span>\n  Save\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">submit-button</span>&gt;</span></code></pre>\n<p>Then the provided content will be rendered instead:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  Save\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<h2 id=\"Named-Slots\"><a href=\"#Named-Slots\" class=\"headerlink\" title=\"Named Slots\"></a>Named Slots</h2><blockquote>\n<p>Updated in 2.6.0+. <a href=\"#Deprecated-Syntax\">See here</a> for the deprecated syntax using the <code>slot</code> attribute.</p>\n</blockquote>\n<p>There are times when it’s useful to have multiple slots. For example, in a <code>&lt;base-layout&gt;</code> component with the following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- We want header content here --&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- We want main content here --&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- We want footer content here --&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>For these cases, the <code>&lt;slot&gt;</code> element has a special attribute, <code>name</code>, which can be used to define additional slots:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"header\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>A <code>&lt;slot&gt;</code> outlet without <code>name</code> implicitly has the name “default”.</p>\n<p>To provide content to named slots, we can use the <code>v-slot</code> directive on a <code>&lt;template&gt;</code>, providing the name of the slot as <code>v-slot</code>‘s argument:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>Now everything inside the <code>&lt;template&gt;</code> elements will be passed to the corresponding slots. Any content not wrapped in a <code>&lt;template&gt;</code> using <code>v-slot</code> is assumed to be for the default slot.</p>\n<p>However, you can still wrap default slot content in a <code>&lt;template&gt;</code> if you wish to be explicit:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:default</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>Either way, the rendered HTML will be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Note that <strong><code>v-slot</code> can only be added to a <code>&lt;template&gt;</code></strong> (with <a href=\"#Abbreviated-Syntax-for-Lone-Default-Slots\">one exception</a>), unlike the deprecated <a href=\"#Deprecated-Syntax\"><code>slot</code> attribute</a>.</p>\n<h2 id=\"Scoped-Slots\"><a href=\"#Scoped-Slots\" class=\"headerlink\" title=\"Scoped Slots\"></a>Scoped Slots</h2><blockquote>\n<p>Updated in 2.6.0+. <a href=\"#Deprecated-Syntax\">See here</a> for the deprecated syntax using the <code>slot-scope</code> attribute.</p>\n</blockquote>\n<p>Sometimes, it’s useful for slot content to have access to data only available in the child component. For example, imagine a <code>&lt;current-user&gt;</code> component with the following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span>&#123;&#123; user.lastName &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<p>We might want to replace this fallback content to display the user’s first name, instead of last, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>That won’t work, however, because only the <code>&lt;current-user&gt;</code> component has access to the <code>user</code> and the content we’re providing is rendered in the parent.</p>\n<p>To make <code>user</code> available to the slot content in the parent, we can bind <code>user</code> as an attribute to the <code>&lt;slot&gt;</code> element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">v-bind:user</span>=<span class=\"hljs-string\">\"user\"</span>&gt;</span>\n    &#123;&#123; user.lastName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<p>Attributes bound to a <code>&lt;slot&gt;</code> element are called <strong>slot props</strong>. Now, in the parent scope, we can use <code>v-slot</code> with a value to define a name for the slot props we’ve been provided:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:default</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.user.firstName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>In this example, we’ve chosen to name the object containing all our slot props <code>slotProps</code>, but you can use any name you like.</p>\n<h3 id=\"Abbreviated-Syntax-for-Lone-Default-Slots\"><a href=\"#Abbreviated-Syntax-for-Lone-Default-Slots\" class=\"headerlink\" title=\"Abbreviated Syntax for Lone Default Slots\"></a>Abbreviated Syntax for Lone Default Slots</h3><p>In cases like above, when <em>only</em> the default slot is provided content, the component’s tags can be used as the slot’s template. This allows us to use <code>v-slot</code> directly on the component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot:default</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n  &#123;&#123; slotProps.user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>This can be shortened even further. Just as non-specified content is assumed to be for the default slot, <code>v-slot</code> without an argument is assumed to refer to the default slot:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n  &#123;&#123; slotProps.user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>Note that the abbreviated syntax for default slot <strong>cannot</strong> be mixed with named slots, as it would lead to scope ambiguity:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- INVALID, will result in warning --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n  &#123;&#123; slotProps.user.firstName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:other</span>=<span class=\"hljs-string\">\"otherSlotProps\"</span>&gt;</span>\n    slotProps is NOT available here\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>Whenever there are multiple slots, use the full <code>&lt;template&gt;</code> based syntax for <em>all</em> slots:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:default</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.user.firstName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:other</span>=<span class=\"hljs-string\">\"otherSlotProps\"</span>&gt;</span>\n    ...\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<h3 id=\"Destructuring-Slot-Props\"><a href=\"#Destructuring-Slot-Props\" class=\"headerlink\" title=\"Destructuring Slot Props\"></a>Destructuring Slot Props</h3><p>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">slotProps</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ... slot content ...</span>\n&#125;</code></pre>\n<p>That means the value of <code>v-slot</code> can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (<a href=\"single-file-components.html\">single-file components</a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility\" target=\"_blank\" rel=\"noopener\">modern browsers</a>), you can also use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\" target=\"_blank\" rel=\"noopener\">ES2015 destructuring</a> to pull out specific slot props, like so:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; user &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>This can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. <code>user</code> to <code>person</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; user: person &#125;\"</span>&gt;</span>\n  &#123;&#123; person.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>You can even define fallbacks, to be used in case a slot prop is undefined:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; user = &#123; firstName: 'Guest' &#125; &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<h2 id=\"Dynamic-Slot-Names\"><a href=\"#Dynamic-Slot-Names\" class=\"headerlink\" title=\"Dynamic Slot Names\"></a>Dynamic Slot Names</h2><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<p><a href=\"syntax.html#Dynamic-Arguments\">Dynamic directive arguments</a> also work on <code>v-slot</code>, allowing the definition of dynamic slot names:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:</span>[<span class=\"hljs-attr\">dynamicSlotName</span>]&gt;</span>\n    ...\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<h2 id=\"Named-Slots-Shorthand\"><a href=\"#Named-Slots-Shorthand\" class=\"headerlink\" title=\"Named Slots Shorthand\"></a>Named Slots Shorthand</h2><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<p>Similar to <code>v-on</code> and <code>v-bind</code>, <code>v-slot</code> also has a shorthand, replacing everything before the argument (<code>v-slot:</code>) with the special symbol <code>#</code>. For example, <code>v-slot:header</code> can be rewritten as <code>#header</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- This will trigger a warning --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> #=<span class=\"hljs-string\">\"&#123; user &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>Instead, you must always specify the name of the slot if you wish to use the shorthand:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> #<span class=\"hljs-attr\">default</span>=<span class=\"hljs-string\">\"&#123; user &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<h2 id=\"Other-Examples\"><a href=\"#Other-Examples\" class=\"headerlink\" title=\"Other Examples\"></a>Other Examples</h2><p><strong>Slot props allow us to turn slots into reusable templates that can render different content based on input props.</strong> This is most useful when you are designing a reusable component that encapsulates data logic while allowing the consuming parent component to customize part of its layout.</p>\n<p>For example, we are implementing a <code>&lt;todo-list&gt;</code> component that contains the layout and filtering logic for a list:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in filteredTodos\"</span>\n    <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding <code>todo</code> as a slot prop:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in filteredTodos\"</span>\n    <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    <span class=\"hljs-comment\">&lt;!--\n    We have a slot for each todo, passing it the\n    `todo` object as a slot prop.\n    --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"todo\"</span> <span class=\"hljs-attr\">v-bind:todo</span>=<span class=\"hljs-string\">\"todo\"</span>&gt;</span>\n      <span class=\"hljs-comment\">&lt;!-- Fallback content --&gt;</span>\n      &#123;&#123; todo.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>Now when we use the <code>&lt;todo-list&gt;</code> component, we can optionally define an alternative <code>&lt;template&gt;</code> for todo items, but with access to data from the child:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">todo-list</span> <span class=\"hljs-attr\">v-bind:todos</span>=<span class=\"hljs-string\">\"todos\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:todo</span>=<span class=\"hljs-string\">\"&#123; todo &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"todo.isComplete\"</span>&gt;</span>✓<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">todo-list</span>&gt;</span></code></pre>\n<p>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as <a href=\"https://github.com/Akryum/vue-virtual-scroller\" target=\"_blank\" rel=\"noopener\">Vue Virtual Scroller</a>, <a href=\"https://github.com/posva/vue-promised\" target=\"_blank\" rel=\"noopener\">Vue Promised</a>, and <a href=\"https://github.com/LinusBorg/portal-vue\" target=\"_blank\" rel=\"noopener\">Portal Vue</a>.</p>\n<h2 id=\"Deprecated-Syntax\"><a href=\"#Deprecated-Syntax\" class=\"headerlink\" title=\"Deprecated Syntax\"></a>Deprecated Syntax</h2><blockquote>\n<p>The <code>v-slot</code> directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported <code>slot</code> and <code>slot-scope</code> attributes. The full rationale for introducing <code>v-slot</code> is described in this <a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC</a>. The <code>slot</code> and <code>slot-scope</code> attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.</p>\n</blockquote>\n<h3 id=\"Named-Slots-with-the-slot-Attribute\"><a href=\"#Named-Slots-with-the-slot-Attribute\" class=\"headerlink\" title=\"Named Slots with the slot Attribute\"></a>Named Slots with the <code>slot</code> Attribute</h3><blockquote>\n<p><abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See <a href=\"#Named-Slots\">here</a> for the new, recommended syntax.</p>\n</blockquote>\n<p>To pass content to named slots from the parent, use the special <code>slot</code> attribute on <code>&lt;template&gt;</code> (using the <code>&lt;base-layout&gt;</code> component described <a href=\"#Named-Slots\">here</a> as example):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"header\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>Or, the <code>slot</code> attribute can also be used directly on a normal element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"header\"</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>There can still be one unnamed slot, which is the <strong>default slot</strong> that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h3 id=\"Scoped-Slots-with-the-slot-scope-Attribute\"><a href=\"#Scoped-Slots-with-the-slot-scope-Attribute\" class=\"headerlink\" title=\"Scoped Slots with the slot-scope Attribute\"></a>Scoped Slots with the <code>slot-scope</code> Attribute</h3><blockquote>\n<p><abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See <a href=\"#Scoped-Slots\">here</a> for the new, recommended syntax.</p>\n</blockquote>\n<p>To receive props passed to a slot, the parent component can use <code>&lt;template&gt;</code> with the <code>slot-scope</code> attribute (using the <code>&lt;slot-example&gt;</code> described <a href=\"#Scoped-Slots\">here</a> as example):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"default\"</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>Here, <code>slot-scope</code> declares the received props object as the <code>slotProps</code> variable, and makes it available inside the <code>&lt;template&gt;</code> scope. You can name <code>slotProps</code> anything you like similar to naming function arguments in JavaScript.</p>\n<p>Here <code>slot=&quot;default&quot;</code> can be omitted as it is implied:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>The <code>slot-scope</code> attribute can also be used directly on a non-<code>&lt;template&gt;</code> element (including components):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>The value of <code>slot-scope</code> can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (<a href=\"single-file-components.html\">single-file components</a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility\" target=\"_blank\" rel=\"noopener\">modern browsers</a>) you can also use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\" target=\"_blank\" rel=\"noopener\">ES2015 destructuring</a> in the expression, like so:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; msg &#125;\"</span>&gt;</span>\n    &#123;&#123; msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>Using the <code>&lt;todo-list&gt;</code> described <a href=\"#Other-Examples\">here</a> as an example, here’s the equivalent usage using <code>slot-scope</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">todo-list</span> <span class=\"hljs-attr\">v-bind:todos</span>=<span class=\"hljs-string\">\"todos\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"todo\"</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; todo &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"todo.isComplete\"</span>&gt;</span>✓<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">todo-list</span>&gt;</span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>This page assumes you’ve already read the <a href=\"components.html\">Components Basics</a>. Read that first if you are new to components.</p>\n</blockquote>\n<blockquote>\n<p>In 2.6.0, we introduced a new unified syntax (the <code>v-slot</code> directive) for named and scoped slots. It replaces the <code>slot</code> and <code>slot-scope</code> attributes, which are now deprecated, but have <em>not</em> been removed and are still documented <a href=\"#Deprecated-Syntax\">here</a>. The rationale for introducing the new syntax is described in this <a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC</a>.</p>\n</blockquote>\n<h2 id=\"Slot-Content\"><a href=\"#Slot-Content\" class=\"headerlink\" title=\"Slot Content\"></a>Slot Content</h2><p>Vue implements a content distribution API inspired by the <a href=\"https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md\" target=\"_blank\" rel=\"noopener\">Web Components spec draft</a>, using the <code>&lt;slot&gt;</code> element to serve as distribution outlets for content.</p>\n<p>This allows you to compose components like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  Your Profile\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>Then in the template for <code>&lt;navigation-link&gt;</code>, you might have:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span>\n  <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>\n  <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"nav-link\"</span>\n&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>When the component renders, <code>&lt;slot&gt;&lt;/slot&gt;</code> will be replaced by “Your Profile”. Slots can contain any template code, including HTML:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Add a Font Awesome icon --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"fa fa-user\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n  Your Profile\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>Or even other components:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- Use a component to add an icon --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">font-awesome-icon</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"user\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">font-awesome-icon</span>&gt;</span>\n  Your Profile\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>If <code>&lt;navigation-link&gt;</code>‘s template did <strong>not</strong> contain a <code>&lt;slot&gt;</code> element, any content provided between its opening and closing tag would be discarded.</p>\n<h2 id=\"Compilation-Scope\"><a href=\"#Compilation-Scope\" class=\"headerlink\" title=\"Compilation Scope\"></a>Compilation Scope</h2><p>When you want to use data inside a slot, such as in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  Logged in as &#123;&#123; user.name &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>That slot has access to the same instance properties (i.e. the same “scope”) as the rest of the template. The slot does <strong>not</strong> have access to <code>&lt;navigation-link&gt;</code>‘s scope. For example, trying to access <code>url</code> would not work:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">navigation-link</span> <span class=\"hljs-attr\">url</span>=<span class=\"hljs-string\">\"/profile\"</span>&gt;</span>\n  Clicking here will send you to: &#123;&#123; url &#125;&#125;\n  <span class=\"hljs-comment\">&lt;!--\n  The `url` will be undefined, because this content is passed\n  _to_ &lt;navigation-link&gt;, rather than defined _inside_ the\n  &lt;navigation-link&gt; component.\n  --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">navigation-link</span>&gt;</span></code></pre>\n<p>As a rule, remember that:</p>\n<blockquote>\n<p>Everything in the parent template is compiled in parent scope; everything in the child template is compiled in the child scope.</p>\n</blockquote>\n<h2 id=\"Fallback-Content\"><a href=\"#Fallback-Content\" class=\"headerlink\" title=\"Fallback Content\"></a>Fallback Content</h2><p>There are cases when it’s useful to specify fallback (i.e. default) content for a slot, to be rendered only when no content is provided. For example, in a <code>&lt;submit-button&gt;</code> component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>We might want the text “Submit” to be rendered inside the <code>&lt;button&gt;</code> most of the time. To make “Submit” the fallback content, we can place it in between the <code>&lt;slot&gt;</code> tags:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Now when we use <code>&lt;submit-button&gt;</code> in a parent component, providing no content for the slot:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">submit-button</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">submit-button</span>&gt;</span></code></pre>\n<p>will render the fallback content, “Submit”:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  Submit\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>But if we provide content:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">submit-button</span>&gt;</span>\n  Save\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">submit-button</span>&gt;</span></code></pre>\n<p>Then the provided content will be rendered instead:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span>\n  Save\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<h2 id=\"Named-Slots\"><a href=\"#Named-Slots\" class=\"headerlink\" title=\"Named Slots\"></a>Named Slots</h2><blockquote>\n<p>Updated in 2.6.0+. <a href=\"#Deprecated-Syntax\">See here</a> for the deprecated syntax using the <code>slot</code> attribute.</p>\n</blockquote>\n<p>There are times when it’s useful to have multiple slots. For example, in a <code>&lt;base-layout&gt;</code> component with the following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- We want header content here --&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- We want main content here --&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-comment\">&lt;!-- We want footer content here --&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>For these cases, the <code>&lt;slot&gt;</code> element has a special attribute, <code>name</code>, which can be used to define additional slots:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"header\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>A <code>&lt;slot&gt;</code> outlet without <code>name</code> implicitly has the name “default”.</p>\n<p>To provide content to named slots, we can use the <code>v-slot</code> directive on a <code>&lt;template&gt;</code>, providing the name of the slot as <code>v-slot</code>‘s argument:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>Now everything inside the <code>&lt;template&gt;</code> elements will be passed to the corresponding slots. Any content not wrapped in a <code>&lt;template&gt;</code> using <code>v-slot</code> is assumed to be for the default slot.</p>\n<p>However, you can still wrap default slot content in a <code>&lt;template&gt;</code> if you wish to be explicit:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:default</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>Either way, the rendered HTML will be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Note that <strong><code>v-slot</code> can only be added to a <code>&lt;template&gt;</code></strong> (with <a href=\"#Abbreviated-Syntax-for-Lone-Default-Slots\">one exception</a>), unlike the deprecated <a href=\"#Deprecated-Syntax\"><code>slot</code> attribute</a>.</p>\n<h2 id=\"Scoped-Slots\"><a href=\"#Scoped-Slots\" class=\"headerlink\" title=\"Scoped Slots\"></a>Scoped Slots</h2><blockquote>\n<p>Updated in 2.6.0+. <a href=\"#Deprecated-Syntax\">See here</a> for the deprecated syntax using the <code>slot-scope</code> attribute.</p>\n</blockquote>\n<p>Sometimes, it’s useful for slot content to have access to data only available in the child component. For example, imagine a <code>&lt;current-user&gt;</code> component with the following template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span>&#123;&#123; user.lastName &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<p>We might want to replace this fallback content to display the user’s first name, instead of last, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>That won’t work, however, because only the <code>&lt;current-user&gt;</code> component has access to the <code>user</code> and the content we’re providing is rendered in the parent.</p>\n<p>To make <code>user</code> available to the slot content in the parent, we can bind <code>user</code> as an attribute to the <code>&lt;slot&gt;</code> element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">v-bind:user</span>=<span class=\"hljs-string\">\"user\"</span>&gt;</span>\n    &#123;&#123; user.lastName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<p>Attributes bound to a <code>&lt;slot&gt;</code> element are called <strong>slot props</strong>. Now, in the parent scope, we can use <code>v-slot</code> with a value to define a name for the slot props we’ve been provided:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:default</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.user.firstName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>In this example, we’ve chosen to name the object containing all our slot props <code>slotProps</code>, but you can use any name you like.</p>\n<h3 id=\"Abbreviated-Syntax-for-Lone-Default-Slots\"><a href=\"#Abbreviated-Syntax-for-Lone-Default-Slots\" class=\"headerlink\" title=\"Abbreviated Syntax for Lone Default Slots\"></a>Abbreviated Syntax for Lone Default Slots</h3><p>In cases like above, when <em>only</em> the default slot is provided content, the component’s tags can be used as the slot’s template. This allows us to use <code>v-slot</code> directly on the component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot:default</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n  &#123;&#123; slotProps.user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>This can be shortened even further. Just as non-specified content is assumed to be for the default slot, <code>v-slot</code> without an argument is assumed to refer to the default slot:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n  &#123;&#123; slotProps.user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>Note that the abbreviated syntax for default slot <strong>cannot</strong> be mixed with named slots, as it would lead to scope ambiguity:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- INVALID, will result in warning --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n  &#123;&#123; slotProps.user.firstName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:other</span>=<span class=\"hljs-string\">\"otherSlotProps\"</span>&gt;</span>\n    slotProps is NOT available here\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>Whenever there are multiple slots, use the full <code>&lt;template&gt;</code> based syntax for <em>all</em> slots:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:default</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.user.firstName &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:other</span>=<span class=\"hljs-string\">\"otherSlotProps\"</span>&gt;</span>\n    ...\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<h3 id=\"Destructuring-Slot-Props\"><a href=\"#Destructuring-Slot-Props\" class=\"headerlink\" title=\"Destructuring Slot Props\"></a>Destructuring Slot Props</h3><p>Internally, scoped slots work by wrapping your slot content in a function passed a single argument:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">slotProps</span>) </span>&#123;\n  <span class=\"hljs-comment\">// ... slot content ...</span>\n&#125;</code></pre>\n<p>That means the value of <code>v-slot</code> can actually accept any valid JavaScript expression that can appear in the argument position of a function definition. So in supported environments (<a href=\"single-file-components.html\">single-file components</a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility\" target=\"_blank\" rel=\"noopener\">modern browsers</a>), you can also use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\" target=\"_blank\" rel=\"noopener\">ES2015 destructuring</a> to pull out specific slot props, like so:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; user &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>This can make the template much cleaner, especially when the slot provides many props. It also opens other possibilities, such as renaming props, e.g. <code>user</code> to <code>person</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; user: person &#125;\"</span>&gt;</span>\n  &#123;&#123; person.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>You can even define fallbacks, to be used in case a slot prop is undefined:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; user = &#123; firstName: 'Guest' &#125; &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<h2 id=\"Dynamic-Slot-Names\"><a href=\"#Dynamic-Slot-Names\" class=\"headerlink\" title=\"Dynamic Slot Names\"></a>Dynamic Slot Names</h2><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<p><a href=\"syntax.html#Dynamic-Arguments\">Dynamic directive arguments</a> also work on <code>v-slot</code>, allowing the definition of dynamic slot names:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:</span>[<span class=\"hljs-attr\">dynamicSlotName</span>]&gt;</span>\n    ...\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<h2 id=\"Named-Slots-Shorthand\"><a href=\"#Named-Slots-Shorthand\" class=\"headerlink\" title=\"Named Slots Shorthand\"></a>Named Slots Shorthand</h2><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<p>Similar to <code>v-on</code> and <code>v-bind</code>, <code>v-slot</code> also has a shorthand, replacing everything before the argument (<code>v-slot:</code>) with the special symbol <code>#</code>. For example, <code>v-slot:header</code> can be rewritten as <code>#header</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>However, just as with other directives, the shorthand is only available when an argument is provided. That means the following syntax is invalid:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- This will trigger a warning --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> #=<span class=\"hljs-string\">\"&#123; user &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<p>Instead, you must always specify the name of the slot if you wish to use the shorthand:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">current-user</span> #<span class=\"hljs-attr\">default</span>=<span class=\"hljs-string\">\"&#123; user &#125;\"</span>&gt;</span>\n  &#123;&#123; user.firstName &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">current-user</span>&gt;</span></code></pre>\n<h2 id=\"Other-Examples\"><a href=\"#Other-Examples\" class=\"headerlink\" title=\"Other Examples\"></a>Other Examples</h2><p><strong>Slot props allow us to turn slots into reusable templates that can render different content based on input props.</strong> This is most useful when you are designing a reusable component that encapsulates data logic while allowing the consuming parent component to customize part of its layout.</p>\n<p>For example, we are implementing a <code>&lt;todo-list&gt;</code> component that contains the layout and filtering logic for a list:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in filteredTodos\"</span>\n    <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>Instead of hard-coding the content for each todo, we can let the parent component take control by making every todo a slot, then binding <code>todo</code> as a slot prop:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in filteredTodos\"</span>\n    <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    <span class=\"hljs-comment\">&lt;!--\n    We have a slot for each todo, passing it the\n    `todo` object as a slot prop.\n    --&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"todo\"</span> <span class=\"hljs-attr\">v-bind:todo</span>=<span class=\"hljs-string\">\"todo\"</span>&gt;</span>\n      <span class=\"hljs-comment\">&lt;!-- Fallback content --&gt;</span>\n      &#123;&#123; todo.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>Now when we use the <code>&lt;todo-list&gt;</code> component, we can optionally define an alternative <code>&lt;template&gt;</code> for todo items, but with access to data from the child:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">todo-list</span> <span class=\"hljs-attr\">v-bind:todos</span>=<span class=\"hljs-string\">\"todos\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:todo</span>=<span class=\"hljs-string\">\"&#123; todo &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"todo.isComplete\"</span>&gt;</span>✓<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">todo-list</span>&gt;</span></code></pre>\n<p>However, even this barely scratches the surface of what scoped slots are capable of. For real-life, powerful examples of scoped slot usage, we recommend browsing libraries such as <a href=\"https://github.com/Akryum/vue-virtual-scroller\" target=\"_blank\" rel=\"noopener\">Vue Virtual Scroller</a>, <a href=\"https://github.com/posva/vue-promised\" target=\"_blank\" rel=\"noopener\">Vue Promised</a>, and <a href=\"https://github.com/LinusBorg/portal-vue\" target=\"_blank\" rel=\"noopener\">Portal Vue</a>.</p>\n<h2 id=\"Deprecated-Syntax\"><a href=\"#Deprecated-Syntax\" class=\"headerlink\" title=\"Deprecated Syntax\"></a>Deprecated Syntax</h2><blockquote>\n<p>The <code>v-slot</code> directive was introduced in Vue 2.6.0, offering an improved, alternative API to the still-supported <code>slot</code> and <code>slot-scope</code> attributes. The full rationale for introducing <code>v-slot</code> is described in this <a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC</a>. The <code>slot</code> and <code>slot-scope</code> attributes will continue to be supported in all future 2.x releases, but are officially deprecated and will eventually be removed in Vue 3.</p>\n</blockquote>\n<h3 id=\"Named-Slots-with-the-slot-Attribute\"><a href=\"#Named-Slots-with-the-slot-Attribute\" class=\"headerlink\" title=\"Named Slots with the slot Attribute\"></a>Named Slots with the <code>slot</code> Attribute</h3><blockquote>\n<p><abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See <a href=\"#Named-Slots\">here</a> for the new, recommended syntax.</p>\n</blockquote>\n<p>To pass content to named slots from the parent, use the special <code>slot</code> attribute on <code>&lt;template&gt;</code> (using the <code>&lt;base-layout&gt;</code> component described <a href=\"#Named-Slots\">here</a> as example):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"header\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>Or, the <code>slot</code> attribute can also be used directly on a normal element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"header\"</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"footer\"</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span></code></pre>\n<p>There can still be one unnamed slot, which is the <strong>default slot</strong> that serves as a catch-all for any unmatched content. In both examples above, the rendered HTML would be:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"container\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">main</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>A paragraph for the main content.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>And another one.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">main</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h3 id=\"Scoped-Slots-with-the-slot-scope-Attribute\"><a href=\"#Scoped-Slots-with-the-slot-scope-Attribute\" class=\"headerlink\" title=\"Scoped Slots with the slot-scope Attribute\"></a>Scoped Slots with the <code>slot-scope</code> Attribute</h3><blockquote>\n<p><abbr title=\"Still supported in all 2.x versions of Vue, but no longer recommended.\">Deprecated</abbr> in 2.6.0+. See <a href=\"#Scoped-Slots\">here</a> for the new, recommended syntax.</p>\n</blockquote>\n<p>To receive props passed to a slot, the parent component can use <code>&lt;template&gt;</code> with the <code>slot-scope</code> attribute (using the <code>&lt;slot-example&gt;</code> described <a href=\"#Scoped-Slots\">here</a> as example):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"default\"</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>Here, <code>slot-scope</code> declares the received props object as the <code>slotProps</code> variable, and makes it available inside the <code>&lt;template&gt;</code> scope. You can name <code>slotProps</code> anything you like similar to naming function arguments in JavaScript.</p>\n<p>Here <code>slot=&quot;default&quot;</code> can be omitted as it is implied:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>The <code>slot-scope</code> attribute can also be used directly on a non-<code>&lt;template&gt;</code> element (including components):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    &#123;&#123; slotProps.msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>The value of <code>slot-scope</code> can accept any valid JavaScript expression that can appear in the argument position of a function definition. This means in supported environments (<a href=\"single-file-components.html\">single-file components</a> or <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Browser_compatibility\" target=\"_blank\" rel=\"noopener\">modern browsers</a>) you can also use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Object_destructuring\" target=\"_blank\" rel=\"noopener\">ES2015 destructuring</a> in the expression, like so:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot-example</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; msg &#125;\"</span>&gt;</span>\n    &#123;&#123; msg &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot-example</span>&gt;</span></code></pre>\n<p>Using the <code>&lt;todo-list&gt;</code> described <a href=\"#Other-Examples\">here</a> as an example, here’s the equivalent usage using <code>slot-scope</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">todo-list</span> <span class=\"hljs-attr\">v-bind:todos</span>=<span class=\"hljs-string\">\"todos\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">\"todo\"</span> <span class=\"hljs-attr\">slot-scope</span>=<span class=\"hljs-string\">\"&#123; todo &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"todo.isComplete\"</span>&gt;</span>✓<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">todo-list</span>&gt;</span></code></pre>\n"},{"title":"Conditional Rendering","type":"guide","order":7,"_content":"\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how conditional rendering works with Vue School\">Learn how conditional rendering works with a free lesson on Vue School</a></div>\n\n## `v-if`\n\nThe directive `v-if` is used to conditionally render a block. The block will only be rendered if the directive's expression returns a truthy value.\n\n``` html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n\nIt is also possible to add an \"else block\" with `v-else`:\n\n``` html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n### Conditional Groups with `v-if` on `<template>`\n\nBecause `v-if` is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use `v-if` on a `<template>` element, which serves as an invisible wrapper. The final rendered result will not include the `<template>` element.\n\n``` html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n\n### `v-else`\n\nYou can use the `v-else` directive to indicate an \"else block\" for `v-if`:\n\n``` html\n<div v-if=\"Math.random() > 0.5\">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n```\n\nA `v-else` element must immediately follow a `v-if` or a `v-else-if` element - otherwise it will not be recognized.\n\n### `v-else-if`\n\n> New in 2.1.0+\n\nThe `v-else-if`, as the name suggests, serves as an \"else if block\" for `v-if`. It can also be chained multiple times:\n\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\nSimilar to `v-else`, a `v-else-if` element must immediately follow a `v-if` or a `v-else-if` element.\n\n### Controlling Reusable Elements with `key`\n\nVue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n```\n\nThen switching the `loginType` in the code above will not erase what the user has already entered. Since both templates use the same elements, the `<input>` is not replaced - just its `placeholder`.\n\nCheck it out for yourself by entering some text in the input, then pressing the toggle button:\n\n{% raw %}\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nThis isn't always desirable though, so Vue offers a way for you to say, \"These two elements are completely separate - don't re-use them.\" Add a `key` attribute with unique values:\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n```\n\nNow those inputs will be rendered from scratch each time you toggle. See for yourself:\n\n{% raw %}\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nNote that the `<label>` elements are still efficiently re-used, because they don't have `key` attributes.\n\n## `v-show`\n\nAnother option for conditionally displaying an element is the `v-show` directive. The usage is largely the same:\n\n``` html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\nThe difference is that an element with `v-show` will always be rendered and remain in the DOM; `v-show` only toggles the `display` CSS property of the element.\n\n<p class=\"tip\">Note that `v-show` doesn't support the `<template>` element, nor does it work with `v-else`.</p>\n\n## `v-if` vs `v-show`\n\n`v-if` is \"real\" conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.\n\n`v-if` is also **lazy**: if the condition is false on initial render, it will not do anything - the conditional block won't be rendered until the condition becomes true for the first time.\n\nIn comparison, `v-show` is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.\n\nGenerally speaking, `v-if` has higher toggle costs while `v-show` has higher initial render costs. So prefer `v-show` if you need to toggle something very often, and prefer `v-if` if the condition is unlikely to change at runtime.\n\n## `v-if` with `v-for`\n\n<p class=\"tip\">Using `v-if` and `v-for` together is **not recommended**. See the [style guide](/v2/style-guide/#Avoid-v-if-with-v-for-essential) for further information.</p>\n\nWhen used together with `v-if`, `v-for` has a higher priority than `v-if`. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.\n","source":"v2/guide/conditional.md","raw":"---\ntitle: Conditional Rendering\ntype: guide\norder: 7\n---\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how conditional rendering works with Vue School\">Learn how conditional rendering works with a free lesson on Vue School</a></div>\n\n## `v-if`\n\nThe directive `v-if` is used to conditionally render a block. The block will only be rendered if the directive's expression returns a truthy value.\n\n``` html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n\nIt is also possible to add an \"else block\" with `v-else`:\n\n``` html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n<h1 v-else>Oh no 😢</h1>\n```\n\n### Conditional Groups with `v-if` on `<template>`\n\nBecause `v-if` is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use `v-if` on a `<template>` element, which serves as an invisible wrapper. The final rendered result will not include the `<template>` element.\n\n``` html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n\n### `v-else`\n\nYou can use the `v-else` directive to indicate an \"else block\" for `v-if`:\n\n``` html\n<div v-if=\"Math.random() > 0.5\">\n  Now you see me\n</div>\n<div v-else>\n  Now you don't\n</div>\n```\n\nA `v-else` element must immediately follow a `v-if` or a `v-else-if` element - otherwise it will not be recognized.\n\n### `v-else-if`\n\n> New in 2.1.0+\n\nThe `v-else-if`, as the name suggests, serves as an \"else if block\" for `v-if`. It can also be chained multiple times:\n\n```html\n<div v-if=\"type === 'A'\">\n  A\n</div>\n<div v-else-if=\"type === 'B'\">\n  B\n</div>\n<div v-else-if=\"type === 'C'\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n\nSimilar to `v-else`, a `v-else-if` element must immediately follow a `v-if` or a `v-else-if` element.\n\n### Controlling Reusable Elements with `key`\n\nVue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\">\n</template>\n```\n\nThen switching the `loginType` in the code above will not erase what the user has already entered. Since both templates use the same elements, the `<input>` is not replaced - just its `placeholder`.\n\nCheck it out for yourself by entering some text in the input, then pressing the toggle button:\n\n{% raw %}\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nThis isn't always desirable though, so Vue offers a way for you to say, \"These two elements are completely separate - don't re-use them.\" Add a `key` attribute with unique values:\n\n``` html\n<template v-if=\"loginType === 'username'\">\n  <label>Username</label>\n  <input placeholder=\"Enter your username\" key=\"username-input\">\n</template>\n<template v-else>\n  <label>Email</label>\n  <input placeholder=\"Enter your email address\" key=\"email-input\">\n</template>\n```\n\nNow those inputs will be rendered from scratch each time you toggle. See for yourself:\n\n{% raw %}\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nNote that the `<label>` elements are still efficiently re-used, because they don't have `key` attributes.\n\n## `v-show`\n\nAnother option for conditionally displaying an element is the `v-show` directive. The usage is largely the same:\n\n``` html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n\nThe difference is that an element with `v-show` will always be rendered and remain in the DOM; `v-show` only toggles the `display` CSS property of the element.\n\n<p class=\"tip\">Note that `v-show` doesn't support the `<template>` element, nor does it work with `v-else`.</p>\n\n## `v-if` vs `v-show`\n\n`v-if` is \"real\" conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.\n\n`v-if` is also **lazy**: if the condition is false on initial render, it will not do anything - the conditional block won't be rendered until the condition becomes true for the first time.\n\nIn comparison, `v-show` is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.\n\nGenerally speaking, `v-if` has higher toggle costs while `v-show` has higher initial render costs. So prefer `v-show` if you need to toggle something very often, and prefer `v-if` if the condition is unlikely to change at runtime.\n\n## `v-if` with `v-for`\n\n<p class=\"tip\">Using `v-if` and `v-for` together is **not recommended**. See the [style guide](/v2/style-guide/#Avoid-v-if-with-v-for-essential) for further information.</p>\n\nWhen used together with `v-if`, `v-for` has a higher priority than `v-if`. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.\n","date":"2020-09-25T23:55:41.135Z","updated":"2020-09-25T23:55:41.135Z","path":"v2/guide/conditional.html","comments":1,"layout":"page","_id":"ckfl66gyj0020c2v56b01qpdl","content":"<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how conditional rendering works with Vue School\">Learn how conditional rendering works with a free lesson on Vue School</a></div>\n\n<h2 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a><code>v-if</code></h2><p>The directive <code>v-if</code> is used to conditionally render a block. The block will only be rendered if the directive’s expression returns a truthy value.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"awesome\"</span>&gt;</span>Vue is awesome!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>It is also possible to add an “else block” with <code>v-else</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"awesome\"</span>&gt;</span>Vue is awesome!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>Oh no 😢<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<h3 id=\"Conditional-Groups-with-v-if-on-lt-template-gt\"><a href=\"#Conditional-Groups-with-v-if-on-lt-template-gt\" class=\"headerlink\" title=\"Conditional Groups with v-if on &lt;template&gt;\"></a>Conditional Groups with <code>v-if</code> on <code>&lt;template&gt;</code></h3><p>Because <code>v-if</code> is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use <code>v-if</code> on a <code>&lt;template&gt;</code> element, which serves as an invisible wrapper. The final rendered result will not include the <code>&lt;template&gt;</code> element.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a><code>v-else</code></h3><p>You can use the <code>v-else</code> directive to indicate an “else block” for <code>v-if</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Now you see me\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Now you don't\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>A <code>v-else</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element - otherwise it will not be recognized.</p>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a><code>v-else-if</code></h3><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<p>The <code>v-else-if</code>, as the name suggests, serves as an “else if block” for <code>v-if</code>. It can also be chained multiple times:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Not A/B/C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Similar to <code>v-else</code>, a <code>v-else-if</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element.</p>\n<h3 id=\"Controlling-Reusable-Elements-with-key\"><a href=\"#Controlling-Reusable-Elements-with-key\" class=\"headerlink\" title=\"Controlling Reusable Elements with key\"></a>Controlling Reusable Elements with <code>key</code></h3><p>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Username<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your username\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Email<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your email address\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Then switching the <code>loginType</code> in the code above will not erase what the user has already entered. Since both templates use the same elements, the <code>&lt;input&gt;</code> is not replaced - just its <code>placeholder</code>.</p>\n<p>Check it out for yourself by entering some text in the input, then pressing the toggle button:</p>\n\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>This isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate - don’t re-use them.” Add a <code>key</code> attribute with unique values:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Username<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your username\"</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"username-input\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Email<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your email address\"</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"email-input\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</p>\n\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>Note that the <code>&lt;label&gt;</code> elements are still efficiently re-used, because they don’t have <code>key</code> attributes.</p>\n<h2 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a><code>v-show</code></h2><p>Another option for conditionally displaying an element is the <code>v-show</code> directive. The usage is largely the same:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>The difference is that an element with <code>v-show</code> will always be rendered and remain in the DOM; <code>v-show</code> only toggles the <code>display</code> CSS property of the element.</p>\n<p class=\"tip\">Note that <code>v-show</code> doesn’t support the <code>&lt;template&gt;</code> element, nor does it work with <code>v-else</code>.</p>\n\n<h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> is “real” conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.</p>\n<p><code>v-if</code> is also <strong>lazy</strong>: if the condition is false on initial render, it will not do anything - the conditional block won’t be rendered until the condition becomes true for the first time.</p>\n<p>In comparison, <code>v-show</code> is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</p>\n<p>Generally speaking, <code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render costs. So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the condition is unlikely to change at runtime.</p>\n<h2 id=\"v-if-with-v-for\"><a href=\"#v-if-with-v-for\" class=\"headerlink\" title=\"v-if with v-for\"></a><code>v-if</code> with <code>v-for</code></h2><p class=\"tip\">Using <code>v-if</code> and <code>v-for</code> together is <strong>not recommended</strong>. See the <a href=\"/v2/style-guide/#Avoid-v-if-with-v-for-essential\">style guide</a> for further information.</p>\n\n<p>When used together with <code>v-if</code>, <code>v-for</code> has a higher priority than <code>v-if</code>. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-conditionals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how conditional rendering works with Vue School\">Learn how conditional rendering works with a free lesson on Vue School</a></div>\n\n<h2 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a><code>v-if</code></h2><p>The directive <code>v-if</code> is used to conditionally render a block. The block will only be rendered if the directive’s expression returns a truthy value.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"awesome\"</span>&gt;</span>Vue is awesome!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>It is also possible to add an “else block” with <code>v-else</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"awesome\"</span>&gt;</span>Vue is awesome!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>Oh no 😢<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<h3 id=\"Conditional-Groups-with-v-if-on-lt-template-gt\"><a href=\"#Conditional-Groups-with-v-if-on-lt-template-gt\" class=\"headerlink\" title=\"Conditional Groups with v-if on &lt;template&gt;\"></a>Conditional Groups with <code>v-if</code> on <code>&lt;template&gt;</code></h3><p>Because <code>v-if</code> is a directive, it has to be attached to a single element. But what if we want to toggle more than one element? In this case we can use <code>v-if</code> on a <code>&lt;template&gt;</code> element, which serves as an invisible wrapper. The final rendered result will not include the <code>&lt;template&gt;</code> element.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Paragraph 2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a><code>v-else</code></h3><p>You can use the <code>v-else</code> directive to indicate an “else block” for <code>v-if</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Now you see me\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Now you don't\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>A <code>v-else</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element - otherwise it will not be recognized.</p>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a><code>v-else-if</code></h3><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<p>The <code>v-else-if</code>, as the name suggests, serves as an “else if block” for <code>v-if</code>. It can also be chained multiple times:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Not A/B/C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Similar to <code>v-else</code>, a <code>v-else-if</code> element must immediately follow a <code>v-if</code> or a <code>v-else-if</code> element.</p>\n<h3 id=\"Controlling-Reusable-Elements-with-key\"><a href=\"#Controlling-Reusable-Elements-with-key\" class=\"headerlink\" title=\"Controlling Reusable Elements with key\"></a>Controlling Reusable Elements with <code>key</code></h3><p>Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch. Beyond helping make Vue very fast, this can have some useful advantages. For example, if you allow users to toggle between multiple login types:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Username<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your username\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Email<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your email address\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Then switching the <code>loginType</code> in the code above will not erase what the user has already entered. Since both templates use the same elements, the <code>&lt;input&gt;</code> is not replaced - just its <code>placeholder</code>.</p>\n<p>Check it out for yourself by entering some text in the input, then pressing the toggle button:</p>\n\n<div id=\"no-key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#no-key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>This isn’t always desirable though, so Vue offers a way for you to say, “These two elements are completely separate - don’t re-use them.” Add a <code>key</code> attribute with unique values:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"loginType === 'username'\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Username<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your username\"</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"username-input\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span>&gt;</span>Email<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"Enter your email address\"</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"email-input\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Now those inputs will be rendered from scratch each time you toggle. See for yourself:</p>\n\n<div id=\"key-example\" class=\"demo\">\n  <div>\n    <template v-if=\"loginType === 'username'\">\n      <label>Username</label>\n      <input placeholder=\"Enter your username\" key=\"username-input\">\n    </template>\n    <template v-else>\n      <label>Email</label>\n      <input placeholder=\"Enter your email address\" key=\"email-input\">\n    </template>\n  </div>\n  <button @click=\"toggleLoginType\">Toggle login type</button>\n</div>\n<script>\nnew Vue({\n  el: '#key-example',\n  data: {\n    loginType: 'username'\n  },\n  methods: {\n    toggleLoginType: function () {\n      return this.loginType = this.loginType === 'username' ? 'email' : 'username'\n    }\n  }\n})\n</script>\n\n<p>Note that the <code>&lt;label&gt;</code> elements are still efficiently re-used, because they don’t have <code>key</code> attributes.</p>\n<h2 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a><code>v-show</code></h2><p>Another option for conditionally displaying an element is the <code>v-show</code> directive. The usage is largely the same:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>Hello!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>The difference is that an element with <code>v-show</code> will always be rendered and remain in the DOM; <code>v-show</code> only toggles the <code>display</code> CSS property of the element.</p>\n<p class=\"tip\">Note that <code>v-show</code> doesn’t support the <code>&lt;template&gt;</code> element, nor does it work with <code>v-else</code>.</p>\n\n<h2 id=\"v-if-vs-v-show\"><a href=\"#v-if-vs-v-show\" class=\"headerlink\" title=\"v-if vs v-show\"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> is “real” conditional rendering because it ensures that event listeners and child components inside the conditional block are properly destroyed and re-created during toggles.</p>\n<p><code>v-if</code> is also <strong>lazy</strong>: if the condition is false on initial render, it will not do anything - the conditional block won’t be rendered until the condition becomes true for the first time.</p>\n<p>In comparison, <code>v-show</code> is much simpler - the element is always rendered regardless of initial condition, with CSS-based toggling.</p>\n<p>Generally speaking, <code>v-if</code> has higher toggle costs while <code>v-show</code> has higher initial render costs. So prefer <code>v-show</code> if you need to toggle something very often, and prefer <code>v-if</code> if the condition is unlikely to change at runtime.</p>\n<h2 id=\"v-if-with-v-for\"><a href=\"#v-if-with-v-for\" class=\"headerlink\" title=\"v-if with v-for\"></a><code>v-if</code> with <code>v-for</code></h2><p class=\"tip\">Using <code>v-if</code> and <code>v-for</code> together is <strong>not recommended</strong>. See the <a href=\"/v2/style-guide/#Avoid-v-if-with-v-for-essential\">style guide</a> for further information.</p>\n\n<p>When used together with <code>v-if</code>, <code>v-for</code> has a higher priority than <code>v-if</code>. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n"},{"title":"Custom Directives","type":"guide","order":302,"_content":"\n## Intro\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/create-vuejs-directive?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Custom Directives lesson\">Watch a free video lesson on Vue School</a></div>\n\nIn addition to the default set of directives shipped in core (`v-model` and `v-show`), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:\n\n{% raw %}\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus>\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n{% endraw %}\n\nWhen the page loads, that element gains focus (note: `autofocus` doesn't work on mobile Safari). In fact, if you haven't clicked on anything else since visiting this page, the input above should be focused now. Now let's build the directive that accomplishes this:\n\n``` js\n// Register a global custom directive called `v-focus`\nVue.directive('focus', {\n  // When the bound element is inserted into the DOM...\n  inserted: function (el) {\n    // Focus the element\n    el.focus()\n  }\n})\n```\n\nIf you want to register a directive locally instead, components also accept a `directives` option:\n\n``` js\ndirectives: {\n  focus: {\n    // directive definition\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n\nThen in a template, you can use the new `v-focus` attribute on any element, like this:\n\n``` html\n<input v-focus>\n```\n\n## Hook Functions\n\nA directive definition object can provide several hook functions (all optional):\n\n- `bind`: called only once, when the directive is first bound to the element. This is where you can do one-time setup work.\n\n- `inserted`: called when the bound element has been inserted into its parent node (this only guarantees parent node presence, not necessarily in-document).\n\n- `update`: called after the containing component's VNode has updated, __but possibly before its children have updated__. The directive's value may or may not have changed, but you can skip unnecessary updates by comparing the binding's current and old values (see below on hook arguments).\n\n<p class=\"tip\">We'll cover VNodes in more detail [later](./render-function.html#The-Virtual-DOM), when we discuss [render functions](./render-function.html).</p>\n\n- `componentUpdated`: called after the containing component's VNode __and the VNodes of its children__ have updated.\n\n- `unbind`: called only once, when the directive is unbound from the element.\n\nWe'll explore the arguments passed into these hooks (i.e. `el`, `binding`, `vnode`, and `oldVnode`) in the next section.\n\n## Directive Hook Arguments\n\nDirective hooks are passed these arguments:\n\n- `el`: The element the directive is bound to. This can be used to directly manipulate the DOM.\n- `binding`: An object containing the following properties.\n  - `name`: The name of the directive, without the `v-` prefix.\n  - `value`: The value passed to the directive. For example in `v-my-directive=\"1 + 1\"`, the value would be `2`.\n  - `oldValue`: The previous value, only available in `update` and `componentUpdated`. It is available whether or not the value has changed.\n  - `expression`: The expression of the binding as a string. For example in `v-my-directive=\"1 + 1\"`, the expression would be `\"1 + 1\"`.\n  - `arg`: The argument passed to the directive, if any. For example in `v-my-directive:foo`, the arg would be `\"foo\"`.\n  - `modifiers`: An object containing modifiers, if any. For example in `v-my-directive.foo.bar`, the modifiers object would be `{ foo: true, bar: true }`.\n- `vnode`: The virtual node produced by Vue's compiler. See the [VNode API](../api/#VNode-Interface) for full details.\n- `oldVnode`: The previous virtual node, only available in the `update` and `componentUpdated` hooks.\n\n<p class=\"tip\">Apart from `el`, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element's [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset).</p>\n\nAn example of a custom directive using some of these properties:\n\n``` html\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n```\n\n``` js\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\n\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n```\n\n{% raw %}\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n{% endraw %}\n\n### Dynamic Directive Arguments\n\nDirective arguments can be dynamic. For example, in `v-mydirective:[argument]=\"value\"`, the `argument` can be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application.\n\nLet's say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:\n\n```html\n<div id=\"baseexample\">\n  <p>Scroll down the page</p>\n  <p v-pin=\"200\">Stick me 200px from the top of the page</p>\n</div>\n```\n\n```js\nVue.directive('pin', {\n  bind: function (el, binding, vnode) {\n    el.style.position = 'fixed'\n    el.style.top = binding.value + 'px'\n  }\n})\n\nnew Vue({\n  el: '#baseexample'\n})\n```\n\nThis would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here's where a dynamic argument that can be updated per component instance comes in very handy:\n\n\n```html\n<div id=\"dynamicexample\">\n  <h3>Scroll down inside this section ↓</h3>\n  <p v-pin:[direction]=\"200\">I am pinned onto the page at 200px to the left.</p>\n</div>\n```\n\n```js\nVue.directive('pin', {\n  bind: function (el, binding, vnode) {\n    el.style.position = 'fixed'\n    var s = (binding.arg == 'left' ? 'left' : 'top')\n    el.style[s] = binding.value + 'px'\n  }\n})\n\nnew Vue({\n  el: '#dynamicexample',\n  data: function () {\n    return {\n      direction: 'left'\n    }\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<iframe height=\"200\" style=\"width: 100%;\" class=\"demo\" scrolling=\"no\" title=\"Dynamic Directive Arguments\" src=\"//codepen.io/team/Vue/embed/rgLLzb/?height=300&theme-id=32763&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/team/Vue/pen/rgLLzb/'>Dynamic Directive Arguments</a> by Vue\n  (<a href='https://codepen.io/Vue'>@Vue</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n{% endraw %}\n\nOur custom directive is now flexible enough to support a few different use cases.\n\n## Function Shorthand\n\nIn many cases, you may want the same behavior on `bind` and `update`, but don't care about the other hooks. For example:\n\n``` js\nVue.directive('color-swatch', function (el, binding) {\n  el.style.backgroundColor = binding.value\n})\n```\n\n## Object Literals\n\nIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.\n\n``` html\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\n```\n\n``` js\nVue.directive('demo', function (el, binding) {\n  console.log(binding.value.color) // => \"white\"\n  console.log(binding.value.text)  // => \"hello!\"\n})\n```\n","source":"v2/guide/custom-directive.md","raw":"---\ntitle: Custom Directives\ntype: guide\norder: 302\n---\n\n## Intro\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/create-vuejs-directive?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Custom Directives lesson\">Watch a free video lesson on Vue School</a></div>\n\nIn addition to the default set of directives shipped in core (`v-model` and `v-show`), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:\n\n{% raw %}\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus>\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n{% endraw %}\n\nWhen the page loads, that element gains focus (note: `autofocus` doesn't work on mobile Safari). In fact, if you haven't clicked on anything else since visiting this page, the input above should be focused now. Now let's build the directive that accomplishes this:\n\n``` js\n// Register a global custom directive called `v-focus`\nVue.directive('focus', {\n  // When the bound element is inserted into the DOM...\n  inserted: function (el) {\n    // Focus the element\n    el.focus()\n  }\n})\n```\n\nIf you want to register a directive locally instead, components also accept a `directives` option:\n\n``` js\ndirectives: {\n  focus: {\n    // directive definition\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n\nThen in a template, you can use the new `v-focus` attribute on any element, like this:\n\n``` html\n<input v-focus>\n```\n\n## Hook Functions\n\nA directive definition object can provide several hook functions (all optional):\n\n- `bind`: called only once, when the directive is first bound to the element. This is where you can do one-time setup work.\n\n- `inserted`: called when the bound element has been inserted into its parent node (this only guarantees parent node presence, not necessarily in-document).\n\n- `update`: called after the containing component's VNode has updated, __but possibly before its children have updated__. The directive's value may or may not have changed, but you can skip unnecessary updates by comparing the binding's current and old values (see below on hook arguments).\n\n<p class=\"tip\">We'll cover VNodes in more detail [later](./render-function.html#The-Virtual-DOM), when we discuss [render functions](./render-function.html).</p>\n\n- `componentUpdated`: called after the containing component's VNode __and the VNodes of its children__ have updated.\n\n- `unbind`: called only once, when the directive is unbound from the element.\n\nWe'll explore the arguments passed into these hooks (i.e. `el`, `binding`, `vnode`, and `oldVnode`) in the next section.\n\n## Directive Hook Arguments\n\nDirective hooks are passed these arguments:\n\n- `el`: The element the directive is bound to. This can be used to directly manipulate the DOM.\n- `binding`: An object containing the following properties.\n  - `name`: The name of the directive, without the `v-` prefix.\n  - `value`: The value passed to the directive. For example in `v-my-directive=\"1 + 1\"`, the value would be `2`.\n  - `oldValue`: The previous value, only available in `update` and `componentUpdated`. It is available whether or not the value has changed.\n  - `expression`: The expression of the binding as a string. For example in `v-my-directive=\"1 + 1\"`, the expression would be `\"1 + 1\"`.\n  - `arg`: The argument passed to the directive, if any. For example in `v-my-directive:foo`, the arg would be `\"foo\"`.\n  - `modifiers`: An object containing modifiers, if any. For example in `v-my-directive.foo.bar`, the modifiers object would be `{ foo: true, bar: true }`.\n- `vnode`: The virtual node produced by Vue's compiler. See the [VNode API](../api/#VNode-Interface) for full details.\n- `oldVnode`: The previous virtual node, only available in the `update` and `componentUpdated` hooks.\n\n<p class=\"tip\">Apart from `el`, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element's [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset).</p>\n\nAn example of a custom directive using some of these properties:\n\n``` html\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n```\n\n``` js\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\n\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n```\n\n{% raw %}\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n{% endraw %}\n\n### Dynamic Directive Arguments\n\nDirective arguments can be dynamic. For example, in `v-mydirective:[argument]=\"value\"`, the `argument` can be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application.\n\nLet's say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:\n\n```html\n<div id=\"baseexample\">\n  <p>Scroll down the page</p>\n  <p v-pin=\"200\">Stick me 200px from the top of the page</p>\n</div>\n```\n\n```js\nVue.directive('pin', {\n  bind: function (el, binding, vnode) {\n    el.style.position = 'fixed'\n    el.style.top = binding.value + 'px'\n  }\n})\n\nnew Vue({\n  el: '#baseexample'\n})\n```\n\nThis would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here's where a dynamic argument that can be updated per component instance comes in very handy:\n\n\n```html\n<div id=\"dynamicexample\">\n  <h3>Scroll down inside this section ↓</h3>\n  <p v-pin:[direction]=\"200\">I am pinned onto the page at 200px to the left.</p>\n</div>\n```\n\n```js\nVue.directive('pin', {\n  bind: function (el, binding, vnode) {\n    el.style.position = 'fixed'\n    var s = (binding.arg == 'left' ? 'left' : 'top')\n    el.style[s] = binding.value + 'px'\n  }\n})\n\nnew Vue({\n  el: '#dynamicexample',\n  data: function () {\n    return {\n      direction: 'left'\n    }\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<iframe height=\"200\" style=\"width: 100%;\" class=\"demo\" scrolling=\"no\" title=\"Dynamic Directive Arguments\" src=\"//codepen.io/team/Vue/embed/rgLLzb/?height=300&theme-id=32763&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href='https://codepen.io/team/Vue/pen/rgLLzb/'>Dynamic Directive Arguments</a> by Vue\n  (<a href='https://codepen.io/Vue'>@Vue</a>) on <a href='https://codepen.io'>CodePen</a>.\n</iframe>\n{% endraw %}\n\nOur custom directive is now flexible enough to support a few different use cases.\n\n## Function Shorthand\n\nIn many cases, you may want the same behavior on `bind` and `update`, but don't care about the other hooks. For example:\n\n``` js\nVue.directive('color-swatch', function (el, binding) {\n  el.style.backgroundColor = binding.value\n})\n```\n\n## Object Literals\n\nIf your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.\n\n``` html\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\n```\n\n``` js\nVue.directive('demo', function (el, binding) {\n  console.log(binding.value.color) // => \"white\"\n  console.log(binding.value.text)  // => \"hello!\"\n})\n```\n","date":"2020-09-25T23:55:41.136Z","updated":"2020-09-25T23:55:41.136Z","path":"v2/guide/custom-directive.html","comments":1,"layout":"page","_id":"ckfl66gyj0021c2v58ss702l8","content":"<h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/create-vuejs-directive?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Custom Directives lesson\">Watch a free video lesson on Vue School</a></div>\n\n<p>In addition to the default set of directives shipped in core (<code>v-model</code> and <code>v-show</code>), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</p>\n\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus>\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n\n<p>When the page loads, that element gains focus (note: <code>autofocus</code> doesn’t work on mobile Safari). In fact, if you haven’t clicked on anything else since visiting this page, the input above should be focused now. Now let’s build the directive that accomplishes this:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Register a global custom directive called `v-focus`</span>\nVue.directive(<span class=\"hljs-string\">'focus'</span>, &#123;\n  <span class=\"hljs-comment\">// When the bound element is inserted into the DOM...</span>\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n    <span class=\"hljs-comment\">// Focus the element</span>\n    el.focus()\n  &#125;\n&#125;)</code></pre>\n<p>If you want to register a directive locally instead, components also accept a <code>directives</code> option:</p>\n<pre><code class=\"hljs js\">directives: &#123;\n  <span class=\"hljs-attr\">focus</span>: &#123;\n    <span class=\"hljs-comment\">// directive definition</span>\n    <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n      el.focus()\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>Then in a template, you can use the new <code>v-focus</code> attribute on any element, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-focus</span>&gt;</span></code></pre>\n<h2 id=\"Hook-Functions\"><a href=\"#Hook-Functions\" class=\"headerlink\" title=\"Hook Functions\"></a>Hook Functions</h2><p>A directive definition object can provide several hook functions (all optional):</p>\n<ul>\n<li><p><code>bind</code>: called only once, when the directive is first bound to the element. This is where you can do one-time setup work.</p>\n</li>\n<li><p><code>inserted</code>: called when the bound element has been inserted into its parent node (this only guarantees parent node presence, not necessarily in-document).</p>\n</li>\n<li><p><code>update</code>: called after the containing component’s VNode has updated, <strong>but possibly before its children have updated</strong>. The directive’s value may or may not have changed, but you can skip unnecessary updates by comparing the binding’s current and old values (see below on hook arguments).</p>\n</li>\n</ul>\n<p class=\"tip\">We’ll cover VNodes in more detail <a href=\"./render-function.html#The-Virtual-DOM\">later</a>, when we discuss <a href=\"./render-function.html\">render functions</a>.</p>\n\n<ul>\n<li><p><code>componentUpdated</code>: called after the containing component’s VNode <strong>and the VNodes of its children</strong> have updated.</p>\n</li>\n<li><p><code>unbind</code>: called only once, when the directive is unbound from the element.</p>\n</li>\n</ul>\n<p>We’ll explore the arguments passed into these hooks (i.e. <code>el</code>, <code>binding</code>, <code>vnode</code>, and <code>oldVnode</code>) in the next section.</p>\n<h2 id=\"Directive-Hook-Arguments\"><a href=\"#Directive-Hook-Arguments\" class=\"headerlink\" title=\"Directive Hook Arguments\"></a>Directive Hook Arguments</h2><p>Directive hooks are passed these arguments:</p>\n<ul>\n<li><code>el</code>: The element the directive is bound to. This can be used to directly manipulate the DOM.</li>\n<li><code>binding</code>: An object containing the following properties.<ul>\n<li><code>name</code>: The name of the directive, without the <code>v-</code> prefix.</li>\n<li><code>value</code>: The value passed to the directive. For example in <code>v-my-directive=&quot;1 + 1&quot;</code>, the value would be <code>2</code>.</li>\n<li><code>oldValue</code>: The previous value, only available in <code>update</code> and <code>componentUpdated</code>. It is available whether or not the value has changed.</li>\n<li><code>expression</code>: The expression of the binding as a string. For example in <code>v-my-directive=&quot;1 + 1&quot;</code>, the expression would be <code>&quot;1 + 1&quot;</code>.</li>\n<li><code>arg</code>: The argument passed to the directive, if any. For example in <code>v-my-directive:foo</code>, the arg would be <code>&quot;foo&quot;</code>.</li>\n<li><code>modifiers</code>: An object containing modifiers, if any. For example in <code>v-my-directive.foo.bar</code>, the modifiers object would be <code>{ foo: true, bar: true }</code>.</li>\n</ul>\n</li>\n<li><code>vnode</code>: The virtual node produced by Vue’s compiler. See the <a href=\"../api/#VNode-Interface\">VNode API</a> for full details.</li>\n<li><code>oldVnode</code>: The previous virtual node, only available in the <code>update</code> and <code>componentUpdated</code> hooks.</li>\n</ul>\n<p class=\"tip\">Apart from <code>el</code>, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\" target=\"_blank\" rel=\"noopener\">dataset</a>.</p>\n\n<p>An example of a custom directive using some of these properties:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"hook-arguments-example\"</span> <span class=\"hljs-attr\">v-demo:foo.a.b</span>=<span class=\"hljs-string\">\"message\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'demo'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding, vnode</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-built_in\">JSON</span>.stringify\n    el.innerHTML =\n      <span class=\"hljs-string\">'name: '</span>       + s(binding.name) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'value: '</span>      + s(binding.value) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'expression: '</span> + s(binding.expression) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'argument: '</span>   + s(binding.arg) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'modifiers: '</span>  + s(binding.modifiers) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'vnode keys: '</span> + <span class=\"hljs-built_in\">Object</span>.keys(vnode).join(<span class=\"hljs-string\">', '</span>)\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#hook-arguments-example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'hello!'</span>\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n\n<h3 id=\"Dynamic-Directive-Arguments\"><a href=\"#Dynamic-Directive-Arguments\" class=\"headerlink\" title=\"Dynamic Directive Arguments\"></a>Dynamic Directive Arguments</h3><p>Directive arguments can be dynamic. For example, in <code>v-mydirective:[argument]=&quot;value&quot;</code>, the <code>argument</code> can be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application.</p>\n<p>Let’s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"baseexample\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Scroll down the page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-pin</span>=<span class=\"hljs-string\">\"200\"</span>&gt;</span>Stick me 200px from the top of the page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'pin'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding, vnode</span>) </span>&#123;\n    el.style.position = <span class=\"hljs-string\">'fixed'</span>\n    el.style.top = binding.value + <span class=\"hljs-string\">'px'</span>\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#baseexample'</span>\n&#125;)</code></pre>\n<p>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here’s where a dynamic argument that can be updated per component instance comes in very handy:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"dynamicexample\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>Scroll down inside this section ↓<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-pin:</span>[<span class=\"hljs-attr\">direction</span>]=<span class=\"hljs-string\">\"200\"</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'pin'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding, vnode</span>) </span>&#123;\n    el.style.position = <span class=\"hljs-string\">'fixed'</span>\n    <span class=\"hljs-keyword\">var</span> s = (binding.arg == <span class=\"hljs-string\">'left'</span> ? <span class=\"hljs-string\">'left'</span> : <span class=\"hljs-string\">'top'</span>)\n    el.style[s] = binding.value + <span class=\"hljs-string\">'px'</span>\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#dynamicexample'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">direction</span>: <span class=\"hljs-string\">'left'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<iframe height=\"200\" style=\"width: 100%;\" class=\"demo\" scrolling=\"no\" title=\"Dynamic Directive Arguments\" src=\"//codepen.io/team/Vue/embed/rgLLzb/?height=300&theme-id=32763&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/team/Vue/pen/rgLLzb/\" target=\"_blank\" rel=\"noopener\">Dynamic Directive Arguments</a> by Vue\n  (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.\n</iframe>\n\n<p>Our custom directive is now flexible enough to support a few different use cases.</p>\n<h2 id=\"Function-Shorthand\"><a href=\"#Function-Shorthand\" class=\"headerlink\" title=\"Function Shorthand\"></a>Function Shorthand</h2><p>In many cases, you may want the same behavior on <code>bind</code> and <code>update</code>, but don’t care about the other hooks. For example:</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'color-swatch'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n  el.style.backgroundColor = binding.value\n&#125;)</code></pre>\n<h2 id=\"Object-Literals\"><a href=\"#Object-Literals\" class=\"headerlink\" title=\"Object Literals\"></a>Object Literals</h2><p>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-demo</span>=<span class=\"hljs-string\">\"&#123; color: 'white', text: 'hello!' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'demo'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(binding.value.color) <span class=\"hljs-comment\">// =&gt; \"white\"</span>\n  <span class=\"hljs-built_in\">console</span>.log(binding.value.text)  <span class=\"hljs-comment\">// =&gt; \"hello!\"</span>\n&#125;)</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Intro\"><a href=\"#Intro\" class=\"headerlink\" title=\"Intro\"></a>Intro</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/create-vuejs-directive?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Custom Directives lesson\">Watch a free video lesson on Vue School</a></div>\n\n<p>In addition to the default set of directives shipped in core (<code>v-model</code> and <code>v-show</code>), Vue also allows you to register your own custom directives. Note that in Vue 2.0, the primary form of code reuse and abstraction is components - however there may be cases where you need some low-level DOM access on plain elements, and this is where custom directives would still be useful. An example would be focusing on an input element, like this one:</p>\n\n<div id=\"simplest-directive-example\" class=\"demo\">\n  <input v-focus>\n</div>\n<script>\nVue.directive('focus', {\n  inserted: function (el) {\n    el.focus()\n  }\n})\nnew Vue({\n  el: '#simplest-directive-example'\n})\n</script>\n\n<p>When the page loads, that element gains focus (note: <code>autofocus</code> doesn’t work on mobile Safari). In fact, if you haven’t clicked on anything else since visiting this page, the input above should be focused now. Now let’s build the directive that accomplishes this:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Register a global custom directive called `v-focus`</span>\nVue.directive(<span class=\"hljs-string\">'focus'</span>, &#123;\n  <span class=\"hljs-comment\">// When the bound element is inserted into the DOM...</span>\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n    <span class=\"hljs-comment\">// Focus the element</span>\n    el.focus()\n  &#125;\n&#125;)</code></pre>\n<p>If you want to register a directive locally instead, components also accept a <code>directives</code> option:</p>\n<pre><code class=\"hljs js\">directives: &#123;\n  <span class=\"hljs-attr\">focus</span>: &#123;\n    <span class=\"hljs-comment\">// directive definition</span>\n    <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n      el.focus()\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>Then in a template, you can use the new <code>v-focus</code> attribute on any element, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-focus</span>&gt;</span></code></pre>\n<h2 id=\"Hook-Functions\"><a href=\"#Hook-Functions\" class=\"headerlink\" title=\"Hook Functions\"></a>Hook Functions</h2><p>A directive definition object can provide several hook functions (all optional):</p>\n<ul>\n<li><p><code>bind</code>: called only once, when the directive is first bound to the element. This is where you can do one-time setup work.</p>\n</li>\n<li><p><code>inserted</code>: called when the bound element has been inserted into its parent node (this only guarantees parent node presence, not necessarily in-document).</p>\n</li>\n<li><p><code>update</code>: called after the containing component’s VNode has updated, <strong>but possibly before its children have updated</strong>. The directive’s value may or may not have changed, but you can skip unnecessary updates by comparing the binding’s current and old values (see below on hook arguments).</p>\n</li>\n</ul>\n<p class=\"tip\">We’ll cover VNodes in more detail <a href=\"./render-function.html#The-Virtual-DOM\">later</a>, when we discuss <a href=\"./render-function.html\">render functions</a>.</p>\n\n<ul>\n<li><p><code>componentUpdated</code>: called after the containing component’s VNode <strong>and the VNodes of its children</strong> have updated.</p>\n</li>\n<li><p><code>unbind</code>: called only once, when the directive is unbound from the element.</p>\n</li>\n</ul>\n<p>We’ll explore the arguments passed into these hooks (i.e. <code>el</code>, <code>binding</code>, <code>vnode</code>, and <code>oldVnode</code>) in the next section.</p>\n<h2 id=\"Directive-Hook-Arguments\"><a href=\"#Directive-Hook-Arguments\" class=\"headerlink\" title=\"Directive Hook Arguments\"></a>Directive Hook Arguments</h2><p>Directive hooks are passed these arguments:</p>\n<ul>\n<li><code>el</code>: The element the directive is bound to. This can be used to directly manipulate the DOM.</li>\n<li><code>binding</code>: An object containing the following properties.<ul>\n<li><code>name</code>: The name of the directive, without the <code>v-</code> prefix.</li>\n<li><code>value</code>: The value passed to the directive. For example in <code>v-my-directive=&quot;1 + 1&quot;</code>, the value would be <code>2</code>.</li>\n<li><code>oldValue</code>: The previous value, only available in <code>update</code> and <code>componentUpdated</code>. It is available whether or not the value has changed.</li>\n<li><code>expression</code>: The expression of the binding as a string. For example in <code>v-my-directive=&quot;1 + 1&quot;</code>, the expression would be <code>&quot;1 + 1&quot;</code>.</li>\n<li><code>arg</code>: The argument passed to the directive, if any. For example in <code>v-my-directive:foo</code>, the arg would be <code>&quot;foo&quot;</code>.</li>\n<li><code>modifiers</code>: An object containing modifiers, if any. For example in <code>v-my-directive.foo.bar</code>, the modifiers object would be <code>{ foo: true, bar: true }</code>.</li>\n</ul>\n</li>\n<li><code>vnode</code>: The virtual node produced by Vue’s compiler. See the <a href=\"../api/#VNode-Interface\">VNode API</a> for full details.</li>\n<li><code>oldVnode</code>: The previous virtual node, only available in the <code>update</code> and <code>componentUpdated</code> hooks.</li>\n</ul>\n<p class=\"tip\">Apart from <code>el</code>, you should treat these arguments as read-only and never modify them. If you need to share information across hooks, it is recommended to do so through element’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset\" target=\"_blank\" rel=\"noopener\">dataset</a>.</p>\n\n<p>An example of a custom directive using some of these properties:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"hook-arguments-example\"</span> <span class=\"hljs-attr\">v-demo:foo.a.b</span>=<span class=\"hljs-string\">\"message\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'demo'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding, vnode</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-built_in\">JSON</span>.stringify\n    el.innerHTML =\n      <span class=\"hljs-string\">'name: '</span>       + s(binding.name) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'value: '</span>      + s(binding.value) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'expression: '</span> + s(binding.expression) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'argument: '</span>   + s(binding.arg) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'modifiers: '</span>  + s(binding.modifiers) + <span class=\"hljs-string\">'&lt;br&gt;'</span> +\n      <span class=\"hljs-string\">'vnode keys: '</span> + <span class=\"hljs-built_in\">Object</span>.keys(vnode).join(<span class=\"hljs-string\">', '</span>)\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#hook-arguments-example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'hello!'</span>\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\" class=\"demo\"></div>\n<script>\nVue.directive('demo', {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify\n    el.innerHTML =\n      'name: '       + s(binding.name) + '<br>' +\n      'value: '      + s(binding.value) + '<br>' +\n      'expression: ' + s(binding.expression) + '<br>' +\n      'argument: '   + s(binding.arg) + '<br>' +\n      'modifiers: '  + s(binding.modifiers) + '<br>' +\n      'vnode keys: ' + Object.keys(vnode).join(', ')\n  }\n})\nnew Vue({\n  el: '#hook-arguments-example',\n  data: {\n    message: 'hello!'\n  }\n})\n</script>\n\n<h3 id=\"Dynamic-Directive-Arguments\"><a href=\"#Dynamic-Directive-Arguments\" class=\"headerlink\" title=\"Dynamic Directive Arguments\"></a>Dynamic Directive Arguments</h3><p>Directive arguments can be dynamic. For example, in <code>v-mydirective:[argument]=&quot;value&quot;</code>, the <code>argument</code> can be updated based on data properties in our component instance! This makes our custom directives flexible for use throughout our application.</p>\n<p>Let’s say you want to make a custom directive that allows you to pin elements to your page using fixed positioning. We could create a custom directive where the value updates the vertical positioning in pixels, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"baseexample\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Scroll down the page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-pin</span>=<span class=\"hljs-string\">\"200\"</span>&gt;</span>Stick me 200px from the top of the page<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'pin'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding, vnode</span>) </span>&#123;\n    el.style.position = <span class=\"hljs-string\">'fixed'</span>\n    el.style.top = binding.value + <span class=\"hljs-string\">'px'</span>\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#baseexample'</span>\n&#125;)</code></pre>\n<p>This would pin the element 200px from the top of the page. But what happens if we run into a scenario when we need to pin the element from the left, instead of the top? Here’s where a dynamic argument that can be updated per component instance comes in very handy:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"dynamicexample\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>Scroll down inside this section ↓<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-pin:</span>[<span class=\"hljs-attr\">direction</span>]=<span class=\"hljs-string\">\"200\"</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'pin'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding, vnode</span>) </span>&#123;\n    el.style.position = <span class=\"hljs-string\">'fixed'</span>\n    <span class=\"hljs-keyword\">var</span> s = (binding.arg == <span class=\"hljs-string\">'left'</span> ? <span class=\"hljs-string\">'left'</span> : <span class=\"hljs-string\">'top'</span>)\n    el.style[s] = binding.value + <span class=\"hljs-string\">'px'</span>\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#dynamicexample'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">direction</span>: <span class=\"hljs-string\">'left'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<iframe height=\"200\" style=\"width: 100%;\" class=\"demo\" scrolling=\"no\" title=\"Dynamic Directive Arguments\" src=\"//codepen.io/team/Vue/embed/rgLLzb/?height=300&theme-id=32763&default-tab=result\" frameborder=\"no\" allowtransparency=\"true\" allowfullscreen=\"true\">\n  See the Pen <a href=\"https://codepen.io/team/Vue/pen/rgLLzb/\" target=\"_blank\" rel=\"noopener\">Dynamic Directive Arguments</a> by Vue\n  (<a href=\"https://codepen.io/Vue\" target=\"_blank\" rel=\"noopener\">@Vue</a>) on <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener\">CodePen</a>.\n</iframe>\n\n<p>Our custom directive is now flexible enough to support a few different use cases.</p>\n<h2 id=\"Function-Shorthand\"><a href=\"#Function-Shorthand\" class=\"headerlink\" title=\"Function Shorthand\"></a>Function Shorthand</h2><p>In many cases, you may want the same behavior on <code>bind</code> and <code>update</code>, but don’t care about the other hooks. For example:</p>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'color-swatch'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n  el.style.backgroundColor = binding.value\n&#125;)</code></pre>\n<h2 id=\"Object-Literals\"><a href=\"#Object-Literals\" class=\"headerlink\" title=\"Object Literals\"></a>Object Literals</h2><p>If your directive needs multiple values, you can also pass in a JavaScript object literal. Remember, directives can take any valid JavaScript expression.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-demo</span>=<span class=\"hljs-string\">\"&#123; color: 'white', text: 'hello!' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.directive(<span class=\"hljs-string\">'demo'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el, binding</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(binding.value.color) <span class=\"hljs-comment\">// =&gt; \"white\"</span>\n  <span class=\"hljs-built_in\">console</span>.log(binding.value.text)  <span class=\"hljs-comment\">// =&gt; \"hello!\"</span>\n&#125;)</code></pre>\n"},{"title":"Computed Properties and Watchers","type":"guide","order":5,"_content":"\n## Computed Properties\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-computed-properties?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how computed properties work with Vue School\">Learn how computed properties work with a free lesson on Vue School</a></div>\n\nIn-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:\n\n``` html\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n\nAt this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays `message` in reverse. The problem is made worse when you want to include the reversed message in your template more than once.\n\nThat's why for any complex logic, you should use a **computed property**.\n\n### Basic Example\n\n``` html\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<div id=\"example\" class=\"demo\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    reversedMessage: function () {\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n{% endraw %}\n\nHere we have declared a computed property `reversedMessage`. The function we provided will be used as the getter function for the property `vm.reversedMessage`:\n\n``` js\nconsole.log(vm.reversedMessage) // => 'olleH'\nvm.message = 'Goodbye'\nconsole.log(vm.reversedMessage) // => 'eybdooG'\n```\n\nYou can open the console and play with the example vm yourself. The value of `vm.reversedMessage` is always dependent on the value of `vm.message`.\n\nYou can data-bind to computed properties in templates just like a normal property. Vue is aware that `vm.reversedMessage` depends on `vm.message`, so it will update any bindings that depend on `vm.reversedMessage` when `vm.message` changes. And the best part is that we've created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.\n\n### Computed Caching vs Methods\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\n``` html\n<p>Reversed message: \"{{ reverseMessage() }}\"</p>\n```\n\n``` js\n// in component\nmethods: {\n  reverseMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that **computed properties are cached based on their reactive dependencies.** A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as `message` has not changed, multiple access to the `reversedMessage` computed property will immediately return the previously computed result without having to run the function again.\n\nThis also means the following computed property will never update, because `Date.now()` is not a reactive dependency:\n\n``` js\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\nIn comparison, a method invocation will **always** run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property **A**, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on **A**. Without caching, we would be executing **A**’s getter many more times than necessary! In cases where you do not want caching, use a method instead.\n\n### Computed vs Watched Property\n\nVue does provide a more generic way to observe and react to data changes on a Vue instance: **watch properties**. When you have some data that needs to change based on some other data, it is tempting to overuse `watch` - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative `watch` callback. Consider this example:\n\n``` html\n<div id=\"demo\">{{ fullName }}</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n```\n\nThe above code is imperative and repetitive. Compare it with a computed property version:\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n\nMuch better, isn't it?\n\n### Computed Setter\n\nComputed properties are by default getter-only, but you can also provide a setter when you need it:\n\n``` js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n\nNow when you run `vm.fullName = 'John Doe'`, the setter will be invoked and `vm.firstName` and `vm.lastName` will be updated accordingly.\n\n## Watchers\n\nWhile computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That's why Vue provides a more generic way to react to data changes through the `watch` option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.\n\nFor example:\n\n``` html\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n```\n\n``` html\n<!-- Since there is already a rich ecosystem of ajax libraries    -->\n<!-- and collections of general-purpose utility methods, Vue core -->\n<!-- is able to remain small by not reinventing them. This also   -->\n<!-- gives you the freedom to use what you're familiar with.      -->\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // whenever question changes, this function will run\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    // _.debounce is a function provided by lodash to limit how\n    // often a particularly expensive operation can be run.\n    // In this case, we want to limit how often we access\n    // yesno.wtf/api, waiting until the user has completely\n    // finished typing before making the ajax request. To learn\n    // more about the _.debounce function (and its cousin\n    // _.throttle), visit: https://lodash.com/docs#debounce\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n```\n\nResult:\n\n{% raw %}\n<div id=\"watch-example\" class=\"demo\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n{% endraw %}\n\nIn this case, using the `watch` option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.\n\nIn addition to the `watch` option, you can also use the imperative [vm.$watch API](../api/#vm-watch).\n","source":"v2/guide/computed.md","raw":"---\ntitle: Computed Properties and Watchers\ntype: guide\norder: 5\n---\n\n## Computed Properties\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-computed-properties?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how computed properties work with Vue School\">Learn how computed properties work with a free lesson on Vue School</a></div>\n\nIn-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:\n\n``` html\n<div id=\"example\">\n  {{ message.split('').reverse().join('') }}\n</div>\n```\n\nAt this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays `message` in reverse. The problem is made worse when you want to include the reversed message in your template more than once.\n\nThat's why for any complex logic, you should use a **computed property**.\n\n### Basic Example\n\n``` html\n<div id=\"example\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    // a computed getter\n    reversedMessage: function () {\n      // `this` points to the vm instance\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<div id=\"example\" class=\"demo\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    reversedMessage: function () {\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n{% endraw %}\n\nHere we have declared a computed property `reversedMessage`. The function we provided will be used as the getter function for the property `vm.reversedMessage`:\n\n``` js\nconsole.log(vm.reversedMessage) // => 'olleH'\nvm.message = 'Goodbye'\nconsole.log(vm.reversedMessage) // => 'eybdooG'\n```\n\nYou can open the console and play with the example vm yourself. The value of `vm.reversedMessage` is always dependent on the value of `vm.message`.\n\nYou can data-bind to computed properties in templates just like a normal property. Vue is aware that `vm.reversedMessage` depends on `vm.message`, so it will update any bindings that depend on `vm.reversedMessage` when `vm.message` changes. And the best part is that we've created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.\n\n### Computed Caching vs Methods\n\nYou may have noticed we can achieve the same result by invoking a method in the expression:\n\n``` html\n<p>Reversed message: \"{{ reverseMessage() }}\"</p>\n```\n\n``` js\n// in component\nmethods: {\n  reverseMessage: function () {\n    return this.message.split('').reverse().join('')\n  }\n}\n```\n\nInstead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that **computed properties are cached based on their reactive dependencies.** A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as `message` has not changed, multiple access to the `reversedMessage` computed property will immediately return the previously computed result without having to run the function again.\n\nThis also means the following computed property will never update, because `Date.now()` is not a reactive dependency:\n\n``` js\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n```\n\nIn comparison, a method invocation will **always** run the function whenever a re-render happens.\n\nWhy do we need caching? Imagine we have an expensive computed property **A**, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on **A**. Without caching, we would be executing **A**’s getter many more times than necessary! In cases where you do not want caching, use a method instead.\n\n### Computed vs Watched Property\n\nVue does provide a more generic way to observe and react to data changes on a Vue instance: **watch properties**. When you have some data that needs to change based on some other data, it is tempting to overuse `watch` - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative `watch` callback. Consider this example:\n\n``` html\n<div id=\"demo\">{{ fullName }}</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar',\n    fullName: 'Foo Bar'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n})\n```\n\nThe above code is imperative and repetitive. Compare it with a computed property version:\n\n``` js\nvar vm = new Vue({\n  el: '#demo',\n  data: {\n    firstName: 'Foo',\n    lastName: 'Bar'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n})\n```\n\nMuch better, isn't it?\n\n### Computed Setter\n\nComputed properties are by default getter-only, but you can also provide a setter when you need it:\n\n``` js\n// ...\ncomputed: {\n  fullName: {\n    // getter\n    get: function () {\n      return this.firstName + ' ' + this.lastName\n    },\n    // setter\n    set: function (newValue) {\n      var names = newValue.split(' ')\n      this.firstName = names[0]\n      this.lastName = names[names.length - 1]\n    }\n  }\n}\n// ...\n```\n\nNow when you run `vm.fullName = 'John Doe'`, the setter will be invoked and `vm.firstName` and `vm.lastName` will be updated accordingly.\n\n## Watchers\n\nWhile computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That's why Vue provides a more generic way to react to data changes through the `watch` option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.\n\nFor example:\n\n``` html\n<div id=\"watch-example\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n```\n\n``` html\n<!-- Since there is already a rich ecosystem of ajax libraries    -->\n<!-- and collections of general-purpose utility methods, Vue core -->\n<!-- is able to remain small by not reinventing them. This also   -->\n<!-- gives you the freedom to use what you're familiar with.      -->\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    // whenever question changes, this function will run\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    // _.debounce is a function provided by lodash to limit how\n    // often a particularly expensive operation can be run.\n    // In this case, we want to limit how often we access\n    // yesno.wtf/api, waiting until the user has completely\n    // finished typing before making the ajax request. To learn\n    // more about the _.debounce function (and its cousin\n    // _.throttle), visit: https://lodash.com/docs#debounce\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n```\n\nResult:\n\n{% raw %}\n<div id=\"watch-example\" class=\"demo\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n{% endraw %}\n\nIn this case, using the `watch` option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.\n\nIn addition to the `watch` option, you can also use the imperative [vm.$watch API](../api/#vm-watch).\n","date":"2020-09-25T23:55:41.135Z","updated":"2020-09-25T23:55:41.135Z","path":"v2/guide/computed.html","comments":1,"layout":"page","_id":"ckfl66gyj0022c2v5oe8sncz8","content":"<h2 id=\"Computed-Properties\"><a href=\"#Computed-Properties\" class=\"headerlink\" title=\"Computed Properties\"></a>Computed Properties</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-computed-properties?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how computed properties work with Vue School\">Learn how computed properties work with a free lesson on Vue School</a></div>\n\n<p>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example\"</span>&gt;</span>\n  &#123;&#123; message.split('').reverse().join('') &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays <code>message</code> in reverse. The problem is made worse when you want to include the reversed message in your template more than once.</p>\n<p>That’s why for any complex logic, you should use a <strong>computed property</strong>.</p>\n<h3 id=\"Basic-Example\"><a href=\"#Basic-Example\" class=\"headerlink\" title=\"Basic Example\"></a>Basic Example</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Original message: \"&#123;&#123; message &#125;&#125;\"<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-comment\">// a computed getter</span>\n    <span class=\"hljs-attr\">reversedMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// `this` points to the vm instance</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.message.split(<span class=\"hljs-string\">''</span>).reverse().join(<span class=\"hljs-string\">''</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<div id=\"example\" class=\"demo\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    reversedMessage: function () {\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n\n<p>Here we have declared a computed property <code>reversedMessage</code>. The function we provided will be used as the getter function for the property <code>vm.reversedMessage</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(vm.reversedMessage) <span class=\"hljs-comment\">// =&gt; 'olleH'</span>\nvm.message = <span class=\"hljs-string\">'Goodbye'</span>\n<span class=\"hljs-built_in\">console</span>.log(vm.reversedMessage) <span class=\"hljs-comment\">// =&gt; 'eybdooG'</span></code></pre>\n<p>You can open the console and play with the example vm yourself. The value of <code>vm.reversedMessage</code> is always dependent on the value of <code>vm.message</code>.</p>\n<p>You can data-bind to computed properties in templates just like a normal property. Vue is aware that <code>vm.reversedMessage</code> depends on <code>vm.message</code>, so it will update any bindings that depend on <code>vm.reversedMessage</code> when <code>vm.message</code> changes. And the best part is that we’ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</p>\n<h3 id=\"Computed-Caching-vs-Methods\"><a href=\"#Computed-Caching-vs-Methods\" class=\"headerlink\" title=\"Computed Caching vs Methods\"></a>Computed Caching vs Methods</h3><p>You may have noticed we can achieve the same result by invoking a method in the expression:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Reversed message: \"&#123;&#123; reverseMessage() &#125;&#125;\"<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// in component</span>\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">reverseMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.message.split(<span class=\"hljs-string\">''</span>).reverse().join(<span class=\"hljs-string\">''</span>)\n  &#125;\n&#125;</code></pre>\n<p>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that <strong>computed properties are cached based on their reactive dependencies.</strong> A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as <code>message</code> has not changed, multiple access to the <code>reversedMessage</code> computed property will immediately return the previously computed result without having to run the function again.</p>\n<p>This also means the following computed property will never update, because <code>Date.now()</code> is not a reactive dependency:</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">now</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()\n  &#125;\n&#125;</code></pre>\n<p>In comparison, a method invocation will <strong>always</strong> run the function whenever a re-render happens.</p>\n<p>Why do we need caching? Imagine we have an expensive computed property <strong>A</strong>, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on <strong>A</strong>. Without caching, we would be executing <strong>A</strong>’s getter many more times than necessary! In cases where you do not want caching, use a method instead.</p>\n<h3 id=\"Computed-vs-Watched-Property\"><a href=\"#Computed-vs-Watched-Property\" class=\"headerlink\" title=\"Computed vs Watched Property\"></a>Computed vs Watched Property</h3><p>Vue does provide a more generic way to observe and react to data changes on a Vue instance: <strong>watch properties</strong>. When you have some data that needs to change based on some other data, it is tempting to overuse <code>watch</code> - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative <code>watch</code> callback. Consider this example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demo\"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Foo'</span>,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Bar'</span>,\n    <span class=\"hljs-attr\">fullName</span>: <span class=\"hljs-string\">'Foo Bar'</span>\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.fullName = val + <span class=\"hljs-string\">' '</span> + <span class=\"hljs-keyword\">this</span>.lastName\n    &#125;,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.fullName = <span class=\"hljs-keyword\">this</span>.firstName + <span class=\"hljs-string\">' '</span> + val\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>The above code is imperative and repetitive. Compare it with a computed property version:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Foo'</span>,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Bar'</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-attr\">fullName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.firstName + <span class=\"hljs-string\">' '</span> + <span class=\"hljs-keyword\">this</span>.lastName\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Much better, isn’t it?</p>\n<h3 id=\"Computed-Setter\"><a href=\"#Computed-Setter\" class=\"headerlink\" title=\"Computed Setter\"></a>Computed Setter</h3><p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">fullName</span>: &#123;\n    <span class=\"hljs-comment\">// getter</span>\n    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.firstName + <span class=\"hljs-string\">' '</span> + <span class=\"hljs-keyword\">this</span>.lastName\n    &#125;,\n    <span class=\"hljs-comment\">// setter</span>\n    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newValue</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> names = newValue.split(<span class=\"hljs-string\">' '</span>)\n      <span class=\"hljs-keyword\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]\n      <span class=\"hljs-keyword\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]\n    &#125;\n  &#125;\n&#125;\n<span class=\"hljs-comment\">// ...</span></code></pre>\n<p>Now when you run <code>vm.fullName = &#39;John Doe&#39;</code>, the setter will be invoked and <code>vm.firstName</code> and <code>vm.lastName</code> will be updated accordingly.</p>\n<h2 id=\"Watchers\"><a href=\"#Watchers\" class=\"headerlink\" title=\"Watchers\"></a>Watchers</h2><p>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That’s why Vue provides a more generic way to react to data changes through the <code>watch</code> option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"watch-example\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    Ask a yes/no question:\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"question\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- gives you the freedom to use what you're familiar with.      --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">var</span> watchExampleVM = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#watch-example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">question</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">answer</span>: <span class=\"hljs-string\">'I cannot give you an answer until you ask a question!'</span>\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-comment\">// whenever question changes, this function will run</span>\n    <span class=\"hljs-attr\">question</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newQuestion, oldQuestion</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.answer = <span class=\"hljs-string\">'Waiting for you to stop typing...'</span>\n      <span class=\"hljs-keyword\">this</span>.debouncedGetAnswer()\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// _.debounce is a function provided by lodash to limit how</span>\n    <span class=\"hljs-comment\">// often a particularly expensive operation can be run.</span>\n    <span class=\"hljs-comment\">// In this case, we want to limit how often we access</span>\n    <span class=\"hljs-comment\">// yesno.wtf/api, waiting until the user has completely</span>\n    <span class=\"hljs-comment\">// finished typing before making the ajax request. To learn</span>\n    <span class=\"hljs-comment\">// more about the _.debounce function (and its cousin</span>\n    <span class=\"hljs-comment\">// _.throttle), visit: https://lodash.com/docs#debounce</span>\n    <span class=\"hljs-keyword\">this</span>.debouncedGetAnswer = _.debounce(<span class=\"hljs-keyword\">this</span>.getAnswer, <span class=\"hljs-number\">500</span>)\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">getAnswer</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.question.indexOf(<span class=\"hljs-string\">'?'</span>) === <span class=\"hljs-number\">-1</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.answer = <span class=\"hljs-string\">'Questions usually contain a question mark. ;-)'</span>\n        <span class=\"hljs-keyword\">return</span>\n      &#125;\n      <span class=\"hljs-keyword\">this</span>.answer = <span class=\"hljs-string\">'Thinking...'</span>\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      axios.get(<span class=\"hljs-string\">'https://yesno.wtf/api'</span>)\n        .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">response</span>) </span>&#123;\n          vm.answer = _.capitalize(response.data.answer)\n        &#125;)\n        .catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) </span>&#123;\n          vm.answer = <span class=\"hljs-string\">'Error! Could not reach the API. '</span> + error\n        &#125;)\n    &#125;\n  &#125;\n&#125;)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>Result:</p>\n\n<div id=\"watch-example\" class=\"demo\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n\n<p>In this case, using the <code>watch</code> option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</p>\n<p>In addition to the <code>watch</code> option, you can also use the imperative <a href=\"../api/#vm-watch\">vm.$watch API</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Computed-Properties\"><a href=\"#Computed-Properties\" class=\"headerlink\" title=\"Computed Properties\"></a>Computed Properties</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-computed-properties?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how computed properties work with Vue School\">Learn how computed properties work with a free lesson on Vue School</a></div>\n\n<p>In-template expressions are very convenient, but they are meant for simple operations. Putting too much logic in your templates can make them bloated and hard to maintain. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example\"</span>&gt;</span>\n  &#123;&#123; message.split('').reverse().join('') &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>At this point, the template is no longer simple and declarative. You have to look at it for a second before realizing that it displays <code>message</code> in reverse. The problem is made worse when you want to include the reversed message in your template more than once.</p>\n<p>That’s why for any complex logic, you should use a <strong>computed property</strong>.</p>\n<h3 id=\"Basic-Example\"><a href=\"#Basic-Example\" class=\"headerlink\" title=\"Basic Example\"></a>Basic Example</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Original message: \"&#123;&#123; message &#125;&#125;\"<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-comment\">// a computed getter</span>\n    <span class=\"hljs-attr\">reversedMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// `this` points to the vm instance</span>\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.message.split(<span class=\"hljs-string\">''</span>).reverse().join(<span class=\"hljs-string\">''</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<div id=\"example\" class=\"demo\">\n  <p>Original message: \"{{ message }}\"</p>\n  <p>Computed reversed message: \"{{ reversedMessage }}\"</p>\n</div>\n<script>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: 'Hello'\n  },\n  computed: {\n    reversedMessage: function () {\n      return this.message.split('').reverse().join('')\n    }\n  }\n})\n</script>\n\n<p>Here we have declared a computed property <code>reversedMessage</code>. The function we provided will be used as the getter function for the property <code>vm.reversedMessage</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">console</span>.log(vm.reversedMessage) <span class=\"hljs-comment\">// =&gt; 'olleH'</span>\nvm.message = <span class=\"hljs-string\">'Goodbye'</span>\n<span class=\"hljs-built_in\">console</span>.log(vm.reversedMessage) <span class=\"hljs-comment\">// =&gt; 'eybdooG'</span></code></pre>\n<p>You can open the console and play with the example vm yourself. The value of <code>vm.reversedMessage</code> is always dependent on the value of <code>vm.message</code>.</p>\n<p>You can data-bind to computed properties in templates just like a normal property. Vue is aware that <code>vm.reversedMessage</code> depends on <code>vm.message</code>, so it will update any bindings that depend on <code>vm.reversedMessage</code> when <code>vm.message</code> changes. And the best part is that we’ve created this dependency relationship declaratively: the computed getter function has no side effects, which makes it easier to test and understand.</p>\n<h3 id=\"Computed-Caching-vs-Methods\"><a href=\"#Computed-Caching-vs-Methods\" class=\"headerlink\" title=\"Computed Caching vs Methods\"></a>Computed Caching vs Methods</h3><p>You may have noticed we can achieve the same result by invoking a method in the expression:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Reversed message: \"&#123;&#123; reverseMessage() &#125;&#125;\"<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// in component</span>\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">reverseMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.message.split(<span class=\"hljs-string\">''</span>).reverse().join(<span class=\"hljs-string\">''</span>)\n  &#125;\n&#125;</code></pre>\n<p>Instead of a computed property, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same. However, the difference is that <strong>computed properties are cached based on their reactive dependencies.</strong> A computed property will only re-evaluate when some of its reactive dependencies have changed. This means as long as <code>message</code> has not changed, multiple access to the <code>reversedMessage</code> computed property will immediately return the previously computed result without having to run the function again.</p>\n<p>This also means the following computed property will never update, because <code>Date.now()</code> is not a reactive dependency:</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">now</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Date</span>.now()\n  &#125;\n&#125;</code></pre>\n<p>In comparison, a method invocation will <strong>always</strong> run the function whenever a re-render happens.</p>\n<p>Why do we need caching? Imagine we have an expensive computed property <strong>A</strong>, which requires looping through a huge Array and doing a lot of computations. Then we may have other computed properties that in turn depend on <strong>A</strong>. Without caching, we would be executing <strong>A</strong>’s getter many more times than necessary! In cases where you do not want caching, use a method instead.</p>\n<h3 id=\"Computed-vs-Watched-Property\"><a href=\"#Computed-vs-Watched-Property\" class=\"headerlink\" title=\"Computed vs Watched Property\"></a>Computed vs Watched Property</h3><p>Vue does provide a more generic way to observe and react to data changes on a Vue instance: <strong>watch properties</strong>. When you have some data that needs to change based on some other data, it is tempting to overuse <code>watch</code> - especially if you are coming from an AngularJS background. However, it is often a better idea to use a computed property rather than an imperative <code>watch</code> callback. Consider this example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"demo\"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Foo'</span>,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Bar'</span>,\n    <span class=\"hljs-attr\">fullName</span>: <span class=\"hljs-string\">'Foo Bar'</span>\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.fullName = val + <span class=\"hljs-string\">' '</span> + <span class=\"hljs-keyword\">this</span>.lastName\n    &#125;,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.fullName = <span class=\"hljs-keyword\">this</span>.firstName + <span class=\"hljs-string\">' '</span> + val\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>The above code is imperative and repetitive. Compare it with a computed property version:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Foo'</span>,\n    <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'Bar'</span>\n  &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-attr\">fullName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.firstName + <span class=\"hljs-string\">' '</span> + <span class=\"hljs-keyword\">this</span>.lastName\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Much better, isn’t it?</p>\n<h3 id=\"Computed-Setter\"><a href=\"#Computed-Setter\" class=\"headerlink\" title=\"Computed Setter\"></a>Computed Setter</h3><p>Computed properties are by default getter-only, but you can also provide a setter when you need it:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">fullName</span>: &#123;\n    <span class=\"hljs-comment\">// getter</span>\n    <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.firstName + <span class=\"hljs-string\">' '</span> + <span class=\"hljs-keyword\">this</span>.lastName\n    &#125;,\n    <span class=\"hljs-comment\">// setter</span>\n    <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newValue</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> names = newValue.split(<span class=\"hljs-string\">' '</span>)\n      <span class=\"hljs-keyword\">this</span>.firstName = names[<span class=\"hljs-number\">0</span>]\n      <span class=\"hljs-keyword\">this</span>.lastName = names[names.length - <span class=\"hljs-number\">1</span>]\n    &#125;\n  &#125;\n&#125;\n<span class=\"hljs-comment\">// ...</span></code></pre>\n<p>Now when you run <code>vm.fullName = &#39;John Doe&#39;</code>, the setter will be invoked and <code>vm.firstName</code> and <code>vm.lastName</code> will be updated accordingly.</p>\n<h2 id=\"Watchers\"><a href=\"#Watchers\" class=\"headerlink\" title=\"Watchers\"></a>Watchers</h2><p>While computed properties are more appropriate in most cases, there are times when a custom watcher is necessary. That’s why Vue provides a more generic way to react to data changes through the <code>watch</code> option. This is most useful when you want to perform asynchronous or expensive operations in response to changing data.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"watch-example\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>\n    Ask a yes/no question:\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"question\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Since there is already a rich ecosystem of ajax libraries    --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- and collections of general-purpose utility methods, Vue core --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- is able to remain small by not reinventing them. This also   --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- gives you the freedom to use what you're familiar with.      --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">var</span> watchExampleVM = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#watch-example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">question</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">answer</span>: <span class=\"hljs-string\">'I cannot give you an answer until you ask a question!'</span>\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-comment\">// whenever question changes, this function will run</span>\n    <span class=\"hljs-attr\">question</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newQuestion, oldQuestion</span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.answer = <span class=\"hljs-string\">'Waiting for you to stop typing...'</span>\n      <span class=\"hljs-keyword\">this</span>.debouncedGetAnswer()\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// _.debounce is a function provided by lodash to limit how</span>\n    <span class=\"hljs-comment\">// often a particularly expensive operation can be run.</span>\n    <span class=\"hljs-comment\">// In this case, we want to limit how often we access</span>\n    <span class=\"hljs-comment\">// yesno.wtf/api, waiting until the user has completely</span>\n    <span class=\"hljs-comment\">// finished typing before making the ajax request. To learn</span>\n    <span class=\"hljs-comment\">// more about the _.debounce function (and its cousin</span>\n    <span class=\"hljs-comment\">// _.throttle), visit: https://lodash.com/docs#debounce</span>\n    <span class=\"hljs-keyword\">this</span>.debouncedGetAnswer = _.debounce(<span class=\"hljs-keyword\">this</span>.getAnswer, <span class=\"hljs-number\">500</span>)\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">getAnswer</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.question.indexOf(<span class=\"hljs-string\">'?'</span>) === <span class=\"hljs-number\">-1</span>) &#123;\n        <span class=\"hljs-keyword\">this</span>.answer = <span class=\"hljs-string\">'Questions usually contain a question mark. ;-)'</span>\n        <span class=\"hljs-keyword\">return</span>\n      &#125;\n      <span class=\"hljs-keyword\">this</span>.answer = <span class=\"hljs-string\">'Thinking...'</span>\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      axios.get(<span class=\"hljs-string\">'https://yesno.wtf/api'</span>)\n        .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">response</span>) </span>&#123;\n          vm.answer = _.capitalize(response.data.answer)\n        &#125;)\n        .catch(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">error</span>) </span>&#123;\n          vm.answer = <span class=\"hljs-string\">'Error! Could not reach the API. '</span> + error\n        &#125;)\n    &#125;\n  &#125;\n&#125;)\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>Result:</p>\n\n<div id=\"watch-example\" class=\"demo\">\n  <p>\n    Ask a yes/no question:\n    <input v-model=\"question\">\n  </p>\n  <p>{{ answer }}</p>\n</div>\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"></script>\n<script>\nvar watchExampleVM = new Vue({\n  el: '#watch-example',\n  data: {\n    question: '',\n    answer: 'I cannot give you an answer until you ask a question!'\n  },\n  watch: {\n    question: function (newQuestion, oldQuestion) {\n      this.answer = 'Waiting for you to stop typing...'\n      this.debouncedGetAnswer()\n    }\n  },\n  created: function () {\n    this.debouncedGetAnswer = _.debounce(this.getAnswer, 500)\n  },\n  methods: {\n    getAnswer: function () {\n      if (this.question.indexOf('?') === -1) {\n        this.answer = 'Questions usually contain a question mark. ;-)'\n        return\n      }\n      this.answer = 'Thinking...'\n      var vm = this\n      axios.get('https://yesno.wtf/api')\n        .then(function (response) {\n          vm.answer = _.capitalize(response.data.answer)\n        })\n        .catch(function (error) {\n          vm.answer = 'Error! Could not reach the API. ' + error\n        })\n    }\n  }\n})\n</script>\n\n<p>In this case, using the <code>watch</code> option allows us to perform an asynchronous operation (accessing an API), limit how often we perform that operation, and set intermediary states until we get a final answer. None of that would be possible with a computed property.</p>\n<p>In addition to the <code>watch</code> option, you can also use the imperative <a href=\"../api/#vm-watch\">vm.$watch API</a>.</p>\n"},{"title":"Components Basics","type":"guide","order":11,"_content":"\n<div class=\"vueschool\"><a href=\"https://vueschool.io/courses/vuejs-components-fundamentals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Components Fundamentals Course\">Watch a free video course on Vue School</a></div>\n\n## Base Example\n\nHere's an example of a Vue component:\n\n``` js\n// Define a new component called button-counter\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\n```\n\nComponents are reusable Vue instances with a name: in this case, `<button-counter>`. We can use this component as a custom element inside a root Vue instance created with `new Vue`:\n\n```html\n<div id=\"components-demo\">\n  <button-counter></button-counter>\n</div>\n```\n\n{% codeblock lang:js %}\nnew Vue({ el: '#components-demo' })\n{% endcodeblock %}\n\n{% raw %}\n<div id=\"components-demo\" class=\"demo\">\n  <button-counter></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count += 1\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo' })\n</script>\n{% endraw %}\n\nSince components are reusable Vue instances, they accept the same options as `new Vue`, such as `data`, `computed`, `watch`, `methods`, and lifecycle hooks. The only exceptions are a few root-specific options like `el`.\n\n## Reusing Components\n\nComponents can be reused as many times as you want:\n\n```html\n<div id=\"components-demo\">\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n</div>\n```\n\n{% raw %}\n<div id=\"components-demo2\" class=\"demo\">\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n</div>\n<script>\nnew Vue({ el: '#components-demo2' })\n</script>\n{% endraw %}\n\nNotice that when clicking on the buttons, each one maintains its own, separate `count`. That's because each time you use a component, a new **instance** of it is created.\n\n### `data` Must Be a Function\n\nWhen we defined the `<button-counter>` component, you may have noticed that `data` wasn't directly provided an object, like this:\n\n```js\ndata: {\n  count: 0\n}\n```\n\nInstead, **a component's `data` option must be a function**, so that each instance can maintain an independent copy of the returned data object:\n\n```js\ndata: function () {\n  return {\n    count: 0\n  }\n}\n```\n\nIf Vue didn't have this rule, clicking on one button would affect the data of _all other instances_, like below:\n\n{% raw %}\n<div id=\"components-demo3\" class=\"demo\">\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n</div>\n<script>\nvar buttonCounter2Data = {\n  count: 0\n}\nVue.component('button-counter2', {\n  data: function () {\n    return buttonCounter2Data\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo3' })\n</script>\n{% endraw %}\n\n## Organizing Components\n\nIt's common for an app to be organized into a tree of nested components:\n\n![Component Tree](/images/components.png)\n\nFor example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.\n\nTo use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: **global** and **local**. So far, we've only registered components globally, using `Vue.component`:\n\n```js\nVue.component('my-component-name', {\n  // ... options ...\n})\n```\n\nGlobally registered components can be used in the template of any root Vue instance (`new Vue`) created afterwards -- and even inside all subcomponents of that Vue instance's component tree.\n\nThat's all you need to know about registration for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Component Registration](components-registration.html).\n\n## Passing Data to Child Components with Props\n\nEarlier, we mentioned creating a component for blog posts. The problem is, that component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a `props` option:\n\n```js\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n```\n\nA component can have as many props as you'd like and by default, any value can be passed to any prop. In the template above, you'll see that we can access this value on the component instance, just like with `data`.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\n```html\n<blog-post title=\"My journey with Vue\"></blog-post>\n<blog-post title=\"Blogging with Vue\"></blog-post>\n<blog-post title=\"Why Vue is so fun\"></blog-post>\n```\n\n{% raw %}\n<div id=\"blog-post-demo\" class=\"demo\">\n  <blog-post1 title=\"My journey with Vue\"></blog-post1>\n  <blog-post1 title=\"Blogging with Vue\"></blog-post1>\n  <blog-post1 title=\"Why Vue is so fun\"></blog-post1>\n</div>\n<script>\nVue.component('blog-post1', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\nnew Vue({ el: '#blog-post-demo' })\n</script>\n{% endraw %}\n\nIn a typical app, however, you'll likely have an array of posts in `data`:\n\n```js\nnew Vue({\n  el: '#blog-post-demo',\n  data: {\n    posts: [\n      { id: 1, title: 'My journey with Vue' },\n      { id: 2, title: 'Blogging with Vue' },\n      { id: 3, title: 'Why Vue is so fun' }\n    ]\n  }\n})\n```\n\nThen want to render a component for each one:\n\n```html\n<blog-post\n  v-for=\"post in posts\"\n  v-bind:key=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\nAbove, you'll see that we can use `v-bind` to dynamically pass props. This is especially useful when you don't know the exact content you're going to render ahead of time, like when [fetching posts from an API](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example).\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Props](components-props.html).\n\n## A Single Root Element\n\nWhen building out a `<blog-post>` component, your template will eventually contain more than just the title:\n\n```html\n<h3>{{ title }}</h3>\n```\n\nAt the very least, you'll want to include the post's content:\n\n```html\n<h3>{{ title }}</h3>\n<div v-html=\"content\"></div>\n```\n\nIf you try this in your template however, Vue will show an error, explaining that **every component must have a single root element**. You can fix this error by wrapping the template in a parent element, such as:\n\n```html\n<div class=\"blog-post\">\n  <h3>{{ title }}</h3>\n  <div v-html=\"content\"></div>\n</div>\n```\n\nAs our component grows, it's likely we'll not only need the title and content of a post, but also the published date, comments, and more. Defining a prop for each related piece of information could become very annoying:\n\n```html\n<blog-post\n  v-for=\"post in posts\"\n  v-bind:key=\"post.id\"\n  v-bind:title=\"post.title\"\n  v-bind:content=\"post.content\"\n  v-bind:publishedAt=\"post.publishedAt\"\n  v-bind:comments=\"post.comments\"\n></blog-post>\n```\n\nSo this might be a good time to refactor the `<blog-post>` component to accept a single `post` prop instead:\n\n```html\n<blog-post\n  v-for=\"post in posts\"\n  v-bind:key=\"post.id\"\n  v-bind:post=\"post\"\n></blog-post>\n```\n\n```js\nVue.component('blog-post', {\n  props: ['post'],\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ post.title }}</h3>\n      <div v-html=\"post.content\"></div>\n    </div>\n  `\n})\n```\n\n<p class=\"tip\">The above example and some future ones use JavaScript's [template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use [newline escapes](https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/) instead.</p>\n\nNow, whenever a new property is added to `post` objects, it will automatically be available inside `<blog-post>`.\n\n## Listening to Child Components Events\n\nAs we develop our `<blog-post>` component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size:\n\nIn the parent, we can support this feature by adding a `postFontSize` data property:\n\n```js\nnew Vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [/* ... */],\n    postFontSize: 1\n  }\n})\n```\n\nWhich can be used in the template to control the font size of all blog posts:\n\n```html\n<div id=\"blog-posts-events-demo\">\n  <div :style=\"{ fontSize: postFontSize + 'em' }\">\n    <blog-post\n      v-for=\"post in posts\"\n      v-bind:key=\"post.id\"\n      v-bind:post=\"post\"\n    ></blog-post>\n  </div>\n</div>\n```\n\nNow let's add a button to enlarge the text right before the content of every post:\n\n```js\nVue.component('blog-post', {\n  props: ['post'],\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ post.title }}</h3>\n      <button>\n        Enlarge text\n      </button>\n      <div v-html=\"post.content\"></div>\n    </div>\n  `\n})\n```\n\nThe problem is, this button doesn't do anything:\n\n```html\n<button>\n  Enlarge text\n</button>\n```\n\nWhen we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with `v-on`, just as we would with a native DOM event:\n\n```html\n<blog-post\n  ...\n  v-on:enlarge-text=\"postFontSize += 0.1\"\n></blog-post>\n```\n\nThen the child component can emit an event on itself by calling the built-in [**`$emit`** method](../api/#vm-emit), passing the name of the event:\n\n```html\n<button v-on:click=\"$emit('enlarge-text')\">\n  Enlarge text\n</button>\n```\n\nThanks to the `v-on:enlarge-text=\"postFontSize += 0.1\"` listener, the parent will receive the event and update `postFontSize` value.\n\n{% raw %}\n<div id=\"blog-posts-events-demo\" class=\"demo\">\n  <div :style=\"{ fontSize: postFontSize + 'em' }\">\n    <blog-post\n      v-for=\"post in posts\"\n      v-bind:key=\"post.id\"\n      v-bind:post=\"post\"\n      v-on:enlarge-text=\"postFontSize += 0.1\"\n    ></blog-post>\n  </div>\n</div>\n<script>\nVue.component('blog-post', {\n  props: ['post'],\n  template: '\\\n    <div class=\"blog-post\">\\\n      <h3>{{ post.title }}</h3>\\\n      <button v-on:click=\"$emit(\\'enlarge-text\\')\">\\\n        Enlarge text\\\n      </button>\\\n      <div v-html=\"post.content\"></div>\\\n    </div>\\\n  '\n})\nnew Vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [\n      { id: 1, title: 'My journey with Vue', content: '...content...' },\n      { id: 2, title: 'Blogging with Vue', content: '...content...' },\n      { id: 3, title: 'Why Vue is so fun', content: '...content...' }\n    ],\n    postFontSize: 1\n  }\n})\n</script>\n{% endraw %}\n\n### Emitting a Value With an Event\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the `<blog-post>` component to be in charge of how much to enlarge the text by. In those cases, we can use `$emit`'s 2nd parameter to provide this value:\n\n```html\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n  Enlarge text\n</button>\n```\n\nThen when we listen to the event in the parent, we can access the emitted event's value with `$event`:\n\n```html\n<blog-post\n  ...\n  v-on:enlarge-text=\"postFontSize += $event\"\n></blog-post>\n```\n\nOr, if the event handler is a method:\n\n```html\n<blog-post\n  ...\n  v-on:enlarge-text=\"onEnlargeText\"\n></blog-post>\n```\n\nThen the value will be passed as the first parameter of that method:\n\n```js\nmethods: {\n  onEnlargeText: function (enlargeAmount) {\n    this.postFontSize += enlargeAmount\n  }\n}\n```\n\n### Using `v-model` on Components\n\nCustom events can also be used to create custom inputs that work with `v-model`. Remember that:\n\n```html\n<input v-model=\"searchText\">\n```\n\ndoes the same thing as:\n\n```html\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n```\n\nWhen used on a component, `v-model` instead does this:\n\n``` html\n<custom-input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event\"\n></custom-input>\n```\n\nFor this to actually work though, the `<input>` inside the component must:\n\n- Bind the `value` attribute to a `value` prop\n- On `input`, emit its own custom `input` event with the new value\n\nHere's that in action:\n\n```js\nVue.component('custom-input', {\n  props: ['value'],\n  template: `\n    <input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n```\n\nNow `v-model` should work perfectly with this component:\n\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Custom Events](components-custom-events.html).\n\n## Content Distribution with Slots\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\n``` html\n<alert-box>\n  Something bad happened.\n</alert-box>\n```\n\nWhich might render something like:\n\n{% raw %}\n<div id=\"slots-demo\" class=\"demo\">\n  <alert-box>\n    Something bad happened.\n  </alert-box>\n</div>\n<script>\nVue.component('alert-box', {\n  template: '\\\n    <div class=\"demo-alert-box\">\\\n      <strong>Error!</strong>\\\n      <slot></slot>\\\n    </div>\\\n  '\n})\nnew Vue({ el: '#slots-demo' })\n</script>\n<style>\n.demo-alert-box {\n  padding: 10px 20px;\n  background: #f3beb8;\n  border: 1px solid #f09898;\n}\n</style>\n{% endraw %}\n\nFortunately, this task is made very simple by Vue's custom `<slot>` element:\n\n```js\nVue.component('alert-box', {\n  template: `\n    <div class=\"demo-alert-box\">\n      <strong>Error!</strong>\n      <slot></slot>\n    </div>\n  `\n})\n```\n\nAs you'll see above, we just add the slot where we want it to go -- and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Slots](components-slots.html).\n\n## Dynamic Components\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\n{% raw %}\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button\n    v-for=\"tab in tabs\"\n    v-bind:key=\"tab\"\n    class=\"dynamic-component-demo-tab-button\"\n    v-bind:class=\"{ 'dynamic-component-demo-tab-button-active': tab === currentTab }\"\n    v-on:click=\"currentTab = tab\"\n  >\n    {{ tab }}\n  </button>\n  <component\n    v-bind:is=\"currentTabComponent\"\n    class=\"dynamic-component-demo-tab\"\n  ></component>\n</div>\n<script>\nVue.component('tab-home', { template: '<div>Home component</div>' })\nVue.component('tab-posts', { template: '<div>Posts component</div>' })\nVue.component('tab-archive', { template: '<div>Archive component</div>' })\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Home',\n    tabs: ['Home', 'Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n</style>\n{% endraw %}\n\nThe above is made possible by Vue's `<component>` element with the `is` special attribute:\n\n```html\n<!-- Component changes when currentTabComponent changes -->\n<component v-bind:is=\"currentTabComponent\"></component>\n```\n\nIn the example above, `currentTabComponent` can contain either:\n\n- the name of a registered component, or\n- a component's options object\n\nSee [this example](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components) to experiment with the full code, or [this version](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components-with-binding) for an example binding to a component's options object, instead of its registered name.\n\nKeep in mind that this attribute can be used with regular HTML elements, however they will be treated as components, which means all attributes **will be bound as DOM attributes**. For some properties such as `value` to work as you would expect, you will need to bind them using the [`.prop` modifier](../api/#v-bind).\n\nThat's all you need to know about dynamic components for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Dynamic & Async Components](components-dynamic-async.html).\n\n## DOM Template Parsing Caveats\n\nSome HTML elements, such as `<ul>`, `<ol>`, `<table>` and `<select>` have restrictions on what elements can appear inside them, and some elements such as `<li>`, `<tr>`, and `<option>` can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\n``` html\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n```\n\nThe custom component `<blog-post-row>` will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the `is` special attribute offers a workaround:\n\n``` html\n<table>\n  <tr is=\"blog-post-row\"></tr>\n</table>\n```\n\nIt should be noted that **this limitation does _not_ apply if you are using string templates from one of the following sources**:\n\n- String templates (e.g. `template: '...'`)\n- [Single-file (`.vue`) components](single-file-components.html)\n- [`<script type=\"text/x-template\">`](components-edge-cases.html#X-Templates)\n\nThat's all you need to know about DOM template parsing caveats for now -- and actually, the end of Vue's _Essentials_. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.\n\nOnce you feel comfortable with the knowledge you've just digested, we recommend coming back to read the full guide on [Dynamic & Async Components](components-dynamic-async.html), as well as the other pages in the Components In-Depth section of the sidebar.\n","source":"v2/guide/components.md","raw":"---\ntitle: Components Basics\ntype: guide\norder: 11\n---\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/courses/vuejs-components-fundamentals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Components Fundamentals Course\">Watch a free video course on Vue School</a></div>\n\n## Base Example\n\nHere's an example of a Vue component:\n\n``` js\n// Define a new component called button-counter\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\n```\n\nComponents are reusable Vue instances with a name: in this case, `<button-counter>`. We can use this component as a custom element inside a root Vue instance created with `new Vue`:\n\n```html\n<div id=\"components-demo\">\n  <button-counter></button-counter>\n</div>\n```\n\n{% codeblock lang:js %}\nnew Vue({ el: '#components-demo' })\n{% endcodeblock %}\n\n{% raw %}\n<div id=\"components-demo\" class=\"demo\">\n  <button-counter></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count += 1\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo' })\n</script>\n{% endraw %}\n\nSince components are reusable Vue instances, they accept the same options as `new Vue`, such as `data`, `computed`, `watch`, `methods`, and lifecycle hooks. The only exceptions are a few root-specific options like `el`.\n\n## Reusing Components\n\nComponents can be reused as many times as you want:\n\n```html\n<div id=\"components-demo\">\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n</div>\n```\n\n{% raw %}\n<div id=\"components-demo2\" class=\"demo\">\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n</div>\n<script>\nnew Vue({ el: '#components-demo2' })\n</script>\n{% endraw %}\n\nNotice that when clicking on the buttons, each one maintains its own, separate `count`. That's because each time you use a component, a new **instance** of it is created.\n\n### `data` Must Be a Function\n\nWhen we defined the `<button-counter>` component, you may have noticed that `data` wasn't directly provided an object, like this:\n\n```js\ndata: {\n  count: 0\n}\n```\n\nInstead, **a component's `data` option must be a function**, so that each instance can maintain an independent copy of the returned data object:\n\n```js\ndata: function () {\n  return {\n    count: 0\n  }\n}\n```\n\nIf Vue didn't have this rule, clicking on one button would affect the data of _all other instances_, like below:\n\n{% raw %}\n<div id=\"components-demo3\" class=\"demo\">\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n</div>\n<script>\nvar buttonCounter2Data = {\n  count: 0\n}\nVue.component('button-counter2', {\n  data: function () {\n    return buttonCounter2Data\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo3' })\n</script>\n{% endraw %}\n\n## Organizing Components\n\nIt's common for an app to be organized into a tree of nested components:\n\n![Component Tree](/images/components.png)\n\nFor example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.\n\nTo use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: **global** and **local**. So far, we've only registered components globally, using `Vue.component`:\n\n```js\nVue.component('my-component-name', {\n  // ... options ...\n})\n```\n\nGlobally registered components can be used in the template of any root Vue instance (`new Vue`) created afterwards -- and even inside all subcomponents of that Vue instance's component tree.\n\nThat's all you need to know about registration for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Component Registration](components-registration.html).\n\n## Passing Data to Child Components with Props\n\nEarlier, we mentioned creating a component for blog posts. The problem is, that component won't be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That's where props come in.\n\nProps are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a `props` option:\n\n```js\nVue.component('blog-post', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\n```\n\nA component can have as many props as you'd like and by default, any value can be passed to any prop. In the template above, you'll see that we can access this value on the component instance, just like with `data`.\n\nOnce a prop is registered, you can pass data to it as a custom attribute, like this:\n\n```html\n<blog-post title=\"My journey with Vue\"></blog-post>\n<blog-post title=\"Blogging with Vue\"></blog-post>\n<blog-post title=\"Why Vue is so fun\"></blog-post>\n```\n\n{% raw %}\n<div id=\"blog-post-demo\" class=\"demo\">\n  <blog-post1 title=\"My journey with Vue\"></blog-post1>\n  <blog-post1 title=\"Blogging with Vue\"></blog-post1>\n  <blog-post1 title=\"Why Vue is so fun\"></blog-post1>\n</div>\n<script>\nVue.component('blog-post1', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\nnew Vue({ el: '#blog-post-demo' })\n</script>\n{% endraw %}\n\nIn a typical app, however, you'll likely have an array of posts in `data`:\n\n```js\nnew Vue({\n  el: '#blog-post-demo',\n  data: {\n    posts: [\n      { id: 1, title: 'My journey with Vue' },\n      { id: 2, title: 'Blogging with Vue' },\n      { id: 3, title: 'Why Vue is so fun' }\n    ]\n  }\n})\n```\n\nThen want to render a component for each one:\n\n```html\n<blog-post\n  v-for=\"post in posts\"\n  v-bind:key=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\nAbove, you'll see that we can use `v-bind` to dynamically pass props. This is especially useful when you don't know the exact content you're going to render ahead of time, like when [fetching posts from an API](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example).\n\nThat's all you need to know about props for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Props](components-props.html).\n\n## A Single Root Element\n\nWhen building out a `<blog-post>` component, your template will eventually contain more than just the title:\n\n```html\n<h3>{{ title }}</h3>\n```\n\nAt the very least, you'll want to include the post's content:\n\n```html\n<h3>{{ title }}</h3>\n<div v-html=\"content\"></div>\n```\n\nIf you try this in your template however, Vue will show an error, explaining that **every component must have a single root element**. You can fix this error by wrapping the template in a parent element, such as:\n\n```html\n<div class=\"blog-post\">\n  <h3>{{ title }}</h3>\n  <div v-html=\"content\"></div>\n</div>\n```\n\nAs our component grows, it's likely we'll not only need the title and content of a post, but also the published date, comments, and more. Defining a prop for each related piece of information could become very annoying:\n\n```html\n<blog-post\n  v-for=\"post in posts\"\n  v-bind:key=\"post.id\"\n  v-bind:title=\"post.title\"\n  v-bind:content=\"post.content\"\n  v-bind:publishedAt=\"post.publishedAt\"\n  v-bind:comments=\"post.comments\"\n></blog-post>\n```\n\nSo this might be a good time to refactor the `<blog-post>` component to accept a single `post` prop instead:\n\n```html\n<blog-post\n  v-for=\"post in posts\"\n  v-bind:key=\"post.id\"\n  v-bind:post=\"post\"\n></blog-post>\n```\n\n```js\nVue.component('blog-post', {\n  props: ['post'],\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ post.title }}</h3>\n      <div v-html=\"post.content\"></div>\n    </div>\n  `\n})\n```\n\n<p class=\"tip\">The above example and some future ones use JavaScript's [template literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use [newline escapes](https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/) instead.</p>\n\nNow, whenever a new property is added to `post` objects, it will automatically be available inside `<blog-post>`.\n\n## Listening to Child Components Events\n\nAs we develop our `<blog-post>` component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size:\n\nIn the parent, we can support this feature by adding a `postFontSize` data property:\n\n```js\nnew Vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [/* ... */],\n    postFontSize: 1\n  }\n})\n```\n\nWhich can be used in the template to control the font size of all blog posts:\n\n```html\n<div id=\"blog-posts-events-demo\">\n  <div :style=\"{ fontSize: postFontSize + 'em' }\">\n    <blog-post\n      v-for=\"post in posts\"\n      v-bind:key=\"post.id\"\n      v-bind:post=\"post\"\n    ></blog-post>\n  </div>\n</div>\n```\n\nNow let's add a button to enlarge the text right before the content of every post:\n\n```js\nVue.component('blog-post', {\n  props: ['post'],\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ post.title }}</h3>\n      <button>\n        Enlarge text\n      </button>\n      <div v-html=\"post.content\"></div>\n    </div>\n  `\n})\n```\n\nThe problem is, this button doesn't do anything:\n\n```html\n<button>\n  Enlarge text\n</button>\n```\n\nWhen we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with `v-on`, just as we would with a native DOM event:\n\n```html\n<blog-post\n  ...\n  v-on:enlarge-text=\"postFontSize += 0.1\"\n></blog-post>\n```\n\nThen the child component can emit an event on itself by calling the built-in [**`$emit`** method](../api/#vm-emit), passing the name of the event:\n\n```html\n<button v-on:click=\"$emit('enlarge-text')\">\n  Enlarge text\n</button>\n```\n\nThanks to the `v-on:enlarge-text=\"postFontSize += 0.1\"` listener, the parent will receive the event and update `postFontSize` value.\n\n{% raw %}\n<div id=\"blog-posts-events-demo\" class=\"demo\">\n  <div :style=\"{ fontSize: postFontSize + 'em' }\">\n    <blog-post\n      v-for=\"post in posts\"\n      v-bind:key=\"post.id\"\n      v-bind:post=\"post\"\n      v-on:enlarge-text=\"postFontSize += 0.1\"\n    ></blog-post>\n  </div>\n</div>\n<script>\nVue.component('blog-post', {\n  props: ['post'],\n  template: '\\\n    <div class=\"blog-post\">\\\n      <h3>{{ post.title }}</h3>\\\n      <button v-on:click=\"$emit(\\'enlarge-text\\')\">\\\n        Enlarge text\\\n      </button>\\\n      <div v-html=\"post.content\"></div>\\\n    </div>\\\n  '\n})\nnew Vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [\n      { id: 1, title: 'My journey with Vue', content: '...content...' },\n      { id: 2, title: 'Blogging with Vue', content: '...content...' },\n      { id: 3, title: 'Why Vue is so fun', content: '...content...' }\n    ],\n    postFontSize: 1\n  }\n})\n</script>\n{% endraw %}\n\n### Emitting a Value With an Event\n\nIt's sometimes useful to emit a specific value with an event. For example, we may want the `<blog-post>` component to be in charge of how much to enlarge the text by. In those cases, we can use `$emit`'s 2nd parameter to provide this value:\n\n```html\n<button v-on:click=\"$emit('enlarge-text', 0.1)\">\n  Enlarge text\n</button>\n```\n\nThen when we listen to the event in the parent, we can access the emitted event's value with `$event`:\n\n```html\n<blog-post\n  ...\n  v-on:enlarge-text=\"postFontSize += $event\"\n></blog-post>\n```\n\nOr, if the event handler is a method:\n\n```html\n<blog-post\n  ...\n  v-on:enlarge-text=\"onEnlargeText\"\n></blog-post>\n```\n\nThen the value will be passed as the first parameter of that method:\n\n```js\nmethods: {\n  onEnlargeText: function (enlargeAmount) {\n    this.postFontSize += enlargeAmount\n  }\n}\n```\n\n### Using `v-model` on Components\n\nCustom events can also be used to create custom inputs that work with `v-model`. Remember that:\n\n```html\n<input v-model=\"searchText\">\n```\n\ndoes the same thing as:\n\n```html\n<input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event.target.value\"\n>\n```\n\nWhen used on a component, `v-model` instead does this:\n\n``` html\n<custom-input\n  v-bind:value=\"searchText\"\n  v-on:input=\"searchText = $event\"\n></custom-input>\n```\n\nFor this to actually work though, the `<input>` inside the component must:\n\n- Bind the `value` attribute to a `value` prop\n- On `input`, emit its own custom `input` event with the new value\n\nHere's that in action:\n\n```js\nVue.component('custom-input', {\n  props: ['value'],\n  template: `\n    <input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n```\n\nNow `v-model` should work perfectly with this component:\n\n```html\n<custom-input v-model=\"searchText\"></custom-input>\n```\n\nThat's all you need to know about custom component events for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Custom Events](components-custom-events.html).\n\n## Content Distribution with Slots\n\nJust like with HTML elements, it's often useful to be able to pass content to a component, like this:\n\n``` html\n<alert-box>\n  Something bad happened.\n</alert-box>\n```\n\nWhich might render something like:\n\n{% raw %}\n<div id=\"slots-demo\" class=\"demo\">\n  <alert-box>\n    Something bad happened.\n  </alert-box>\n</div>\n<script>\nVue.component('alert-box', {\n  template: '\\\n    <div class=\"demo-alert-box\">\\\n      <strong>Error!</strong>\\\n      <slot></slot>\\\n    </div>\\\n  '\n})\nnew Vue({ el: '#slots-demo' })\n</script>\n<style>\n.demo-alert-box {\n  padding: 10px 20px;\n  background: #f3beb8;\n  border: 1px solid #f09898;\n}\n</style>\n{% endraw %}\n\nFortunately, this task is made very simple by Vue's custom `<slot>` element:\n\n```js\nVue.component('alert-box', {\n  template: `\n    <div class=\"demo-alert-box\">\n      <strong>Error!</strong>\n      <slot></slot>\n    </div>\n  `\n})\n```\n\nAs you'll see above, we just add the slot where we want it to go -- and that's it. We're done!\n\nThat's all you need to know about slots for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Slots](components-slots.html).\n\n## Dynamic Components\n\nSometimes, it's useful to dynamically switch between components, like in a tabbed interface:\n\n{% raw %}\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button\n    v-for=\"tab in tabs\"\n    v-bind:key=\"tab\"\n    class=\"dynamic-component-demo-tab-button\"\n    v-bind:class=\"{ 'dynamic-component-demo-tab-button-active': tab === currentTab }\"\n    v-on:click=\"currentTab = tab\"\n  >\n    {{ tab }}\n  </button>\n  <component\n    v-bind:is=\"currentTabComponent\"\n    class=\"dynamic-component-demo-tab\"\n  ></component>\n</div>\n<script>\nVue.component('tab-home', { template: '<div>Home component</div>' })\nVue.component('tab-posts', { template: '<div>Posts component</div>' })\nVue.component('tab-archive', { template: '<div>Archive component</div>' })\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Home',\n    tabs: ['Home', 'Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n</style>\n{% endraw %}\n\nThe above is made possible by Vue's `<component>` element with the `is` special attribute:\n\n```html\n<!-- Component changes when currentTabComponent changes -->\n<component v-bind:is=\"currentTabComponent\"></component>\n```\n\nIn the example above, `currentTabComponent` can contain either:\n\n- the name of a registered component, or\n- a component's options object\n\nSee [this example](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components) to experiment with the full code, or [this version](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components-with-binding) for an example binding to a component's options object, instead of its registered name.\n\nKeep in mind that this attribute can be used with regular HTML elements, however they will be treated as components, which means all attributes **will be bound as DOM attributes**. For some properties such as `value` to work as you would expect, you will need to bind them using the [`.prop` modifier](../api/#v-bind).\n\nThat's all you need to know about dynamic components for now, but once you've finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on [Dynamic & Async Components](components-dynamic-async.html).\n\n## DOM Template Parsing Caveats\n\nSome HTML elements, such as `<ul>`, `<ol>`, `<table>` and `<select>` have restrictions on what elements can appear inside them, and some elements such as `<li>`, `<tr>`, and `<option>` can only appear inside certain other elements.\n\nThis will lead to issues when using components with elements that have such restrictions. For example:\n\n``` html\n<table>\n  <blog-post-row></blog-post-row>\n</table>\n```\n\nThe custom component `<blog-post-row>` will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the `is` special attribute offers a workaround:\n\n``` html\n<table>\n  <tr is=\"blog-post-row\"></tr>\n</table>\n```\n\nIt should be noted that **this limitation does _not_ apply if you are using string templates from one of the following sources**:\n\n- String templates (e.g. `template: '...'`)\n- [Single-file (`.vue`) components](single-file-components.html)\n- [`<script type=\"text/x-template\">`](components-edge-cases.html#X-Templates)\n\nThat's all you need to know about DOM template parsing caveats for now -- and actually, the end of Vue's _Essentials_. Congratulations! There's still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.\n\nOnce you feel comfortable with the knowledge you've just digested, we recommend coming back to read the full guide on [Dynamic & Async Components](components-dynamic-async.html), as well as the other pages in the Components In-Depth section of the sidebar.\n","date":"2020-09-25T23:55:41.135Z","updated":"2020-09-25T23:55:41.135Z","path":"v2/guide/components.html","comments":1,"layout":"page","_id":"ckfl66gyk0023c2v5r3jucn1k","content":"<div class=\"vueschool\"><a href=\"https://vueschool.io/courses/vuejs-components-fundamentals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Components Fundamentals Course\">Watch a free video course on Vue School</a></div>\n\n<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Here’s an example of a Vue component:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Define a new component called button-counter</span>\nVue.component(<span class=\"hljs-string\">'button-counter'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span>\n&#125;)</code></pre>\n<p>Components are reusable Vue instances with a name: in this case, <code>&lt;button-counter&gt;</code>. We can use this component as a custom element inside a root Vue instance created with <code>new Vue</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"components-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#components-demo'</span> &#125;)</code></pre>\n\n<div id=\"components-demo\" class=\"demo\">\n  <button-counter></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count += 1\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo' })\n</script>\n\n<p>Since components are reusable Vue instances, they accept the same options as <code>new Vue</code>, such as <code>data</code>, <code>computed</code>, <code>watch</code>, <code>methods</code>, and lifecycle hooks. The only exceptions are a few root-specific options like <code>el</code>.</p>\n<h2 id=\"Reusing-Components\"><a href=\"#Reusing-Components\" class=\"headerlink\" title=\"Reusing Components\"></a>Reusing Components</h2><p>Components can be reused as many times as you want:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"components-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<div id=\"components-demo2\" class=\"demo\">\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n</div>\n<script>\nnew Vue({ el: '#components-demo2' })\n</script>\n\n<p>Notice that when clicking on the buttons, each one maintains its own, separate <code>count</code>. That’s because each time you use a component, a new <strong>instance</strong> of it is created.</p>\n<h3 id=\"data-Must-Be-a-Function\"><a href=\"#data-Must-Be-a-Function\" class=\"headerlink\" title=\"data Must Be a Function\"></a><code>data</code> Must Be a Function</h3><p>When we defined the <code>&lt;button-counter&gt;</code> component, you may have noticed that <code>data</code> wasn’t directly provided an object, like this:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n&#125;</code></pre>\n<p>Instead, <strong>a component’s <code>data</code> option must be a function</strong>, so that each instance can maintain an independent copy of the returned data object:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n  &#125;\n&#125;</code></pre>\n<p>If Vue didn’t have this rule, clicking on one button would affect the data of <em>all other instances</em>, like below:</p>\n\n<div id=\"components-demo3\" class=\"demo\">\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n</div>\n<script>\nvar buttonCounter2Data = {\n  count: 0\n}\nVue.component('button-counter2', {\n  data: function () {\n    return buttonCounter2Data\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo3' })\n</script>\n\n<h2 id=\"Organizing-Components\"><a href=\"#Organizing-Components\" class=\"headerlink\" title=\"Organizing Components\"></a>Organizing Components</h2><p>It’s common for an app to be organized into a tree of nested components:</p>\n<p><img src=\"/images/components.png\" alt=\"Component Tree\"></p>\n<p>For example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.</p>\n<p>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: <strong>global</strong> and <strong>local</strong>. So far, we’ve only registered components globally, using <code>Vue.component</code>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123;\n  <span class=\"hljs-comment\">// ... options ...</span>\n&#125;)</code></pre>\n<p>Globally registered components can be used in the template of any root Vue instance (<code>new Vue</code>) created afterwards – and even inside all subcomponents of that Vue instance’s component tree.</p>\n<p>That’s all you need to know about registration for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-registration.html\">Component Registration</a>.</p>\n<h2 id=\"Passing-Data-to-Child-Components-with-Props\"><a href=\"#Passing-Data-to-Child-Components-with-Props\" class=\"headerlink\" title=\"Passing Data to Child Components with Props\"></a>Passing Data to Child Components with Props</h2><p>Earlier, we mentioned creating a component for blog posts. The problem is, that component won’t be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That’s where props come in.</p>\n<p>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a <code>props</code> option:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'title'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span>\n&#125;)</code></pre>\n<p>A component can have as many props as you’d like and by default, any value can be passed to any prop. In the template above, you’ll see that we can access this value on the component instance, just like with <code>data</code>.</p>\n<p>Once a prop is registered, you can pass data to it as a custom attribute, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"My journey with Vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"Blogging with Vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"Why Vue is so fun\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n\n<div id=\"blog-post-demo\" class=\"demo\">\n  <blog-post1 title=\"My journey with Vue\"></blog-post1>\n  <blog-post1 title=\"Blogging with Vue\"></blog-post1>\n  <blog-post1 title=\"Why Vue is so fun\"></blog-post1>\n</div>\n<script>\nVue.component('blog-post1', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\nnew Vue({ el: '#blog-post-demo' })\n</script>\n\n<p>In a typical app, however, you’ll likely have an array of posts in <code>data</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#blog-post-demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">posts</span>: [\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'My journey with Vue'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Blogging with Vue'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Why Vue is so fun'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n<p>Then want to render a component for each one:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Above, you’ll see that we can use <code>v-bind</code> to dynamically pass props. This is especially useful when you don’t know the exact content you’re going to render ahead of time, like when <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example\" target=\"_blank\" rel=\"noopener\">fetching posts from an API</a>.</p>\n<p>That’s all you need to know about props for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-props.html\">Props</a>.</p>\n<h2 id=\"A-Single-Root-Element\"><a href=\"#A-Single-Root-Element\" class=\"headerlink\" title=\"A Single Root Element\"></a>A Single Root Element</h2><p>When building out a <code>&lt;blog-post&gt;</code> component, your template will eventually contain more than just the title:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></code></pre>\n<p>At the very least, you’ll want to include the post’s content:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>If you try this in your template however, Vue will show an error, explaining that <strong>every component must have a single root element</strong>. You can fix this error by wrapping the template in a parent element, such as:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"blog-post\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>As our component grows, it’s likely we’ll not only need the title and content of a post, but also the published date, comments, and more. Defining a prop for each related piece of information could become very annoying:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>\n  <span class=\"hljs-attr\">v-bind:content</span>=<span class=\"hljs-string\">\"post.content\"</span>\n  <span class=\"hljs-attr\">v-bind:publishedAt</span>=<span class=\"hljs-string\">\"post.publishedAt\"</span>\n  <span class=\"hljs-attr\">v-bind:comments</span>=<span class=\"hljs-string\">\"post.comments\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>So this might be a good time to refactor the <code>&lt;blog-post&gt;</code> component to accept a single <code>post</code> prop instead:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:post</span>=<span class=\"hljs-string\">\"post\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'post'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div class=\"blog-post\"&gt;\n      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;\n      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p class=\"tip\">The above example and some future ones use JavaScript’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\" target=\"_blank\" rel=\"noopener\">template literal</a> to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use <a href=\"https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/\" target=\"_blank\" rel=\"noopener\">newline escapes</a> instead.</p>\n\n<p>Now, whenever a new property is added to <code>post</code> objects, it will automatically be available inside <code>&lt;blog-post&gt;</code>.</p>\n<h2 id=\"Listening-to-Child-Components-Events\"><a href=\"#Listening-to-Child-Components-Events\" class=\"headerlink\" title=\"Listening to Child Components Events\"></a>Listening to Child Components Events</h2><p>As we develop our <code>&lt;blog-post&gt;</code> component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size:</p>\n<p>In the parent, we can support this feature by adding a <code>postFontSize</code> data property:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#blog-posts-events-demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">posts</span>: [<span class=\"hljs-comment\">/* ... */</span>],\n    <span class=\"hljs-attr\">postFontSize</span>: <span class=\"hljs-number\">1</span>\n  &#125;\n&#125;)</code></pre>\n<p>Which can be used in the template to control the font size of all blog posts:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"blog-posts-events-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; fontSize: postFontSize + 'em' &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n      <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n      <span class=\"hljs-attr\">v-bind:post</span>=<span class=\"hljs-string\">\"post\"</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Now let’s add a button to enlarge the text right before the content of every post:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'post'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div class=\"blog-post\"&gt;\n      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;\n      &lt;button&gt;\n        Enlarge text\n      &lt;/button&gt;\n      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p>The problem is, this button doesn’t do anything:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>\n  Enlarge text\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with <code>v-on</code>, just as we would with a native DOM event:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">...</span>\n  <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">\"postFontSize += 0.1\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Then the child component can emit an event on itself by calling the built-in <a href=\"../api/#vm-emit\"><strong><code>$emit</code></strong> method</a>, passing the name of the event:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"$emit('enlarge-text')\"</span>&gt;</span>\n  Enlarge text\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Thanks to the <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> listener, the parent will receive the event and update <code>postFontSize</code> value.</p>\n\n<div id=\"blog-posts-events-demo\" class=\"demo\">\n  <div :style=\"{ fontSize: postFontSize + 'em' }\">\n    <blog-post v-for=\"post in posts\" v-bind:key=\"post.id\" v-bind:post=\"post\" v-on:enlarge-text=\"postFontSize += 0.1\"></blog-post>\n  </div>\n</div>\n<script>\nVue.component('blog-post', {\n  props: ['post'],\n  template: '\\\n    <div class=\"blog-post\">\\\n      <h3>{{ post.title }}</h3>\\\n      <button v-on:click=\"$emit(\\'enlarge-text\\')\">\\\n        Enlarge text\\\n      </button>\\\n      <div v-html=\"post.content\"></div>\\\n    </div>\\\n  '\n})\nnew Vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [\n      { id: 1, title: 'My journey with Vue', content: '...content...' },\n      { id: 2, title: 'Blogging with Vue', content: '...content...' },\n      { id: 3, title: 'Why Vue is so fun', content: '...content...' }\n    ],\n    postFontSize: 1\n  }\n})\n</script>\n\n<h3 id=\"Emitting-a-Value-With-an-Event\"><a href=\"#Emitting-a-Value-With-an-Event\" class=\"headerlink\" title=\"Emitting a Value With an Event\"></a>Emitting a Value With an Event</h3><p>It’s sometimes useful to emit a specific value with an event. For example, we may want the <code>&lt;blog-post&gt;</code> component to be in charge of how much to enlarge the text by. In those cases, we can use <code>$emit</code>‘s 2nd parameter to provide this value:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"$emit('enlarge-text', 0.1)\"</span>&gt;</span>\n  Enlarge text\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Then when we listen to the event in the parent, we can access the emitted event’s value with <code>$event</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">...</span>\n  <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">\"postFontSize += $event\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Or, if the event handler is a method:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">...</span>\n  <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">\"onEnlargeText\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Then the value will be passed as the first parameter of that method:</p>\n<pre><code class=\"hljs js\">methods: &#123;\n  <span class=\"hljs-attr\">onEnlargeText</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">enlargeAmount</span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.postFontSize += enlargeAmount\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Using-v-model-on-Components\"><a href=\"#Using-v-model-on-Components\" class=\"headerlink\" title=\"Using v-model on Components\"></a>Using <code>v-model</code> on Components</h3><p>Custom events can also be used to create custom inputs that work with <code>v-model</code>. Remember that:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"searchText\"</span>&gt;</span></code></pre>\n<p>does the same thing as:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"searchText\"</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"searchText = $event.target.value\"</span>\n&gt;</span></code></pre>\n<p>When used on a component, <code>v-model</code> instead does this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"searchText\"</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"searchText = $event\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span></code></pre>\n<p>For this to actually work though, the <code>&lt;input&gt;</code> inside the component must:</p>\n<ul>\n<li>Bind the <code>value</code> attribute to a <code>value</code> prop</li>\n<li>On <code>input</code>, emit its own custom <code>input</code> event with the new value</li>\n</ul>\n<p>Here’s that in action:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'custom-input'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'value'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<p>Now <code>v-model</code> should work perfectly with this component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"searchText\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span></code></pre>\n<p>That’s all you need to know about custom component events for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-custom-events.html\">Custom Events</a>.</p>\n<h2 id=\"Content-Distribution-with-Slots\"><a href=\"#Content-Distribution-with-Slots\" class=\"headerlink\" title=\"Content Distribution with Slots\"></a>Content Distribution with Slots</h2><p>Just like with HTML elements, it’s often useful to be able to pass content to a component, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">alert-box</span>&gt;</span>\n  Something bad happened.\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">alert-box</span>&gt;</span></code></pre>\n<p>Which might render something like:</p>\n\n<div id=\"slots-demo\" class=\"demo\">\n  <alert-box>\n    Something bad happened.\n  </alert-box>\n</div>\n<script>\nVue.component('alert-box', {\n  template: '\\\n    <div class=\"demo-alert-box\">\\\n      <strong>Error!</strong>\\\n      <slot></slot>\\\n    </div>\\\n  '\n})\nnew Vue({ el: '#slots-demo' })\n</script>\n<style>\n.demo-alert-box {\n  padding: 10px 20px;\n  background: #f3beb8;\n  border: 1px solid #f09898;\n}\n</style>\n\n<p>Fortunately, this task is made very simple by Vue’s custom <code>&lt;slot&gt;</code> element:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'alert-box'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div class=\"demo-alert-box\"&gt;\n      &lt;strong&gt;Error!&lt;/strong&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p>As you’ll see above, we just add the slot where we want it to go – and that’s it. We’re done!</p>\n<p>That’s all you need to know about slots for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-slots.html\">Slots</a>.</p>\n<h2 id=\"Dynamic-Components\"><a href=\"#Dynamic-Components\" class=\"headerlink\" title=\"Dynamic Components\"></a>Dynamic Components</h2><p>Sometimes, it’s useful to dynamically switch between components, like in a tabbed interface:</p>\n\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button v-for=\"tab in tabs\" v-bind:key=\"tab\" class=\"dynamic-component-demo-tab-button\" v-bind:class=\"{ 'dynamic-component-demo-tab-button-active': tab === currentTab }\" v-on:click=\"currentTab = tab\">\n    {{ tab }}\n  </button>\n  <component v-bind:is=\"currentTabComponent\" class=\"dynamic-component-demo-tab\"></component>\n</div>\n<script>\nVue.component('tab-home', { template: '<div>Home component</div>' })\nVue.component('tab-posts', { template: '<div>Posts component</div>' })\nVue.component('tab-archive', { template: '<div>Archive component</div>' })\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Home',\n    tabs: ['Home', 'Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n</style>\n\n<p>The above is made possible by Vue’s <code>&lt;component&gt;</code> element with the <code>is</code> special attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Component changes when currentTabComponent changes --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentTabComponent\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n<p>In the example above, <code>currentTabComponent</code> can contain either:</p>\n<ul>\n<li>the name of a registered component, or</li>\n<li>a component’s options object</li>\n</ul>\n<p>See <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components\" target=\"_blank\" rel=\"noopener\">this example</a> to experiment with the full code, or <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components-with-binding\" target=\"_blank\" rel=\"noopener\">this version</a> for an example binding to a component’s options object, instead of its registered name.</p>\n<p>Keep in mind that this attribute can be used with regular HTML elements, however they will be treated as components, which means all attributes <strong>will be bound as DOM attributes</strong>. For some properties such as <code>value</code> to work as you would expect, you will need to bind them using the <a href=\"../api/#v-bind\"><code>.prop</code> modifier</a>.</p>\n<p>That’s all you need to know about dynamic components for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-dynamic-async.html\">Dynamic &amp; Async Components</a>.</p>\n<h2 id=\"DOM-Template-Parsing-Caveats\"><a href=\"#DOM-Template-Parsing-Caveats\" class=\"headerlink\" title=\"DOM Template Parsing Caveats\"></a>DOM Template Parsing Caveats</h2><p>Some HTML elements, such as <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> and <code>&lt;select&gt;</code> have restrictions on what elements can appear inside them, and some elements such as <code>&lt;li&gt;</code>, <code>&lt;tr&gt;</code>, and <code>&lt;option&gt;</code> can only appear inside certain other elements.</p>\n<p>This will lead to issues when using components with elements that have such restrictions. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post-row</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post-row</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>The custom component <code>&lt;blog-post-row&gt;</code> will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the <code>is</code> special attribute offers a workaround:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"blog-post-row\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>It should be noted that <strong>this limitation does <em>not</em> apply if you are using string templates from one of the following sources</strong>:</p>\n<ul>\n<li>String templates (e.g. <code>template: &#39;...&#39;</code>)</li>\n<li><a href=\"single-file-components.html\">Single-file (<code>.vue</code>) components</a></li>\n<li><a href=\"components-edge-cases.html#X-Templates\"><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></a></li>\n</ul>\n<p>That’s all you need to know about DOM template parsing caveats for now – and actually, the end of Vue’s <em>Essentials</em>. Congratulations! There’s still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.</p>\n<p>Once you feel comfortable with the knowledge you’ve just digested, we recommend coming back to read the full guide on <a href=\"components-dynamic-async.html\">Dynamic &amp; Async Components</a>, as well as the other pages in the Components In-Depth section of the sidebar.</p>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"vueschool\"><a href=\"https://vueschool.io/courses/vuejs-components-fundamentals?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Components Fundamentals Course\">Watch a free video course on Vue School</a></div>\n\n<h2 id=\"Base-Example\"><a href=\"#Base-Example\" class=\"headerlink\" title=\"Base Example\"></a>Base Example</h2><p>Here’s an example of a Vue component:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Define a new component called button-counter</span>\nVue.component(<span class=\"hljs-string\">'button-counter'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span>\n&#125;)</code></pre>\n<p>Components are reusable Vue instances with a name: in this case, <code>&lt;button-counter&gt;</code>. We can use this component as a custom element inside a root Vue instance created with <code>new Vue</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"components-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#components-demo'</span> &#125;)</code></pre>\n\n<div id=\"components-demo\" class=\"demo\">\n  <button-counter></button-counter>\n</div>\n<script>\nVue.component('button-counter', {\n  data: function () {\n    return {\n      count: 0\n    }\n  },\n  template: '<button v-on:click=\"count += 1\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo' })\n</script>\n\n<p>Since components are reusable Vue instances, they accept the same options as <code>new Vue</code>, such as <code>data</code>, <code>computed</code>, <code>watch</code>, <code>methods</code>, and lifecycle hooks. The only exceptions are a few root-specific options like <code>el</code>.</p>\n<h2 id=\"Reusing-Components\"><a href=\"#Reusing-Components\" class=\"headerlink\" title=\"Reusing Components\"></a>Reusing Components</h2><p>Components can be reused as many times as you want:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"components-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button-counter</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button-counter</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<div id=\"components-demo2\" class=\"demo\">\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n  <button-counter></button-counter>\n</div>\n<script>\nnew Vue({ el: '#components-demo2' })\n</script>\n\n<p>Notice that when clicking on the buttons, each one maintains its own, separate <code>count</code>. That’s because each time you use a component, a new <strong>instance</strong> of it is created.</p>\n<h3 id=\"data-Must-Be-a-Function\"><a href=\"#data-Must-Be-a-Function\" class=\"headerlink\" title=\"data Must Be a Function\"></a><code>data</code> Must Be a Function</h3><p>When we defined the <code>&lt;button-counter&gt;</code> component, you may have noticed that <code>data</code> wasn’t directly provided an object, like this:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n&#125;</code></pre>\n<p>Instead, <strong>a component’s <code>data</code> option must be a function</strong>, so that each instance can maintain an independent copy of the returned data object:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span>\n  &#125;\n&#125;</code></pre>\n<p>If Vue didn’t have this rule, clicking on one button would affect the data of <em>all other instances</em>, like below:</p>\n\n<div id=\"components-demo3\" class=\"demo\">\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n  <button-counter2></button-counter2>\n</div>\n<script>\nvar buttonCounter2Data = {\n  count: 0\n}\nVue.component('button-counter2', {\n  data: function () {\n    return buttonCounter2Data\n  },\n  template: '<button v-on:click=\"count++\">You clicked me {{ count }} times.</button>'\n})\nnew Vue({ el: '#components-demo3' })\n</script>\n\n<h2 id=\"Organizing-Components\"><a href=\"#Organizing-Components\" class=\"headerlink\" title=\"Organizing Components\"></a>Organizing Components</h2><p>It’s common for an app to be organized into a tree of nested components:</p>\n<p><img src=\"/images/components.png\" alt=\"Component Tree\"></p>\n<p>For example, you might have components for a header, sidebar, and content area, each typically containing other components for navigation links, blog posts, etc.</p>\n<p>To use these components in templates, they must be registered so that Vue knows about them. There are two types of component registration: <strong>global</strong> and <strong>local</strong>. So far, we’ve only registered components globally, using <code>Vue.component</code>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component-name'</span>, &#123;\n  <span class=\"hljs-comment\">// ... options ...</span>\n&#125;)</code></pre>\n<p>Globally registered components can be used in the template of any root Vue instance (<code>new Vue</code>) created afterwards – and even inside all subcomponents of that Vue instance’s component tree.</p>\n<p>That’s all you need to know about registration for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-registration.html\">Component Registration</a>.</p>\n<h2 id=\"Passing-Data-to-Child-Components-with-Props\"><a href=\"#Passing-Data-to-Child-Components-with-Props\" class=\"headerlink\" title=\"Passing Data to Child Components with Props\"></a>Passing Data to Child Components with Props</h2><p>Earlier, we mentioned creating a component for blog posts. The problem is, that component won’t be useful unless you can pass data to it, such as the title and content of the specific post we want to display. That’s where props come in.</p>\n<p>Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. To pass a title to our blog post component, we can include it in the list of props this component accepts, using a <code>props</code> option:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'title'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span>\n&#125;)</code></pre>\n<p>A component can have as many props as you’d like and by default, any value can be passed to any prop. In the template above, you’ll see that we can access this value on the component instance, just like with <code>data</code>.</p>\n<p>Once a prop is registered, you can pass data to it as a custom attribute, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"My journey with Vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"Blogging with Vue\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span> <span class=\"hljs-attr\">title</span>=<span class=\"hljs-string\">\"Why Vue is so fun\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n\n<div id=\"blog-post-demo\" class=\"demo\">\n  <blog-post1 title=\"My journey with Vue\"></blog-post1>\n  <blog-post1 title=\"Blogging with Vue\"></blog-post1>\n  <blog-post1 title=\"Why Vue is so fun\"></blog-post1>\n</div>\n<script>\nVue.component('blog-post1', {\n  props: ['title'],\n  template: '<h3>{{ title }}</h3>'\n})\nnew Vue({ el: '#blog-post-demo' })\n</script>\n\n<p>In a typical app, however, you’ll likely have an array of posts in <code>data</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#blog-post-demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">posts</span>: [\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'My journey with Vue'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Blogging with Vue'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Why Vue is so fun'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n<p>Then want to render a component for each one:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Above, you’ll see that we can use <code>v-bind</code> to dynamically pass props. This is especially useful when you don’t know the exact content you’re going to render ahead of time, like when <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-component-blog-post-example\" target=\"_blank\" rel=\"noopener\">fetching posts from an API</a>.</p>\n<p>That’s all you need to know about props for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-props.html\">Props</a>.</p>\n<h2 id=\"A-Single-Root-Element\"><a href=\"#A-Single-Root-Element\" class=\"headerlink\" title=\"A Single Root Element\"></a>A Single Root Element</h2><p>When building out a <code>&lt;blog-post&gt;</code> component, your template will eventually contain more than just the title:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span></code></pre>\n<p>At the very least, you’ll want to include the post’s content:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>If you try this in your template however, Vue will show an error, explaining that <strong>every component must have a single root element</strong>. You can fix this error by wrapping the template in a parent element, such as:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"blog-post\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>As our component grows, it’s likely we’ll not only need the title and content of a post, but also the published date, comments, and more. Defining a prop for each related piece of information could become very annoying:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"post.title\"</span>\n  <span class=\"hljs-attr\">v-bind:content</span>=<span class=\"hljs-string\">\"post.content\"</span>\n  <span class=\"hljs-attr\">v-bind:publishedAt</span>=<span class=\"hljs-string\">\"post.publishedAt\"</span>\n  <span class=\"hljs-attr\">v-bind:comments</span>=<span class=\"hljs-string\">\"post.comments\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>So this might be a good time to refactor the <code>&lt;blog-post&gt;</code> component to accept a single <code>post</code> prop instead:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n  <span class=\"hljs-attr\">v-bind:post</span>=<span class=\"hljs-string\">\"post\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'post'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div class=\"blog-post\"&gt;\n      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;\n      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p class=\"tip\">The above example and some future ones use JavaScript’s <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\" target=\"_blank\" rel=\"noopener\">template literal</a> to make multi-line templates more readable. These are not supported by Internet Explorer (IE), so if you must support IE and are not transpiling (e.g. with Babel or TypeScript), use <a href=\"https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/\" target=\"_blank\" rel=\"noopener\">newline escapes</a> instead.</p>\n\n<p>Now, whenever a new property is added to <code>post</code> objects, it will automatically be available inside <code>&lt;blog-post&gt;</code>.</p>\n<h2 id=\"Listening-to-Child-Components-Events\"><a href=\"#Listening-to-Child-Components-Events\" class=\"headerlink\" title=\"Listening to Child Components Events\"></a>Listening to Child Components Events</h2><p>As we develop our <code>&lt;blog-post&gt;</code> component, some features may require communicating back up to the parent. For example, we may decide to include an accessibility feature to enlarge the text of blog posts, while leaving the rest of the page its default size:</p>\n<p>In the parent, we can support this feature by adding a <code>postFontSize</code> data property:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#blog-posts-events-demo'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">posts</span>: [<span class=\"hljs-comment\">/* ... */</span>],\n    <span class=\"hljs-attr\">postFontSize</span>: <span class=\"hljs-number\">1</span>\n  &#125;\n&#125;)</code></pre>\n<p>Which can be used in the template to control the font size of all blog posts:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"blog-posts-events-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; fontSize: postFontSize + 'em' &#125;\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"post in posts\"</span>\n      <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"post.id\"</span>\n      <span class=\"hljs-attr\">v-bind:post</span>=<span class=\"hljs-string\">\"post\"</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Now let’s add a button to enlarge the text right before the content of every post:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'post'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div class=\"blog-post\"&gt;\n      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;\n      &lt;button&gt;\n        Enlarge text\n      &lt;/button&gt;\n      &lt;div v-html=\"post.content\"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p>The problem is, this button doesn’t do anything:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>\n  Enlarge text\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>When we click on the button, we need to communicate to the parent that it should enlarge the text of all posts. Fortunately, Vue instances provide a custom events system to solve this problem. The parent can choose to listen to any event on the child component instance with <code>v-on</code>, just as we would with a native DOM event:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">...</span>\n  <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">\"postFontSize += 0.1\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Then the child component can emit an event on itself by calling the built-in <a href=\"../api/#vm-emit\"><strong><code>$emit</code></strong> method</a>, passing the name of the event:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"$emit('enlarge-text')\"</span>&gt;</span>\n  Enlarge text\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Thanks to the <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> listener, the parent will receive the event and update <code>postFontSize</code> value.</p>\n\n<div id=\"blog-posts-events-demo\" class=\"demo\">\n  <div :style=\"{ fontSize: postFontSize + 'em' }\">\n    <blog-post v-for=\"post in posts\" v-bind:key=\"post.id\" v-bind:post=\"post\" v-on:enlarge-text=\"postFontSize += 0.1\"></blog-post>\n  </div>\n</div>\n<script>\nVue.component('blog-post', {\n  props: ['post'],\n  template: '\\\n    <div class=\"blog-post\">\\\n      <h3>{{ post.title }}</h3>\\\n      <button v-on:click=\"$emit(\\'enlarge-text\\')\">\\\n        Enlarge text\\\n      </button>\\\n      <div v-html=\"post.content\"></div>\\\n    </div>\\\n  '\n})\nnew Vue({\n  el: '#blog-posts-events-demo',\n  data: {\n    posts: [\n      { id: 1, title: 'My journey with Vue', content: '...content...' },\n      { id: 2, title: 'Blogging with Vue', content: '...content...' },\n      { id: 3, title: 'Why Vue is so fun', content: '...content...' }\n    ],\n    postFontSize: 1\n  }\n})\n</script>\n\n<h3 id=\"Emitting-a-Value-With-an-Event\"><a href=\"#Emitting-a-Value-With-an-Event\" class=\"headerlink\" title=\"Emitting a Value With an Event\"></a>Emitting a Value With an Event</h3><p>It’s sometimes useful to emit a specific value with an event. For example, we may want the <code>&lt;blog-post&gt;</code> component to be in charge of how much to enlarge the text by. In those cases, we can use <code>$emit</code>‘s 2nd parameter to provide this value:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"$emit('enlarge-text', 0.1)\"</span>&gt;</span>\n  Enlarge text\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Then when we listen to the event in the parent, we can access the emitted event’s value with <code>$event</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">...</span>\n  <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">\"postFontSize += $event\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Or, if the event handler is a method:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>\n  <span class=\"hljs-attr\">...</span>\n  <span class=\"hljs-attr\">v-on:enlarge-text</span>=<span class=\"hljs-string\">\"onEnlargeText\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<p>Then the value will be passed as the first parameter of that method:</p>\n<pre><code class=\"hljs js\">methods: &#123;\n  <span class=\"hljs-attr\">onEnlargeText</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">enlargeAmount</span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.postFontSize += enlargeAmount\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Using-v-model-on-Components\"><a href=\"#Using-v-model-on-Components\" class=\"headerlink\" title=\"Using v-model on Components\"></a>Using <code>v-model</code> on Components</h3><p>Custom events can also be used to create custom inputs that work with <code>v-model</code>. Remember that:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"searchText\"</span>&gt;</span></code></pre>\n<p>does the same thing as:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"searchText\"</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"searchText = $event.target.value\"</span>\n&gt;</span></code></pre>\n<p>When used on a component, <code>v-model</code> instead does this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"searchText\"</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"searchText = $event\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span></code></pre>\n<p>For this to actually work though, the <code>&lt;input&gt;</code> inside the component must:</p>\n<ul>\n<li>Bind the <code>value</code> attribute to a <code>value</code> prop</li>\n<li>On <code>input</code>, emit its own custom <code>input</code> event with the new value</li>\n</ul>\n<p>Here’s that in action:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'custom-input'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'value'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      v-bind:value=\"value\"\n      v-on:input=\"$emit('input', $event.target.value)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<p>Now <code>v-model</code> should work perfectly with this component:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">custom-input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"searchText\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">custom-input</span>&gt;</span></code></pre>\n<p>That’s all you need to know about custom component events for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-custom-events.html\">Custom Events</a>.</p>\n<h2 id=\"Content-Distribution-with-Slots\"><a href=\"#Content-Distribution-with-Slots\" class=\"headerlink\" title=\"Content Distribution with Slots\"></a>Content Distribution with Slots</h2><p>Just like with HTML elements, it’s often useful to be able to pass content to a component, like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">alert-box</span>&gt;</span>\n  Something bad happened.\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">alert-box</span>&gt;</span></code></pre>\n<p>Which might render something like:</p>\n\n<div id=\"slots-demo\" class=\"demo\">\n  <alert-box>\n    Something bad happened.\n  </alert-box>\n</div>\n<script>\nVue.component('alert-box', {\n  template: '\\\n    <div class=\"demo-alert-box\">\\\n      <strong>Error!</strong>\\\n      <slot></slot>\\\n    </div>\\\n  '\n})\nnew Vue({ el: '#slots-demo' })\n</script>\n<style>\n.demo-alert-box {\n  padding: 10px 20px;\n  background: #f3beb8;\n  border: 1px solid #f09898;\n}\n</style>\n\n<p>Fortunately, this task is made very simple by Vue’s custom <code>&lt;slot&gt;</code> element:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'alert-box'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;div class=\"demo-alert-box\"&gt;\n      &lt;strong&gt;Error!&lt;/strong&gt;\n      &lt;slot&gt;&lt;/slot&gt;\n    &lt;/div&gt;\n  `</span>\n&#125;)</code></pre>\n<p>As you’ll see above, we just add the slot where we want it to go – and that’s it. We’re done!</p>\n<p>That’s all you need to know about slots for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-slots.html\">Slots</a>.</p>\n<h2 id=\"Dynamic-Components\"><a href=\"#Dynamic-Components\" class=\"headerlink\" title=\"Dynamic Components\"></a>Dynamic Components</h2><p>Sometimes, it’s useful to dynamically switch between components, like in a tabbed interface:</p>\n\n<div id=\"dynamic-component-demo\" class=\"demo\">\n  <button v-for=\"tab in tabs\" v-bind:key=\"tab\" class=\"dynamic-component-demo-tab-button\" v-bind:class=\"{ 'dynamic-component-demo-tab-button-active': tab === currentTab }\" v-on:click=\"currentTab = tab\">\n    {{ tab }}\n  </button>\n  <component v-bind:is=\"currentTabComponent\" class=\"dynamic-component-demo-tab\"></component>\n</div>\n<script>\nVue.component('tab-home', { template: '<div>Home component</div>' })\nVue.component('tab-posts', { template: '<div>Posts component</div>' })\nVue.component('tab-archive', { template: '<div>Archive component</div>' })\nnew Vue({\n  el: '#dynamic-component-demo',\n  data: {\n    currentTab: 'Home',\n    tabs: ['Home', 'Posts', 'Archive']\n  },\n  computed: {\n    currentTabComponent: function () {\n      return 'tab-' + this.currentTab.toLowerCase()\n    }\n  }\n})\n</script>\n<style>\n.dynamic-component-demo-tab-button {\n  padding: 6px 10px;\n  border-top-left-radius: 3px;\n  border-top-right-radius: 3px;\n  border: 1px solid #ccc;\n  cursor: pointer;\n  background: #f0f0f0;\n  margin-bottom: -1px;\n  margin-right: -1px;\n}\n.dynamic-component-demo-tab-button:hover {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab-button-active {\n  background: #e0e0e0;\n}\n.dynamic-component-demo-tab {\n  border: 1px solid #ccc;\n  padding: 10px;\n}\n</style>\n\n<p>The above is made possible by Vue’s <code>&lt;component&gt;</code> element with the <code>is</code> special attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Component changes when currentTabComponent changes --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentTabComponent\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n<p>In the example above, <code>currentTabComponent</code> can contain either:</p>\n<ul>\n<li>the name of a registered component, or</li>\n<li>a component’s options object</li>\n</ul>\n<p>See <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components\" target=\"_blank\" rel=\"noopener\">this example</a> to experiment with the full code, or <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components-with-binding\" target=\"_blank\" rel=\"noopener\">this version</a> for an example binding to a component’s options object, instead of its registered name.</p>\n<p>Keep in mind that this attribute can be used with regular HTML elements, however they will be treated as components, which means all attributes <strong>will be bound as DOM attributes</strong>. For some properties such as <code>value</code> to work as you would expect, you will need to bind them using the <a href=\"../api/#v-bind\"><code>.prop</code> modifier</a>.</p>\n<p>That’s all you need to know about dynamic components for now, but once you’ve finished reading this page and feel comfortable with its content, we recommend coming back later to read the full guide on <a href=\"components-dynamic-async.html\">Dynamic &amp; Async Components</a>.</p>\n<h2 id=\"DOM-Template-Parsing-Caveats\"><a href=\"#DOM-Template-Parsing-Caveats\" class=\"headerlink\" title=\"DOM Template Parsing Caveats\"></a>DOM Template Parsing Caveats</h2><p>Some HTML elements, such as <code>&lt;ul&gt;</code>, <code>&lt;ol&gt;</code>, <code>&lt;table&gt;</code> and <code>&lt;select&gt;</code> have restrictions on what elements can appear inside them, and some elements such as <code>&lt;li&gt;</code>, <code>&lt;tr&gt;</code>, and <code>&lt;option&gt;</code> can only appear inside certain other elements.</p>\n<p>This will lead to issues when using components with elements that have such restrictions. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post-row</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post-row</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>The custom component <code>&lt;blog-post-row&gt;</code> will be hoisted out as invalid content, causing errors in the eventual rendered output. Fortunately, the <code>is</code> special attribute offers a workaround:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"blog-post-row\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>It should be noted that <strong>this limitation does <em>not</em> apply if you are using string templates from one of the following sources</strong>:</p>\n<ul>\n<li>String templates (e.g. <code>template: &#39;...&#39;</code>)</li>\n<li><a href=\"single-file-components.html\">Single-file (<code>.vue</code>) components</a></li>\n<li><a href=\"components-edge-cases.html#X-Templates\"><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></a></li>\n</ul>\n<p>That’s all you need to know about DOM template parsing caveats for now – and actually, the end of Vue’s <em>Essentials</em>. Congratulations! There’s still more to learn, but first, we recommend taking a break to play with Vue yourself and build something fun.</p>\n<p>Once you feel comfortable with the knowledge you’ve just digested, we recommend coming back to read the full guide on <a href=\"components-dynamic-async.html\">Dynamic &amp; Async Components</a>, as well as the other pages in the Components In-Depth section of the sidebar.</p>\n"},{"title":"Event Handling","type":"guide","order":9,"_content":"\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-user-events?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to handle events on Vue School\">Learn how to handle events in a free Vue School lesson</a></div>\n\n## Listening to Events\n\nWe can use the `v-on` directive to listen to DOM events and run some JavaScript when they're triggered.\n\nFor example:\n\n``` html\n<div id=\"example-1\">\n  <button v-on:click=\"counter += 1\">Add 1</button>\n  <p>The button above has been clicked {{ counter }} times.</p>\n</div>\n```\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">Add 1</button>\n  <p>The button above has been clicked {{ counter }} times.</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n{% endraw %}\n\n## Method Event Handlers\n\nThe logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the `v-on` attribute isn't feasible. That's why `v-on` can also accept the name of a method you'd like to call.\n\nFor example:\n\n``` html\n<div id=\"example-2\">\n  <!-- `greet` is the name of a method defined below -->\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  // define methods under the `methods` object\n  methods: {\n    greet: function (event) {\n      // `this` inside methods points to the Vue instance\n      alert('Hello ' + this.name + '!')\n      // `event` is the native DOM event\n      if (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n\n// you can invoke methods in JavaScript too\nexample2.greet() // => 'Hello Vue.js!'\n```\n\nResult:\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      if (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## Methods in Inline Handlers\n\nInstead of binding directly to a method name, we can also use methods in an inline JavaScript statement:\n\n``` html\n<div id=\"example-3\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n```\n``` js\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n```\n\nResult:\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n{% endraw %}\n\nSometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special `$event` variable:\n\n``` html\n<button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n```\n\n``` js\n// ...\nmethods: {\n  warn: function (message, event) {\n    // now we have access to the native event\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}\n```\n\n## Event Modifiers\n\nIt is a very common need to call `event.preventDefault()` or `event.stopPropagation()` inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\n\nTo address this problem, Vue provides **event modifiers** for `v-on`. Recall that modifiers are directive postfixes denoted by a dot.\n\n- `.stop`\n- `.prevent`\n- `.capture`\n- `.self`\n- `.once`\n- `.passive`\n\n``` html\n<!-- the click event's propagation will be stopped -->\n<a v-on:click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form v-on:submit.prevent></form>\n\n<!-- use capture mode when adding the event listener -->\n<!-- i.e. an event targeting an inner element is handled here before being handled by that element -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n<p class=\"tip\">Order matters when using modifiers because the relevant code is generated in the same order. Therefore using `v-on:click.prevent.self` will prevent **all clicks** while `v-on:click.self.prevent` will only prevent clicks on the element itself.</p>\n\n> New in 2.1.4+\n\n``` html\n<!-- the click event will be triggered at most once -->\n<a v-on:click.once=\"doThis\"></a>\n```\n\nUnlike the other modifiers, which are exclusive to native DOM events, the `.once` modifier can also be used on [component events](components-custom-events.html). If you haven't read about components yet, don't worry about this for now.\n\n> New in 2.3.0+\n\nVue also offers the `.passive` modifier, corresponding to [`addEventListener`'s `passive` option](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters).\n\n``` html\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n\nThe `.passive` modifier is especially useful for improving performance on mobile devices.\n\n<p class=\"tip\">Don't use `.passive` and `.prevent` together, because `.prevent` will be ignored and your browser will probably show you a warning. Remember, `.passive` communicates to the browser that you _don't_ want to prevent the event's default behavior.</p>\n\n## Key Modifiers\n\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for `v-on` when listening for key events:\n\n``` html\n<!-- only call `vm.submit()` when the `key` is `Enter` -->\n<input v-on:keyup.enter=\"submit\">\n```\n\nYou can directly use any valid key names exposed via [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) as modifiers by converting them to kebab-case.\n\n``` html\n<input v-on:keyup.page-down=\"onPageDown\">\n```\n\nIn the above example, the handler will only be called if `$event.key` is equal to `'PageDown'`.\n\n### Key Codes\n\n<p class=\"tip\">The use of `keyCode` events [is deprecated](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode) and may not be supported in new browsers.</p>\n\nUsing `keyCode` attributes is also permitted:\n\n``` html\n<input v-on:keyup.13=\"submit\">\n```\n\nVue provides aliases for the most commonly used key codes when necessary for legacy browser support:\n\n- `.enter`\n- `.tab`\n- `.delete` (captures both \"Delete\" and \"Backspace\" keys)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n<p class=\"tip\">A few keys (`.esc` and all arrow keys) have inconsistent `key` values in IE9, so these built-in aliases should be preferred if you need to support IE9.</p>\n\nYou can also [define custom key modifier aliases](../api/#keyCodes) via the global `config.keyCodes` object:\n\n``` js\n// enable `v-on:keyup.f1`\nVue.config.keyCodes.f1 = 112\n```\n\n## System Modifier Keys\n\n> New in 2.1.0+\n\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n> Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.\n\nFor example:\n\n```html\n<!-- Alt + C -->\n<input v-on:keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div v-on:click.ctrl=\"doSomething\">Do something</div>\n```\n\n<p class=\"tip\">Note that modifier keys are different from regular keys and when used with `keyup` events, they have to be pressed when the event is emitted. In other words, `keyup.ctrl` will only trigger if you release a key while holding down `ctrl`. It won't trigger if you release the `ctrl` key alone. If you do want such behaviour, use the `keyCode` for `ctrl` instead: `keyup.17`.</p>\n\n### `.exact` Modifier\n\n> New in 2.5.0+\n\nThe `.exact` modifier allows control of the exact combination of system modifiers needed to trigger an event.\n\n``` html\n<!-- this will fire even if Alt or Shift is also pressed -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button v-on:click.exact=\"onClick\">A</button>\n```\n\n### Mouse Button Modifiers\n\n> New in 2.2.0+\n\n- `.left`\n- `.right`\n- `.middle`\n\nThese modifiers restrict the handler to events triggered by a specific mouse button.\n\n## Why Listeners in HTML?\n\nYou might be concerned that this whole event listening approach violates the good old rules about \"separation of concerns\". Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that's handling the current view, it won't cause any maintenance difficulty. In fact, there are several benefits in using `v-on`:\n\n1. It's easier to locate the handler function implementations within your JS code by skimming the HTML template.\n\n2. Since you don't have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.\n\n3. When a ViewModel is destroyed, all event listeners are automatically removed. You don't need to worry about cleaning it up yourself.\n","source":"v2/guide/events.md","raw":"---\ntitle: Event Handling\ntype: guide\norder: 9\n---\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-user-events?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to handle events on Vue School\">Learn how to handle events in a free Vue School lesson</a></div>\n\n## Listening to Events\n\nWe can use the `v-on` directive to listen to DOM events and run some JavaScript when they're triggered.\n\nFor example:\n\n``` html\n<div id=\"example-1\">\n  <button v-on:click=\"counter += 1\">Add 1</button>\n  <p>The button above has been clicked {{ counter }} times.</p>\n</div>\n```\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">Add 1</button>\n  <p>The button above has been clicked {{ counter }} times.</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n{% endraw %}\n\n## Method Event Handlers\n\nThe logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the `v-on` attribute isn't feasible. That's why `v-on` can also accept the name of a method you'd like to call.\n\nFor example:\n\n``` html\n<div id=\"example-2\">\n  <!-- `greet` is the name of a method defined below -->\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  // define methods under the `methods` object\n  methods: {\n    greet: function (event) {\n      // `this` inside methods points to the Vue instance\n      alert('Hello ' + this.name + '!')\n      // `event` is the native DOM event\n      if (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n\n// you can invoke methods in JavaScript too\nexample2.greet() // => 'Hello Vue.js!'\n```\n\nResult:\n\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      if (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n</script>\n{% endraw %}\n\n## Methods in Inline Handlers\n\nInstead of binding directly to a method name, we can also use methods in an inline JavaScript statement:\n\n``` html\n<div id=\"example-3\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n```\n``` js\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n```\n\nResult:\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n{% endraw %}\n\nSometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special `$event` variable:\n\n``` html\n<button v-on:click=\"warn('Form cannot be submitted yet.', $event)\">\n  Submit\n</button>\n```\n\n``` js\n// ...\nmethods: {\n  warn: function (message, event) {\n    // now we have access to the native event\n    if (event) {\n      event.preventDefault()\n    }\n    alert(message)\n  }\n}\n```\n\n## Event Modifiers\n\nIt is a very common need to call `event.preventDefault()` or `event.stopPropagation()` inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.\n\nTo address this problem, Vue provides **event modifiers** for `v-on`. Recall that modifiers are directive postfixes denoted by a dot.\n\n- `.stop`\n- `.prevent`\n- `.capture`\n- `.self`\n- `.once`\n- `.passive`\n\n``` html\n<!-- the click event's propagation will be stopped -->\n<a v-on:click.stop=\"doThis\"></a>\n\n<!-- the submit event will no longer reload the page -->\n<form v-on:submit.prevent=\"onSubmit\"></form>\n\n<!-- modifiers can be chained -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n\n<!-- just the modifier -->\n<form v-on:submit.prevent></form>\n\n<!-- use capture mode when adding the event listener -->\n<!-- i.e. an event targeting an inner element is handled here before being handled by that element -->\n<div v-on:click.capture=\"doThis\">...</div>\n\n<!-- only trigger handler if event.target is the element itself -->\n<!-- i.e. not from a child element -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n<p class=\"tip\">Order matters when using modifiers because the relevant code is generated in the same order. Therefore using `v-on:click.prevent.self` will prevent **all clicks** while `v-on:click.self.prevent` will only prevent clicks on the element itself.</p>\n\n> New in 2.1.4+\n\n``` html\n<!-- the click event will be triggered at most once -->\n<a v-on:click.once=\"doThis\"></a>\n```\n\nUnlike the other modifiers, which are exclusive to native DOM events, the `.once` modifier can also be used on [component events](components-custom-events.html). If you haven't read about components yet, don't worry about this for now.\n\n> New in 2.3.0+\n\nVue also offers the `.passive` modifier, corresponding to [`addEventListener`'s `passive` option](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters).\n\n``` html\n<!-- the scroll event's default behavior (scrolling) will happen -->\n<!-- immediately, instead of waiting for `onScroll` to complete  -->\n<!-- in case it contains `event.preventDefault()`                -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n\nThe `.passive` modifier is especially useful for improving performance on mobile devices.\n\n<p class=\"tip\">Don't use `.passive` and `.prevent` together, because `.prevent` will be ignored and your browser will probably show you a warning. Remember, `.passive` communicates to the browser that you _don't_ want to prevent the event's default behavior.</p>\n\n## Key Modifiers\n\nWhen listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for `v-on` when listening for key events:\n\n``` html\n<!-- only call `vm.submit()` when the `key` is `Enter` -->\n<input v-on:keyup.enter=\"submit\">\n```\n\nYou can directly use any valid key names exposed via [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) as modifiers by converting them to kebab-case.\n\n``` html\n<input v-on:keyup.page-down=\"onPageDown\">\n```\n\nIn the above example, the handler will only be called if `$event.key` is equal to `'PageDown'`.\n\n### Key Codes\n\n<p class=\"tip\">The use of `keyCode` events [is deprecated](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode) and may not be supported in new browsers.</p>\n\nUsing `keyCode` attributes is also permitted:\n\n``` html\n<input v-on:keyup.13=\"submit\">\n```\n\nVue provides aliases for the most commonly used key codes when necessary for legacy browser support:\n\n- `.enter`\n- `.tab`\n- `.delete` (captures both \"Delete\" and \"Backspace\" keys)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`\n\n<p class=\"tip\">A few keys (`.esc` and all arrow keys) have inconsistent `key` values in IE9, so these built-in aliases should be preferred if you need to support IE9.</p>\n\nYou can also [define custom key modifier aliases](../api/#keyCodes) via the global `config.keyCodes` object:\n\n``` js\n// enable `v-on:keyup.f1`\nVue.config.keyCodes.f1 = 112\n```\n\n## System Modifier Keys\n\n> New in 2.1.0+\n\nYou can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:\n\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n> Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.\n\nFor example:\n\n```html\n<!-- Alt + C -->\n<input v-on:keyup.alt.67=\"clear\">\n\n<!-- Ctrl + Click -->\n<div v-on:click.ctrl=\"doSomething\">Do something</div>\n```\n\n<p class=\"tip\">Note that modifier keys are different from regular keys and when used with `keyup` events, they have to be pressed when the event is emitted. In other words, `keyup.ctrl` will only trigger if you release a key while holding down `ctrl`. It won't trigger if you release the `ctrl` key alone. If you do want such behaviour, use the `keyCode` for `ctrl` instead: `keyup.17`.</p>\n\n### `.exact` Modifier\n\n> New in 2.5.0+\n\nThe `.exact` modifier allows control of the exact combination of system modifiers needed to trigger an event.\n\n``` html\n<!-- this will fire even if Alt or Shift is also pressed -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n\n<!-- this will only fire when Ctrl and no other keys are pressed -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n\n<!-- this will only fire when no system modifiers are pressed -->\n<button v-on:click.exact=\"onClick\">A</button>\n```\n\n### Mouse Button Modifiers\n\n> New in 2.2.0+\n\n- `.left`\n- `.right`\n- `.middle`\n\nThese modifiers restrict the handler to events triggered by a specific mouse button.\n\n## Why Listeners in HTML?\n\nYou might be concerned that this whole event listening approach violates the good old rules about \"separation of concerns\". Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that's handling the current view, it won't cause any maintenance difficulty. In fact, there are several benefits in using `v-on`:\n\n1. It's easier to locate the handler function implementations within your JS code by skimming the HTML template.\n\n2. Since you don't have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.\n\n3. When a ViewModel is destroyed, all event listeners are automatically removed. You don't need to worry about cleaning it up yourself.\n","date":"2020-09-25T23:55:41.136Z","updated":"2020-09-25T23:55:41.136Z","path":"v2/guide/events.html","comments":1,"layout":"page","_id":"ckfl66gyk0024c2v5h6vlluvf","content":"<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-user-events?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to handle events on Vue School\">Learn how to handle events in a free Vue School lesson</a></div>\n\n<h2 id=\"Listening-to-Events\"><a href=\"#Listening-to-Events\" class=\"headerlink\" title=\"Listening to Events\"></a>Listening to Events</h2><p>We can use the <code>v-on</code> directive to listen to DOM events and run some JavaScript when they’re triggered.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-1\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"counter += 1\"</span>&gt;</span>Add 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example1 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-1'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span>\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">Add 1</button>\n  <p>The button above has been clicked {{ counter }} times.</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n\n<h2 id=\"Method-Event-Handlers\"><a href=\"#Method-Event-Handlers\" class=\"headerlink\" title=\"Method Event Handlers\"></a>Method Event Handlers</h2><p>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the <code>v-on</code> attribute isn’t feasible. That’s why <code>v-on</code> can also accept the name of a method you’d like to call.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-2\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- `greet` is the name of a method defined below --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"greet\"</span>&gt;</span>Greet<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example2 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-2'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Vue.js'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// define methods under the `methods` object</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">greet</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n      <span class=\"hljs-comment\">// `this` inside methods points to the Vue instance</span>\n      alert(<span class=\"hljs-string\">'Hello '</span> + <span class=\"hljs-keyword\">this</span>.name + <span class=\"hljs-string\">'!'</span>)\n      <span class=\"hljs-comment\">// `event` is the native DOM event</span>\n      <span class=\"hljs-keyword\">if</span> (event) &#123;\n        alert(event.target.tagName)\n      &#125;\n    &#125;\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// you can invoke methods in JavaScript too</span>\nexample2.greet() <span class=\"hljs-comment\">// =&gt; 'Hello Vue.js!'</span></code></pre>\n<p>Result:</p>\n\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      if (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n</script>\n\n<h2 id=\"Methods-in-Inline-Handlers\"><a href=\"#Methods-in-Inline-Handlers\" class=\"headerlink\" title=\"Methods in Inline Handlers\"></a>Methods in Inline Handlers</h2><p>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-3\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"say('hi')\"</span>&gt;</span>Say hi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"say('what')\"</span>&gt;</span>Say what<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-3'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">say</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">message</span>) </span>&#123;\n      alert(message)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:<br>\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n</p>\n<p>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special <code>$event</code> variable:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"warn('Form cannot be submitted yet.', $event)\"</span>&gt;</span>\n  Submit\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">warn</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">message, event</span>) </span>&#123;\n    <span class=\"hljs-comment\">// now we have access to the native event</span>\n    <span class=\"hljs-keyword\">if</span> (event) &#123;\n      event.preventDefault()\n    &#125;\n    alert(message)\n  &#125;\n&#125;</code></pre>\n<h2 id=\"Event-Modifiers\"><a href=\"#Event-Modifiers\" class=\"headerlink\" title=\"Event Modifiers\"></a>Event Modifiers</h2><p>It is a very common need to call <code>event.preventDefault()</code> or <code>event.stopPropagation()</code> inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</p>\n<p>To address this problem, Vue provides <strong>event modifiers</strong> for <code>v-on</code>. Recall that modifiers are directive postfixes denoted by a dot.</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n<li><code>.passive</code></li>\n</ul>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- the click event's propagation will be stopped --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click.stop</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- the submit event will no longer reload the page --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>=<span class=\"hljs-string\">\"onSubmit\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- modifiers can be chained --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click.stop.prevent</span>=<span class=\"hljs-string\">\"doThat\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- just the modifier --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- use capture mode when adding the event listener --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- i.e. an event targeting an inner element is handled here before being handled by that element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:click.capture</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- only trigger handler if event.target is the element itself --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- i.e. not from a child element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:click.self</span>=<span class=\"hljs-string\">\"doThat\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Order matters when using modifiers because the relevant code is generated in the same order. Therefore using <code>v-on:click.prevent.self</code> will prevent <strong>all clicks</strong> while <code>v-on:click.self.prevent</code> will only prevent clicks on the element itself.</p>\n\n<blockquote>\n<p>New in 2.1.4+</p>\n</blockquote>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- the click event will be triggered at most once --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click.once</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Unlike the other modifiers, which are exclusive to native DOM events, the <code>.once</code> modifier can also be used on <a href=\"components-custom-events.html\">component events</a>. If you haven’t read about components yet, don’t worry about this for now.</p>\n<blockquote>\n<p>New in 2.3.0+</p>\n</blockquote>\n<p>Vue also offers the <code>.passive</code> modifier, corresponding to <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\" target=\"_blank\" rel=\"noopener\"><code>addEventListener</code>‘s <code>passive</code> option</a>.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- the scroll event's default behavior (scrolling) will happen --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- immediately, instead of waiting for `onScroll` to complete  --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- in case it contains `event.preventDefault()`                --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:scroll.passive</span>=<span class=\"hljs-string\">\"onScroll\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The <code>.passive</code> modifier is especially useful for improving performance on mobile devices.</p>\n<p class=\"tip\">Don’t use <code>.passive</code> and <code>.prevent</code> together, because <code>.prevent</code> will be ignored and your browser will probably show you a warning. Remember, <code>.passive</code> communicates to the browser that you <em>don’t</em> want to prevent the event’s default behavior.</p>\n\n<h2 id=\"Key-Modifiers\"><a href=\"#Key-Modifiers\" class=\"headerlink\" title=\"Key Modifiers\"></a>Key Modifiers</h2><p>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for <code>v-on</code> when listening for key events:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- only call `vm.submit()` when the `key` is `Enter` --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.enter</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span></code></pre>\n<p>You can directly use any valid key names exposed via <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\" target=\"_blank\" rel=\"noopener\"><code>KeyboardEvent.key</code></a> as modifiers by converting them to kebab-case.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.page-down</span>=<span class=\"hljs-string\">\"onPageDown\"</span>&gt;</span></code></pre>\n<p>In the above example, the handler will only be called if <code>$event.key</code> is equal to <code>&#39;PageDown&#39;</code>.</p>\n<h3 id=\"Key-Codes\"><a href=\"#Key-Codes\" class=\"headerlink\" title=\"Key Codes\"></a>Key Codes</h3><p class=\"tip\">The use of <code>keyCode</code> events <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\" target=\"_blank\" rel=\"noopener\">is deprecated</a> and may not be supported in new browsers.</p>\n\n<p>Using <code>keyCode</code> attributes is also permitted:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.13</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span></code></pre>\n<p>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code> (captures both “Delete” and “Backspace” keys)</li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p class=\"tip\">A few keys (<code>.esc</code> and all arrow keys) have inconsistent <code>key</code> values in IE9, so these built-in aliases should be preferred if you need to support IE9.</p>\n\n<p>You can also <a href=\"../api/#keyCodes\">define custom key modifier aliases</a> via the global <code>config.keyCodes</code> object:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// enable `v-on:keyup.f1`</span>\nVue.config.keyCodes.f1 = <span class=\"hljs-number\">112</span></code></pre>\n<h2 id=\"System-Modifier-Keys\"><a href=\"#System-Modifier-Keys\" class=\"headerlink\" title=\"System Modifier Keys\"></a>System Modifier Keys</h2><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<p>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</p>\n<ul>\n<li><code>.ctrl</code></li>\n<li><code>.alt</code></li>\n<li><code>.shift</code></li>\n<li><code>.meta</code></li>\n</ul>\n<blockquote>\n<p>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.</p>\n</blockquote>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Alt + C --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.alt.67</span>=<span class=\"hljs-string\">\"clear\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Ctrl + Click --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:click.ctrl</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Note that modifier keys are different from regular keys and when used with <code>keyup</code> events, they have to be pressed when the event is emitted. In other words, <code>keyup.ctrl</code> will only trigger if you release a key while holding down <code>ctrl</code>. It won’t trigger if you release the <code>ctrl</code> key alone. If you do want such behaviour, use the <code>keyCode</code> for <code>ctrl</code> instead: <code>keyup.17</code>.</p>\n\n<h3 id=\"exact-Modifier\"><a href=\"#exact-Modifier\" class=\"headerlink\" title=\".exact Modifier\"></a><code>.exact</code> Modifier</h3><blockquote>\n<p>New in 2.5.0+</p>\n</blockquote>\n<p>The <code>.exact</code> modifier allows control of the exact combination of system modifiers needed to trigger an event.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- this will fire even if Alt or Shift is also pressed --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.ctrl</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- this will only fire when Ctrl and no other keys are pressed --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.ctrl.exact</span>=<span class=\"hljs-string\">\"onCtrlClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- this will only fire when no system modifiers are pressed --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.exact</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<h3 id=\"Mouse-Button-Modifiers\"><a href=\"#Mouse-Button-Modifiers\" class=\"headerlink\" title=\"Mouse Button Modifiers\"></a>Mouse Button Modifiers</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n<li><code>.middle</code></li>\n</ul>\n<p>These modifiers restrict the handler to events triggered by a specific mouse button.</p>\n<h2 id=\"Why-Listeners-in-HTML\"><a href=\"#Why-Listeners-in-HTML\" class=\"headerlink\" title=\"Why Listeners in HTML?\"></a>Why Listeners in HTML?</h2><p>You might be concerned that this whole event listening approach violates the good old rules about “separation of concerns”. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that’s handling the current view, it won’t cause any maintenance difficulty. In fact, there are several benefits in using <code>v-on</code>:</p>\n<ol>\n<li><p>It’s easier to locate the handler function implementations within your JS code by skimming the HTML template.</p>\n</li>\n<li><p>Since you don’t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</p>\n</li>\n<li><p>When a ViewModel is destroyed, all event listeners are automatically removed. You don’t need to worry about cleaning it up yourself.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-user-events?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to handle events on Vue School\">Learn how to handle events in a free Vue School lesson</a></div>\n\n<h2 id=\"Listening-to-Events\"><a href=\"#Listening-to-Events\" class=\"headerlink\" title=\"Listening to Events\"></a>Listening to Events</h2><p>We can use the <code>v-on</code> directive to listen to DOM events and run some JavaScript when they’re triggered.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-1\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"counter += 1\"</span>&gt;</span>Add 1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example1 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-1'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">counter</span>: <span class=\"hljs-number\">0</span>\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<div id=\"example-1\" class=\"demo\">\n  <button v-on:click=\"counter += 1\">Add 1</button>\n  <p>The button above has been clicked {{ counter }} times.</p>\n</div>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    counter: 0\n  }\n})\n</script>\n\n<h2 id=\"Method-Event-Handlers\"><a href=\"#Method-Event-Handlers\" class=\"headerlink\" title=\"Method Event Handlers\"></a>Method Event Handlers</h2><p>The logic for many event handlers will be more complex though, so keeping your JavaScript in the value of the <code>v-on</code> attribute isn’t feasible. That’s why <code>v-on</code> can also accept the name of a method you’d like to call.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-2\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- `greet` is the name of a method defined below --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"greet\"</span>&gt;</span>Greet<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example2 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-2'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Vue.js'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// define methods under the `methods` object</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">greet</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n      <span class=\"hljs-comment\">// `this` inside methods points to the Vue instance</span>\n      alert(<span class=\"hljs-string\">'Hello '</span> + <span class=\"hljs-keyword\">this</span>.name + <span class=\"hljs-string\">'!'</span>)\n      <span class=\"hljs-comment\">// `event` is the native DOM event</span>\n      <span class=\"hljs-keyword\">if</span> (event) &#123;\n        alert(event.target.tagName)\n      &#125;\n    &#125;\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// you can invoke methods in JavaScript too</span>\nexample2.greet() <span class=\"hljs-comment\">// =&gt; 'Hello Vue.js!'</span></code></pre>\n<p>Result:</p>\n\n<div id=\"example-2\" class=\"demo\">\n  <button v-on:click=\"greet\">Greet</button>\n</div>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    name: 'Vue.js'\n  },\n  methods: {\n    greet: function (event) {\n      alert('Hello ' + this.name + '!')\n      if (event) {\n        alert(event.target.tagName)\n      }\n    }\n  }\n})\n</script>\n\n<h2 id=\"Methods-in-Inline-Handlers\"><a href=\"#Methods-in-Inline-Handlers\" class=\"headerlink\" title=\"Methods in Inline Handlers\"></a>Methods in Inline Handlers</h2><p>Instead of binding directly to a method name, we can also use methods in an inline JavaScript statement:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-3\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"say('hi')\"</span>&gt;</span>Say hi<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"say('what')\"</span>&gt;</span>Say what<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-3'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">say</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">message</span>) </span>&#123;\n      alert(message)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:<br>\n<div id=\"example-3\" class=\"demo\">\n  <button v-on:click=\"say('hi')\">Say hi</button>\n  <button v-on:click=\"say('what')\">Say what</button>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  methods: {\n    say: function (message) {\n      alert(message)\n    }\n  }\n})\n</script>\n</p>\n<p>Sometimes we also need to access the original DOM event in an inline statement handler. You can pass it into a method using the special <code>$event</code> variable:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"warn('Form cannot be submitted yet.', $event)\"</span>&gt;</span>\n  Submit\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ...</span>\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">warn</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">message, event</span>) </span>&#123;\n    <span class=\"hljs-comment\">// now we have access to the native event</span>\n    <span class=\"hljs-keyword\">if</span> (event) &#123;\n      event.preventDefault()\n    &#125;\n    alert(message)\n  &#125;\n&#125;</code></pre>\n<h2 id=\"Event-Modifiers\"><a href=\"#Event-Modifiers\" class=\"headerlink\" title=\"Event Modifiers\"></a>Event Modifiers</h2><p>It is a very common need to call <code>event.preventDefault()</code> or <code>event.stopPropagation()</code> inside event handlers. Although we can do this easily inside methods, it would be better if the methods can be purely about data logic rather than having to deal with DOM event details.</p>\n<p>To address this problem, Vue provides <strong>event modifiers</strong> for <code>v-on</code>. Recall that modifiers are directive postfixes denoted by a dot.</p>\n<ul>\n<li><code>.stop</code></li>\n<li><code>.prevent</code></li>\n<li><code>.capture</code></li>\n<li><code>.self</code></li>\n<li><code>.once</code></li>\n<li><code>.passive</code></li>\n</ul>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- the click event's propagation will be stopped --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click.stop</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- the submit event will no longer reload the page --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>=<span class=\"hljs-string\">\"onSubmit\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- modifiers can be chained --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click.stop.prevent</span>=<span class=\"hljs-string\">\"doThat\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- just the modifier --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- use capture mode when adding the event listener --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- i.e. an event targeting an inner element is handled here before being handled by that element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:click.capture</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- only trigger handler if event.target is the element itself --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- i.e. not from a child element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:click.self</span>=<span class=\"hljs-string\">\"doThat\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Order matters when using modifiers because the relevant code is generated in the same order. Therefore using <code>v-on:click.prevent.self</code> will prevent <strong>all clicks</strong> while <code>v-on:click.self.prevent</code> will only prevent clicks on the element itself.</p>\n\n<blockquote>\n<p>New in 2.1.4+</p>\n</blockquote>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- the click event will be triggered at most once --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click.once</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Unlike the other modifiers, which are exclusive to native DOM events, the <code>.once</code> modifier can also be used on <a href=\"components-custom-events.html\">component events</a>. If you haven’t read about components yet, don’t worry about this for now.</p>\n<blockquote>\n<p>New in 2.3.0+</p>\n</blockquote>\n<p>Vue also offers the <code>.passive</code> modifier, corresponding to <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\" target=\"_blank\" rel=\"noopener\"><code>addEventListener</code>‘s <code>passive</code> option</a>.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- the scroll event's default behavior (scrolling) will happen --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- immediately, instead of waiting for `onScroll` to complete  --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- in case it contains `event.preventDefault()`                --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:scroll.passive</span>=<span class=\"hljs-string\">\"onScroll\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The <code>.passive</code> modifier is especially useful for improving performance on mobile devices.</p>\n<p class=\"tip\">Don’t use <code>.passive</code> and <code>.prevent</code> together, because <code>.prevent</code> will be ignored and your browser will probably show you a warning. Remember, <code>.passive</code> communicates to the browser that you <em>don’t</em> want to prevent the event’s default behavior.</p>\n\n<h2 id=\"Key-Modifiers\"><a href=\"#Key-Modifiers\" class=\"headerlink\" title=\"Key Modifiers\"></a>Key Modifiers</h2><p>When listening for keyboard events, we often need to check for specific keys. Vue allows adding key modifiers for <code>v-on</code> when listening for key events:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- only call `vm.submit()` when the `key` is `Enter` --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.enter</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span></code></pre>\n<p>You can directly use any valid key names exposed via <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\" target=\"_blank\" rel=\"noopener\"><code>KeyboardEvent.key</code></a> as modifiers by converting them to kebab-case.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.page-down</span>=<span class=\"hljs-string\">\"onPageDown\"</span>&gt;</span></code></pre>\n<p>In the above example, the handler will only be called if <code>$event.key</code> is equal to <code>&#39;PageDown&#39;</code>.</p>\n<h3 id=\"Key-Codes\"><a href=\"#Key-Codes\" class=\"headerlink\" title=\"Key Codes\"></a>Key Codes</h3><p class=\"tip\">The use of <code>keyCode</code> events <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\" target=\"_blank\" rel=\"noopener\">is deprecated</a> and may not be supported in new browsers.</p>\n\n<p>Using <code>keyCode</code> attributes is also permitted:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.13</span>=<span class=\"hljs-string\">\"submit\"</span>&gt;</span></code></pre>\n<p>Vue provides aliases for the most commonly used key codes when necessary for legacy browser support:</p>\n<ul>\n<li><code>.enter</code></li>\n<li><code>.tab</code></li>\n<li><code>.delete</code> (captures both “Delete” and “Backspace” keys)</li>\n<li><code>.esc</code></li>\n<li><code>.space</code></li>\n<li><code>.up</code></li>\n<li><code>.down</code></li>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n</ul>\n<p class=\"tip\">A few keys (<code>.esc</code> and all arrow keys) have inconsistent <code>key</code> values in IE9, so these built-in aliases should be preferred if you need to support IE9.</p>\n\n<p>You can also <a href=\"../api/#keyCodes\">define custom key modifier aliases</a> via the global <code>config.keyCodes</code> object:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// enable `v-on:keyup.f1`</span>\nVue.config.keyCodes.f1 = <span class=\"hljs-number\">112</span></code></pre>\n<h2 id=\"System-Modifier-Keys\"><a href=\"#System-Modifier-Keys\" class=\"headerlink\" title=\"System Modifier Keys\"></a>System Modifier Keys</h2><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<p>You can use the following modifiers to trigger mouse or keyboard event listeners only when the corresponding modifier key is pressed:</p>\n<ul>\n<li><code>.ctrl</code></li>\n<li><code>.alt</code></li>\n<li><code>.shift</code></li>\n<li><code>.meta</code></li>\n</ul>\n<blockquote>\n<p>Note: On Macintosh keyboards, meta is the command key (⌘). On Windows keyboards, meta is the Windows key (⊞). On Sun Microsystems keyboards, meta is marked as a solid diamond (◆). On certain keyboards, specifically MIT and Lisp machine keyboards and successors, such as the Knight keyboard, space-cadet keyboard, meta is labeled “META”. On Symbolics keyboards, meta is labeled “META” or “Meta”.</p>\n</blockquote>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Alt + C --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-on:keyup.alt.67</span>=<span class=\"hljs-string\">\"clear\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Ctrl + Click --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on:click.ctrl</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span>Do something<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Note that modifier keys are different from regular keys and when used with <code>keyup</code> events, they have to be pressed when the event is emitted. In other words, <code>keyup.ctrl</code> will only trigger if you release a key while holding down <code>ctrl</code>. It won’t trigger if you release the <code>ctrl</code> key alone. If you do want such behaviour, use the <code>keyCode</code> for <code>ctrl</code> instead: <code>keyup.17</code>.</p>\n\n<h3 id=\"exact-Modifier\"><a href=\"#exact-Modifier\" class=\"headerlink\" title=\".exact Modifier\"></a><code>.exact</code> Modifier</h3><blockquote>\n<p>New in 2.5.0+</p>\n</blockquote>\n<p>The <code>.exact</code> modifier allows control of the exact combination of system modifiers needed to trigger an event.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- this will fire even if Alt or Shift is also pressed --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.ctrl</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- this will only fire when Ctrl and no other keys are pressed --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.ctrl.exact</span>=<span class=\"hljs-string\">\"onCtrlClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- this will only fire when no system modifiers are pressed --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.exact</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<h3 id=\"Mouse-Button-Modifiers\"><a href=\"#Mouse-Button-Modifiers\" class=\"headerlink\" title=\"Mouse Button Modifiers\"></a>Mouse Button Modifiers</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><code>.left</code></li>\n<li><code>.right</code></li>\n<li><code>.middle</code></li>\n</ul>\n<p>These modifiers restrict the handler to events triggered by a specific mouse button.</p>\n<h2 id=\"Why-Listeners-in-HTML\"><a href=\"#Why-Listeners-in-HTML\" class=\"headerlink\" title=\"Why Listeners in HTML?\"></a>Why Listeners in HTML?</h2><p>You might be concerned that this whole event listening approach violates the good old rules about “separation of concerns”. Rest assured - since all Vue handler functions and expressions are strictly bound to the ViewModel that’s handling the current view, it won’t cause any maintenance difficulty. In fact, there are several benefits in using <code>v-on</code>:</p>\n<ol>\n<li><p>It’s easier to locate the handler function implementations within your JS code by skimming the HTML template.</p>\n</li>\n<li><p>Since you don’t have to manually attach event listeners in JS, your ViewModel code can be pure logic and DOM-free. This makes it easier to test.</p>\n</li>\n<li><p>When a ViewModel is destroyed, all event listeners are automatically removed. You don’t need to worry about cleaning it up yourself.</p>\n</li>\n</ol>\n"},{"title":"Form Input Bindings","type":"guide","order":10,"_content":"\n## Basic Usage\n\nYou can use the `v-model` directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, `v-model` is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.\n\n<p class=\"tip\">`v-model` will ignore the initial `value`, `checked`, or `selected` attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the `data` option of your component.</p>\n\n`v-model` internally uses different properties and emits different events for different input elements:\n- text and textarea elements use `value` property and `input` event;\n- checkboxes and radiobuttons use `checked` property and `change` event;\n- select fields use `value` as a prop and `change` as an event.\n\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an [IME](https://en.wikipedia.org/wiki/Input_method) (Chinese, Japanese, Korean, etc.), you'll notice that `v-model` doesn't get updated during IME composition. If you want to cater to these updates as well, use the `input` event instead.</p>\n\n### Text\n\n``` html\n<input v-model=\"message\" placeholder=\"edit me\">\n<p>Message is: {{ message }}</p>\n```\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n### Multiline text\n\n``` html\n<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n\n{% raw %}\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre-line;\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n{% raw %}\n<p class=\"tip\">Interpolation on textareas (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>) won't work. Use <code>v-model</code> instead.</p>\n{% endraw %}\n\n### Checkbox\n\nSingle checkbox, boolean value:\n\n``` html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">{{ checked }}</label>\n```\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n{% endraw %}\n\nMultiple checkboxes, bound to the same Array:\n\n``` html\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n<br>\n<span>Checked names: {{ checkedNames }}</span>\n```\n\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    checkedNames: []\n  }\n})\n```\n\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n{% endraw %}\n\n### Radio\n\n``` html\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n{% raw %}\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n{% endraw %}\n\n### Select\n\nSingle select:\n\n``` html\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    selected: ''\n  }\n})\n```\n{% raw %}\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option disabled value=\"\">Please select one</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: ''\n  }\n})\n</script>\n{% endraw %}\n\n<p class=\"tip\">If the initial value of your `v-model` expression does not match any of the options, the `<select>` element will render in an \"unselected\" state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a `change` event in this case. It is therefore recommended to provide a `disabled` option with an empty value, as demonstrated in the example above.</p>\n\nMultiple select (bound to Array):\n\n``` html\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<br>\n<span>Selected: {{ selected }}</span>\n```\n{% raw %}\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px;\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n{% endraw %}\n\nDynamic options rendered with `v-for`:\n\n``` html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" v-bind:value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n## Value Bindings\n\nFor radio, checkbox and select options, the `v-model` binding values are usually static strings (or booleans for checkboxes):\n\n``` html\n<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\">\n\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\">\n\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>\n```\n\nBut sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use `v-bind` to achieve that. In addition, using `v-bind` allows us to bind the input value to non-string values.\n\n### Checkbox\n\n``` html\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\"\n>\n```\n\n``` js\n// when checked:\nvm.toggle === 'yes'\n// when unchecked:\nvm.toggle === 'no'\n```\n\n<p class=\"tip\">The `true-value` and `false-value` attributes don't affect the input's `value` attribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. \"yes\" or \"no\"), use radio inputs instead.</p>\n\n### Radio\n\n``` html\n<input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\">\n```\n\n``` js\n// when checked:\nvm.pick === vm.a\n```\n\n### Select Options\n\n``` html\n<select v-model=\"selected\">\n  <!-- inline object literal -->\n  <option v-bind:value=\"{ number: 123 }\">123</option>\n</select>\n```\n\n``` js\n// when selected:\ntypeof vm.selected // => 'object'\nvm.selected.number // => 123\n```\n\n## Modifiers\n\n### `.lazy`\n\nBy default, `v-model` syncs the input with the data after each `input` event (with the exception of IME composition, as [stated above](#vmodel-ime-tip)). You can add the `lazy` modifier to instead sync _after_ `change` events:\n\n``` html\n<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\">\n```\n\n### `.number`\n\nIf you want user input to be automatically typecast as a Number, you can add the `number` modifier to your `v-model` managed inputs:\n\n``` html\n<input v-model.number=\"age\" type=\"number\">\n```\n\nThis is often useful, because even with `type=\"number\"`, the value of HTML input elements always returns a string. If the value cannot be parsed with `parseFloat()`, then the original value is returned.\n\n### `.trim`\n\nIf you want whitespace from user input to be trimmed automatically, you can add the `trim` modifier to your `v-model`-managed inputs:\n\n```html\n<input v-model.trim=\"msg\">\n```\n\n## `v-model` with Components\n\n> If you're not yet familiar with Vue's components, you can skip this for now.\n\nHTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with `v-model`!\n\nTo learn more, read about [custom inputs](components.html#Using-v-model-on-Components) in the Components guide.\n","source":"v2/guide/forms.md","raw":"---\ntitle: Form Input Bindings\ntype: guide\norder: 10\n---\n\n## Basic Usage\n\nYou can use the `v-model` directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, `v-model` is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.\n\n<p class=\"tip\">`v-model` will ignore the initial `value`, `checked`, or `selected` attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the `data` option of your component.</p>\n\n`v-model` internally uses different properties and emits different events for different input elements:\n- text and textarea elements use `value` property and `input` event;\n- checkboxes and radiobuttons use `checked` property and `change` event;\n- select fields use `value` as a prop and `change` as an event.\n\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an [IME](https://en.wikipedia.org/wiki/Input_method) (Chinese, Japanese, Korean, etc.), you'll notice that `v-model` doesn't get updated during IME composition. If you want to cater to these updates as well, use the `input` event instead.</p>\n\n### Text\n\n``` html\n<input v-model=\"message\" placeholder=\"edit me\">\n<p>Message is: {{ message }}</p>\n```\n\n{% raw %}\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n### Multiline text\n\n``` html\n<span>Multiline message is:</span>\n<p style=\"white-space: pre-line;\">{{ message }}</p>\n<br>\n<textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n```\n\n{% raw %}\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre-line;\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n{% endraw %}\n\n{% raw %}\n<p class=\"tip\">Interpolation on textareas (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>) won't work. Use <code>v-model</code> instead.</p>\n{% endraw %}\n\n### Checkbox\n\nSingle checkbox, boolean value:\n\n``` html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n<label for=\"checkbox\">{{ checked }}</label>\n```\n{% raw %}\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n{% endraw %}\n\nMultiple checkboxes, bound to the same Array:\n\n``` html\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n<input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n<label for=\"mike\">Mike</label>\n<br>\n<span>Checked names: {{ checkedNames }}</span>\n```\n\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    checkedNames: []\n  }\n})\n```\n\n{% raw %}\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n{% endraw %}\n\n### Radio\n\n``` html\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n<label for=\"one\">One</label>\n<br>\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n<label for=\"two\">Two</label>\n<br>\n<span>Picked: {{ picked }}</span>\n```\n{% raw %}\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n{% endraw %}\n\n### Select\n\nSingle select:\n\n``` html\n<select v-model=\"selected\">\n  <option disabled value=\"\">Please select one</option>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    selected: ''\n  }\n})\n```\n{% raw %}\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option disabled value=\"\">Please select one</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: ''\n  }\n})\n</script>\n{% endraw %}\n\n<p class=\"tip\">If the initial value of your `v-model` expression does not match any of the options, the `<select>` element will render in an \"unselected\" state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a `change` event in this case. It is therefore recommended to provide a `disabled` option with an empty value, as demonstrated in the example above.</p>\n\nMultiple select (bound to Array):\n\n``` html\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n  <option>C</option>\n</select>\n<br>\n<span>Selected: {{ selected }}</span>\n```\n{% raw %}\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px;\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n{% endraw %}\n\nDynamic options rendered with `v-for`:\n\n``` html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" v-bind:value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<span>Selected: {{ selected }}</span>\n```\n``` js\nnew Vue({\n  el: '...',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n```\n{% raw %}\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\n## Value Bindings\n\nFor radio, checkbox and select options, the `v-model` binding values are usually static strings (or booleans for checkboxes):\n\n``` html\n<!-- `picked` is a string \"a\" when checked -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\">\n\n<!-- `toggle` is either true or false -->\n<input type=\"checkbox\" v-model=\"toggle\">\n\n<!-- `selected` is a string \"abc\" when the first option is selected -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select>\n```\n\nBut sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use `v-bind` to achieve that. In addition, using `v-bind` allows us to bind the input value to non-string values.\n\n### Checkbox\n\n``` html\n<input\n  type=\"checkbox\"\n  v-model=\"toggle\"\n  true-value=\"yes\"\n  false-value=\"no\"\n>\n```\n\n``` js\n// when checked:\nvm.toggle === 'yes'\n// when unchecked:\nvm.toggle === 'no'\n```\n\n<p class=\"tip\">The `true-value` and `false-value` attributes don't affect the input's `value` attribute, because browsers don't include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. \"yes\" or \"no\"), use radio inputs instead.</p>\n\n### Radio\n\n``` html\n<input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\">\n```\n\n``` js\n// when checked:\nvm.pick === vm.a\n```\n\n### Select Options\n\n``` html\n<select v-model=\"selected\">\n  <!-- inline object literal -->\n  <option v-bind:value=\"{ number: 123 }\">123</option>\n</select>\n```\n\n``` js\n// when selected:\ntypeof vm.selected // => 'object'\nvm.selected.number // => 123\n```\n\n## Modifiers\n\n### `.lazy`\n\nBy default, `v-model` syncs the input with the data after each `input` event (with the exception of IME composition, as [stated above](#vmodel-ime-tip)). You can add the `lazy` modifier to instead sync _after_ `change` events:\n\n``` html\n<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\">\n```\n\n### `.number`\n\nIf you want user input to be automatically typecast as a Number, you can add the `number` modifier to your `v-model` managed inputs:\n\n``` html\n<input v-model.number=\"age\" type=\"number\">\n```\n\nThis is often useful, because even with `type=\"number\"`, the value of HTML input elements always returns a string. If the value cannot be parsed with `parseFloat()`, then the original value is returned.\n\n### `.trim`\n\nIf you want whitespace from user input to be trimmed automatically, you can add the `trim` modifier to your `v-model`-managed inputs:\n\n```html\n<input v-model.trim=\"msg\">\n```\n\n## `v-model` with Components\n\n> If you're not yet familiar with Vue's components, you can skip this for now.\n\nHTML's built-in input types won't always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with `v-model`!\n\nTo learn more, read about [custom inputs](components.html#Using-v-model-on-Components) in the Components guide.\n","date":"2020-09-25T23:55:41.137Z","updated":"2020-09-25T23:55:41.137Z","path":"v2/guide/forms.html","comments":1,"layout":"page","_id":"ckfl66gyk0025c2v5j73srj5x","content":"<h2 id=\"Basic-Usage\"><a href=\"#Basic-Usage\" class=\"headerlink\" title=\"Basic Usage\"></a>Basic Usage</h2><p>You can use the <code>v-model</code> directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, <code>v-model</code> is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</p>\n<p class=\"tip\"><code>v-model</code> will ignore the initial <code>value</code>, <code>checked</code>, or <code>selected</code> attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the <code>data</code> option of your component.</p>\n\n<p><code>v-model</code> internally uses different properties and emits different events for different input elements:</p>\n<ul>\n<li>text and textarea elements use <code>value</code> property and <code>input</code> event;</li>\n<li>checkboxes and radiobuttons use <code>checked</code> property and <code>change</code> event;</li>\n<li>select fields use <code>value</code> as a prop and <code>change</code> as an event.</li>\n</ul>\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an <a href=\"https://en.wikipedia.org/wiki/Input_method\" target=\"_blank\" rel=\"noopener\">IME</a> (Chinese, Japanese, Korean, etc.), you’ll notice that <code>v-model</code> doesn’t get updated during IME composition. If you want to cater to these updates as well, use the <code>input</code> event instead.</p>\n\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"message\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"edit me\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n<h3 id=\"Multiline-text\"><a href=\"#Multiline-text\" class=\"headerlink\" title=\"Multiline text\"></a>Multiline text</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Multiline message is:<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"white-space: pre-line;\"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"message\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"add multiple lines\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span></code></pre>\n\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre-line;\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n\n<p class=\"tip\">Interpolation on textareas (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>) won't work. Use <code>v-model</code> instead.</p>\n\n<h3 id=\"Checkbox\"><a href=\"#Checkbox\" class=\"headerlink\" title=\"Checkbox\"></a>Checkbox</h3><p>Single checkbox, boolean value:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checked\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"checkbox\"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></code></pre>\n\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n\n<p>Multiple checkboxes, bound to the same Array:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"jack\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Jack\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checkedNames\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"jack\"</span>&gt;</span>Jack<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"john\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"John\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checkedNames\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"john\"</span>&gt;</span>John<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"mike\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Mike\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checkedNames\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"mike\"</span>&gt;</span>Mike<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'...'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">checkedNames</span>: []\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n\n<h3 id=\"Radio\"><a href=\"#Radio\" class=\"headerlink\" title=\"Radio\"></a>Radio</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"one\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"One\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"one\"</span>&gt;</span>One<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"two\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Two\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"two\"</span>&gt;</span>Two<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n\n<h3 id=\"Select\"><a href=\"#Select\" class=\"headerlink\" title=\"Select\"></a>Select</h3><p>Single select:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">disabled</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"\"</span>&gt;</span>Please select one<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>B<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>C<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'...'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">selected</span>: <span class=\"hljs-string\">''</span>\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option disabled value>Please select one</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: ''\n  }\n})\n</script>\n\n<p class=\"tip\">If the initial value of your <code>v-model</code> expression does not match any of the options, the <code>&lt;select&gt;</code> element will render in an “unselected” state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a <code>change</code> event in this case. It is therefore recommended to provide a <code>disabled</code> option with an empty value, as demonstrated in the example above.</p>\n\n<p>Multiple select (bound to Array):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span> <span class=\"hljs-attr\">multiple</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>B<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>C<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px;\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n\n<p>Dynamic options rendered with <code>v-for</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"option in options\"</span> <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"option.value\"</span>&gt;</span>\n    &#123;&#123; option.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'...'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">selected</span>: <span class=\"hljs-string\">'A'</span>,\n    <span class=\"hljs-attr\">options</span>: [\n      &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'One'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'A'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Two'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'B'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Three'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'C'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n\n<h2 id=\"Value-Bindings\"><a href=\"#Value-Bindings\" class=\"headerlink\" title=\"Value Bindings\"></a>Value Bindings</h2><p>For radio, checkbox and select options, the <code>v-model</code> binding values are usually static strings (or booleans for checkboxes):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- `picked` is a string \"a\" when checked --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"a\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- `toggle` is either true or false --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"toggle\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- `selected` is a string \"abc\" when the first option is selected --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"abc\"</span>&gt;</span>ABC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span></code></pre>\n<p>But sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use <code>v-bind</code> to achieve that. In addition, using <code>v-bind</code> allows us to bind the input value to non-string values.</p>\n<h3 id=\"Checkbox-1\"><a href=\"#Checkbox-1\" class=\"headerlink\" title=\"Checkbox\"></a>Checkbox</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span>\n  <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"toggle\"</span>\n  <span class=\"hljs-attr\">true-value</span>=<span class=\"hljs-string\">\"yes\"</span>\n  <span class=\"hljs-attr\">false-value</span>=<span class=\"hljs-string\">\"no\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// when checked:</span>\nvm.toggle === <span class=\"hljs-string\">'yes'</span>\n<span class=\"hljs-comment\">// when unchecked:</span>\nvm.toggle === <span class=\"hljs-string\">'no'</span></code></pre>\n<p class=\"tip\">The <code>true-value</code> and <code>false-value</code> attributes don’t affect the input’s <code>value</code> attribute, because browsers don’t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. “yes” or “no”), use radio inputs instead.</p>\n\n<h3 id=\"Radio-1\"><a href=\"#Radio-1\" class=\"headerlink\" title=\"Radio\"></a>Radio</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"pick\"</span> <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"a\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// when checked:</span>\nvm.pick === vm.a</code></pre>\n<h3 id=\"Select-Options\"><a href=\"#Select-Options\" class=\"headerlink\" title=\"Select Options\"></a>Select Options</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- inline object literal --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"&#123; number: 123 &#125;\"</span>&gt;</span>123<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// when selected:</span>\n<span class=\"hljs-keyword\">typeof</span> vm.selected <span class=\"hljs-comment\">// =&gt; 'object'</span>\nvm.selected.number <span class=\"hljs-comment\">// =&gt; 123</span></code></pre>\n<h2 id=\"Modifiers\"><a href=\"#Modifiers\" class=\"headerlink\" title=\"Modifiers\"></a>Modifiers</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a><code>.lazy</code></h3><p>By default, <code>v-model</code> syncs the input with the data after each <code>input</code> event (with the exception of IME composition, as <a href=\"#vmodel-ime-tip\">stated above</a>). You can add the <code>lazy</code> modifier to instead sync <em>after</em> <code>change</code> events:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- synced after \"change\" instead of \"input\" --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.lazy</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span></code></pre>\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a><code>.number</code></h3><p>If you want user input to be automatically typecast as a Number, you can add the <code>number</code> modifier to your <code>v-model</code> managed inputs:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"age\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>&gt;</span></code></pre>\n<p>This is often useful, because even with <code>type=&quot;number&quot;</code>, the value of HTML input elements always returns a string. If the value cannot be parsed with <code>parseFloat()</code>, then the original value is returned.</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a><code>.trim</code></h3><p>If you want whitespace from user input to be trimmed automatically, you can add the <code>trim</code> modifier to your <code>v-model</code>-managed inputs:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.trim</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span></code></pre>\n<h2 id=\"v-model-with-Components\"><a href=\"#v-model-with-Components\" class=\"headerlink\" title=\"v-model with Components\"></a><code>v-model</code> with Components</h2><blockquote>\n<p>If you’re not yet familiar with Vue’s components, you can skip this for now.</p>\n</blockquote>\n<p>HTML’s built-in input types won’t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with <code>v-model</code>!</p>\n<p>To learn more, read about <a href=\"components.html#Using-v-model-on-Components\">custom inputs</a> in the Components guide.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Basic-Usage\"><a href=\"#Basic-Usage\" class=\"headerlink\" title=\"Basic Usage\"></a>Basic Usage</h2><p>You can use the <code>v-model</code> directive to create two-way data bindings on form input, textarea, and select elements. It automatically picks the correct way to update the element based on the input type. Although a bit magical, <code>v-model</code> is essentially syntax sugar for updating data on user input events, plus special care for some edge cases.</p>\n<p class=\"tip\"><code>v-model</code> will ignore the initial <code>value</code>, <code>checked</code>, or <code>selected</code> attributes found on any form elements. It will always treat the Vue instance data as the source of truth. You should declare the initial value on the JavaScript side, inside the <code>data</code> option of your component.</p>\n\n<p><code>v-model</code> internally uses different properties and emits different events for different input elements:</p>\n<ul>\n<li>text and textarea elements use <code>value</code> property and <code>input</code> event;</li>\n<li>checkboxes and radiobuttons use <code>checked</code> property and <code>change</code> event;</li>\n<li>select fields use <code>value</code> as a prop and <code>change</code> as an event.</li>\n</ul>\n<p class=\"tip\" id=\"vmodel-ime-tip\">For languages that require an <a href=\"https://en.wikipedia.org/wiki/Input_method\" target=\"_blank\" rel=\"noopener\">IME</a> (Chinese, Japanese, Korean, etc.), you’ll notice that <code>v-model</code> doesn’t get updated during IME composition. If you want to cater to these updates as well, use the <code>input</code> event instead.</p>\n\n<h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"message\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"edit me\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n\n<div id=\"example-1\" class=\"demo\">\n  <input v-model=\"message\" placeholder=\"edit me\">\n  <p>Message is: {{ message }}</p>\n</div>\n<script>\nnew Vue({\n  el: '#example-1',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n<h3 id=\"Multiline-text\"><a href=\"#Multiline-text\" class=\"headerlink\" title=\"Multiline text\"></a>Multiline text</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Multiline message is:<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">\"white-space: pre-line;\"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">textarea</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"message\"</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"add multiple lines\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">textarea</span>&gt;</span></code></pre>\n\n<div id=\"example-textarea\" class=\"demo\">\n  <span>Multiline message is:</span>\n  <p style=\"white-space: pre-line;\">{{ message }}</p>\n  <br>\n  <textarea v-model=\"message\" placeholder=\"add multiple lines\"></textarea>\n</div>\n<script>\nnew Vue({\n  el: '#example-textarea',\n  data: {\n    message: ''\n  }\n})\n</script>\n\n\n<p class=\"tip\">Interpolation on textareas (<code>&lt;textarea&gt;{{text}}&lt;/textarea&gt;</code>) won't work. Use <code>v-model</code> instead.</p>\n\n<h3 id=\"Checkbox\"><a href=\"#Checkbox\" class=\"headerlink\" title=\"Checkbox\"></a>Checkbox</h3><p>Single checkbox, boolean value:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checked\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"checkbox\"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></code></pre>\n\n<div id=\"example-2\" class=\"demo\">\n  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">\n  <label for=\"checkbox\">{{ checked }}</label>\n</div>\n<script>\nnew Vue({\n  el: '#example-2',\n  data: {\n    checked: false\n  }\n})\n</script>\n\n<p>Multiple checkboxes, bound to the same Array:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"jack\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Jack\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checkedNames\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"jack\"</span>&gt;</span>Jack<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"john\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"John\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checkedNames\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"john\"</span>&gt;</span>John<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"mike\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Mike\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"checkedNames\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"mike\"</span>&gt;</span>Mike<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'...'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">checkedNames</span>: []\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"example-3\" class=\"demo\">\n  <input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n  <label for=\"jack\">Jack</label>\n  <input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n  <label for=\"john\">John</label>\n  <input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\">\n  <label for=\"mike\">Mike</label>\n  <br>\n  <span>Checked names: {{ checkedNames }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-3',\n  data: {\n    checkedNames: []\n  }\n})\n</script>\n\n<h3 id=\"Radio\"><a href=\"#Radio\" class=\"headerlink\" title=\"Radio\"></a>Radio</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"one\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"One\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"one\"</span>&gt;</span>One<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"two\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"Two\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"two\"</span>&gt;</span>Two<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n\n<div id=\"example-4\" class=\"demo\">\n  <input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\">\n  <label for=\"one\">One</label>\n  <br>\n  <input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\">\n  <label for=\"two\">Two</label>\n  <br>\n  <span>Picked: {{ picked }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-4',\n  data: {\n    picked: ''\n  }\n})\n</script>\n\n<h3 id=\"Select\"><a href=\"#Select\" class=\"headerlink\" title=\"Select\"></a>Select</h3><p>Single select:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">disabled</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"\"</span>&gt;</span>Please select one<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>B<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>C<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'...'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">selected</span>: <span class=\"hljs-string\">''</span>\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"example-5\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option disabled value>Please select one</option>\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-5',\n  data: {\n    selected: ''\n  }\n})\n</script>\n\n<p class=\"tip\">If the initial value of your <code>v-model</code> expression does not match any of the options, the <code>&lt;select&gt;</code> element will render in an “unselected” state. On iOS, this will prevent the user from being able to select the first item, because iOS does not fire a <code>change</code> event in this case. It is therefore recommended to provide a <code>disabled</code> option with an empty value, as demonstrated in the example above.</p>\n\n<p>Multiple select (bound to Array):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span> <span class=\"hljs-attr\">multiple</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>A<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>B<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span>&gt;</span>C<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n\n<div id=\"example-6\" class=\"demo\">\n  <select v-model=\"selected\" multiple style=\"width: 50px;\">\n    <option>A</option>\n    <option>B</option>\n    <option>C</option>\n  </select>\n  <br>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-6',\n  data: {\n    selected: []\n  }\n})\n</script>\n\n<p>Dynamic options rendered with <code>v-for</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"option in options\"</span> <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"option.value\"</span>&gt;</span>\n    &#123;&#123; option.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'...'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">selected</span>: <span class=\"hljs-string\">'A'</span>,\n    <span class=\"hljs-attr\">options</span>: [\n      &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'One'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'A'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Two'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'B'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Three'</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'C'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"example-7\" class=\"demo\">\n  <select v-model=\"selected\">\n    <option v-for=\"option in options\" v-bind:value=\"option.value\">\n      {{ option.text }}\n    </option>\n  </select>\n  <span>Selected: {{ selected }}</span>\n</div>\n<script>\nnew Vue({\n  el: '#example-7',\n  data: {\n    selected: 'A',\n    options: [\n      { text: 'One', value: 'A' },\n      { text: 'Two', value: 'B' },\n      { text: 'Three', value: 'C' }\n    ]\n  }\n})\n</script>\n\n<h2 id=\"Value-Bindings\"><a href=\"#Value-Bindings\" class=\"headerlink\" title=\"Value Bindings\"></a>Value Bindings</h2><p>For radio, checkbox and select options, the <code>v-model</code> binding values are usually static strings (or booleans for checkboxes):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- `picked` is a string \"a\" when checked --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"picked\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"a\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- `toggle` is either true or false --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"toggle\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- `selected` is a string \"abc\" when the first option is selected --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"abc\"</span>&gt;</span>ABC<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span></code></pre>\n<p>But sometimes, we may want to bind the value to a dynamic property on the Vue instance. We can use <code>v-bind</code> to achieve that. In addition, using <code>v-bind</code> allows us to bind the input value to non-string values.</p>\n<h3 id=\"Checkbox-1\"><a href=\"#Checkbox-1\" class=\"headerlink\" title=\"Checkbox\"></a>Checkbox</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"checkbox\"</span>\n  <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"toggle\"</span>\n  <span class=\"hljs-attr\">true-value</span>=<span class=\"hljs-string\">\"yes\"</span>\n  <span class=\"hljs-attr\">false-value</span>=<span class=\"hljs-string\">\"no\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// when checked:</span>\nvm.toggle === <span class=\"hljs-string\">'yes'</span>\n<span class=\"hljs-comment\">// when unchecked:</span>\nvm.toggle === <span class=\"hljs-string\">'no'</span></code></pre>\n<p class=\"tip\">The <code>true-value</code> and <code>false-value</code> attributes don’t affect the input’s <code>value</code> attribute, because browsers don’t include unchecked boxes in form submissions. To guarantee that one of two values is submitted in a form (i.e. “yes” or “no”), use radio inputs instead.</p>\n\n<h3 id=\"Radio-1\"><a href=\"#Radio-1\" class=\"headerlink\" title=\"Radio\"></a>Radio</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"radio\"</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"pick\"</span> <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"a\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// when checked:</span>\nvm.pick === vm.a</code></pre>\n<h3 id=\"Select-Options\"><a href=\"#Select-Options\" class=\"headerlink\" title=\"Select Options\"></a>Select Options</h3><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">select</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"selected\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- inline object literal --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">option</span> <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"&#123; number: 123 &#125;\"</span>&gt;</span>123<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">option</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">select</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// when selected:</span>\n<span class=\"hljs-keyword\">typeof</span> vm.selected <span class=\"hljs-comment\">// =&gt; 'object'</span>\nvm.selected.number <span class=\"hljs-comment\">// =&gt; 123</span></code></pre>\n<h2 id=\"Modifiers\"><a href=\"#Modifiers\" class=\"headerlink\" title=\"Modifiers\"></a>Modifiers</h2><h3 id=\"lazy\"><a href=\"#lazy\" class=\"headerlink\" title=\".lazy\"></a><code>.lazy</code></h3><p>By default, <code>v-model</code> syncs the input with the data after each <code>input</code> event (with the exception of IME composition, as <a href=\"#vmodel-ime-tip\">stated above</a>). You can add the <code>lazy</code> modifier to instead sync <em>after</em> <code>change</code> events:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- synced after \"change\" instead of \"input\" --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.lazy</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span></code></pre>\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\".number\"></a><code>.number</code></h3><p>If you want user input to be automatically typecast as a Number, you can add the <code>number</code> modifier to your <code>v-model</code> managed inputs:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.number</span>=<span class=\"hljs-string\">\"age\"</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"number\"</span>&gt;</span></code></pre>\n<p>This is often useful, because even with <code>type=&quot;number&quot;</code>, the value of HTML input elements always returns a string. If the value cannot be parsed with <code>parseFloat()</code>, then the original value is returned.</p>\n<h3 id=\"trim\"><a href=\"#trim\" class=\"headerlink\" title=\".trim\"></a><code>.trim</code></h3><p>If you want whitespace from user input to be trimmed automatically, you can add the <code>trim</code> modifier to your <code>v-model</code>-managed inputs:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model.trim</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span></code></pre>\n<h2 id=\"v-model-with-Components\"><a href=\"#v-model-with-Components\" class=\"headerlink\" title=\"v-model with Components\"></a><code>v-model</code> with Components</h2><blockquote>\n<p>If you’re not yet familiar with Vue’s components, you can skip this for now.</p>\n</blockquote>\n<p>HTML’s built-in input types won’t always meet your needs. Fortunately, Vue components allow you to build reusable inputs with completely customized behavior. These inputs even work with <code>v-model</code>!</p>\n<p>To learn more, read about <a href=\"components.html#Using-v-model-on-Components\">custom inputs</a> in the Components guide.</p>\n"},{"type":"guide","_content":"\n\n\n\n\n","source":"v2/guide/index.md","raw":"---\ntype: guide\n---\n\n\n\n\n\n","date":"2020-09-25T23:55:41.137Z","updated":"2020-09-25T23:55:41.137Z","path":"v2/guide/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gyl0026c2v5pvdaj05p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Production Deployment","type":"guide","order":404,"_content":"\n> Most of the tips below are enabled by default if you are using [Vue CLI](https://cli.vuejs.org). This section is only relevant if you are using a custom build setup.\n\n## Turn on Production Mode\n\nDuring development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app's payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode.\n\n### Without Build Tools\n\nIf you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (`vue.min.js`) for production. Both versions can be found in the [Installation guide](installation.html#Direct-lt-script-gt-Include).\n\n### With Build Tools\n\nWhen using a build tool like Webpack or Browserify, the production mode will be determined by `process.env.NODE_ENV` inside Vue's source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue's production mode, and warnings will be stripped by minifiers during the build. All `vue-cli` templates have these pre-configured for you, but it would be beneficial to know how it is done:\n\n#### Webpack\n\nIn Webpack 4+, you can use the `mode` option:\n\n``` js\nmodule.exports = {\n  mode: 'production'\n}\n```\n\nBut in Webpack 3 and earlier, you'll need to use [DefinePlugin](https://webpack.js.org/plugins/define-plugin/):\n\n``` js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    // ...\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    })\n  ]\n}\n```\n\n#### Browserify\n\n- Run your bundling command with the actual `NODE_ENV` environment variable set to `\"production\"`. This tells `vueify` to avoid including hot-reload and development related code.\n\n- Apply a global [envify](https://github.com/hughsk/envify) transform to your bundle. This allows the minifier to strip out all the warnings in Vue's source code wrapped in env variable conditional blocks. For example:\n\n  ``` bash\n  NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js\n  ```\n\n- Or, using [envify](https://github.com/hughsk/envify) with Gulp:\n\n  ``` js\n  // Use the envify custom module to specify environment variables\n  var envify = require('envify/custom')\n\n  browserify(browserifyOptions)\n    .transform(vueify)\n    .transform(\n      // Required in order to process node_modules files\n      { global: true },\n      envify({ NODE_ENV: 'production' })\n    )\n    .bundle()\n  ```\n\n- Or, using [envify](https://github.com/hughsk/envify) with Grunt and [grunt-browserify](https://github.com/jmreidy/grunt-browserify):\n\n  ``` js\n  // Use the envify custom module to specify environment variables\n  var envify = require('envify/custom')\n\n  browserify: {\n    dist: {\n      options: {\n        // Function to deviate from grunt-browserify's default order\n        configure: b => b\n          .transform('vueify')\n          .transform(\n            // Required in order to process node_modules files\n            { global: true },\n            envify({ NODE_ENV: 'production' })\n          )\n          .bundle()\n      }\n    }\n  }\n  ```\n\n#### Rollup\n\nUse [@rollup/plugin-replace](https://github.com/rollup/plugins/tree/master/packages/replace):\n\n``` js\nconst replace = require('@rollup/plugin-replace')\n\nrollup({\n  // ...\n  plugins: [\n    replace({\n      'process.env.NODE_ENV': JSON.stringify( 'production' )\n    })\n  ]\n}).then(...)\n```\n\n## Pre-Compiling Templates\n\nWhen using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.\n\nThe easiest way to pre-compile templates is using [Single-File Components](single-file-components.html) - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.\n\nIf you are using Webpack, and prefer separating JavaScript and template files, you can use [vue-template-loader](https://github.com/ktsn/vue-template-loader), which also transforms the template files into JavaScript render functions during the build step.\n\n## Extracting Component CSS\n\nWhen using Single-File Components, the CSS inside components are injected dynamically as `<style>` tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a \"flash of unstyled content\". Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.\n\nRefer to the respective build tool documentations to see how it's done:\n\n- [Webpack + vue-loader](https://vue-loader.vuejs.org/en/configurations/extract-css.html) (the `vue-cli` webpack template has this pre-configured)\n- [Browserify + vueify](https://github.com/vuejs/vueify#css-extraction)\n- [Rollup + rollup-plugin-vue](https://vuejs.github.io/rollup-plugin-vue/#/en/2.3/?id=custom-handler)\n\n## Tracking Runtime Errors\n\nIf a runtime error occurs during a component's render, it will be passed to the global `Vue.config.errorHandler` config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like [Sentry](https://sentry.io), which provides [an official integration](https://sentry.io/for/vue/) for Vue.\n","source":"v2/guide/deployment.md","raw":"---\ntitle: Production Deployment\ntype: guide\norder: 404\n---\n\n> Most of the tips below are enabled by default if you are using [Vue CLI](https://cli.vuejs.org). This section is only relevant if you are using a custom build setup.\n\n## Turn on Production Mode\n\nDuring development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app's payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode.\n\n### Without Build Tools\n\nIf you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (`vue.min.js`) for production. Both versions can be found in the [Installation guide](installation.html#Direct-lt-script-gt-Include).\n\n### With Build Tools\n\nWhen using a build tool like Webpack or Browserify, the production mode will be determined by `process.env.NODE_ENV` inside Vue's source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue's production mode, and warnings will be stripped by minifiers during the build. All `vue-cli` templates have these pre-configured for you, but it would be beneficial to know how it is done:\n\n#### Webpack\n\nIn Webpack 4+, you can use the `mode` option:\n\n``` js\nmodule.exports = {\n  mode: 'production'\n}\n```\n\nBut in Webpack 3 and earlier, you'll need to use [DefinePlugin](https://webpack.js.org/plugins/define-plugin/):\n\n``` js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    // ...\n    new webpack.DefinePlugin({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    })\n  ]\n}\n```\n\n#### Browserify\n\n- Run your bundling command with the actual `NODE_ENV` environment variable set to `\"production\"`. This tells `vueify` to avoid including hot-reload and development related code.\n\n- Apply a global [envify](https://github.com/hughsk/envify) transform to your bundle. This allows the minifier to strip out all the warnings in Vue's source code wrapped in env variable conditional blocks. For example:\n\n  ``` bash\n  NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js\n  ```\n\n- Or, using [envify](https://github.com/hughsk/envify) with Gulp:\n\n  ``` js\n  // Use the envify custom module to specify environment variables\n  var envify = require('envify/custom')\n\n  browserify(browserifyOptions)\n    .transform(vueify)\n    .transform(\n      // Required in order to process node_modules files\n      { global: true },\n      envify({ NODE_ENV: 'production' })\n    )\n    .bundle()\n  ```\n\n- Or, using [envify](https://github.com/hughsk/envify) with Grunt and [grunt-browserify](https://github.com/jmreidy/grunt-browserify):\n\n  ``` js\n  // Use the envify custom module to specify environment variables\n  var envify = require('envify/custom')\n\n  browserify: {\n    dist: {\n      options: {\n        // Function to deviate from grunt-browserify's default order\n        configure: b => b\n          .transform('vueify')\n          .transform(\n            // Required in order to process node_modules files\n            { global: true },\n            envify({ NODE_ENV: 'production' })\n          )\n          .bundle()\n      }\n    }\n  }\n  ```\n\n#### Rollup\n\nUse [@rollup/plugin-replace](https://github.com/rollup/plugins/tree/master/packages/replace):\n\n``` js\nconst replace = require('@rollup/plugin-replace')\n\nrollup({\n  // ...\n  plugins: [\n    replace({\n      'process.env.NODE_ENV': JSON.stringify( 'production' )\n    })\n  ]\n}).then(...)\n```\n\n## Pre-Compiling Templates\n\nWhen using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.\n\nThe easiest way to pre-compile templates is using [Single-File Components](single-file-components.html) - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.\n\nIf you are using Webpack, and prefer separating JavaScript and template files, you can use [vue-template-loader](https://github.com/ktsn/vue-template-loader), which also transforms the template files into JavaScript render functions during the build step.\n\n## Extracting Component CSS\n\nWhen using Single-File Components, the CSS inside components are injected dynamically as `<style>` tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a \"flash of unstyled content\". Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.\n\nRefer to the respective build tool documentations to see how it's done:\n\n- [Webpack + vue-loader](https://vue-loader.vuejs.org/en/configurations/extract-css.html) (the `vue-cli` webpack template has this pre-configured)\n- [Browserify + vueify](https://github.com/vuejs/vueify#css-extraction)\n- [Rollup + rollup-plugin-vue](https://vuejs.github.io/rollup-plugin-vue/#/en/2.3/?id=custom-handler)\n\n## Tracking Runtime Errors\n\nIf a runtime error occurs during a component's render, it will be passed to the global `Vue.config.errorHandler` config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like [Sentry](https://sentry.io), which provides [an official integration](https://sentry.io/for/vue/) for Vue.\n","date":"2020-09-25T23:55:41.136Z","updated":"2020-09-25T23:55:41.136Z","path":"v2/guide/deployment.html","comments":1,"layout":"page","_id":"ckfl66gyl0027c2v51r7gfae0","content":"<blockquote>\n<p>Most of the tips below are enabled by default if you are using <a href=\"https://cli.vuejs.org\" target=\"_blank\" rel=\"noopener\">Vue CLI</a>. This section is only relevant if you are using a custom build setup.</p>\n</blockquote>\n<h2 id=\"Turn-on-Production-Mode\"><a href=\"#Turn-on-Production-Mode\" class=\"headerlink\" title=\"Turn on Production Mode\"></a>Turn on Production Mode</h2><p>During development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app’s payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode.</p>\n<h3 id=\"Without-Build-Tools\"><a href=\"#Without-Build-Tools\" class=\"headerlink\" title=\"Without Build Tools\"></a>Without Build Tools</h3><p>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (<code>vue.min.js</code>) for production. Both versions can be found in the <a href=\"installation.html#Direct-lt-script-gt-Include\">Installation guide</a>.</p>\n<h3 id=\"With-Build-Tools\"><a href=\"#With-Build-Tools\" class=\"headerlink\" title=\"With Build Tools\"></a>With Build Tools</h3><p>When using a build tool like Webpack or Browserify, the production mode will be determined by <code>process.env.NODE_ENV</code> inside Vue’s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue’s production mode, and warnings will be stripped by minifiers during the build. All <code>vue-cli</code> templates have these pre-configured for you, but it would be beneficial to know how it is done:</p>\n<h4 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h4><p>In Webpack 4+, you can use the <code>mode</code> option:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'production'</span>\n&#125;</code></pre>\n<p>But in Webpack 3 and earlier, you’ll need to use <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\">DefinePlugin</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'webpack'</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">new</span> webpack.DefinePlugin(&#123;\n      <span class=\"hljs-string\">'process.env.NODE_ENV'</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-string\">'production'</span>)\n    &#125;)\n  ]\n&#125;</code></pre>\n<h4 id=\"Browserify\"><a href=\"#Browserify\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h4><ul>\n<li><p>Run your bundling command with the actual <code>NODE_ENV</code> environment variable set to <code>&quot;production&quot;</code>. This tells <code>vueify</code> to avoid including hot-reload and development related code.</p>\n</li>\n<li><p>Apply a global <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> transform to your bundle. This allows the minifier to strip out all the warnings in Vue’s source code wrapped in env variable conditional blocks. For example:</p>\n<pre><code class=\"hljs bash\">NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js</code></pre>\n</li>\n<li><p>Or, using <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> with Gulp:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Use the envify custom module to specify environment variables</span>\n<span class=\"hljs-keyword\">var</span> envify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'envify/custom'</span>)\n\nbrowserify(browserifyOptions)\n  .transform(vueify)\n  .transform(\n    <span class=\"hljs-comment\">// Required in order to process node_modules files</span>\n    &#123; <span class=\"hljs-attr\">global</span>: <span class=\"hljs-literal\">true</span> &#125;,\n    envify(&#123; <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">'production'</span> &#125;)\n  )\n  .bundle()</code></pre>\n</li>\n<li><p>Or, using <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> with Grunt and <a href=\"https://github.com/jmreidy/grunt-browserify\" target=\"_blank\" rel=\"noopener\">grunt-browserify</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Use the envify custom module to specify environment variables</span>\n<span class=\"hljs-keyword\">var</span> envify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'envify/custom'</span>)\n\n<span class=\"hljs-attr\">browserify</span>: &#123;\n  <span class=\"hljs-attr\">dist</span>: &#123;\n    <span class=\"hljs-attr\">options</span>: &#123;\n      <span class=\"hljs-comment\">// Function to deviate from grunt-browserify's default order</span>\n      <span class=\"hljs-attr\">configure</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">b</span> =&gt;</span> b\n        .transform(<span class=\"hljs-string\">'vueify'</span>)\n        .transform(\n          <span class=\"hljs-comment\">// Required in order to process node_modules files</span>\n          &#123; <span class=\"hljs-attr\">global</span>: <span class=\"hljs-literal\">true</span> &#125;,\n          envify(&#123; <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">'production'</span> &#125;)\n        )\n        .bundle()\n    &#125;\n  &#125;\n&#125;</code></pre>\n</li>\n</ul>\n<h4 id=\"Rollup\"><a href=\"#Rollup\" class=\"headerlink\" title=\"Rollup\"></a>Rollup</h4><p>Use <a href=\"https://github.com/rollup/plugins/tree/master/packages/replace\" target=\"_blank\" rel=\"noopener\">@rollup/plugin-replace</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> replace = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'@rollup/plugin-replace'</span>)\n\nrollup(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    replace(&#123;\n      <span class=\"hljs-string\">'process.env.NODE_ENV'</span>: <span class=\"hljs-built_in\">JSON</span>.stringify( <span class=\"hljs-string\">'production'</span> )\n    &#125;)\n  ]\n&#125;).then(...)</code></pre>\n<h2 id=\"Pre-Compiling-Templates\"><a href=\"#Pre-Compiling-Templates\" class=\"headerlink\" title=\"Pre-Compiling Templates\"></a>Pre-Compiling Templates</h2><p>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</p>\n<p>The easiest way to pre-compile templates is using <a href=\"single-file-components.html\">Single-File Components</a> - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.</p>\n<p>If you are using Webpack, and prefer separating JavaScript and template files, you can use <a href=\"https://github.com/ktsn/vue-template-loader\" target=\"_blank\" rel=\"noopener\">vue-template-loader</a>, which also transforms the template files into JavaScript render functions during the build step.</p>\n<h2 id=\"Extracting-Component-CSS\"><a href=\"#Extracting-Component-CSS\" class=\"headerlink\" title=\"Extracting Component CSS\"></a>Extracting Component CSS</h2><p>When using Single-File Components, the CSS inside components are injected dynamically as <code>&lt;style&gt;</code> tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a “flash of unstyled content”. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</p>\n<p>Refer to the respective build tool documentations to see how it’s done:</p>\n<ul>\n<li><a href=\"https://vue-loader.vuejs.org/en/configurations/extract-css.html\" target=\"_blank\" rel=\"noopener\">Webpack + vue-loader</a> (the <code>vue-cli</code> webpack template has this pre-configured)</li>\n<li><a href=\"https://github.com/vuejs/vueify#css-extraction\" target=\"_blank\" rel=\"noopener\">Browserify + vueify</a></li>\n<li><a href=\"https://vuejs.github.io/rollup-plugin-vue/#/en/2.3/?id=custom-handler\" target=\"_blank\" rel=\"noopener\">Rollup + rollup-plugin-vue</a></li>\n</ul>\n<h2 id=\"Tracking-Runtime-Errors\"><a href=\"#Tracking-Runtime-Errors\" class=\"headerlink\" title=\"Tracking Runtime Errors\"></a>Tracking Runtime Errors</h2><p>If a runtime error occurs during a component’s render, it will be passed to the global <code>Vue.config.errorHandler</code> config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like <a href=\"https://sentry.io\" target=\"_blank\" rel=\"noopener\">Sentry</a>, which provides <a href=\"https://sentry.io/for/vue/\" target=\"_blank\" rel=\"noopener\">an official integration</a> for Vue.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Most of the tips below are enabled by default if you are using <a href=\"https://cli.vuejs.org\" target=\"_blank\" rel=\"noopener\">Vue CLI</a>. This section is only relevant if you are using a custom build setup.</p>\n</blockquote>\n<h2 id=\"Turn-on-Production-Mode\"><a href=\"#Turn-on-Production-Mode\" class=\"headerlink\" title=\"Turn on Production Mode\"></a>Turn on Production Mode</h2><p>During development, Vue provides a lot of warnings to help you with common errors and pitfalls. However, these warning strings become useless in production and bloat your app’s payload size. In addition, some of these warning checks have small runtime costs that can be avoided in production mode.</p>\n<h3 id=\"Without-Build-Tools\"><a href=\"#Without-Build-Tools\" class=\"headerlink\" title=\"Without Build Tools\"></a>Without Build Tools</h3><p>If you are using the full build, i.e. directly including Vue via a script tag without a build tool, make sure to use the minified version (<code>vue.min.js</code>) for production. Both versions can be found in the <a href=\"installation.html#Direct-lt-script-gt-Include\">Installation guide</a>.</p>\n<h3 id=\"With-Build-Tools\"><a href=\"#With-Build-Tools\" class=\"headerlink\" title=\"With Build Tools\"></a>With Build Tools</h3><p>When using a build tool like Webpack or Browserify, the production mode will be determined by <code>process.env.NODE_ENV</code> inside Vue’s source code, and it will be in development mode by default. Both build tools provide ways to overwrite this variable to enable Vue’s production mode, and warnings will be stripped by minifiers during the build. All <code>vue-cli</code> templates have these pre-configured for you, but it would be beneficial to know how it is done:</p>\n<h4 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h4><p>In Webpack 4+, you can use the <code>mode</code> option:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'production'</span>\n&#125;</code></pre>\n<p>But in Webpack 3 and earlier, you’ll need to use <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\">DefinePlugin</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'webpack'</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">new</span> webpack.DefinePlugin(&#123;\n      <span class=\"hljs-string\">'process.env.NODE_ENV'</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-string\">'production'</span>)\n    &#125;)\n  ]\n&#125;</code></pre>\n<h4 id=\"Browserify\"><a href=\"#Browserify\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h4><ul>\n<li><p>Run your bundling command with the actual <code>NODE_ENV</code> environment variable set to <code>&quot;production&quot;</code>. This tells <code>vueify</code> to avoid including hot-reload and development related code.</p>\n</li>\n<li><p>Apply a global <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> transform to your bundle. This allows the minifier to strip out all the warnings in Vue’s source code wrapped in env variable conditional blocks. For example:</p>\n<pre><code class=\"hljs bash\">NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js</code></pre>\n</li>\n<li><p>Or, using <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> with Gulp:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Use the envify custom module to specify environment variables</span>\n<span class=\"hljs-keyword\">var</span> envify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'envify/custom'</span>)\n\nbrowserify(browserifyOptions)\n  .transform(vueify)\n  .transform(\n    <span class=\"hljs-comment\">// Required in order to process node_modules files</span>\n    &#123; <span class=\"hljs-attr\">global</span>: <span class=\"hljs-literal\">true</span> &#125;,\n    envify(&#123; <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">'production'</span> &#125;)\n  )\n  .bundle()</code></pre>\n</li>\n<li><p>Or, using <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> with Grunt and <a href=\"https://github.com/jmreidy/grunt-browserify\" target=\"_blank\" rel=\"noopener\">grunt-browserify</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Use the envify custom module to specify environment variables</span>\n<span class=\"hljs-keyword\">var</span> envify = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'envify/custom'</span>)\n\n<span class=\"hljs-attr\">browserify</span>: &#123;\n  <span class=\"hljs-attr\">dist</span>: &#123;\n    <span class=\"hljs-attr\">options</span>: &#123;\n      <span class=\"hljs-comment\">// Function to deviate from grunt-browserify's default order</span>\n      <span class=\"hljs-attr\">configure</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">b</span> =&gt;</span> b\n        .transform(<span class=\"hljs-string\">'vueify'</span>)\n        .transform(\n          <span class=\"hljs-comment\">// Required in order to process node_modules files</span>\n          &#123; <span class=\"hljs-attr\">global</span>: <span class=\"hljs-literal\">true</span> &#125;,\n          envify(&#123; <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-string\">'production'</span> &#125;)\n        )\n        .bundle()\n    &#125;\n  &#125;\n&#125;</code></pre>\n</li>\n</ul>\n<h4 id=\"Rollup\"><a href=\"#Rollup\" class=\"headerlink\" title=\"Rollup\"></a>Rollup</h4><p>Use <a href=\"https://github.com/rollup/plugins/tree/master/packages/replace\" target=\"_blank\" rel=\"noopener\">@rollup/plugin-replace</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> replace = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'@rollup/plugin-replace'</span>)\n\nrollup(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    replace(&#123;\n      <span class=\"hljs-string\">'process.env.NODE_ENV'</span>: <span class=\"hljs-built_in\">JSON</span>.stringify( <span class=\"hljs-string\">'production'</span> )\n    &#125;)\n  ]\n&#125;).then(...)</code></pre>\n<h2 id=\"Pre-Compiling-Templates\"><a href=\"#Pre-Compiling-Templates\" class=\"headerlink\" title=\"Pre-Compiling Templates\"></a>Pre-Compiling Templates</h2><p>When using in-DOM templates or in-JavaScript template strings, the template-to-render-function compilation is performed on the fly. This is usually fast enough in most cases, but is best avoided if your application is performance-sensitive.</p>\n<p>The easiest way to pre-compile templates is using <a href=\"single-file-components.html\">Single-File Components</a> - the associated build setups automatically performs pre-compilation for you, so the built code contains the already compiled render functions instead of raw template strings.</p>\n<p>If you are using Webpack, and prefer separating JavaScript and template files, you can use <a href=\"https://github.com/ktsn/vue-template-loader\" target=\"_blank\" rel=\"noopener\">vue-template-loader</a>, which also transforms the template files into JavaScript render functions during the build step.</p>\n<h2 id=\"Extracting-Component-CSS\"><a href=\"#Extracting-Component-CSS\" class=\"headerlink\" title=\"Extracting Component CSS\"></a>Extracting Component CSS</h2><p>When using Single-File Components, the CSS inside components are injected dynamically as <code>&lt;style&gt;</code> tags via JavaScript. This has a small runtime cost, and if you are using server-side rendering it will cause a “flash of unstyled content”. Extracting the CSS across all components into the same file will avoid these issues, and also result in better CSS minification and caching.</p>\n<p>Refer to the respective build tool documentations to see how it’s done:</p>\n<ul>\n<li><a href=\"https://vue-loader.vuejs.org/en/configurations/extract-css.html\" target=\"_blank\" rel=\"noopener\">Webpack + vue-loader</a> (the <code>vue-cli</code> webpack template has this pre-configured)</li>\n<li><a href=\"https://github.com/vuejs/vueify#css-extraction\" target=\"_blank\" rel=\"noopener\">Browserify + vueify</a></li>\n<li><a href=\"https://vuejs.github.io/rollup-plugin-vue/#/en/2.3/?id=custom-handler\" target=\"_blank\" rel=\"noopener\">Rollup + rollup-plugin-vue</a></li>\n</ul>\n<h2 id=\"Tracking-Runtime-Errors\"><a href=\"#Tracking-Runtime-Errors\" class=\"headerlink\" title=\"Tracking Runtime Errors\"></a>Tracking Runtime Errors</h2><p>If a runtime error occurs during a component’s render, it will be passed to the global <code>Vue.config.errorHandler</code> config function if it has been set. It might be a good idea to leverage this hook together with an error-tracking service like <a href=\"https://sentry.io\" target=\"_blank\" rel=\"noopener\">Sentry</a>, which provides <a href=\"https://sentry.io/for/vue/\" target=\"_blank\" rel=\"noopener\">an official integration</a> for Vue.</p>\n"},{"title":"Filters","type":"guide","order":305,"_content":"\nVue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: **mustache interpolations and `v-bind` expressions** (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the \"pipe\" symbol:\n\n``` html\n<!-- in mustaches -->\n{{ message | capitalize }}\n\n<!-- in v-bind -->\n<div v-bind:id=\"rawId | formatId\"></div>\n```\n\nYou can define local filters in a component's options:\n\n``` js\nfilters: {\n  capitalize: function (value) {\n    if (!value) return ''\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  }\n}\n```\n\nor define a filter globally before creating the Vue instance:\n\n``` js\nVue.filter('capitalize', function (value) {\n  if (!value) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n})\n\nnew Vue({\n  // ...\n})\n```\n\nWhen the global filter has the same name as the local filter, the local filter will be preferred.\n\nBelow is an example of our `capitalize` filter being used:\n\n{% raw %}\n<div id=\"example_1\" class=\"demo\">\n  <input type=\"text\" v-model=\"message\">\n  <p>{{ message | capitalize }}</p>\n</div>\n<script>\n  new Vue({\n    el: '#example_1',\n    data: function () {\n      return {\n        message: 'john'\n      }\n    },\n    filters: {\n      capitalize: function (value) {\n        if (!value) return ''\n        value = value.toString()\n        return value.charAt(0).toUpperCase() + value.slice(1)\n      }\n    }\n  })\n</script>\n{% endraw %}\n\nThe filter's function always receives the expression's value (the result of the former chain) as its first argument. In the above example, the `capitalize` filter function will receive the value of `message` as its argument.\n\nFilters can be chained:\n\n``` html\n{{ message | filterA | filterB }}\n```\n\nIn this case, `filterA`, defined with a single argument, will receive the value of `message`, and then the `filterB` function will be called with the result of `filterA` passed into `filterB`'s single argument.\n\nFilters are JavaScript functions, therefore they can take arguments:\n\n``` html\n{{ message | filterA('arg1', arg2) }}\n```\n\nHere `filterA` is defined as a function taking three arguments. The value of `message` will be passed into the first argument. The plain string `'arg1'` will be passed into the `filterA` as its second argument, and the value of expression `arg2` will be evaluated and passed in as the third argument.\n","source":"v2/guide/filters.md","raw":"---\ntitle: Filters\ntype: guide\norder: 305\n---\n\nVue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: **mustache interpolations and `v-bind` expressions** (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the \"pipe\" symbol:\n\n``` html\n<!-- in mustaches -->\n{{ message | capitalize }}\n\n<!-- in v-bind -->\n<div v-bind:id=\"rawId | formatId\"></div>\n```\n\nYou can define local filters in a component's options:\n\n``` js\nfilters: {\n  capitalize: function (value) {\n    if (!value) return ''\n    value = value.toString()\n    return value.charAt(0).toUpperCase() + value.slice(1)\n  }\n}\n```\n\nor define a filter globally before creating the Vue instance:\n\n``` js\nVue.filter('capitalize', function (value) {\n  if (!value) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n})\n\nnew Vue({\n  // ...\n})\n```\n\nWhen the global filter has the same name as the local filter, the local filter will be preferred.\n\nBelow is an example of our `capitalize` filter being used:\n\n{% raw %}\n<div id=\"example_1\" class=\"demo\">\n  <input type=\"text\" v-model=\"message\">\n  <p>{{ message | capitalize }}</p>\n</div>\n<script>\n  new Vue({\n    el: '#example_1',\n    data: function () {\n      return {\n        message: 'john'\n      }\n    },\n    filters: {\n      capitalize: function (value) {\n        if (!value) return ''\n        value = value.toString()\n        return value.charAt(0).toUpperCase() + value.slice(1)\n      }\n    }\n  })\n</script>\n{% endraw %}\n\nThe filter's function always receives the expression's value (the result of the former chain) as its first argument. In the above example, the `capitalize` filter function will receive the value of `message` as its argument.\n\nFilters can be chained:\n\n``` html\n{{ message | filterA | filterB }}\n```\n\nIn this case, `filterA`, defined with a single argument, will receive the value of `message`, and then the `filterB` function will be called with the result of `filterA` passed into `filterB`'s single argument.\n\nFilters are JavaScript functions, therefore they can take arguments:\n\n``` html\n{{ message | filterA('arg1', arg2) }}\n```\n\nHere `filterA` is defined as a function taking three arguments. The value of `message` will be passed into the first argument. The plain string `'arg1'` will be passed into the `filterA` as its second argument, and the value of expression `arg2` will be evaluated and passed in as the third argument.\n","date":"2020-09-25T23:55:41.137Z","updated":"2020-09-25T23:55:41.137Z","path":"v2/guide/filters.html","comments":1,"layout":"page","_id":"ckfl66gyl0028c2v54us8anx2","content":"<p>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: <strong>mustache interpolations and <code>v-bind</code> expressions</strong> (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- in mustaches --&gt;</span>\n&#123;&#123; message | capitalize &#125;&#125;\n\n<span class=\"hljs-comment\">&lt;!-- in v-bind --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"rawId | formatId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>You can define local filters in a component’s options:</p>\n<pre><code class=\"hljs js\">filters: &#123;\n  <span class=\"hljs-attr\">capitalize</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!value) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>\n    value = value.toString()\n    <span class=\"hljs-keyword\">return</span> value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)\n  &#125;\n&#125;</code></pre>\n<p>or define a filter globally before creating the Vue instance:</p>\n<pre><code class=\"hljs js\">Vue.filter(<span class=\"hljs-string\">'capitalize'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (!value) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>\n  value = value.toString()\n  <span class=\"hljs-keyword\">return</span> value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<p>When the global filter has the same name as the local filter, the local filter will be preferred.</p>\n<p>Below is an example of our <code>capitalize</code> filter being used:</p>\n\n<div id=\"example_1\" class=\"demo\">\n  <input type=\"text\" v-model=\"message\">\n  <p>{{ message | capitalize }}</p>\n</div>\n<script>\n  new Vue({\n    el: '#example_1',\n    data: function () {\n      return {\n        message: 'john'\n      }\n    },\n    filters: {\n      capitalize: function (value) {\n        if (!value) return ''\n        value = value.toString()\n        return value.charAt(0).toUpperCase() + value.slice(1)\n      }\n    }\n  })\n</script>\n\n<p>The filter’s function always receives the expression’s value (the result of the former chain) as its first argument. In the above example, the <code>capitalize</code> filter function will receive the value of <code>message</code> as its argument.</p>\n<p>Filters can be chained:</p>\n<pre><code class=\"hljs html\">&#123;&#123; message | filterA | filterB &#125;&#125;</code></pre>\n<p>In this case, <code>filterA</code>, defined with a single argument, will receive the value of <code>message</code>, and then the <code>filterB</code> function will be called with the result of <code>filterA</code> passed into <code>filterB</code>‘s single argument.</p>\n<p>Filters are JavaScript functions, therefore they can take arguments:</p>\n<pre><code class=\"hljs html\">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</code></pre>\n<p>Here <code>filterA</code> is defined as a function taking three arguments. The value of <code>message</code> will be passed into the first argument. The plain string <code>&#39;arg1&#39;</code> will be passed into the <code>filterA</code> as its second argument, and the value of expression <code>arg2</code> will be evaluated and passed in as the third argument.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vue.js allows you to define filters that can be used to apply common text formatting. Filters are usable in two places: <strong>mustache interpolations and <code>v-bind</code> expressions</strong> (the latter supported in 2.1.0+). Filters should be appended to the end of the JavaScript expression, denoted by the “pipe” symbol:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- in mustaches --&gt;</span>\n&#123;&#123; message | capitalize &#125;&#125;\n\n<span class=\"hljs-comment\">&lt;!-- in v-bind --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"rawId | formatId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>You can define local filters in a component’s options:</p>\n<pre><code class=\"hljs js\">filters: &#123;\n  <span class=\"hljs-attr\">capitalize</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!value) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>\n    value = value.toString()\n    <span class=\"hljs-keyword\">return</span> value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)\n  &#125;\n&#125;</code></pre>\n<p>or define a filter globally before creating the Vue instance:</p>\n<pre><code class=\"hljs js\">Vue.filter(<span class=\"hljs-string\">'capitalize'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (!value) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">''</span>\n  value = value.toString()\n  <span class=\"hljs-keyword\">return</span> value.charAt(<span class=\"hljs-number\">0</span>).toUpperCase() + value.slice(<span class=\"hljs-number\">1</span>)\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<p>When the global filter has the same name as the local filter, the local filter will be preferred.</p>\n<p>Below is an example of our <code>capitalize</code> filter being used:</p>\n\n<div id=\"example_1\" class=\"demo\">\n  <input type=\"text\" v-model=\"message\">\n  <p>{{ message | capitalize }}</p>\n</div>\n<script>\n  new Vue({\n    el: '#example_1',\n    data: function () {\n      return {\n        message: 'john'\n      }\n    },\n    filters: {\n      capitalize: function (value) {\n        if (!value) return ''\n        value = value.toString()\n        return value.charAt(0).toUpperCase() + value.slice(1)\n      }\n    }\n  })\n</script>\n\n<p>The filter’s function always receives the expression’s value (the result of the former chain) as its first argument. In the above example, the <code>capitalize</code> filter function will receive the value of <code>message</code> as its argument.</p>\n<p>Filters can be chained:</p>\n<pre><code class=\"hljs html\">&#123;&#123; message | filterA | filterB &#125;&#125;</code></pre>\n<p>In this case, <code>filterA</code>, defined with a single argument, will receive the value of <code>message</code>, and then the <code>filterB</code> function will be called with the result of <code>filterA</code> passed into <code>filterB</code>‘s single argument.</p>\n<p>Filters are JavaScript functions, therefore they can take arguments:</p>\n<pre><code class=\"hljs html\">&#123;&#123; message | filterA('arg1', arg2) &#125;&#125;</code></pre>\n<p>Here <code>filterA</code> is defined as a function taking three arguments. The value of <code>message</code> will be passed into the first argument. The plain string <code>&#39;arg1&#39;</code> will be passed into the <code>filterA</code> as its second argument, and the value of expression <code>arg2</code> will be evaluated and passed in as the third argument.</p>\n"},{"title":"The Vue Instance","type":"guide","order":3,"_content":"\n## Creating a Vue Instance\n\nEvery Vue application starts by creating a new **Vue instance** with the `Vue` function:\n\n```js\nvar vm = new Vue({\n  // options\n})\n```\n\nAlthough not strictly associated with the [MVVM pattern](https://en.wikipedia.org/wiki/Model_View_ViewModel), Vue's design was partly inspired by it. As a convention, we often use the variable `vm` (short for ViewModel) to refer to our Vue instance.\n\nWhen you create a Vue instance, you pass in an **options object**. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the [API reference](../api/#Options-Data).\n\nA Vue application consists of a **root Vue instance** created with `new Vue`, optionally organized into a tree of nested, reusable components. For example, a todo app's component tree might look like this:\n\n```\nRoot Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ TodoButtonDelete\n   │  └─ TodoButtonEdit\n   └─ TodoListFooter\n      ├─ TodosButtonClear\n      └─ TodoListStatistics\n```\n\nWe'll talk about [the component system](components.html) in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).\n\n## Data and Methods\n\nWhen a Vue instance is created, it adds all the properties found in its `data` object to Vue's **reactivity system**. When the values of those properties change, the view will \"react\", updating to match the new values.\n\n```js\n// Our data object\nvar data = { a: 1 }\n\n// The object is added to a Vue instance\nvar vm = new Vue({\n  data: data\n})\n\n// Getting the property on the instance\n// returns the one from the original data\nvm.a == data.a // => true\n\n// Setting the property on the instance\n// also affects the original data\nvm.a = 2\ndata.a // => 2\n\n// ... and vice-versa\ndata.a = 3\nvm.a // => 3\n```\n\nWhen this data changes, the view will re-render. It should be noted that properties in `data` are only **reactive** if they existed when the instance was created. That means if you add a new property, like:\n\n```js\nvm.b = 'hi'\n```\n\nThen changes to `b` will not trigger any view updates. If you know you'll need a property later, but it starts out empty or non-existent, you'll need to set some initial value. For example:\n\n```js\ndata: {\n  newTodoText: '',\n  visitCount: 0,\n  hideCompletedTodos: false,\n  todos: [],\n  error: null\n}\n```\n\nThe only exception to this being the use of `Object.freeze()`, which prevents existing properties from being changed, which also means the reactivity system can't _track_ changes.\n\n```js\nvar obj = {\n  foo: 'bar'\n}\n\nObject.freeze(obj)\n\nnew Vue({\n  el: '#app',\n  data: obj\n})\n```\n\n```html\n<div id=\"app\">\n  <p>{{ foo }}</p>\n  <!-- this will no longer update `foo`! -->\n  <button v-on:click=\"foo = 'baz'\">Change it</button>\n</div>\n```\n\nIn addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with `$` to differentiate them from user-defined properties. For example:\n\n```js\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch is an instance method\nvm.$watch('a', function (newValue, oldValue) {\n  // This callback will be called when `vm.a` changes\n})\n```\n\nIn the future, you can consult the [API reference](../api/#Instance-Properties) for a full list of instance properties and methods.\n\n## Instance Lifecycle Hooks\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/understanding-the-vuejs-lifecycle-hooks?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Lifecycle Hooks Lesson\">Watch a free lesson on Vue School</a></div>\n\nEach Vue instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called **lifecycle hooks**, giving users the opportunity to add their own code at specific stages.\n\nFor example, the [`created`](../api/#created) hook can be used to run code after an instance is created:\n\n```js\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` points to the vm instance\n    console.log('a is: ' + this.a)\n  }\n})\n// => \"a is: 1\"\n```\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, such as [`mounted`](../api/#mounted), [`updated`](../api/#updated), and [`destroyed`](../api/#destroyed). All lifecycle hooks are called with their `this` context pointing to the Vue instance invoking it.\n\n<p class=\"tip\">Don't use [arrow functions](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions) on an options property or callback, such as `created: () => console.log(this.a)` or `vm.$watch('a', newValue => this.myMethod())`. Since an arrow function doesn't have a `this`, `this` will be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as `Uncaught TypeError: Cannot read property of undefined` or `Uncaught TypeError: this.myMethod is not a function`.</p>\n\n## Lifecycle Diagram\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\n![The Vue Instance Lifecycle](/images/lifecycle.png)\n","source":"v2/guide/instance.md","raw":"---\ntitle: The Vue Instance\ntype: guide\norder: 3\n---\n\n## Creating a Vue Instance\n\nEvery Vue application starts by creating a new **Vue instance** with the `Vue` function:\n\n```js\nvar vm = new Vue({\n  // options\n})\n```\n\nAlthough not strictly associated with the [MVVM pattern](https://en.wikipedia.org/wiki/Model_View_ViewModel), Vue's design was partly inspired by it. As a convention, we often use the variable `vm` (short for ViewModel) to refer to our Vue instance.\n\nWhen you create a Vue instance, you pass in an **options object**. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the [API reference](../api/#Options-Data).\n\nA Vue application consists of a **root Vue instance** created with `new Vue`, optionally organized into a tree of nested, reusable components. For example, a todo app's component tree might look like this:\n\n```\nRoot Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ TodoButtonDelete\n   │  └─ TodoButtonEdit\n   └─ TodoListFooter\n      ├─ TodosButtonClear\n      └─ TodoListStatistics\n```\n\nWe'll talk about [the component system](components.html) in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).\n\n## Data and Methods\n\nWhen a Vue instance is created, it adds all the properties found in its `data` object to Vue's **reactivity system**. When the values of those properties change, the view will \"react\", updating to match the new values.\n\n```js\n// Our data object\nvar data = { a: 1 }\n\n// The object is added to a Vue instance\nvar vm = new Vue({\n  data: data\n})\n\n// Getting the property on the instance\n// returns the one from the original data\nvm.a == data.a // => true\n\n// Setting the property on the instance\n// also affects the original data\nvm.a = 2\ndata.a // => 2\n\n// ... and vice-versa\ndata.a = 3\nvm.a // => 3\n```\n\nWhen this data changes, the view will re-render. It should be noted that properties in `data` are only **reactive** if they existed when the instance was created. That means if you add a new property, like:\n\n```js\nvm.b = 'hi'\n```\n\nThen changes to `b` will not trigger any view updates. If you know you'll need a property later, but it starts out empty or non-existent, you'll need to set some initial value. For example:\n\n```js\ndata: {\n  newTodoText: '',\n  visitCount: 0,\n  hideCompletedTodos: false,\n  todos: [],\n  error: null\n}\n```\n\nThe only exception to this being the use of `Object.freeze()`, which prevents existing properties from being changed, which also means the reactivity system can't _track_ changes.\n\n```js\nvar obj = {\n  foo: 'bar'\n}\n\nObject.freeze(obj)\n\nnew Vue({\n  el: '#app',\n  data: obj\n})\n```\n\n```html\n<div id=\"app\">\n  <p>{{ foo }}</p>\n  <!-- this will no longer update `foo`! -->\n  <button v-on:click=\"foo = 'baz'\">Change it</button>\n</div>\n```\n\nIn addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with `$` to differentiate them from user-defined properties. For example:\n\n```js\nvar data = { a: 1 }\nvar vm = new Vue({\n  el: '#example',\n  data: data\n})\n\nvm.$data === data // => true\nvm.$el === document.getElementById('example') // => true\n\n// $watch is an instance method\nvm.$watch('a', function (newValue, oldValue) {\n  // This callback will be called when `vm.a` changes\n})\n```\n\nIn the future, you can consult the [API reference](../api/#Instance-Properties) for a full list of instance properties and methods.\n\n## Instance Lifecycle Hooks\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/understanding-the-vuejs-lifecycle-hooks?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Lifecycle Hooks Lesson\">Watch a free lesson on Vue School</a></div>\n\nEach Vue instance goes through a series of initialization steps when it's created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called **lifecycle hooks**, giving users the opportunity to add their own code at specific stages.\n\nFor example, the [`created`](../api/#created) hook can be used to run code after an instance is created:\n\n```js\nnew Vue({\n  data: {\n    a: 1\n  },\n  created: function () {\n    // `this` points to the vm instance\n    console.log('a is: ' + this.a)\n  }\n})\n// => \"a is: 1\"\n```\n\nThere are also other hooks which will be called at different stages of the instance's lifecycle, such as [`mounted`](../api/#mounted), [`updated`](../api/#updated), and [`destroyed`](../api/#destroyed). All lifecycle hooks are called with their `this` context pointing to the Vue instance invoking it.\n\n<p class=\"tip\">Don't use [arrow functions](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions) on an options property or callback, such as `created: () => console.log(this.a)` or `vm.$watch('a', newValue => this.myMethod())`. Since an arrow function doesn't have a `this`, `this` will be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as `Uncaught TypeError: Cannot read property of undefined` or `Uncaught TypeError: this.myMethod is not a function`.</p>\n\n## Lifecycle Diagram\n\nBelow is a diagram for the instance lifecycle. You don't need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.\n\n![The Vue Instance Lifecycle](/images/lifecycle.png)\n","date":"2020-09-25T23:55:41.138Z","updated":"2020-09-25T23:55:41.138Z","path":"v2/guide/instance.html","comments":1,"layout":"page","_id":"ckfl66gyl0029c2v575w7ies5","content":"<h2 id=\"Creating-a-Vue-Instance\"><a href=\"#Creating-a-Vue-Instance\" class=\"headerlink\" title=\"Creating a Vue Instance\"></a>Creating a Vue Instance</h2><p>Every Vue application starts by creating a new <strong>Vue instance</strong> with the <code>Vue</code> function:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// options</span>\n&#125;)</code></pre>\n<p>Although not strictly associated with the <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\" target=\"_blank\" rel=\"noopener\">MVVM pattern</a>, Vue’s design was partly inspired by it. As a convention, we often use the variable <code>vm</code> (short for ViewModel) to refer to our Vue instance.</p>\n<p>When you create a Vue instance, you pass in an <strong>options object</strong>. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the <a href=\"../api/#Options-Data\">API reference</a>.</p>\n<p>A Vue application consists of a <strong>root Vue instance</strong> created with <code>new Vue</code>, optionally organized into a tree of nested, reusable components. For example, a todo app’s component tree might look like this:</p>\n<pre><code class=\"hljs undefined\">Root Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ TodoButtonDelete\n   │  └─ TodoButtonEdit\n   └─ TodoListFooter\n      ├─ TodosButtonClear\n      └─ TodoListStatistics</code></pre>\n<p>We’ll talk about <a href=\"components.html\">the component system</a> in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</p>\n<h2 id=\"Data-and-Methods\"><a href=\"#Data-and-Methods\" class=\"headerlink\" title=\"Data and Methods\"></a>Data and Methods</h2><p>When a Vue instance is created, it adds all the properties found in its <code>data</code> object to Vue’s <strong>reactivity system</strong>. When the values of those properties change, the view will “react”, updating to match the new values.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Our data object</span>\n<span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n\n<span class=\"hljs-comment\">// The object is added to a Vue instance</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\n\n<span class=\"hljs-comment\">// Getting the property on the instance</span>\n<span class=\"hljs-comment\">// returns the one from the original data</span>\nvm.a == data.a <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// Setting the property on the instance</span>\n<span class=\"hljs-comment\">// also affects the original data</span>\nvm.a = <span class=\"hljs-number\">2</span>\ndata.a <span class=\"hljs-comment\">// =&gt; 2</span>\n\n<span class=\"hljs-comment\">// ... and vice-versa</span>\ndata.a = <span class=\"hljs-number\">3</span>\nvm.a <span class=\"hljs-comment\">// =&gt; 3</span></code></pre>\n<p>When this data changes, the view will re-render. It should be noted that properties in <code>data</code> are only <strong>reactive</strong> if they existed when the instance was created. That means if you add a new property, like:</p>\n<pre><code class=\"hljs js\">vm.b = <span class=\"hljs-string\">'hi'</span></code></pre>\n<p>Then changes to <code>b</code> will not trigger any view updates. If you know you’ll need a property later, but it starts out empty or non-existent, you’ll need to set some initial value. For example:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">newTodoText</span>: <span class=\"hljs-string\">''</span>,\n  <span class=\"hljs-attr\">visitCount</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">hideCompletedTodos</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">todos</span>: [],\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-literal\">null</span>\n&#125;</code></pre>\n<p>The only exception to this being the use of <code>Object.freeze()</code>, which prevents existing properties from being changed, which also means the reactivity system can’t <em>track</em> changes.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n&#125;\n\n<span class=\"hljs-built_in\">Object</span>.freeze(obj)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: obj\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- this will no longer update `foo`! --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"foo = 'baz'\"</span>&gt;</span>Change it<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with <code>$</code> to differentiate them from user-defined properties. For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example'</span>,\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\n\nvm.$data === data <span class=\"hljs-comment\">// =&gt; true</span>\nvm.$el === <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'example'</span>) <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// $watch is an instance method</span>\nvm.$watch(<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newValue, oldValue</span>) </span>&#123;\n  <span class=\"hljs-comment\">// This callback will be called when `vm.a` changes</span>\n&#125;)</code></pre>\n<p>In the future, you can consult the <a href=\"../api/#Instance-Properties\">API reference</a> for a full list of instance properties and methods.</p>\n<h2 id=\"Instance-Lifecycle-Hooks\"><a href=\"#Instance-Lifecycle-Hooks\" class=\"headerlink\" title=\"Instance Lifecycle Hooks\"></a>Instance Lifecycle Hooks</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/understanding-the-vuejs-lifecycle-hooks?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Lifecycle Hooks Lesson\">Watch a free lesson on Vue School</a></div>\n\n<p>Each Vue instance goes through a series of initialization steps when it’s created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called <strong>lifecycle hooks</strong>, giving users the opportunity to add their own code at specific stages.</p>\n<p>For example, the <a href=\"../api/#created\"><code>created</code></a> hook can be used to run code after an instance is created:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// `this` points to the vm instance</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'a is: '</span> + <span class=\"hljs-keyword\">this</span>.a)\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// =&gt; \"a is: 1\"</span></code></pre>\n<p>There are also other hooks which will be called at different stages of the instance’s lifecycle, such as <a href=\"../api/#mounted\"><code>mounted</code></a>, <a href=\"../api/#updated\"><code>updated</code></a>, and <a href=\"../api/#destroyed\"><code>destroyed</code></a>. All lifecycle hooks are called with their <code>this</code> context pointing to the Vue instance invoking it.</p>\n<p class=\"tip\">Don’t use <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">arrow functions</a> on an options property or callback, such as <code>created: () =&gt; console.log(this.a)</code> or <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>. Since an arrow function doesn’t have a <code>this</code>, <code>this</code> will be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as <code>Uncaught TypeError: Cannot read property of undefined</code> or <code>Uncaught TypeError: this.myMethod is not a function</code>.</p>\n\n<h2 id=\"Lifecycle-Diagram\"><a href=\"#Lifecycle-Diagram\" class=\"headerlink\" title=\"Lifecycle Diagram\"></a>Lifecycle Diagram</h2><p>Below is a diagram for the instance lifecycle. You don’t need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.</p>\n<p><img src=\"/images/lifecycle.png\" alt=\"The Vue Instance Lifecycle\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Creating-a-Vue-Instance\"><a href=\"#Creating-a-Vue-Instance\" class=\"headerlink\" title=\"Creating a Vue Instance\"></a>Creating a Vue Instance</h2><p>Every Vue application starts by creating a new <strong>Vue instance</strong> with the <code>Vue</code> function:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// options</span>\n&#125;)</code></pre>\n<p>Although not strictly associated with the <a href=\"https://en.wikipedia.org/wiki/Model_View_ViewModel\" target=\"_blank\" rel=\"noopener\">MVVM pattern</a>, Vue’s design was partly inspired by it. As a convention, we often use the variable <code>vm</code> (short for ViewModel) to refer to our Vue instance.</p>\n<p>When you create a Vue instance, you pass in an <strong>options object</strong>. The majority of this guide describes how you can use these options to create your desired behavior. For reference, you can also browse the full list of options in the <a href=\"../api/#Options-Data\">API reference</a>.</p>\n<p>A Vue application consists of a <strong>root Vue instance</strong> created with <code>new Vue</code>, optionally organized into a tree of nested, reusable components. For example, a todo app’s component tree might look like this:</p>\n<pre><code class=\"hljs undefined\">Root Instance\n└─ TodoList\n   ├─ TodoItem\n   │  ├─ TodoButtonDelete\n   │  └─ TodoButtonEdit\n   └─ TodoListFooter\n      ├─ TodosButtonClear\n      └─ TodoListStatistics</code></pre>\n<p>We’ll talk about <a href=\"components.html\">the component system</a> in detail later. For now, just know that all Vue components are also Vue instances, and so accept the same options object (except for a few root-specific options).</p>\n<h2 id=\"Data-and-Methods\"><a href=\"#Data-and-Methods\" class=\"headerlink\" title=\"Data and Methods\"></a>Data and Methods</h2><p>When a Vue instance is created, it adds all the properties found in its <code>data</code> object to Vue’s <strong>reactivity system</strong>. When the values of those properties change, the view will “react”, updating to match the new values.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Our data object</span>\n<span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n\n<span class=\"hljs-comment\">// The object is added to a Vue instance</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\n\n<span class=\"hljs-comment\">// Getting the property on the instance</span>\n<span class=\"hljs-comment\">// returns the one from the original data</span>\nvm.a == data.a <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// Setting the property on the instance</span>\n<span class=\"hljs-comment\">// also affects the original data</span>\nvm.a = <span class=\"hljs-number\">2</span>\ndata.a <span class=\"hljs-comment\">// =&gt; 2</span>\n\n<span class=\"hljs-comment\">// ... and vice-versa</span>\ndata.a = <span class=\"hljs-number\">3</span>\nvm.a <span class=\"hljs-comment\">// =&gt; 3</span></code></pre>\n<p>When this data changes, the view will re-render. It should be noted that properties in <code>data</code> are only <strong>reactive</strong> if they existed when the instance was created. That means if you add a new property, like:</p>\n<pre><code class=\"hljs js\">vm.b = <span class=\"hljs-string\">'hi'</span></code></pre>\n<p>Then changes to <code>b</code> will not trigger any view updates. If you know you’ll need a property later, but it starts out empty or non-existent, you’ll need to set some initial value. For example:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">newTodoText</span>: <span class=\"hljs-string\">''</span>,\n  <span class=\"hljs-attr\">visitCount</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-attr\">hideCompletedTodos</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">todos</span>: [],\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-literal\">null</span>\n&#125;</code></pre>\n<p>The only exception to this being the use of <code>Object.freeze()</code>, which prevents existing properties from being changed, which also means the reactivity system can’t <em>track</em> changes.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;\n  <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n&#125;\n\n<span class=\"hljs-built_in\">Object</span>.freeze(obj)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span>,\n  <span class=\"hljs-attr\">data</span>: obj\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"app\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- this will no longer update `foo`! --&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"foo = 'baz'\"</span>&gt;</span>Change it<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>In addition to data properties, Vue instances expose a number of useful instance properties and methods. These are prefixed with <code>$</code> to differentiate them from user-defined properties. For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example'</span>,\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\n\nvm.$data === data <span class=\"hljs-comment\">// =&gt; true</span>\nvm.$el === <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'example'</span>) <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// $watch is an instance method</span>\nvm.$watch(<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newValue, oldValue</span>) </span>&#123;\n  <span class=\"hljs-comment\">// This callback will be called when `vm.a` changes</span>\n&#125;)</code></pre>\n<p>In the future, you can consult the <a href=\"../api/#Instance-Properties\">API reference</a> for a full list of instance properties and methods.</p>\n<h2 id=\"Instance-Lifecycle-Hooks\"><a href=\"#Instance-Lifecycle-Hooks\" class=\"headerlink\" title=\"Instance Lifecycle Hooks\"></a>Instance Lifecycle Hooks</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/understanding-the-vuejs-lifecycle-hooks?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Lifecycle Hooks Lesson\">Watch a free lesson on Vue School</a></div>\n\n<p>Each Vue instance goes through a series of initialization steps when it’s created - for example, it needs to set up data observation, compile the template, mount the instance to the DOM, and update the DOM when data changes. Along the way, it also runs functions called <strong>lifecycle hooks</strong>, giving users the opportunity to add their own code at specific stages.</p>\n<p>For example, the <a href=\"../api/#created\"><code>created</code></a> hook can be used to run code after an instance is created:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// `this` points to the vm instance</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'a is: '</span> + <span class=\"hljs-keyword\">this</span>.a)\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// =&gt; \"a is: 1\"</span></code></pre>\n<p>There are also other hooks which will be called at different stages of the instance’s lifecycle, such as <a href=\"../api/#mounted\"><code>mounted</code></a>, <a href=\"../api/#updated\"><code>updated</code></a>, and <a href=\"../api/#destroyed\"><code>destroyed</code></a>. All lifecycle hooks are called with their <code>this</code> context pointing to the Vue instance invoking it.</p>\n<p class=\"tip\">Don’t use <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions\" target=\"_blank\" rel=\"noopener\">arrow functions</a> on an options property or callback, such as <code>created: () =&gt; console.log(this.a)</code> or <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>. Since an arrow function doesn’t have a <code>this</code>, <code>this</code> will be treated as any other variable and lexically looked up through parent scopes until found, often resulting in errors such as <code>Uncaught TypeError: Cannot read property of undefined</code> or <code>Uncaught TypeError: this.myMethod is not a function</code>.</p>\n\n<h2 id=\"Lifecycle-Diagram\"><a href=\"#Lifecycle-Diagram\" class=\"headerlink\" title=\"Lifecycle Diagram\"></a>Lifecycle Diagram</h2><p>Below is a diagram for the instance lifecycle. You don’t need to fully understand everything going on right now, but as you learn and build more, it will be a useful reference.</p>\n<p><img src=\"/images/lifecycle.png\" alt=\"The Vue Instance Lifecycle\"></p>\n"},{"title":"Installation","type":"guide","order":1,"vue_version":"2.6.12","gz_size":"33.30","_content":"\n### Compatibility Note\n\nVue does **not** support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all [ECMAScript 5 compliant browsers](https://caniuse.com/#feat=es5).\n\n### Semantic Versioning\n\nVue follows [Semantic Versioning](https://semver.org/) in all its official projects for documented features and behavior. For undocumented behavior or exposed internals, changes are described in [release notes](https://github.com/vuejs/vue/releases).\n\n### Release Notes\n\nLatest stable version: {{vue_version}}\n\nDetailed release notes for each version are available on [GitHub](https://github.com/vuejs/vue/releases).\n\n## Vue Devtools\n\nWhen using Vue, we recommend also installing the [Vue Devtools](https://github.com/vuejs/vue-devtools#vue-devtools) in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.\n\n## Direct `<script>` Include\n\nSimply download and include with a script tag. `Vue` will be registered as a global variable.\n\n<p class=\"tip\">Don't use the minified version during development. You will miss out on all the nice warnings for common mistakes!</p>\n\n<div id=\"downloads\">\n  <a class=\"button\" href=\"/js/vue.js\" download>Development Version</a><span class=\"light info\">With full warnings and debug mode</span>\n\n  <a class=\"button\" href=\"/js/vue.min.js\" download>Production Version</a><span class=\"light info\">Warnings stripped, {{gz_size}}KB min+gzip</span>\n</div>\n\n### CDN\n\nFor prototyping or learning purposes, you can use the latest version with:\n\n``` html\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n```\n\nFor production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:\n\n``` html\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.12\"></script>\n```\n\nIf you are using native ES Modules, there is also an ES Modules compatible build:\n\n``` html\n<script type=\"module\">\n  import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js'\n</script>\n```\n\nYou can browse the source of the NPM package at [cdn.jsdelivr.net/npm/vue](https://cdn.jsdelivr.net/npm/vue/).\n\nVue is also available on [unpkg](https://unpkg.com/vue@{{vue_version}}/dist/vue.js) and [cdnjs](https://cdnjs.cloudflare.com/ajax/libs/vue/{{vue_version}}/vue.js) (cdnjs takes some time to sync so the latest release may not be available yet).\n\nMake sure to read about [the different builds of Vue](#Explanation-of-Different-Builds) and use the **production\n version** in your published site, replacing `vue.js` with `vue.min.js`. This is a smaller build optimized for speed instead of development experience.\n\n## NPM\n\nNPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as [Webpack](https://webpack.js.org/) or [Browserify](http://browserify.org/). Vue also provides accompanying tools for authoring [Single File Components](single-file-components.html).\n\n``` bash\n# latest stable\n$ npm install vue\n```\n\n## CLI\n\nVue provides an [official CLI](https://github.com/vuejs/vue-cli) for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See [the Vue CLI docs](https://cli.vuejs.org) for more details.\n\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/real-world-vue-js/vue-cli\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue CLI\">Watch a video explanation on Vue Mastery</a></div>\n\n## Explanation of Different Builds\n\nIn the [`dist/` directory of the NPM package](https://cdn.jsdelivr.net/npm/vue/dist/) you will find many different builds of Vue.js. Here's an overview of the difference between them:\n\n| | UMD | CommonJS | ES Module (for bundlers) | ES Module (for browsers) |\n| --- | --- | --- | --- | --- |\n| **Full** | vue.js | vue.common.js | vue.esm.js | vue.esm.browser.js |\n| **Runtime-only** | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js | - |\n| **Full (production)** | vue.min.js | - | - | vue.esm.browser.min.js |\n| **Runtime-only (production)** | vue.runtime.min.js | - | - | - |\n\n### Terms\n\n- **Full**: builds that contain both the compiler and the runtime.\n\n- **Compiler**: code that is responsible for compiling template strings into JavaScript render functions.\n\n- **Runtime**: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler.\n\n- **[UMD](https://github.com/umdjs/umd)**: UMD builds can be used directly in the browser via a `<script>` tag. The default file from jsDelivr CDN at [https://cdn.jsdelivr.net/npm/vue](https://cdn.jsdelivr.net/npm/vue) is the Runtime + Compiler UMD build (`vue.js`).\n\n- **[CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1)**: CommonJS builds are intended for use with older bundlers like [browserify](http://browserify.org/) or [webpack 1](https://webpack.github.io). The default file for these bundlers (`pkg.main`) is the Runtime only CommonJS build (`vue.runtime.common.js`).\n\n- **[ES Module](http://exploringjs.com/es6/ch_modules.html)**: starting in 2.6 Vue provides two ES Modules (ESM) builds:\n\n  - ESM for bundlers: intended for use with modern bundlers like [webpack 2](https://webpack.js.org) or [Rollup](https://rollupjs.org/). ESM format is designed to be statically analyzable so the bundlers can take advantage of that to perform \"tree-shaking\" and eliminate unused code from your final bundle. The default file for these bundlers (`pkg.module`) is the Runtime only ES Module build (`vue.runtime.esm.js`).\n\n  - ESM for browsers (2.6+ only): intended for direct imports in modern browsers via `<script type=\"module\">`.\n\n### Runtime + Compiler vs. Runtime-only\n\nIf you need to compile templates on the client (e.g. passing a string to the `template` option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:\n\n``` js\n// this requires the compiler\nnew Vue({\n  template: '<div>{{ hi }}</div>'\n})\n\n// this does not\nnew Vue({\n  render (h) {\n    return h('div', this.hi)\n  }\n})\n```\n\nWhen using `vue-loader` or `vueify`, templates inside `*.vue` files are pre-compiled into JavaScript at build time. You don't really need the compiler in the final bundle, and can therefore use the runtime-only build.\n\nSince the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:\n\n#### Webpack\n\n``` js\nmodule.exports = {\n  // ...\n  resolve: {\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1\n    }\n  }\n}\n```\n\n#### Rollup\n\n``` js\nconst alias = require('rollup-plugin-alias')\n\nrollup({\n  // ...\n  plugins: [\n    alias({\n      'vue': require.resolve('vue/dist/vue.esm.js')\n    })\n  ]\n})\n```\n\n#### Browserify\n\nAdd to your project's `package.json`:\n\n``` js\n{\n  // ...\n  \"browser\": {\n    \"vue\": \"vue/dist/vue.common.js\"\n  }\n}\n```\n\n#### Parcel\n\nAdd to your project's `package.json`:\n\n``` js\n{\n  // ...\n  \"alias\": {\n    \"vue\" : \"./node_modules/vue/dist/vue.common.js\"\n  }\n}\n```\n\n### Development vs. Production Mode\n\nDevelopment/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.\n\nCommonJS and ES Module builds are intended for bundlers, therefore we don't provide minified versions for them. You will be responsible for minifying the final bundle yourself.\n\nCommonJS and ES Module builds also preserve raw checks for `process.env.NODE_ENV` to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing `process.env.NODE_ENV` with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.\n\n#### Webpack\n\nIn Webpack 4+, you can use the `mode` option:\n\n``` js\nmodule.exports = {\n  mode: 'production'\n}\n```\n\nBut in Webpack 3 and earlier, you'll need to use [DefinePlugin](https://webpack.js.org/plugins/define-plugin/):\n\n``` js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    // ...\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: JSON.stringify('production')\n      }\n    })\n  ]\n}\n```\n\n#### Rollup\n\nUse [rollup-plugin-replace](https://github.com/rollup/rollup-plugin-replace):\n\n``` js\nconst replace = require('rollup-plugin-replace')\n\nrollup({\n  // ...\n  plugins: [\n    replace({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    })\n  ]\n}).then(...)\n```\n\n#### Browserify\n\nApply a global [envify](https://github.com/hughsk/envify) transform to your bundle.\n\n``` bash\nNODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js\n```\n\nAlso see [Production Deployment Tips](deployment.html).\n\n### CSP environments\n\nSome environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of `new Function()` for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.\n\nOn the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with [Webpack + vue-loader](https://github.com/vuejs-templates/webpack-simple) or [Browserify + vueify](https://github.com/vuejs-templates/browserify-simple), your templates will be precompiled into `render` functions which work perfectly in CSP environments.\n\n## Dev Build\n\n**Important**: the built files in GitHub's `/dist` folder are only checked-in during releases. To use Vue from the latest source code on GitHub, you will have to build it yourself!\n\n``` bash\ngit clone https://github.com/vuejs/vue.git node_modules/vue\ncd node_modules/vue\nnpm install\nnpm run build\n```\n\n## Bower\n\nOnly UMD builds are available from Bower.\n\n``` bash\n# latest stable\n$ bower install vue\n```\n\n## AMD Module Loaders\n\nAll UMD builds can be used directly as an AMD module.\n","source":"v2/guide/installation.md","raw":"---\ntitle: Installation\ntype: guide\norder: 1\nvue_version: 2.6.12\ngz_size: \"33.30\"\n---\n\n### Compatibility Note\n\nVue does **not** support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all [ECMAScript 5 compliant browsers](https://caniuse.com/#feat=es5).\n\n### Semantic Versioning\n\nVue follows [Semantic Versioning](https://semver.org/) in all its official projects for documented features and behavior. For undocumented behavior or exposed internals, changes are described in [release notes](https://github.com/vuejs/vue/releases).\n\n### Release Notes\n\nLatest stable version: {{vue_version}}\n\nDetailed release notes for each version are available on [GitHub](https://github.com/vuejs/vue/releases).\n\n## Vue Devtools\n\nWhen using Vue, we recommend also installing the [Vue Devtools](https://github.com/vuejs/vue-devtools#vue-devtools) in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.\n\n## Direct `<script>` Include\n\nSimply download and include with a script tag. `Vue` will be registered as a global variable.\n\n<p class=\"tip\">Don't use the minified version during development. You will miss out on all the nice warnings for common mistakes!</p>\n\n<div id=\"downloads\">\n  <a class=\"button\" href=\"/js/vue.js\" download>Development Version</a><span class=\"light info\">With full warnings and debug mode</span>\n\n  <a class=\"button\" href=\"/js/vue.min.js\" download>Production Version</a><span class=\"light info\">Warnings stripped, {{gz_size}}KB min+gzip</span>\n</div>\n\n### CDN\n\nFor prototyping or learning purposes, you can use the latest version with:\n\n``` html\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>\n```\n\nFor production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:\n\n``` html\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.12\"></script>\n```\n\nIf you are using native ES Modules, there is also an ES Modules compatible build:\n\n``` html\n<script type=\"module\">\n  import Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js'\n</script>\n```\n\nYou can browse the source of the NPM package at [cdn.jsdelivr.net/npm/vue](https://cdn.jsdelivr.net/npm/vue/).\n\nVue is also available on [unpkg](https://unpkg.com/vue@{{vue_version}}/dist/vue.js) and [cdnjs](https://cdnjs.cloudflare.com/ajax/libs/vue/{{vue_version}}/vue.js) (cdnjs takes some time to sync so the latest release may not be available yet).\n\nMake sure to read about [the different builds of Vue](#Explanation-of-Different-Builds) and use the **production\n version** in your published site, replacing `vue.js` with `vue.min.js`. This is a smaller build optimized for speed instead of development experience.\n\n## NPM\n\nNPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as [Webpack](https://webpack.js.org/) or [Browserify](http://browserify.org/). Vue also provides accompanying tools for authoring [Single File Components](single-file-components.html).\n\n``` bash\n# latest stable\n$ npm install vue\n```\n\n## CLI\n\nVue provides an [official CLI](https://github.com/vuejs/vue-cli) for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See [the Vue CLI docs](https://cli.vuejs.org) for more details.\n\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/real-world-vue-js/vue-cli\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue CLI\">Watch a video explanation on Vue Mastery</a></div>\n\n## Explanation of Different Builds\n\nIn the [`dist/` directory of the NPM package](https://cdn.jsdelivr.net/npm/vue/dist/) you will find many different builds of Vue.js. Here's an overview of the difference between them:\n\n| | UMD | CommonJS | ES Module (for bundlers) | ES Module (for browsers) |\n| --- | --- | --- | --- | --- |\n| **Full** | vue.js | vue.common.js | vue.esm.js | vue.esm.browser.js |\n| **Runtime-only** | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js | - |\n| **Full (production)** | vue.min.js | - | - | vue.esm.browser.min.js |\n| **Runtime-only (production)** | vue.runtime.min.js | - | - | - |\n\n### Terms\n\n- **Full**: builds that contain both the compiler and the runtime.\n\n- **Compiler**: code that is responsible for compiling template strings into JavaScript render functions.\n\n- **Runtime**: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler.\n\n- **[UMD](https://github.com/umdjs/umd)**: UMD builds can be used directly in the browser via a `<script>` tag. The default file from jsDelivr CDN at [https://cdn.jsdelivr.net/npm/vue](https://cdn.jsdelivr.net/npm/vue) is the Runtime + Compiler UMD build (`vue.js`).\n\n- **[CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1)**: CommonJS builds are intended for use with older bundlers like [browserify](http://browserify.org/) or [webpack 1](https://webpack.github.io). The default file for these bundlers (`pkg.main`) is the Runtime only CommonJS build (`vue.runtime.common.js`).\n\n- **[ES Module](http://exploringjs.com/es6/ch_modules.html)**: starting in 2.6 Vue provides two ES Modules (ESM) builds:\n\n  - ESM for bundlers: intended for use with modern bundlers like [webpack 2](https://webpack.js.org) or [Rollup](https://rollupjs.org/). ESM format is designed to be statically analyzable so the bundlers can take advantage of that to perform \"tree-shaking\" and eliminate unused code from your final bundle. The default file for these bundlers (`pkg.module`) is the Runtime only ES Module build (`vue.runtime.esm.js`).\n\n  - ESM for browsers (2.6+ only): intended for direct imports in modern browsers via `<script type=\"module\">`.\n\n### Runtime + Compiler vs. Runtime-only\n\nIf you need to compile templates on the client (e.g. passing a string to the `template` option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:\n\n``` js\n// this requires the compiler\nnew Vue({\n  template: '<div>{{ hi }}</div>'\n})\n\n// this does not\nnew Vue({\n  render (h) {\n    return h('div', this.hi)\n  }\n})\n```\n\nWhen using `vue-loader` or `vueify`, templates inside `*.vue` files are pre-compiled into JavaScript at build time. You don't really need the compiler in the final bundle, and can therefore use the runtime-only build.\n\nSince the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:\n\n#### Webpack\n\n``` js\nmodule.exports = {\n  // ...\n  resolve: {\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1\n    }\n  }\n}\n```\n\n#### Rollup\n\n``` js\nconst alias = require('rollup-plugin-alias')\n\nrollup({\n  // ...\n  plugins: [\n    alias({\n      'vue': require.resolve('vue/dist/vue.esm.js')\n    })\n  ]\n})\n```\n\n#### Browserify\n\nAdd to your project's `package.json`:\n\n``` js\n{\n  // ...\n  \"browser\": {\n    \"vue\": \"vue/dist/vue.common.js\"\n  }\n}\n```\n\n#### Parcel\n\nAdd to your project's `package.json`:\n\n``` js\n{\n  // ...\n  \"alias\": {\n    \"vue\" : \"./node_modules/vue/dist/vue.common.js\"\n  }\n}\n```\n\n### Development vs. Production Mode\n\nDevelopment/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.\n\nCommonJS and ES Module builds are intended for bundlers, therefore we don't provide minified versions for them. You will be responsible for minifying the final bundle yourself.\n\nCommonJS and ES Module builds also preserve raw checks for `process.env.NODE_ENV` to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing `process.env.NODE_ENV` with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.\n\n#### Webpack\n\nIn Webpack 4+, you can use the `mode` option:\n\n``` js\nmodule.exports = {\n  mode: 'production'\n}\n```\n\nBut in Webpack 3 and earlier, you'll need to use [DefinePlugin](https://webpack.js.org/plugins/define-plugin/):\n\n``` js\nvar webpack = require('webpack')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    // ...\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: JSON.stringify('production')\n      }\n    })\n  ]\n}\n```\n\n#### Rollup\n\nUse [rollup-plugin-replace](https://github.com/rollup/rollup-plugin-replace):\n\n``` js\nconst replace = require('rollup-plugin-replace')\n\nrollup({\n  // ...\n  plugins: [\n    replace({\n      'process.env.NODE_ENV': JSON.stringify('production')\n    })\n  ]\n}).then(...)\n```\n\n#### Browserify\n\nApply a global [envify](https://github.com/hughsk/envify) transform to your bundle.\n\n``` bash\nNODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js\n```\n\nAlso see [Production Deployment Tips](deployment.html).\n\n### CSP environments\n\nSome environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of `new Function()` for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.\n\nOn the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with [Webpack + vue-loader](https://github.com/vuejs-templates/webpack-simple) or [Browserify + vueify](https://github.com/vuejs-templates/browserify-simple), your templates will be precompiled into `render` functions which work perfectly in CSP environments.\n\n## Dev Build\n\n**Important**: the built files in GitHub's `/dist` folder are only checked-in during releases. To use Vue from the latest source code on GitHub, you will have to build it yourself!\n\n``` bash\ngit clone https://github.com/vuejs/vue.git node_modules/vue\ncd node_modules/vue\nnpm install\nnpm run build\n```\n\n## Bower\n\nOnly UMD builds are available from Bower.\n\n``` bash\n# latest stable\n$ bower install vue\n```\n\n## AMD Module Loaders\n\nAll UMD builds can be used directly as an AMD module.\n","date":"2020-09-27T13:57:52.539Z","updated":"2020-09-27T13:57:52.539Z","path":"v2/guide/installation.html","comments":1,"layout":"page","_id":"ckfl66gym002ac2v5v8jim6li","content":"<h3 id=\"Compatibility-Note\"><a href=\"#Compatibility-Note\" class=\"headerlink\" title=\"Compatibility Note\"></a>Compatibility Note</h3><p>Vue does <strong>not</strong> support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all <a href=\"https://caniuse.com/#feat=es5\" target=\"_blank\" rel=\"noopener\">ECMAScript 5 compliant browsers</a>.</p>\n<h3 id=\"Semantic-Versioning\"><a href=\"#Semantic-Versioning\" class=\"headerlink\" title=\"Semantic Versioning\"></a>Semantic Versioning</h3><p>Vue follows <a href=\"https://semver.org/\" target=\"_blank\" rel=\"noopener\">Semantic Versioning</a> in all its official projects for documented features and behavior. For undocumented behavior or exposed internals, changes are described in <a href=\"https://github.com/vuejs/vue/releases\" target=\"_blank\" rel=\"noopener\">release notes</a>.</p>\n<h3 id=\"Release-Notes\"><a href=\"#Release-Notes\" class=\"headerlink\" title=\"Release Notes\"></a>Release Notes</h3><p>Latest stable version: 2.6.12</p>\n<p>Detailed release notes for each version are available on <a href=\"https://github.com/vuejs/vue/releases\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Vue-Devtools\"><a href=\"#Vue-Devtools\" class=\"headerlink\" title=\"Vue Devtools\"></a>Vue Devtools</h2><p>When using Vue, we recommend also installing the <a href=\"https://github.com/vuejs/vue-devtools#vue-devtools\" target=\"_blank\" rel=\"noopener\">Vue Devtools</a> in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</p>\n<h2 id=\"Direct-lt-script-gt-Include\"><a href=\"#Direct-lt-script-gt-Include\" class=\"headerlink\" title=\"Direct &lt;script&gt; Include\"></a>Direct <code>&lt;script&gt;</code> Include</h2><p>Simply download and include with a script tag. <code>Vue</code> will be registered as a global variable.</p>\n<p class=\"tip\">Don’t use the minified version during development. You will miss out on all the nice warnings for common mistakes!</p>\n\n<div id=\"downloads\"><br>  <a class=\"button\" href=\"/js/vue.js\" download>Development Version</a><span class=\"light info\">With full warnings and debug mode</span><br><br>  <a class=\"button\" href=\"/js/vue.min.js\" download>Production Version</a><span class=\"light info\">Warnings stripped, 33.30KB min+gzip</span><br></div>\n\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>For prototyping or learning purposes, you can use the latest version with:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>For production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue@2.6.12\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>If you are using native ES Modules, there is also an ES Modules compatible build:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js'</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>You can browse the source of the NPM package at <a href=\"https://cdn.jsdelivr.net/npm/vue/\" target=\"_blank\" rel=\"noopener\">cdn.jsdelivr.net/npm/vue</a>.</p>\n<p>Vue is also available on <a href=\"https://unpkg.com/vue@2.6.12/dist/vue.js\" target=\"_blank\" rel=\"noopener\">unpkg</a> and <a href=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.12/vue.js\" target=\"_blank\" rel=\"noopener\">cdnjs</a> (cdnjs takes some time to sync so the latest release may not be available yet).</p>\n<p>Make sure to read about <a href=\"#Explanation-of-Different-Builds\">the different builds of Vue</a> and use the <strong>production<br> version</strong> in your published site, replacing <code>vue.js</code> with <code>vue.min.js</code>. This is a smaller build optimized for speed instead of development experience.</p>\n<h2 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h2><p>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as <a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">Webpack</a> or <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>. Vue also provides accompanying tools for authoring <a href=\"single-file-components.html\">Single File Components</a>.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># latest stable</span>\n$ npm install vue</code></pre>\n<h2 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h2><p>Vue provides an <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">official CLI</a> for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See <a href=\"https://cli.vuejs.org\" target=\"_blank\" rel=\"noopener\">the Vue CLI docs</a> for more details.</p>\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/real-world-vue-js/vue-cli\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue CLI\">Watch a video explanation on Vue Mastery</a></div>\n\n<h2 id=\"Explanation-of-Different-Builds\"><a href=\"#Explanation-of-Different-Builds\" class=\"headerlink\" title=\"Explanation of Different Builds\"></a>Explanation of Different Builds</h2><p>In the <a href=\"https://cdn.jsdelivr.net/npm/vue/dist/\" target=\"_blank\" rel=\"noopener\"><code>dist/</code> directory of the NPM package</a> you will find many different builds of Vue.js. Here’s an overview of the difference between them:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>UMD</th>\n<th>CommonJS</th>\n<th>ES Module (for bundlers)</th>\n<th>ES Module (for browsers)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Full</strong></td>\n<td>vue.js</td>\n<td>vue.common.js</td>\n<td>vue.esm.js</td>\n<td>vue.esm.browser.js</td>\n</tr>\n<tr>\n<td><strong>Runtime-only</strong></td>\n<td>vue.runtime.js</td>\n<td>vue.runtime.common.js</td>\n<td>vue.runtime.esm.js</td>\n<td>-</td>\n</tr>\n<tr>\n<td><strong>Full (production)</strong></td>\n<td>vue.min.js</td>\n<td>-</td>\n<td>-</td>\n<td>vue.esm.browser.min.js</td>\n</tr>\n<tr>\n<td><strong>Runtime-only (production)</strong></td>\n<td>vue.runtime.min.js</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Terms\"><a href=\"#Terms\" class=\"headerlink\" title=\"Terms\"></a>Terms</h3><ul>\n<li><p><strong>Full</strong>: builds that contain both the compiler and the runtime.</p>\n</li>\n<li><p><strong>Compiler</strong>: code that is responsible for compiling template strings into JavaScript render functions.</p>\n</li>\n<li><p><strong>Runtime</strong>: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler.</p>\n</li>\n<li><p><strong><a href=\"https://github.com/umdjs/umd\" target=\"_blank\" rel=\"noopener\">UMD</a></strong>: UMD builds can be used directly in the browser via a <code>&lt;script&gt;</code> tag. The default file from jsDelivr CDN at <a href=\"https://cdn.jsdelivr.net/npm/vue\" target=\"_blank\" rel=\"noopener\">https://cdn.jsdelivr.net/npm/vue</a> is the Runtime + Compiler UMD build (<code>vue.js</code>).</p>\n</li>\n<li><p><strong><a href=\"http://wiki.commonjs.org/wiki/Modules/1.1\" target=\"_blank\" rel=\"noopener\">CommonJS</a></strong>: CommonJS builds are intended for use with older bundlers like <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserify</a> or <a href=\"https://webpack.github.io\" target=\"_blank\" rel=\"noopener\">webpack 1</a>. The default file for these bundlers (<code>pkg.main</code>) is the Runtime only CommonJS build (<code>vue.runtime.common.js</code>).</p>\n</li>\n<li><p><strong><a href=\"http://exploringjs.com/es6/ch_modules.html\" target=\"_blank\" rel=\"noopener\">ES Module</a></strong>: starting in 2.6 Vue provides two ES Modules (ESM) builds:</p>\n<ul>\n<li><p>ESM for bundlers: intended for use with modern bundlers like <a href=\"https://webpack.js.org\" target=\"_blank\" rel=\"noopener\">webpack 2</a> or <a href=\"https://rollupjs.org/\" target=\"_blank\" rel=\"noopener\">Rollup</a>. ESM format is designed to be statically analyzable so the bundlers can take advantage of that to perform “tree-shaking” and eliminate unused code from your final bundle. The default file for these bundlers (<code>pkg.module</code>) is the Runtime only ES Module build (<code>vue.runtime.esm.js</code>).</p>\n</li>\n<li><p>ESM for browsers (2.6+ only): intended for direct imports in modern browsers via <code>&lt;script type=&quot;module&quot;&gt;</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Runtime-Compiler-vs-Runtime-only\"><a href=\"#Runtime-Compiler-vs-Runtime-only\" class=\"headerlink\" title=\"Runtime + Compiler vs. Runtime-only\"></a>Runtime + Compiler vs. Runtime-only</h3><p>If you need to compile templates on the client (e.g. passing a string to the <code>template</code> option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// this requires the compiler</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-comment\">// this does not</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  render (h) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'div'</span>, <span class=\"hljs-keyword\">this</span>.hi)\n  &#125;\n&#125;)</code></pre>\n<p>When using <code>vue-loader</code> or <code>vueify</code>, templates inside <code>*.vue</code> files are pre-compiled into JavaScript at build time. You don’t really need the compiler in the final bundle, and can therefore use the runtime-only build.</p>\n<p>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:</p>\n<h4 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h4><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">resolve</span>: &#123;\n    <span class=\"hljs-attr\">alias</span>: &#123;\n      <span class=\"hljs-string\">'vue$'</span>: <span class=\"hljs-string\">'vue/dist/vue.esm.js'</span> <span class=\"hljs-comment\">// 'vue/dist/vue.common.js' for webpack 1</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h4 id=\"Rollup\"><a href=\"#Rollup\" class=\"headerlink\" title=\"Rollup\"></a>Rollup</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> alias = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup-plugin-alias'</span>)\n\nrollup(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    alias(&#123;\n      <span class=\"hljs-string\">'vue'</span>: <span class=\"hljs-built_in\">require</span>.resolve(<span class=\"hljs-string\">'vue/dist/vue.esm.js'</span>)\n    &#125;)\n  ]\n&#125;)</code></pre>\n<h4 id=\"Browserify\"><a href=\"#Browserify\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h4><p>Add to your project’s <code>package.json</code>:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-string\">\"browser\"</span>: &#123;\n    <span class=\"hljs-string\">\"vue\"</span>: <span class=\"hljs-string\">\"vue/dist/vue.common.js\"</span>\n  &#125;\n&#125;</code></pre>\n<h4 id=\"Parcel\"><a href=\"#Parcel\" class=\"headerlink\" title=\"Parcel\"></a>Parcel</h4><p>Add to your project’s <code>package.json</code>:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-string\">\"alias\"</span>: &#123;\n    <span class=\"hljs-string\">\"vue\"</span> : <span class=\"hljs-string\">\"./node_modules/vue/dist/vue.common.js\"</span>\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Development-vs-Production-Mode\"><a href=\"#Development-vs-Production-Mode\" class=\"headerlink\" title=\"Development vs. Production Mode\"></a>Development vs. Production Mode</h3><p>Development/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.</p>\n<p>CommonJS and ES Module builds are intended for bundlers, therefore we don’t provide minified versions for them. You will be responsible for minifying the final bundle yourself.</p>\n<p>CommonJS and ES Module builds also preserve raw checks for <code>process.env.NODE_ENV</code> to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing <code>process.env.NODE_ENV</code> with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.</p>\n<h4 id=\"Webpack-1\"><a href=\"#Webpack-1\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h4><p>In Webpack 4+, you can use the <code>mode</code> option:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'production'</span>\n&#125;</code></pre>\n<p>But in Webpack 3 and earlier, you’ll need to use <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\">DefinePlugin</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'webpack'</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">new</span> webpack.DefinePlugin(&#123;\n      <span class=\"hljs-string\">'process.env'</span>: &#123;\n        <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-string\">'production'</span>)\n      &#125;\n    &#125;)\n  ]\n&#125;</code></pre>\n<h4 id=\"Rollup-1\"><a href=\"#Rollup-1\" class=\"headerlink\" title=\"Rollup\"></a>Rollup</h4><p>Use <a href=\"https://github.com/rollup/rollup-plugin-replace\" target=\"_blank\" rel=\"noopener\">rollup-plugin-replace</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> replace = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup-plugin-replace'</span>)\n\nrollup(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    replace(&#123;\n      <span class=\"hljs-string\">'process.env.NODE_ENV'</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-string\">'production'</span>)\n    &#125;)\n  ]\n&#125;).then(...)</code></pre>\n<h4 id=\"Browserify-1\"><a href=\"#Browserify-1\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h4><p>Apply a global <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> transform to your bundle.</p>\n<pre><code class=\"hljs bash\">NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js</code></pre>\n<p>Also see <a href=\"deployment.html\">Production Deployment Tips</a>.</p>\n<h3 id=\"CSP-environments\"><a href=\"#CSP-environments\" class=\"headerlink\" title=\"CSP environments\"></a>CSP environments</h3><p>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of <code>new Function()</code> for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.</p>\n<p>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with <a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"noopener\">Webpack + vue-loader</a> or <a href=\"https://github.com/vuejs-templates/browserify-simple\" target=\"_blank\" rel=\"noopener\">Browserify + vueify</a>, your templates will be precompiled into <code>render</code> functions which work perfectly in CSP environments.</p>\n<h2 id=\"Dev-Build\"><a href=\"#Dev-Build\" class=\"headerlink\" title=\"Dev Build\"></a>Dev Build</h2><p><strong>Important</strong>: the built files in GitHub’s <code>/dist</code> folder are only checked-in during releases. To use Vue from the latest source code on GitHub, you will have to build it yourself!</p>\n<pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/vuejs/vue.git node_modules/vue\n<span class=\"hljs-built_in\">cd</span> node_modules/vue\nnpm install\nnpm run build</code></pre>\n<h2 id=\"Bower\"><a href=\"#Bower\" class=\"headerlink\" title=\"Bower\"></a>Bower</h2><p>Only UMD builds are available from Bower.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># latest stable</span>\n$ bower install vue</code></pre>\n<h2 id=\"AMD-Module-Loaders\"><a href=\"#AMD-Module-Loaders\" class=\"headerlink\" title=\"AMD Module Loaders\"></a>AMD Module Loaders</h2><p>All UMD builds can be used directly as an AMD module.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Compatibility-Note\"><a href=\"#Compatibility-Note\" class=\"headerlink\" title=\"Compatibility Note\"></a>Compatibility Note</h3><p>Vue does <strong>not</strong> support IE8 and below, because it uses ECMAScript 5 features that are un-shimmable in IE8. However it supports all <a href=\"https://caniuse.com/#feat=es5\" target=\"_blank\" rel=\"noopener\">ECMAScript 5 compliant browsers</a>.</p>\n<h3 id=\"Semantic-Versioning\"><a href=\"#Semantic-Versioning\" class=\"headerlink\" title=\"Semantic Versioning\"></a>Semantic Versioning</h3><p>Vue follows <a href=\"https://semver.org/\" target=\"_blank\" rel=\"noopener\">Semantic Versioning</a> in all its official projects for documented features and behavior. For undocumented behavior or exposed internals, changes are described in <a href=\"https://github.com/vuejs/vue/releases\" target=\"_blank\" rel=\"noopener\">release notes</a>.</p>\n<h3 id=\"Release-Notes\"><a href=\"#Release-Notes\" class=\"headerlink\" title=\"Release Notes\"></a>Release Notes</h3><p>Latest stable version: 2.6.12</p>\n<p>Detailed release notes for each version are available on <a href=\"https://github.com/vuejs/vue/releases\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Vue-Devtools\"><a href=\"#Vue-Devtools\" class=\"headerlink\" title=\"Vue Devtools\"></a>Vue Devtools</h2><p>When using Vue, we recommend also installing the <a href=\"https://github.com/vuejs/vue-devtools#vue-devtools\" target=\"_blank\" rel=\"noopener\">Vue Devtools</a> in your browser, allowing you to inspect and debug your Vue applications in a more user-friendly interface.</p>\n<h2 id=\"Direct-lt-script-gt-Include\"><a href=\"#Direct-lt-script-gt-Include\" class=\"headerlink\" title=\"Direct &lt;script&gt; Include\"></a>Direct <code>&lt;script&gt;</code> Include</h2><p>Simply download and include with a script tag. <code>Vue</code> will be registered as a global variable.</p>\n<p class=\"tip\">Don’t use the minified version during development. You will miss out on all the nice warnings for common mistakes!</p>\n\n<div id=\"downloads\"><br>  <a class=\"button\" href=\"/js/vue.js\" download>Development Version</a><span class=\"light info\">With full warnings and debug mode</span><br><br>  <a class=\"button\" href=\"/js/vue.min.js\" download>Production Version</a><span class=\"light info\">Warnings stripped, 33.30KB min+gzip</span><br></div>\n\n<h3 id=\"CDN\"><a href=\"#CDN\" class=\"headerlink\" title=\"CDN\"></a>CDN</h3><p>For prototyping or learning purposes, you can use the latest version with:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>For production, we recommend linking to a specific version number and build to avoid unexpected breakage from newer versions:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://cdn.jsdelivr.net/npm/vue@2.6.12\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>If you are using native ES Modules, there is also an ES Modules compatible build:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"module\"</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js'</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>You can browse the source of the NPM package at <a href=\"https://cdn.jsdelivr.net/npm/vue/\" target=\"_blank\" rel=\"noopener\">cdn.jsdelivr.net/npm/vue</a>.</p>\n<p>Vue is also available on <a href=\"https://unpkg.com/vue@2.6.12/dist/vue.js\" target=\"_blank\" rel=\"noopener\">unpkg</a> and <a href=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.12/vue.js\" target=\"_blank\" rel=\"noopener\">cdnjs</a> (cdnjs takes some time to sync so the latest release may not be available yet).</p>\n<p>Make sure to read about <a href=\"#Explanation-of-Different-Builds\">the different builds of Vue</a> and use the <strong>production<br> version</strong> in your published site, replacing <code>vue.js</code> with <code>vue.min.js</code>. This is a smaller build optimized for speed instead of development experience.</p>\n<h2 id=\"NPM\"><a href=\"#NPM\" class=\"headerlink\" title=\"NPM\"></a>NPM</h2><p>NPM is the recommended installation method when building large scale applications with Vue. It pairs nicely with module bundlers such as <a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"noopener\">Webpack</a> or <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>. Vue also provides accompanying tools for authoring <a href=\"single-file-components.html\">Single File Components</a>.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># latest stable</span>\n$ npm install vue</code></pre>\n<h2 id=\"CLI\"><a href=\"#CLI\" class=\"headerlink\" title=\"CLI\"></a>CLI</h2><p>Vue provides an <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">official CLI</a> for quickly scaffolding ambitious Single Page Applications. It provides batteries-included build setups for a modern frontend workflow. It takes only a few minutes to get up and running with hot-reload, lint-on-save, and production-ready builds. See <a href=\"https://cli.vuejs.org\" target=\"_blank\" rel=\"noopener\">the Vue CLI docs</a> for more details.</p>\n<p class=\"tip\">The CLI assumes prior knowledge of Node.js and the associated build tools. If you are new to Vue or front-end build tools, we strongly suggest going through <a href=\"./\">the guide</a> without any build tools before using the CLI.</p>\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/real-world-vue-js/vue-cli\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue CLI\">Watch a video explanation on Vue Mastery</a></div>\n\n<h2 id=\"Explanation-of-Different-Builds\"><a href=\"#Explanation-of-Different-Builds\" class=\"headerlink\" title=\"Explanation of Different Builds\"></a>Explanation of Different Builds</h2><p>In the <a href=\"https://cdn.jsdelivr.net/npm/vue/dist/\" target=\"_blank\" rel=\"noopener\"><code>dist/</code> directory of the NPM package</a> you will find many different builds of Vue.js. Here’s an overview of the difference between them:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>UMD</th>\n<th>CommonJS</th>\n<th>ES Module (for bundlers)</th>\n<th>ES Module (for browsers)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Full</strong></td>\n<td>vue.js</td>\n<td>vue.common.js</td>\n<td>vue.esm.js</td>\n<td>vue.esm.browser.js</td>\n</tr>\n<tr>\n<td><strong>Runtime-only</strong></td>\n<td>vue.runtime.js</td>\n<td>vue.runtime.common.js</td>\n<td>vue.runtime.esm.js</td>\n<td>-</td>\n</tr>\n<tr>\n<td><strong>Full (production)</strong></td>\n<td>vue.min.js</td>\n<td>-</td>\n<td>-</td>\n<td>vue.esm.browser.min.js</td>\n</tr>\n<tr>\n<td><strong>Runtime-only (production)</strong></td>\n<td>vue.runtime.min.js</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Terms\"><a href=\"#Terms\" class=\"headerlink\" title=\"Terms\"></a>Terms</h3><ul>\n<li><p><strong>Full</strong>: builds that contain both the compiler and the runtime.</p>\n</li>\n<li><p><strong>Compiler</strong>: code that is responsible for compiling template strings into JavaScript render functions.</p>\n</li>\n<li><p><strong>Runtime</strong>: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler.</p>\n</li>\n<li><p><strong><a href=\"https://github.com/umdjs/umd\" target=\"_blank\" rel=\"noopener\">UMD</a></strong>: UMD builds can be used directly in the browser via a <code>&lt;script&gt;</code> tag. The default file from jsDelivr CDN at <a href=\"https://cdn.jsdelivr.net/npm/vue\" target=\"_blank\" rel=\"noopener\">https://cdn.jsdelivr.net/npm/vue</a> is the Runtime + Compiler UMD build (<code>vue.js</code>).</p>\n</li>\n<li><p><strong><a href=\"http://wiki.commonjs.org/wiki/Modules/1.1\" target=\"_blank\" rel=\"noopener\">CommonJS</a></strong>: CommonJS builds are intended for use with older bundlers like <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">browserify</a> or <a href=\"https://webpack.github.io\" target=\"_blank\" rel=\"noopener\">webpack 1</a>. The default file for these bundlers (<code>pkg.main</code>) is the Runtime only CommonJS build (<code>vue.runtime.common.js</code>).</p>\n</li>\n<li><p><strong><a href=\"http://exploringjs.com/es6/ch_modules.html\" target=\"_blank\" rel=\"noopener\">ES Module</a></strong>: starting in 2.6 Vue provides two ES Modules (ESM) builds:</p>\n<ul>\n<li><p>ESM for bundlers: intended for use with modern bundlers like <a href=\"https://webpack.js.org\" target=\"_blank\" rel=\"noopener\">webpack 2</a> or <a href=\"https://rollupjs.org/\" target=\"_blank\" rel=\"noopener\">Rollup</a>. ESM format is designed to be statically analyzable so the bundlers can take advantage of that to perform “tree-shaking” and eliminate unused code from your final bundle. The default file for these bundlers (<code>pkg.module</code>) is the Runtime only ES Module build (<code>vue.runtime.esm.js</code>).</p>\n</li>\n<li><p>ESM for browsers (2.6+ only): intended for direct imports in modern browsers via <code>&lt;script type=&quot;module&quot;&gt;</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Runtime-Compiler-vs-Runtime-only\"><a href=\"#Runtime-Compiler-vs-Runtime-only\" class=\"headerlink\" title=\"Runtime + Compiler vs. Runtime-only\"></a>Runtime + Compiler vs. Runtime-only</h3><p>If you need to compile templates on the client (e.g. passing a string to the <code>template</code> option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// this requires the compiler</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; hi &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-comment\">// this does not</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  render (h) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'div'</span>, <span class=\"hljs-keyword\">this</span>.hi)\n  &#125;\n&#125;)</code></pre>\n<p>When using <code>vue-loader</code> or <code>vueify</code>, templates inside <code>*.vue</code> files are pre-compiled into JavaScript at build time. You don’t really need the compiler in the final bundle, and can therefore use the runtime-only build.</p>\n<p>Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you still wish to use the full build instead, you need to configure an alias in your bundler:</p>\n<h4 id=\"Webpack\"><a href=\"#Webpack\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h4><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">resolve</span>: &#123;\n    <span class=\"hljs-attr\">alias</span>: &#123;\n      <span class=\"hljs-string\">'vue$'</span>: <span class=\"hljs-string\">'vue/dist/vue.esm.js'</span> <span class=\"hljs-comment\">// 'vue/dist/vue.common.js' for webpack 1</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h4 id=\"Rollup\"><a href=\"#Rollup\" class=\"headerlink\" title=\"Rollup\"></a>Rollup</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> alias = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup-plugin-alias'</span>)\n\nrollup(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    alias(&#123;\n      <span class=\"hljs-string\">'vue'</span>: <span class=\"hljs-built_in\">require</span>.resolve(<span class=\"hljs-string\">'vue/dist/vue.esm.js'</span>)\n    &#125;)\n  ]\n&#125;)</code></pre>\n<h4 id=\"Browserify\"><a href=\"#Browserify\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h4><p>Add to your project’s <code>package.json</code>:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-string\">\"browser\"</span>: &#123;\n    <span class=\"hljs-string\">\"vue\"</span>: <span class=\"hljs-string\">\"vue/dist/vue.common.js\"</span>\n  &#125;\n&#125;</code></pre>\n<h4 id=\"Parcel\"><a href=\"#Parcel\" class=\"headerlink\" title=\"Parcel\"></a>Parcel</h4><p>Add to your project’s <code>package.json</code>:</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-string\">\"alias\"</span>: &#123;\n    <span class=\"hljs-string\">\"vue\"</span> : <span class=\"hljs-string\">\"./node_modules/vue/dist/vue.common.js\"</span>\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Development-vs-Production-Mode\"><a href=\"#Development-vs-Production-Mode\" class=\"headerlink\" title=\"Development vs. Production Mode\"></a>Development vs. Production Mode</h3><p>Development/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.</p>\n<p>CommonJS and ES Module builds are intended for bundlers, therefore we don’t provide minified versions for them. You will be responsible for minifying the final bundle yourself.</p>\n<p>CommonJS and ES Module builds also preserve raw checks for <code>process.env.NODE_ENV</code> to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing <code>process.env.NODE_ENV</code> with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.</p>\n<h4 id=\"Webpack-1\"><a href=\"#Webpack-1\" class=\"headerlink\" title=\"Webpack\"></a>Webpack</h4><p>In Webpack 4+, you can use the <code>mode</code> option:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-attr\">mode</span>: <span class=\"hljs-string\">'production'</span>\n&#125;</code></pre>\n<p>But in Webpack 3 and earlier, you’ll need to use <a href=\"https://webpack.js.org/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\">DefinePlugin</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> webpack = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'webpack'</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-keyword\">new</span> webpack.DefinePlugin(&#123;\n      <span class=\"hljs-string\">'process.env'</span>: &#123;\n        <span class=\"hljs-attr\">NODE_ENV</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-string\">'production'</span>)\n      &#125;\n    &#125;)\n  ]\n&#125;</code></pre>\n<h4 id=\"Rollup-1\"><a href=\"#Rollup-1\" class=\"headerlink\" title=\"Rollup\"></a>Rollup</h4><p>Use <a href=\"https://github.com/rollup/rollup-plugin-replace\" target=\"_blank\" rel=\"noopener\">rollup-plugin-replace</a>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> replace = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rollup-plugin-replace'</span>)\n\nrollup(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">plugins</span>: [\n    replace(&#123;\n      <span class=\"hljs-string\">'process.env.NODE_ENV'</span>: <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-string\">'production'</span>)\n    &#125;)\n  ]\n&#125;).then(...)</code></pre>\n<h4 id=\"Browserify-1\"><a href=\"#Browserify-1\" class=\"headerlink\" title=\"Browserify\"></a>Browserify</h4><p>Apply a global <a href=\"https://github.com/hughsk/envify\" target=\"_blank\" rel=\"noopener\">envify</a> transform to your bundle.</p>\n<pre><code class=\"hljs bash\">NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m &gt; build.js</code></pre>\n<p>Also see <a href=\"deployment.html\">Production Deployment Tips</a>.</p>\n<h3 id=\"CSP-environments\"><a href=\"#CSP-environments\" class=\"headerlink\" title=\"CSP environments\"></a>CSP environments</h3><p>Some environments, such as Google Chrome Apps, enforce Content Security Policy (CSP), which prohibits the use of <code>new Function()</code> for evaluating expressions. The full build depends on this feature to compile templates, so is unusable in these environments.</p>\n<p>On the other hand, the runtime-only build is fully CSP-compliant. When using the runtime-only build with <a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"noopener\">Webpack + vue-loader</a> or <a href=\"https://github.com/vuejs-templates/browserify-simple\" target=\"_blank\" rel=\"noopener\">Browserify + vueify</a>, your templates will be precompiled into <code>render</code> functions which work perfectly in CSP environments.</p>\n<h2 id=\"Dev-Build\"><a href=\"#Dev-Build\" class=\"headerlink\" title=\"Dev Build\"></a>Dev Build</h2><p><strong>Important</strong>: the built files in GitHub’s <code>/dist</code> folder are only checked-in during releases. To use Vue from the latest source code on GitHub, you will have to build it yourself!</p>\n<pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">clone</span> https://github.com/vuejs/vue.git node_modules/vue\n<span class=\"hljs-built_in\">cd</span> node_modules/vue\nnpm install\nnpm run build</code></pre>\n<h2 id=\"Bower\"><a href=\"#Bower\" class=\"headerlink\" title=\"Bower\"></a>Bower</h2><p>Only UMD builds are available from Bower.</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># latest stable</span>\n$ bower install vue</code></pre>\n<h2 id=\"AMD-Module-Loaders\"><a href=\"#AMD-Module-Loaders\" class=\"headerlink\" title=\"AMD Module Loaders\"></a>AMD Module Loaders</h2><p>All UMD builds can be used directly as an AMD module.</p>\n"},{"title":"Join the BytePath Community!","type":"guide","order":802,"_content":"\nVue's community is growing incredibly fast and if you're reading this, there's a good chance you're ready to join it. So... welcome!\n\nNow we'll answer both what the community can do for you and what you can do for the community.\n\n## Resources\n\n### Code of Conduct\n\nOur [Code of Conduct](/coc) is a guide to make it easier to enrich all of us and the technical communities in which we participate.\n\n### Get Support\n\n- [Forum](https://forum.vuejs.org/): The best place to ask questions and get answers about Vue and its ecosystem.\n- [Chat](https://chat.vuejs.org/): A place for Vue devs to meet and chat in real time.\n- [Meetups](https://events.vuejs.org/meetups): Want to find local Vue.js enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need right here!\n- [GitHub](https://github.com/vuejs): If you have a bug to report or feature to request, that's what the GitHub issues are for. We also welcome pull requests!\n\n### Explore the Ecosystem\n\n- [The Awesome Vue Page](https://github.com/vuejs/awesome-vue): See what other awesome resources have been published by other awesome people.\n- [The \"Show and Tell\" Subforum](https://forum.vuejs.org/c/show-and-tell): Another great place to check out what others have built with and for the growing Vue ecosystem.\n\n## What You Can Do\n\n### Contribute Code\n\nAs with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read [the contributing guide](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md).\n\nAfter that, you'll be ready to contribute to Vue's core repositories:\n\n- [vue](https://github.com/vuejs/vue): the core library\n- [vuex](https://github.com/vuejs/vuex): Flux-inspired state management\n- [vue-router](https://github.com/vuejs/vue-router): a routing system for SPAs\n\n...as well as many smaller official [companion libraries](https://github.com/vuejs).\n\n### Share (and Build) Your Experience\n\nApart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know:\n\n- **Develop learning materials.** It's often said that the best way to learn is to teach. If there's something interesting you're doing with Vue, strengthen your expertise by writing a blog post, developing a workshop, or even publishing a gist that you share on social media.\n- **Watch a repo you care about.** This will send you notifications whenever there's activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It's a fantastic way to build expertise so that you're eventually able to help address issues and pull requests.\n\n### Translate Docs\n\nVue has already spread across the globe, with even the core team in at least half a dozen timezones. [The forum](https://forum.vuejs.org/) includes 7 languages and counting and many of our docs have [actively-maintained translations](https://github.com/vuejs?utf8=%E2%9C%93&q=vuejs.org). We're very proud of Vue's international reach, but we can do even better.\n\nI hope that right now, you're reading this sentence in your preferred language. If not, would you like to help us get there?\n\nIf so, please feel free to fork the repo for [these docs](https://github.com/vuejs/vuejs.org/) or for any other officially maintained documentation, then start translating. Once you've made some progress, open an issue or pull request in the main repo and we'll put out a call for more contributors to help you out.\n\n### Become a Community Leader\n\nThere's a lot you can do to help Vue grow in your community:\n\n- **Present at your local meetup.** Whether it's giving a talk or running a workshop, you can bring a lot of value to your community by helping both new and experienced Vue developers continue to grow.\n- **Start your own meetup.** If there's not already a Vue meetup in your area, you can start your own! Use the [resources at events.vuejs.org](https://events.vuejs.org/resources/#getting-started) to help you succeed!\n- **Help meetup organizers.** There can never be too much help when it comes to running an event, so offer a hand to help out local organizers to help make every event a success.\n\nIf you have any questions on how you can get more involved with your local Vue community, reach out at [@Vuejs_Events](https://www.twitter.com/vuejs_events)!\n","source":"v2/guide/join.md","raw":"---\ntitle: Join the BytePath Community!\ntype: guide\norder: 802\n---\n\nVue's community is growing incredibly fast and if you're reading this, there's a good chance you're ready to join it. So... welcome!\n\nNow we'll answer both what the community can do for you and what you can do for the community.\n\n## Resources\n\n### Code of Conduct\n\nOur [Code of Conduct](/coc) is a guide to make it easier to enrich all of us and the technical communities in which we participate.\n\n### Get Support\n\n- [Forum](https://forum.vuejs.org/): The best place to ask questions and get answers about Vue and its ecosystem.\n- [Chat](https://chat.vuejs.org/): A place for Vue devs to meet and chat in real time.\n- [Meetups](https://events.vuejs.org/meetups): Want to find local Vue.js enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need right here!\n- [GitHub](https://github.com/vuejs): If you have a bug to report or feature to request, that's what the GitHub issues are for. We also welcome pull requests!\n\n### Explore the Ecosystem\n\n- [The Awesome Vue Page](https://github.com/vuejs/awesome-vue): See what other awesome resources have been published by other awesome people.\n- [The \"Show and Tell\" Subforum](https://forum.vuejs.org/c/show-and-tell): Another great place to check out what others have built with and for the growing Vue ecosystem.\n\n## What You Can Do\n\n### Contribute Code\n\nAs with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read [the contributing guide](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md).\n\nAfter that, you'll be ready to contribute to Vue's core repositories:\n\n- [vue](https://github.com/vuejs/vue): the core library\n- [vuex](https://github.com/vuejs/vuex): Flux-inspired state management\n- [vue-router](https://github.com/vuejs/vue-router): a routing system for SPAs\n\n...as well as many smaller official [companion libraries](https://github.com/vuejs).\n\n### Share (and Build) Your Experience\n\nApart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know:\n\n- **Develop learning materials.** It's often said that the best way to learn is to teach. If there's something interesting you're doing with Vue, strengthen your expertise by writing a blog post, developing a workshop, or even publishing a gist that you share on social media.\n- **Watch a repo you care about.** This will send you notifications whenever there's activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It's a fantastic way to build expertise so that you're eventually able to help address issues and pull requests.\n\n### Translate Docs\n\nVue has already spread across the globe, with even the core team in at least half a dozen timezones. [The forum](https://forum.vuejs.org/) includes 7 languages and counting and many of our docs have [actively-maintained translations](https://github.com/vuejs?utf8=%E2%9C%93&q=vuejs.org). We're very proud of Vue's international reach, but we can do even better.\n\nI hope that right now, you're reading this sentence in your preferred language. If not, would you like to help us get there?\n\nIf so, please feel free to fork the repo for [these docs](https://github.com/vuejs/vuejs.org/) or for any other officially maintained documentation, then start translating. Once you've made some progress, open an issue or pull request in the main repo and we'll put out a call for more contributors to help you out.\n\n### Become a Community Leader\n\nThere's a lot you can do to help Vue grow in your community:\n\n- **Present at your local meetup.** Whether it's giving a talk or running a workshop, you can bring a lot of value to your community by helping both new and experienced Vue developers continue to grow.\n- **Start your own meetup.** If there's not already a Vue meetup in your area, you can start your own! Use the [resources at events.vuejs.org](https://events.vuejs.org/resources/#getting-started) to help you succeed!\n- **Help meetup organizers.** There can never be too much help when it comes to running an event, so offer a hand to help out local organizers to help make every event a success.\n\nIf you have any questions on how you can get more involved with your local Vue community, reach out at [@Vuejs_Events](https://www.twitter.com/vuejs_events)!\n","date":"2020-09-25T23:55:41.138Z","updated":"2020-09-25T23:55:41.138Z","path":"v2/guide/join.html","comments":1,"layout":"page","_id":"ckfl66gym002bc2v5tui84ci5","content":"<p>Vue’s community is growing incredibly fast and if you’re reading this, there’s a good chance you’re ready to join it. So… welcome!</p>\n<p>Now we’ll answer both what the community can do for you and what you can do for the community.</p>\n<h2 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources\"></a>Resources</h2><h3 id=\"Code-of-Conduct\"><a href=\"#Code-of-Conduct\" class=\"headerlink\" title=\"Code of Conduct\"></a>Code of Conduct</h3><p>Our <a href=\"/coc\">Code of Conduct</a> is a guide to make it easier to enrich all of us and the technical communities in which we participate.</p>\n<h3 id=\"Get-Support\"><a href=\"#Get-Support\" class=\"headerlink\" title=\"Get Support\"></a>Get Support</h3><ul>\n<li><a href=\"https://forum.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Forum</a>: The best place to ask questions and get answers about Vue and its ecosystem.</li>\n<li><a href=\"https://chat.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Chat</a>: A place for Vue devs to meet and chat in real time.</li>\n<li><a href=\"https://events.vuejs.org/meetups\" target=\"_blank\" rel=\"noopener\">Meetups</a>: Want to find local Vue.js enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need right here!</li>\n<li><a href=\"https://github.com/vuejs\" target=\"_blank\" rel=\"noopener\">GitHub</a>: If you have a bug to report or feature to request, that’s what the GitHub issues are for. We also welcome pull requests!</li>\n</ul>\n<h3 id=\"Explore-the-Ecosystem\"><a href=\"#Explore-the-Ecosystem\" class=\"headerlink\" title=\"Explore the Ecosystem\"></a>Explore the Ecosystem</h3><ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\" rel=\"noopener\">The Awesome Vue Page</a>: See what other awesome resources have been published by other awesome people.</li>\n<li><a href=\"https://forum.vuejs.org/c/show-and-tell\" target=\"_blank\" rel=\"noopener\">The “Show and Tell” Subforum</a>: Another great place to check out what others have built with and for the growing Vue ecosystem.</li>\n</ul>\n<h2 id=\"What-You-Can-Do\"><a href=\"#What-You-Can-Do\" class=\"headerlink\" title=\"What You Can Do\"></a>What You Can Do</h2><h3 id=\"Contribute-Code\"><a href=\"#Contribute-Code\" class=\"headerlink\" title=\"Contribute Code\"></a>Contribute Code</h3><p>As with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read <a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener\">the contributing guide</a>.</p>\n<p>After that, you’ll be ready to contribute to Vue’s core repositories:</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"noopener\">vue</a>: the core library</li>\n<li><a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">vuex</a>: Flux-inspired state management</li>\n<li><a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a>: a routing system for SPAs</li>\n</ul>\n<p>…as well as many smaller official <a href=\"https://github.com/vuejs\" target=\"_blank\" rel=\"noopener\">companion libraries</a>.</p>\n<h3 id=\"Share-and-Build-Your-Experience\"><a href=\"#Share-and-Build-Your-Experience\" class=\"headerlink\" title=\"Share (and Build) Your Experience\"></a>Share (and Build) Your Experience</h3><p>Apart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know:</p>\n<ul>\n<li><strong>Develop learning materials.</strong> It’s often said that the best way to learn is to teach. If there’s something interesting you’re doing with Vue, strengthen your expertise by writing a blog post, developing a workshop, or even publishing a gist that you share on social media.</li>\n<li><strong>Watch a repo you care about.</strong> This will send you notifications whenever there’s activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It’s a fantastic way to build expertise so that you’re eventually able to help address issues and pull requests.</li>\n</ul>\n<h3 id=\"Translate-Docs\"><a href=\"#Translate-Docs\" class=\"headerlink\" title=\"Translate Docs\"></a>Translate Docs</h3><p>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. <a href=\"https://forum.vuejs.org/\" target=\"_blank\" rel=\"noopener\">The forum</a> includes 7 languages and counting and many of our docs have <a href=\"https://github.com/vuejs?utf8=%E2%9C%93&amp;q=vuejs.org\" target=\"_blank\" rel=\"noopener\">actively-maintained translations</a>. We’re very proud of Vue’s international reach, but we can do even better.</p>\n<p>I hope that right now, you’re reading this sentence in your preferred language. If not, would you like to help us get there?</p>\n<p>If so, please feel free to fork the repo for <a href=\"https://github.com/vuejs/vuejs.org/\" target=\"_blank\" rel=\"noopener\">these docs</a> or for any other officially maintained documentation, then start translating. Once you’ve made some progress, open an issue or pull request in the main repo and we’ll put out a call for more contributors to help you out.</p>\n<h3 id=\"Become-a-Community-Leader\"><a href=\"#Become-a-Community-Leader\" class=\"headerlink\" title=\"Become a Community Leader\"></a>Become a Community Leader</h3><p>There’s a lot you can do to help Vue grow in your community:</p>\n<ul>\n<li><strong>Present at your local meetup.</strong> Whether it’s giving a talk or running a workshop, you can bring a lot of value to your community by helping both new and experienced Vue developers continue to grow.</li>\n<li><strong>Start your own meetup.</strong> If there’s not already a Vue meetup in your area, you can start your own! Use the <a href=\"https://events.vuejs.org/resources/#getting-started\" target=\"_blank\" rel=\"noopener\">resources at events.vuejs.org</a> to help you succeed!</li>\n<li><strong>Help meetup organizers.</strong> There can never be too much help when it comes to running an event, so offer a hand to help out local organizers to help make every event a success.</li>\n</ul>\n<p>If you have any questions on how you can get more involved with your local Vue community, reach out at <a href=\"https://www.twitter.com/vuejs_events\" target=\"_blank\" rel=\"noopener\">@Vuejs_Events</a>!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vue’s community is growing incredibly fast and if you’re reading this, there’s a good chance you’re ready to join it. So… welcome!</p>\n<p>Now we’ll answer both what the community can do for you and what you can do for the community.</p>\n<h2 id=\"Resources\"><a href=\"#Resources\" class=\"headerlink\" title=\"Resources\"></a>Resources</h2><h3 id=\"Code-of-Conduct\"><a href=\"#Code-of-Conduct\" class=\"headerlink\" title=\"Code of Conduct\"></a>Code of Conduct</h3><p>Our <a href=\"/coc\">Code of Conduct</a> is a guide to make it easier to enrich all of us and the technical communities in which we participate.</p>\n<h3 id=\"Get-Support\"><a href=\"#Get-Support\" class=\"headerlink\" title=\"Get Support\"></a>Get Support</h3><ul>\n<li><a href=\"https://forum.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Forum</a>: The best place to ask questions and get answers about Vue and its ecosystem.</li>\n<li><a href=\"https://chat.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Chat</a>: A place for Vue devs to meet and chat in real time.</li>\n<li><a href=\"https://events.vuejs.org/meetups\" target=\"_blank\" rel=\"noopener\">Meetups</a>: Want to find local Vue.js enthusiasts like yourself? Interested in becoming a community leader? We have the help and support you need right here!</li>\n<li><a href=\"https://github.com/vuejs\" target=\"_blank\" rel=\"noopener\">GitHub</a>: If you have a bug to report or feature to request, that’s what the GitHub issues are for. We also welcome pull requests!</li>\n</ul>\n<h3 id=\"Explore-the-Ecosystem\"><a href=\"#Explore-the-Ecosystem\" class=\"headerlink\" title=\"Explore the Ecosystem\"></a>Explore the Ecosystem</h3><ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\" rel=\"noopener\">The Awesome Vue Page</a>: See what other awesome resources have been published by other awesome people.</li>\n<li><a href=\"https://forum.vuejs.org/c/show-and-tell\" target=\"_blank\" rel=\"noopener\">The “Show and Tell” Subforum</a>: Another great place to check out what others have built with and for the growing Vue ecosystem.</li>\n</ul>\n<h2 id=\"What-You-Can-Do\"><a href=\"#What-You-Can-Do\" class=\"headerlink\" title=\"What You Can Do\"></a>What You Can Do</h2><h3 id=\"Contribute-Code\"><a href=\"#Contribute-Code\" class=\"headerlink\" title=\"Contribute Code\"></a>Contribute Code</h3><p>As with any project, there are rules to contributing. To ensure that we can help you or accept your pull request as quickly as possible, please read <a href=\"https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md\" target=\"_blank\" rel=\"noopener\">the contributing guide</a>.</p>\n<p>After that, you’ll be ready to contribute to Vue’s core repositories:</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/vue\" target=\"_blank\" rel=\"noopener\">vue</a>: the core library</li>\n<li><a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">vuex</a>: Flux-inspired state management</li>\n<li><a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a>: a routing system for SPAs</li>\n</ul>\n<p>…as well as many smaller official <a href=\"https://github.com/vuejs\" target=\"_blank\" rel=\"noopener\">companion libraries</a>.</p>\n<h3 id=\"Share-and-Build-Your-Experience\"><a href=\"#Share-and-Build-Your-Experience\" class=\"headerlink\" title=\"Share (and Build) Your Experience\"></a>Share (and Build) Your Experience</h3><p>Apart from answering questions and sharing resources in the forum and chat, there are a few other less obvious ways to share and expand what you know:</p>\n<ul>\n<li><strong>Develop learning materials.</strong> It’s often said that the best way to learn is to teach. If there’s something interesting you’re doing with Vue, strengthen your expertise by writing a blog post, developing a workshop, or even publishing a gist that you share on social media.</li>\n<li><strong>Watch a repo you care about.</strong> This will send you notifications whenever there’s activity in that repository, giving you insider knowledge about ongoing discussions and upcoming features. It’s a fantastic way to build expertise so that you’re eventually able to help address issues and pull requests.</li>\n</ul>\n<h3 id=\"Translate-Docs\"><a href=\"#Translate-Docs\" class=\"headerlink\" title=\"Translate Docs\"></a>Translate Docs</h3><p>Vue has already spread across the globe, with even the core team in at least half a dozen timezones. <a href=\"https://forum.vuejs.org/\" target=\"_blank\" rel=\"noopener\">The forum</a> includes 7 languages and counting and many of our docs have <a href=\"https://github.com/vuejs?utf8=%E2%9C%93&amp;q=vuejs.org\" target=\"_blank\" rel=\"noopener\">actively-maintained translations</a>. We’re very proud of Vue’s international reach, but we can do even better.</p>\n<p>I hope that right now, you’re reading this sentence in your preferred language. If not, would you like to help us get there?</p>\n<p>If so, please feel free to fork the repo for <a href=\"https://github.com/vuejs/vuejs.org/\" target=\"_blank\" rel=\"noopener\">these docs</a> or for any other officially maintained documentation, then start translating. Once you’ve made some progress, open an issue or pull request in the main repo and we’ll put out a call for more contributors to help you out.</p>\n<h3 id=\"Become-a-Community-Leader\"><a href=\"#Become-a-Community-Leader\" class=\"headerlink\" title=\"Become a Community Leader\"></a>Become a Community Leader</h3><p>There’s a lot you can do to help Vue grow in your community:</p>\n<ul>\n<li><strong>Present at your local meetup.</strong> Whether it’s giving a talk or running a workshop, you can bring a lot of value to your community by helping both new and experienced Vue developers continue to grow.</li>\n<li><strong>Start your own meetup.</strong> If there’s not already a Vue meetup in your area, you can start your own! Use the <a href=\"https://events.vuejs.org/resources/#getting-started\" target=\"_blank\" rel=\"noopener\">resources at events.vuejs.org</a> to help you succeed!</li>\n<li><strong>Help meetup organizers.</strong> There can never be too much help when it comes to running an event, so offer a hand to help out local organizers to help make every event a success.</li>\n</ul>\n<p>If you have any questions on how you can get more involved with your local Vue community, reach out at <a href=\"https://www.twitter.com/vuejs_events\" target=\"_blank\" rel=\"noopener\">@Vuejs_Events</a>!</p>\n"},{"title":"List Rendering","type":"guide","order":8,"_content":"\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-loops?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to render lists on Vue School\">Learn how to render list with a free Vue School lesson</a></div>\n\n\n## Mapping an Array to Elements with `v-for`\n\nWe can use the `v-for` directive to render a list of items based on an array. The `v-for` directive requires a special syntax in the form of `item in items`, where `items` is the source data array and `item` is an **alias** for the array element being iterated on:\n\n``` html\n<ul id=\"example-1\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\nInside `v-for` blocks we have full access to parent scope properties. `v-for` also supports an optional second argument for the index of the current item.\n\n``` html\n<ul id=\"example-2\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n\nResult:\n\n{% raw%}\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\nYou can also use `of` as the delimiter instead of `in`, so that it is closer to JavaScript's syntax for iterators:\n\n``` html\n<div v-for=\"item of items\"></div>\n```\n\n## `v-for` with an Object\n\nYou can also use `v-for` to iterate through the properties of an object.\n\n``` html\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n```\n\n``` js\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nYou can also provide a second argument for the property's name (a.k.a. key):\n\n``` html\n<div v-for=\"(value, name) in object\">\n  {{ name }}: {{ value }}\n</div>\n```\n\n{% raw %}\n<div id=\"v-for-object-value-name\" class=\"demo\">\n  <div v-for=\"(value, name) in object\">\n    {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nAnd another for the index:\n\n``` html\n<div v-for=\"(value, name, index) in object\">\n  {{ index }}. {{ name }}: {{ value }}\n</div>\n```\n\n{% raw %}\n<div id=\"v-for-object-value-name-index\" class=\"demo\">\n  <div v-for=\"(value, name, index) in object\">\n    {{ index }}. {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name-index',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n<p class=\"tip\">When iterating over an object, the order is based on the enumeration order of `Object.keys()`, which is **not** guaranteed to be consistent across JavaScript engine implementations.</p>\n\n## Maintaining State\n\nWhen Vue is updating a list of elements rendered with `v-for`, by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of `track-by=\"$index\"` in Vue 1.x.\n\nThis default mode is efficient, but **only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)**.\n\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique `key` attribute for each item:\n\n``` html\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- content -->\n</div>\n```\n\nIt is recommended to provide a `key` attribute with `v-for` whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.\n\nSince it's a generic mechanism for Vue to identify nodes, the `key` also has other uses that are not specifically tied to `v-for`, as we will see later in the guide.\n\n<p class=\"tip\">Don't use non-primitive values like objects and arrays as `v-for` keys. Use string or numeric values instead.</p>\n\nFor detailed usage of the `key` attribute, please see the [`key` API documentation](https://vuejs.org/v2/api/#key).\n\n## Array Change Detection\n\n### Mutation Methods\n\nVue wraps an observed array's mutation methods so they will also trigger view updates. The wrapped methods are:\n\n- `push()`\n- `pop()`\n- `shift()`\n- `unshift()`\n- `splice()`\n- `sort()`\n- `reverse()`\n\nYou can open the console and play with the previous examples' `items` array by calling their mutation methods. For example: `example1.items.push({ message: 'Baz' })`.\n\n### Replacing an Array\n\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. `filter()`, `concat()` and `slice()`, which do not mutate the original array but **always return a new array**. When working with non-mutating methods, you can replace the old array with the new one:\n\n``` js\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n```\n\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\n\n### Caveats\n\nDue to limitations in JavaScript, there are types of changes that Vue **cannot detect** with arrays and objects. These are discussed in the [reactivity](reactivity.html#Change-Detection-Caveats) section.\n\n## Displaying Filtered/Sorted Results\n\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\n\nFor example:\n\n``` html\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n\n``` js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\nIn situations where computed properties are not feasible (e.g. inside nested `v-for` loops), you can use a method:\n\n```html\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\">{{ n }}</li>\n</ul>\n```\n\n```js\ndata: {\n  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]\n},\nmethods: {\n  even: function (numbers) {\n    return numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\n## `v-for` with a Range\n\n`v-for` can also take an integer. In this case it will repeat the template that many times.\n\n``` html\n<div>\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n```\n\nResult:\n\n{% raw %}\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\n  new Vue({ el: '#range' })\n</script>\n{% endraw %}\n\n## `v-for` on a `<template>`\n\nSimilar to template `v-if`, you can also use a `<template>` tag with `v-for` to render a block of multiple elements. For example:\n\n``` html\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n</ul>\n```\n\n## `v-for` with `v-if`\n\n<p class=\"tip\">Note that it's **not** recommended to use `v-if` and `v-for` together. Refer to [style guide](/v2/style-guide/#Avoid-v-if-with-v-for-essential) for details.</p>\n\nWhen they exist on the same node, `v-for` has a higher priority than `v-if`. That means the `v-if` will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only _some_ items, like below:\n\n``` html\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n\nThe above only renders the todos that are not complete.\n\nIf instead, your intent is to conditionally skip execution of the loop, you can place the `v-if` on a wrapper element (or [`<template>`](conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt)). For example:\n\n``` html\n<ul v-if=\"todos.length\">\n  <li v-for=\"todo in todos\">\n    {{ todo }}\n  </li>\n</ul>\n<p v-else>No todos left!</p>\n```\n\n## `v-for` with a Component\n\n> This section assumes knowledge of [Components](components.html). Feel free to skip it and come back later.\n\nYou can directly use `v-for` on a custom component, like any normal element:\n\n``` html\n<my-component v-for=\"item in items\" :key=\"item.id\"></my-component>\n```\n\n> In 2.2.0+, when using `v-for` with a component, a [`key`](list.html#key) is now required.\n\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n\n``` html\n<my-component\n  v-for=\"(item, index) in items\"\n  v-bind:item=\"item\"\n  v-bind:index=\"index\"\n  v-bind:key=\"item.id\"\n></my-component>\n```\n\nThe reason for not automatically injecting `item` into the component is because that makes the component tightly coupled to how `v-for` works. Being explicit about where its data comes from makes the component reusable in other situations.\n\nHere's a complete example of a simple todo list:\n\n``` html\n<div id=\"todo-list-example\">\n  <form v-on:submit.prevent=\"addNewTodo\">\n    <label for=\"new-todo\">Add a todo</label>\n    <input\n      v-model=\"newTodoText\"\n      id=\"new-todo\"\n      placeholder=\"E.g. Feed the cat\"\n    >\n    <button>Add</button>\n  </form>\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:key=\"todo.id\"\n      v-bind:title=\"todo.title\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n```\n\n<p class=\"tip\">Note the `is=\"todo-item\"` attribute. This is necessary in DOM templates, because only an `<li>` element is valid inside a `<ul>`. It does the same thing as `<todo-item>`, but works around a potential browser parsing error. See [DOM Template Parsing Caveats](components.html#DOM-Template-Parsing-Caveats) to learn more.</p>\n\n``` js\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      {\n        id: 1,\n        title: 'Do the dishes',\n      },\n      {\n        id: 2,\n        title: 'Take out the trash',\n      },\n      {\n        id: 3,\n        title: 'Mow the lawn'\n      }\n    ],\n    nextTodoId: 4\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push({\n        id: this.nextTodoId++,\n        title: this.newTodoText\n      })\n      this.newTodoText = ''\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"todo-list-example\" class=\"demo\">\n  <form v-on:submit.prevent=\"addNewTodo\">\n    <label for=\"new-todo\">Add a todo</label>\n    <input\n      v-model=\"newTodoText\"\n      id=\"new-todo\"\n      placeholder=\"E.g. Feed the cat\"\n    >\n    <button>Add</button>\n  </form>\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:key=\"todo.id\"\n      v-bind:title=\"todo.title\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      {\n        id: 1,\n        title: 'Do the dishes',\n      },\n      {\n        id: 2,\n        title: 'Take out the trash',\n      },\n      {\n        id: 3,\n        title: 'Mow the lawn'\n      }\n    ],\n    nextTodoId: 4\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push({\n        id: this.nextTodoId++,\n        title: this.newTodoText\n      })\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n{% endraw %}\n","source":"v2/guide/list.md","raw":"---\ntitle: List Rendering\ntype: guide\norder: 8\n---\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-loops?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to render lists on Vue School\">Learn how to render list with a free Vue School lesson</a></div>\n\n\n## Mapping an Array to Elements with `v-for`\n\nWe can use the `v-for` directive to render a list of items based on an array. The `v-for` directive requires a special syntax in the form of `item in items`, where `items` is the source data array and `item` is an **alias** for the array element being iterated on:\n\n``` html\n<ul id=\"example-1\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\nInside `v-for` blocks we have full access to parent scope properties. `v-for` also supports an optional second argument for the index of the current item.\n\n``` html\n<ul id=\"example-2\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n```\n\n``` js\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n```\n\nResult:\n\n{% raw%}\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n{% endraw %}\n\nYou can also use `of` as the delimiter instead of `in`, so that it is closer to JavaScript's syntax for iterators:\n\n``` html\n<div v-for=\"item of items\"></div>\n```\n\n## `v-for` with an Object\n\nYou can also use `v-for` to iterate through the properties of an object.\n\n``` html\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n```\n\n``` js\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n```\n\nResult:\n\n{% raw %}\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nYou can also provide a second argument for the property's name (a.k.a. key):\n\n``` html\n<div v-for=\"(value, name) in object\">\n  {{ name }}: {{ value }}\n</div>\n```\n\n{% raw %}\n<div id=\"v-for-object-value-name\" class=\"demo\">\n  <div v-for=\"(value, name) in object\">\n    {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nAnd another for the index:\n\n``` html\n<div v-for=\"(value, name, index) in object\">\n  {{ index }}. {{ name }}: {{ value }}\n</div>\n```\n\n{% raw %}\n<div id=\"v-for-object-value-name-index\" class=\"demo\">\n  <div v-for=\"(value, name, index) in object\">\n    {{ index }}. {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name-index',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n{% endraw %}\n\n<p class=\"tip\">When iterating over an object, the order is based on the enumeration order of `Object.keys()`, which is **not** guaranteed to be consistent across JavaScript engine implementations.</p>\n\n## Maintaining State\n\nWhen Vue is updating a list of elements rendered with `v-for`, by default it uses an \"in-place patch\" strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of `track-by=\"$index\"` in Vue 1.x.\n\nThis default mode is efficient, but **only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)**.\n\nTo give Vue a hint so that it can track each node's identity, and thus reuse and reorder existing elements, you need to provide a unique `key` attribute for each item:\n\n``` html\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- content -->\n</div>\n```\n\nIt is recommended to provide a `key` attribute with `v-for` whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.\n\nSince it's a generic mechanism for Vue to identify nodes, the `key` also has other uses that are not specifically tied to `v-for`, as we will see later in the guide.\n\n<p class=\"tip\">Don't use non-primitive values like objects and arrays as `v-for` keys. Use string or numeric values instead.</p>\n\nFor detailed usage of the `key` attribute, please see the [`key` API documentation](https://vuejs.org/v2/api/#key).\n\n## Array Change Detection\n\n### Mutation Methods\n\nVue wraps an observed array's mutation methods so they will also trigger view updates. The wrapped methods are:\n\n- `push()`\n- `pop()`\n- `shift()`\n- `unshift()`\n- `splice()`\n- `sort()`\n- `reverse()`\n\nYou can open the console and play with the previous examples' `items` array by calling their mutation methods. For example: `example1.items.push({ message: 'Baz' })`.\n\n### Replacing an Array\n\nMutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. `filter()`, `concat()` and `slice()`, which do not mutate the original array but **always return a new array**. When working with non-mutating methods, you can replace the old array with the new one:\n\n``` js\nexample1.items = example1.items.filter(function (item) {\n  return item.message.match(/Foo/)\n})\n```\n\nYou might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.\n\n### Caveats\n\nDue to limitations in JavaScript, there are types of changes that Vue **cannot detect** with arrays and objects. These are discussed in the [reactivity](reactivity.html#Change-Detection-Caveats) section.\n\n## Displaying Filtered/Sorted Results\n\nSometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.\n\nFor example:\n\n``` html\n<li v-for=\"n in evenNumbers\">{{ n }}</li>\n```\n\n``` js\ndata: {\n  numbers: [ 1, 2, 3, 4, 5 ]\n},\ncomputed: {\n  evenNumbers: function () {\n    return this.numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\nIn situations where computed properties are not feasible (e.g. inside nested `v-for` loops), you can use a method:\n\n```html\n<ul v-for=\"set in sets\">\n  <li v-for=\"n in even(set)\">{{ n }}</li>\n</ul>\n```\n\n```js\ndata: {\n  sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]\n},\nmethods: {\n  even: function (numbers) {\n    return numbers.filter(function (number) {\n      return number % 2 === 0\n    })\n  }\n}\n```\n\n## `v-for` with a Range\n\n`v-for` can also take an integer. In this case it will repeat the template that many times.\n\n``` html\n<div>\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n```\n\nResult:\n\n{% raw %}\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\n  new Vue({ el: '#range' })\n</script>\n{% endraw %}\n\n## `v-for` on a `<template>`\n\nSimilar to template `v-if`, you can also use a `<template>` tag with `v-for` to render a block of multiple elements. For example:\n\n``` html\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n</ul>\n```\n\n## `v-for` with `v-if`\n\n<p class=\"tip\">Note that it's **not** recommended to use `v-if` and `v-for` together. Refer to [style guide](/v2/style-guide/#Avoid-v-if-with-v-for-essential) for details.</p>\n\nWhen they exist on the same node, `v-for` has a higher priority than `v-if`. That means the `v-if` will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only _some_ items, like below:\n\n``` html\n<li v-for=\"todo in todos\" v-if=\"!todo.isComplete\">\n  {{ todo }}\n</li>\n```\n\nThe above only renders the todos that are not complete.\n\nIf instead, your intent is to conditionally skip execution of the loop, you can place the `v-if` on a wrapper element (or [`<template>`](conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt)). For example:\n\n``` html\n<ul v-if=\"todos.length\">\n  <li v-for=\"todo in todos\">\n    {{ todo }}\n  </li>\n</ul>\n<p v-else>No todos left!</p>\n```\n\n## `v-for` with a Component\n\n> This section assumes knowledge of [Components](components.html). Feel free to skip it and come back later.\n\nYou can directly use `v-for` on a custom component, like any normal element:\n\n``` html\n<my-component v-for=\"item in items\" :key=\"item.id\"></my-component>\n```\n\n> In 2.2.0+, when using `v-for` with a component, a [`key`](list.html#key) is now required.\n\nHowever, this won't automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:\n\n``` html\n<my-component\n  v-for=\"(item, index) in items\"\n  v-bind:item=\"item\"\n  v-bind:index=\"index\"\n  v-bind:key=\"item.id\"\n></my-component>\n```\n\nThe reason for not automatically injecting `item` into the component is because that makes the component tightly coupled to how `v-for` works. Being explicit about where its data comes from makes the component reusable in other situations.\n\nHere's a complete example of a simple todo list:\n\n``` html\n<div id=\"todo-list-example\">\n  <form v-on:submit.prevent=\"addNewTodo\">\n    <label for=\"new-todo\">Add a todo</label>\n    <input\n      v-model=\"newTodoText\"\n      id=\"new-todo\"\n      placeholder=\"E.g. Feed the cat\"\n    >\n    <button>Add</button>\n  </form>\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:key=\"todo.id\"\n      v-bind:title=\"todo.title\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n```\n\n<p class=\"tip\">Note the `is=\"todo-item\"` attribute. This is necessary in DOM templates, because only an `<li>` element is valid inside a `<ul>`. It does the same thing as `<todo-item>`, but works around a potential browser parsing error. See [DOM Template Parsing Caveats](components.html#DOM-Template-Parsing-Caveats) to learn more.</p>\n\n``` js\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      {\n        id: 1,\n        title: 'Do the dishes',\n      },\n      {\n        id: 2,\n        title: 'Take out the trash',\n      },\n      {\n        id: 3,\n        title: 'Mow the lawn'\n      }\n    ],\n    nextTodoId: 4\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push({\n        id: this.nextTodoId++,\n        title: this.newTodoText\n      })\n      this.newTodoText = ''\n    }\n  }\n})\n```\n\n{% raw %}\n<div id=\"todo-list-example\" class=\"demo\">\n  <form v-on:submit.prevent=\"addNewTodo\">\n    <label for=\"new-todo\">Add a todo</label>\n    <input\n      v-model=\"newTodoText\"\n      id=\"new-todo\"\n      placeholder=\"E.g. Feed the cat\"\n    >\n    <button>Add</button>\n  </form>\n  <ul>\n    <li\n      is=\"todo-item\"\n      v-for=\"(todo, index) in todos\"\n      v-bind:key=\"todo.id\"\n      v-bind:title=\"todo.title\"\n      v-on:remove=\"todos.splice(index, 1)\"\n    ></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      {\n        id: 1,\n        title: 'Do the dishes',\n      },\n      {\n        id: 2,\n        title: 'Take out the trash',\n      },\n      {\n        id: 3,\n        title: 'Mow the lawn'\n      }\n    ],\n    nextTodoId: 4\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push({\n        id: this.nextTodoId++,\n        title: this.newTodoText\n      })\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n{% endraw %}\n","date":"2020-09-25T23:55:41.138Z","updated":"2020-09-25T23:55:41.138Z","path":"v2/guide/list.html","comments":1,"layout":"page","_id":"ckfl66gyn002cc2v58bhif7e5","content":"<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-loops?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to render lists on Vue School\">Learn how to render list with a free Vue School lesson</a></div>\n\n\n<h2 id=\"Mapping-an-Array-to-Elements-with-v-for\"><a href=\"#Mapping-an-Array-to-Elements-with-v-for\" class=\"headerlink\" title=\"Mapping an Array to Elements with v-for\"></a>Mapping an Array to Elements with <code>v-for</code></h2><p>We can use the <code>v-for</code> directive to render a list of items based on an array. The <code>v-for</code> directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the source data array and <code>item</code> is an <strong>alias</strong> for the array element being iterated on:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-1\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.message\"</span>&gt;</span>\n    &#123;&#123; item.message &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example1 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-1'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">items</span>: [\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Foo'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Bar'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n\n<p>Inside <code>v-for</code> blocks we have full access to parent scope properties. <code>v-for</code> also supports an optional second argument for the index of the current item.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-2\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>&gt;</span>\n    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example2 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-2'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">parentMessage</span>: <span class=\"hljs-string\">'Parent'</span>,\n    <span class=\"hljs-attr\">items</span>: [\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Foo'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Bar'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n\n<p>You can also use <code>of</code> as the delimiter instead of <code>in</code>, so that it is closer to JavaScript’s syntax for iterators:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item of items\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h2 id=\"v-for-with-an-Object\"><a href=\"#v-for-with-an-Object\" class=\"headerlink\" title=\"v-for with an Object\"></a><code>v-for</code> with an Object</h2><p>You can also use <code>v-for</code> to iterate through the properties of an object.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"v-for-object\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"value in object\"</span>&gt;</span>\n    &#123;&#123; value &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#v-for-object'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">object</span>: &#123;\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'How to do lists in Vue'</span>,\n      <span class=\"hljs-attr\">author</span>: <span class=\"hljs-string\">'Jane Doe'</span>,\n      <span class=\"hljs-attr\">publishedAt</span>: <span class=\"hljs-string\">'2016-04-10'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n\n<p>You can also provide a second argument for the property’s name (a.k.a. key):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(value, name) in object\"</span>&gt;</span>\n  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<div id=\"v-for-object-value-name\" class=\"demo\">\n  <div v-for=\"(value, name) in object\">\n    {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n\n<p>And another for the index:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(value, name, index) in object\"</span>&gt;</span>\n  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<div id=\"v-for-object-value-name-index\" class=\"demo\">\n  <div v-for=\"(value, name, index) in object\">\n    {{ index }}. {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name-index',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n\n<p class=\"tip\">When iterating over an object, the order is based on the enumeration order of <code>Object.keys()</code>, which is <strong>not</strong> guaranteed to be consistent across JavaScript engine implementations.</p>\n\n<h2 id=\"Maintaining-State\"><a href=\"#Maintaining-State\" class=\"headerlink\" title=\"Maintaining State\"></a>Maintaining State</h2><p>When Vue is updating a list of elements rendered with <code>v-for</code>, by default it uses an “in-place patch” strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of <code>track-by=&quot;$index&quot;</code> in Vue 1.x.</p>\n<p>This default mode is efficient, but <strong>only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)</strong>.</p>\n<p>To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique <code>key</code> attribute for each item:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- content --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>It is recommended to provide a <code>key</code> attribute with <code>v-for</code> whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</p>\n<p>Since it’s a generic mechanism for Vue to identify nodes, the <code>key</code> also has other uses that are not specifically tied to <code>v-for</code>, as we will see later in the guide.</p>\n<p class=\"tip\">Don’t use non-primitive values like objects and arrays as <code>v-for</code> keys. Use string or numeric values instead.</p>\n\n<p>For detailed usage of the <code>key</code> attribute, please see the <a href=\"https://vuejs.org/v2/api/#key\"><code>key</code> API documentation</a>.</p>\n<h2 id=\"Array-Change-Detection\"><a href=\"#Array-Change-Detection\" class=\"headerlink\" title=\"Array Change Detection\"></a>Array Change Detection</h2><h3 id=\"Mutation-Methods\"><a href=\"#Mutation-Methods\" class=\"headerlink\" title=\"Mutation Methods\"></a>Mutation Methods</h3><p>Vue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:</p>\n<ul>\n<li><code>push()</code></li>\n<li><code>pop()</code></li>\n<li><code>shift()</code></li>\n<li><code>unshift()</code></li>\n<li><code>splice()</code></li>\n<li><code>sort()</code></li>\n<li><code>reverse()</code></li>\n</ul>\n<p>You can open the console and play with the previous examples’ <code>items</code> array by calling their mutation methods. For example: <code>example1.items.push({ message: &#39;Baz&#39; })</code>.</p>\n<h3 id=\"Replacing-an-Array\"><a href=\"#Replacing-an-Array\" class=\"headerlink\" title=\"Replacing an Array\"></a>Replacing an Array</h3><p>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. <code>filter()</code>, <code>concat()</code> and <code>slice()</code>, which do not mutate the original array but <strong>always return a new array</strong>. When working with non-mutating methods, you can replace the old array with the new one:</p>\n<pre><code class=\"hljs js\">example1.items = example1.items.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> item.message.match(<span class=\"hljs-regexp\">/Foo/</span>)\n&#125;)</code></pre>\n<p>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</p>\n<h3 id=\"Caveats\"><a href=\"#Caveats\" class=\"headerlink\" title=\"Caveats\"></a>Caveats</h3><p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong> with arrays and objects. These are discussed in the <a href=\"reactivity.html#Change-Detection-Caveats\">reactivity</a> section.</p>\n<h2 id=\"Displaying-Filtered-Sorted-Results\"><a href=\"#Displaying-Filtered-Sorted-Results\" class=\"headerlink\" title=\"Displaying Filtered/Sorted Results\"></a>Displaying Filtered/Sorted Results</h2><p>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"n in evenNumbers\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">numbers</span>: [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span> ]\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">evenNumbers</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.numbers.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">number</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> number % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p>In situations where computed properties are not feasible (e.g. inside nested <code>v-for</code> loops), you can use a method:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"set in sets\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"n in even(set)\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">sets</span>: [[ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span> ], [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>]]\n&#125;,\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">even</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">numbers</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> numbers.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">number</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> number % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<h2 id=\"v-for-with-a-Range\"><a href=\"#v-for-with-a-Range\" class=\"headerlink\" title=\"v-for with a Range\"></a><code>v-for</code> with a Range</h2><p><code>v-for</code> can also take an integer. In this case it will repeat the template that many times.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"n in 10\"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Result:</p>\n\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\n  new Vue({ el: '#range' })\n</script>\n\n<h2 id=\"v-for-on-a-lt-template-gt\"><a href=\"#v-for-on-a-lt-template-gt\" class=\"headerlink\" title=\"v-for on a &lt;template&gt;\"></a><code>v-for</code> on a <code>&lt;template&gt;</code></h2><p>Similar to template <code>v-if</code>, you can also use a <code>&lt;template&gt;</code> tag with <code>v-for</code> to render a block of multiple elements. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"divider\"</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"presentation\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<h2 id=\"v-for-with-v-if\"><a href=\"#v-for-with-v-if\" class=\"headerlink\" title=\"v-for with v-if\"></a><code>v-for</code> with <code>v-if</code></h2><p class=\"tip\">Note that it’s <strong>not</strong> recommended to use <code>v-if</code> and <code>v-for</code> together. Refer to <a href=\"/v2/style-guide/#Avoid-v-if-with-v-for-essential\">style guide</a> for details.</p>\n\n<p>When they exist on the same node, <code>v-for</code> has a higher priority than <code>v-if</code>. That means the <code>v-if</code> will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only <em>some</em> items, like below:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"!todo.isComplete\"</span>&gt;</span>\n  &#123;&#123; todo &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></code></pre>\n<p>The above only renders the todos that are not complete.</p>\n<p>If instead, your intent is to conditionally skip execution of the loop, you can place the <code>v-if</code> on a wrapper element (or <a href=\"conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt\"><code>&lt;template&gt;</code></a>). For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"todos.length\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>&gt;</span>\n    &#123;&#123; todo &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>No todos left!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<h2 id=\"v-for-with-a-Component\"><a href=\"#v-for-with-a-Component\" class=\"headerlink\" title=\"v-for with a Component\"></a><code>v-for</code> with a Component</h2><blockquote>\n<p>This section assumes knowledge of <a href=\"components.html\">Components</a>. Feel free to skip it and come back later.</p>\n</blockquote>\n<p>You can directly use <code>v-for</code> on a custom component, like any normal element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<blockquote>\n<p>In 2.2.0+, when using <code>v-for</code> with a component, a <a href=\"list.html#key\"><code>key</code></a> is now required.</p>\n</blockquote>\n<p>However, this won’t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>\n  <span class=\"hljs-attr\">v-bind:item</span>=<span class=\"hljs-string\">\"item\"</span>\n  <span class=\"hljs-attr\">v-bind:index</span>=<span class=\"hljs-string\">\"index\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"item.id\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>The reason for not automatically injecting <code>item</code> into the component is because that makes the component tightly coupled to how <code>v-for</code> works. Being explicit about where its data comes from makes the component reusable in other situations.</p>\n<p>Here’s a complete example of a simple todo list:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"todo-list-example\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>=<span class=\"hljs-string\">\"addNewTodo\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"new-todo\"</span>&gt;</span>Add a todo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"new-todo\"</span>\n      <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"E.g. Feed the cat\"</span>\n    &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>Add<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n      <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"todo-item\"</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(todo, index) in todos\"</span>\n      <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n      <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"todo.title\"</span>\n      <span class=\"hljs-attr\">v-on:remove</span>=<span class=\"hljs-string\">\"todos.splice(index, 1)\"</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Note the <code>is=&quot;todo-item&quot;</code> attribute. This is necessary in DOM templates, because only an <code>&lt;li&gt;</code> element is valid inside a <code>&lt;ul&gt;</code>. It does the same thing as <code>&lt;todo-item&gt;</code>, but works around a potential browser parsing error. See <a href=\"components.html#DOM-Template-Parsing-Caveats\">DOM Template Parsing Caveats</a> to learn more.</p>\n\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo-item'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'\\\n    &lt;li&gt;\\\n      &#123;&#123; title &#125;&#125;\\\n      &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;Remove&lt;/button&gt;\\\n    &lt;/li&gt;\\\n  '</span>,\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'title'</span>]\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#todo-list-example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">newTodoText</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">todos</span>: [\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Do the dishes'</span>,\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Take out the trash'</span>,\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Mow the lawn'</span>\n      &#125;\n    ],\n    <span class=\"hljs-attr\">nextTodoId</span>: <span class=\"hljs-number\">4</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">addNewTodo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.todos.push(&#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-keyword\">this</span>.nextTodoId++,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-keyword\">this</span>.newTodoText\n      &#125;)\n      <span class=\"hljs-keyword\">this</span>.newTodoText = <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"todo-list-example\" class=\"demo\">\n  <form v-on:submit.prevent=\"addNewTodo\">\n    <label for=\"new-todo\">Add a todo</label>\n    <input v-model=\"newTodoText\" id=\"new-todo\" placeholder=\"E.g. Feed the cat\">\n    <button>Add</button>\n  </form>\n  <ul>\n    <li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\"></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      {\n        id: 1,\n        title: 'Do the dishes',\n      },\n      {\n        id: 2,\n        title: 'Take out the trash',\n      },\n      {\n        id: 3,\n        title: 'Mow the lawn'\n      }\n    ],\n    nextTodoId: 4\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push({\n        id: this.nextTodoId++,\n        title: this.newTodoText\n      })\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n\n","site":{"data":{}},"excerpt":"","more":"<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/vuejs-loops?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Learn how to render lists on Vue School\">Learn how to render list with a free Vue School lesson</a></div>\n\n\n<h2 id=\"Mapping-an-Array-to-Elements-with-v-for\"><a href=\"#Mapping-an-Array-to-Elements-with-v-for\" class=\"headerlink\" title=\"Mapping an Array to Elements with v-for\"></a>Mapping an Array to Elements with <code>v-for</code></h2><p>We can use the <code>v-for</code> directive to render a list of items based on an array. The <code>v-for</code> directive requires a special syntax in the form of <code>item in items</code>, where <code>items</code> is the source data array and <code>item</code> is an <strong>alias</strong> for the array element being iterated on:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-1\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.message\"</span>&gt;</span>\n    &#123;&#123; item.message &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example1 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-1'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">items</span>: [\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Foo'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Bar'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<ul id=\"example-1\" class=\"demo\">\n  <li v-for=\"item in items\" :key=\"item.message\">\n    {{item.message}}\n  </li>\n</ul>\n<script>\nvar example1 = new Vue({\n  el: '#example-1',\n  data: {\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n\n<p>Inside <code>v-for</code> blocks we have full access to parent scope properties. <code>v-for</code> also supports an optional second argument for the index of the current item.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example-2\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>&gt;</span>\n    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> example2 = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example-2'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">parentMessage</span>: <span class=\"hljs-string\">'Parent'</span>,\n    <span class=\"hljs-attr\">items</span>: [\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Foo'</span> &#125;,\n      &#123; <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Bar'</span> &#125;\n    ]\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<ul id=\"example-2\" class=\"demo\">\n  <li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n  </li>\n</ul>\n<script>\nvar example2 = new Vue({\n  el: '#example-2',\n  data: {\n    parentMessage: 'Parent',\n    items: [\n      { message: 'Foo' },\n      { message: 'Bar' }\n    ]\n  }\n})\n</script>\n\n<p>You can also use <code>of</code> as the delimiter instead of <code>in</code>, so that it is closer to JavaScript’s syntax for iterators:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item of items\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<h2 id=\"v-for-with-an-Object\"><a href=\"#v-for-with-an-Object\" class=\"headerlink\" title=\"v-for with an Object\"></a><code>v-for</code> with an Object</h2><p>You can also use <code>v-for</code> to iterate through the properties of an object.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"v-for-object\"</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"value in object\"</span>&gt;</span>\n    &#123;&#123; value &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#v-for-object'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">object</span>: &#123;\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'How to do lists in Vue'</span>,\n      <span class=\"hljs-attr\">author</span>: <span class=\"hljs-string\">'Jane Doe'</span>,\n      <span class=\"hljs-attr\">publishedAt</span>: <span class=\"hljs-string\">'2016-04-10'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Result:</p>\n\n<ul id=\"v-for-object\" class=\"demo\">\n  <li v-for=\"value in object\">\n    {{ value }}\n  </li>\n</ul>\n<script>\nnew Vue({\n  el: '#v-for-object',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n\n<p>You can also provide a second argument for the property’s name (a.k.a. key):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(value, name) in object\"</span>&gt;</span>\n  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<div id=\"v-for-object-value-name\" class=\"demo\">\n  <div v-for=\"(value, name) in object\">\n    {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n\n<p>And another for the index:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(value, name, index) in object\"</span>&gt;</span>\n  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n\n<div id=\"v-for-object-value-name-index\" class=\"demo\">\n  <div v-for=\"(value, name, index) in object\">\n    {{ index }}. {{ name }}: {{ value }}\n  </div>\n</div>\n<script>\nnew Vue({\n  el: '#v-for-object-value-name-index',\n  data: {\n    object: {\n      title: 'How to do lists in Vue',\n      author: 'Jane Doe',\n      publishedAt: '2016-04-10'\n    }\n  }\n})\n</script>\n\n<p class=\"tip\">When iterating over an object, the order is based on the enumeration order of <code>Object.keys()</code>, which is <strong>not</strong> guaranteed to be consistent across JavaScript engine implementations.</p>\n\n<h2 id=\"Maintaining-State\"><a href=\"#Maintaining-State\" class=\"headerlink\" title=\"Maintaining State\"></a>Maintaining State</h2><p>When Vue is updating a list of elements rendered with <code>v-for</code>, by default it uses an “in-place patch” strategy. If the order of the data items has changed, instead of moving the DOM elements to match the order of the items, Vue will patch each element in-place and make sure it reflects what should be rendered at that particular index. This is similar to the behavior of <code>track-by=&quot;$index&quot;</code> in Vue 1.x.</p>\n<p>This default mode is efficient, but <strong>only suitable when your list render output does not rely on child component state or temporary DOM state (e.g. form input values)</strong>.</p>\n<p>To give Vue a hint so that it can track each node’s identity, and thus reuse and reorder existing elements, you need to provide a unique <code>key</code> attribute for each item:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n  <span class=\"hljs-comment\">&lt;!-- content --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>It is recommended to provide a <code>key</code> attribute with <code>v-for</code> whenever possible, unless the iterated DOM content is simple, or you are intentionally relying on the default behavior for performance gains.</p>\n<p>Since it’s a generic mechanism for Vue to identify nodes, the <code>key</code> also has other uses that are not specifically tied to <code>v-for</code>, as we will see later in the guide.</p>\n<p class=\"tip\">Don’t use non-primitive values like objects and arrays as <code>v-for</code> keys. Use string or numeric values instead.</p>\n\n<p>For detailed usage of the <code>key</code> attribute, please see the <a href=\"https://vuejs.org/v2/api/#key\"><code>key</code> API documentation</a>.</p>\n<h2 id=\"Array-Change-Detection\"><a href=\"#Array-Change-Detection\" class=\"headerlink\" title=\"Array Change Detection\"></a>Array Change Detection</h2><h3 id=\"Mutation-Methods\"><a href=\"#Mutation-Methods\" class=\"headerlink\" title=\"Mutation Methods\"></a>Mutation Methods</h3><p>Vue wraps an observed array’s mutation methods so they will also trigger view updates. The wrapped methods are:</p>\n<ul>\n<li><code>push()</code></li>\n<li><code>pop()</code></li>\n<li><code>shift()</code></li>\n<li><code>unshift()</code></li>\n<li><code>splice()</code></li>\n<li><code>sort()</code></li>\n<li><code>reverse()</code></li>\n</ul>\n<p>You can open the console and play with the previous examples’ <code>items</code> array by calling their mutation methods. For example: <code>example1.items.push({ message: &#39;Baz&#39; })</code>.</p>\n<h3 id=\"Replacing-an-Array\"><a href=\"#Replacing-an-Array\" class=\"headerlink\" title=\"Replacing an Array\"></a>Replacing an Array</h3><p>Mutation methods, as the name suggests, mutate the original array they are called on. In comparison, there are also non-mutating methods, e.g. <code>filter()</code>, <code>concat()</code> and <code>slice()</code>, which do not mutate the original array but <strong>always return a new array</strong>. When working with non-mutating methods, you can replace the old array with the new one:</p>\n<pre><code class=\"hljs js\">example1.items = example1.items.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> item.message.match(<span class=\"hljs-regexp\">/Foo/</span>)\n&#125;)</code></pre>\n<p>You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.</p>\n<h3 id=\"Caveats\"><a href=\"#Caveats\" class=\"headerlink\" title=\"Caveats\"></a>Caveats</h3><p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong> with arrays and objects. These are discussed in the <a href=\"reactivity.html#Change-Detection-Caveats\">reactivity</a> section.</p>\n<h2 id=\"Displaying-Filtered-Sorted-Results\"><a href=\"#Displaying-Filtered-Sorted-Results\" class=\"headerlink\" title=\"Displaying Filtered/Sorted Results\"></a>Displaying Filtered/Sorted Results</h2><p>Sometimes we want to display a filtered or sorted version of an array without actually mutating or resetting the original data. In this case, you can create a computed property that returns the filtered or sorted array.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"n in evenNumbers\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">numbers</span>: [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span> ]\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">evenNumbers</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.numbers.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">number</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> number % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<p>In situations where computed properties are not feasible (e.g. inside nested <code>v-for</code> loops), you can use a method:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"set in sets\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"n in even(set)\"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">sets</span>: [[ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span> ], [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>]]\n&#125;,\n<span class=\"hljs-attr\">methods</span>: &#123;\n  <span class=\"hljs-attr\">even</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">numbers</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> numbers.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">number</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> number % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<h2 id=\"v-for-with-a-Range\"><a href=\"#v-for-with-a-Range\" class=\"headerlink\" title=\"v-for with a Range\"></a><code>v-for</code> with a Range</h2><p><code>v-for</code> can also take an integer. In this case it will repeat the template that many times.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"n in 10\"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Result:</p>\n\n<div id=\"range\" class=\"demo\">\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n<script>\n  new Vue({ el: '#range' })\n</script>\n\n<h2 id=\"v-for-on-a-lt-template-gt\"><a href=\"#v-for-on-a-lt-template-gt\" class=\"headerlink\" title=\"v-for on a &lt;template&gt;\"></a><code>v-for</code> on a <code>&lt;template&gt;</code></h2><p>Similar to template <code>v-if</code>, you can also use a <code>&lt;template&gt;</code> tag with <code>v-for</code> to render a block of multiple elements. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"divider\"</span> <span class=\"hljs-attr\">role</span>=<span class=\"hljs-string\">\"presentation\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<h2 id=\"v-for-with-v-if\"><a href=\"#v-for-with-v-if\" class=\"headerlink\" title=\"v-for with v-if\"></a><code>v-for</code> with <code>v-if</code></h2><p class=\"tip\">Note that it’s <strong>not</strong> recommended to use <code>v-if</code> and <code>v-for</code> together. Refer to <a href=\"/v2/style-guide/#Avoid-v-if-with-v-for-essential\">style guide</a> for details.</p>\n\n<p>When they exist on the same node, <code>v-for</code> has a higher priority than <code>v-if</code>. That means the <code>v-if</code> will be run on each iteration of the loop separately. This can be useful when you want to render nodes for only <em>some</em> items, like below:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"!todo.isComplete\"</span>&gt;</span>\n  &#123;&#123; todo &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span></code></pre>\n<p>The above only renders the todos that are not complete.</p>\n<p>If instead, your intent is to conditionally skip execution of the loop, you can place the <code>v-if</code> on a wrapper element (or <a href=\"conditional.html#Conditional-Groups-with-v-if-on-lt-template-gt\"><code>&lt;template&gt;</code></a>). For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"todos.length\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>&gt;</span>\n    &#123;&#123; todo &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>No todos left!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<h2 id=\"v-for-with-a-Component\"><a href=\"#v-for-with-a-Component\" class=\"headerlink\" title=\"v-for with a Component\"></a><code>v-for</code> with a Component</h2><blockquote>\n<p>This section assumes knowledge of <a href=\"components.html\">Components</a>. Feel free to skip it and come back later.</p>\n</blockquote>\n<p>You can directly use <code>v-for</code> on a custom component, like any normal element:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<blockquote>\n<p>In 2.2.0+, when using <code>v-for</code> with a component, a <a href=\"list.html#key\"><code>key</code></a> is now required.</p>\n</blockquote>\n<p>However, this won’t automatically pass any data to the component, because components have isolated scopes of their own. In order to pass the iterated data into the component, we should also use props:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>\n  <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>\n  <span class=\"hljs-attr\">v-bind:item</span>=<span class=\"hljs-string\">\"item\"</span>\n  <span class=\"hljs-attr\">v-bind:index</span>=<span class=\"hljs-string\">\"index\"</span>\n  <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"item.id\"</span>\n&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>The reason for not automatically injecting <code>item</code> into the component is because that makes the component tightly coupled to how <code>v-for</code> works. Being explicit about where its data comes from makes the component reusable in other situations.</p>\n<p>Here’s a complete example of a simple todo list:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"todo-list-example\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>=<span class=\"hljs-string\">\"addNewTodo\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">\"new-todo\"</span>&gt;</span>Add a todo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n      <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n      <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"new-todo\"</span>\n      <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">\"E.g. Feed the cat\"</span>\n    &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>Add<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n      <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"todo-item\"</span>\n      <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(todo, index) in todos\"</span>\n      <span class=\"hljs-attr\">v-bind:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n      <span class=\"hljs-attr\">v-bind:title</span>=<span class=\"hljs-string\">\"todo.title\"</span>\n      <span class=\"hljs-attr\">v-on:remove</span>=<span class=\"hljs-string\">\"todos.splice(index, 1)\"</span>\n    &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p class=\"tip\">Note the <code>is=&quot;todo-item&quot;</code> attribute. This is necessary in DOM templates, because only an <code>&lt;li&gt;</code> element is valid inside a <code>&lt;ul&gt;</code>. It does the same thing as <code>&lt;todo-item&gt;</code>, but works around a potential browser parsing error. See <a href=\"components.html#DOM-Template-Parsing-Caveats\">DOM Template Parsing Caveats</a> to learn more.</p>\n\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo-item'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'\\\n    &lt;li&gt;\\\n      &#123;&#123; title &#125;&#125;\\\n      &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;Remove&lt;/button&gt;\\\n    &lt;/li&gt;\\\n  '</span>,\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'title'</span>]\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#todo-list-example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">newTodoText</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">todos</span>: [\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Do the dishes'</span>,\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Take out the trash'</span>,\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Mow the lawn'</span>\n      &#125;\n    ],\n    <span class=\"hljs-attr\">nextTodoId</span>: <span class=\"hljs-number\">4</span>\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">addNewTodo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.todos.push(&#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-keyword\">this</span>.nextTodoId++,\n        <span class=\"hljs-attr\">title</span>: <span class=\"hljs-keyword\">this</span>.newTodoText\n      &#125;)\n      <span class=\"hljs-keyword\">this</span>.newTodoText = <span class=\"hljs-string\">''</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n<div id=\"todo-list-example\" class=\"demo\">\n  <form v-on:submit.prevent=\"addNewTodo\">\n    <label for=\"new-todo\">Add a todo</label>\n    <input v-model=\"newTodoText\" id=\"new-todo\" placeholder=\"E.g. Feed the cat\">\n    <button>Add</button>\n  </form>\n  <ul>\n    <li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\"></li>\n  </ul>\n</div>\n<script>\nVue.component('todo-item', {\n  template: '\\\n    <li>\\\n      {{ title }}\\\n      <button v-on:click=\"$emit(\\'remove\\')\">Remove</button>\\\n    </li>\\\n  ',\n  props: ['title']\n})\n\nnew Vue({\n  el: '#todo-list-example',\n  data: {\n    newTodoText: '',\n    todos: [\n      {\n        id: 1,\n        title: 'Do the dishes',\n      },\n      {\n        id: 2,\n        title: 'Take out the trash',\n      },\n      {\n        id: 3,\n        title: 'Mow the lawn'\n      }\n    ],\n    nextTodoId: 4\n  },\n  methods: {\n    addNewTodo: function () {\n      this.todos.push({\n        id: this.nextTodoId++,\n        title: this.newTodoText\n      })\n      this.newTodoText = ''\n    }\n  }\n})\n</script>\n\n"},{"title":"Mixins","type":"guide","order":301,"_content":"\n## Basics\n\nMixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be \"mixed\" into the component's own options.\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/next-level-vue/mixins\" target=\"_blank\" rel=\"noopener\" title=\"Mixins Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\nExample:\n\n``` js\n// define a mixin object\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n// define a component that uses this mixin\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // => \"hello from mixin!\"\n```\n\n## Option Merging\n\nWhen a mixin and the component itself contain overlapping options, they will be \"merged\" using appropriate strategies.\n\nFor example, data objects undergo a recursive merge, with the component's data taking priority in cases of conflicts.\n\n``` js\nvar mixin = {\n  data: function () {\n    return {\n      message: 'hello',\n      foo: 'abc'\n    }\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  data: function () {\n    return {\n      message: 'goodbye',\n      bar: 'def'\n    }\n  },\n  created: function () {\n    console.log(this.$data)\n    // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" }\n  }\n})\n```\n\nHook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called **before** the component's own hooks.\n\n``` js\nvar mixin = {\n  created: function () {\n    console.log('mixin hook called')\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  created: function () {\n    console.log('component hook called')\n  }\n})\n\n// => \"mixin hook called\"\n// => \"component hook called\"\n```\n\nOptions that expect object values, for example `methods`, `components` and `directives`, will be merged into the same object. The component's options will take priority when there are conflicting keys in these objects:\n\n``` js\nvar mixin = {\n  methods: {\n    foo: function () {\n      console.log('foo')\n    },\n    conflicting: function () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log('bar')\n    },\n    conflicting: function () {\n      console.log('from self')\n    }\n  }\n})\n\nvm.foo() // => \"foo\"\nvm.bar() // => \"bar\"\nvm.conflicting() // => \"from self\"\n```\n\nNote that the same merge strategies are used in `Vue.extend()`.\n\n## Global Mixin\n\nYou can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect **every** Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:\n\n``` js\n// inject a handler for `myOption` custom option\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: 'hello!'\n})\n// => \"hello!\"\n```\n\n<p class=\"tip\">Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It's also a good idea to ship them as [Plugins](plugins.html) to avoid duplicate application.</p>\n\n## Custom Option Merge Strategies\n\nWhen custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to `Vue.config.optionMergeStrategies`:\n\n``` js\nVue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n  // return mergedVal\n}\n```\n\nFor most object-based options, you can use the same strategy used by `methods`:\n\n``` js\nvar strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods\n```\n\nA more advanced example can be found on [Vuex](https://github.com/vuejs/vuex)'s 1.x merging strategy:\n\n``` js\nconst merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n  if (!toVal) return fromVal\n  if (!fromVal) return toVal\n  return {\n    getters: merge(toVal.getters, fromVal.getters),\n    state: merge(toVal.state, fromVal.state),\n    actions: merge(toVal.actions, fromVal.actions)\n  }\n}\n```\n","source":"v2/guide/mixins.md","raw":"---\ntitle: Mixins\ntype: guide\norder: 301\n---\n\n## Basics\n\nMixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be \"mixed\" into the component's own options.\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/next-level-vue/mixins\" target=\"_blank\" rel=\"noopener\" title=\"Mixins Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\nExample:\n\n``` js\n// define a mixin object\nvar myMixin = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log('hello from mixin!')\n    }\n  }\n}\n\n// define a component that uses this mixin\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\n\nvar component = new Component() // => \"hello from mixin!\"\n```\n\n## Option Merging\n\nWhen a mixin and the component itself contain overlapping options, they will be \"merged\" using appropriate strategies.\n\nFor example, data objects undergo a recursive merge, with the component's data taking priority in cases of conflicts.\n\n``` js\nvar mixin = {\n  data: function () {\n    return {\n      message: 'hello',\n      foo: 'abc'\n    }\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  data: function () {\n    return {\n      message: 'goodbye',\n      bar: 'def'\n    }\n  },\n  created: function () {\n    console.log(this.$data)\n    // => { message: \"goodbye\", foo: \"abc\", bar: \"def\" }\n  }\n})\n```\n\nHook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called **before** the component's own hooks.\n\n``` js\nvar mixin = {\n  created: function () {\n    console.log('mixin hook called')\n  }\n}\n\nnew Vue({\n  mixins: [mixin],\n  created: function () {\n    console.log('component hook called')\n  }\n})\n\n// => \"mixin hook called\"\n// => \"component hook called\"\n```\n\nOptions that expect object values, for example `methods`, `components` and `directives`, will be merged into the same object. The component's options will take priority when there are conflicting keys in these objects:\n\n``` js\nvar mixin = {\n  methods: {\n    foo: function () {\n      console.log('foo')\n    },\n    conflicting: function () {\n      console.log('from mixin')\n    }\n  }\n}\n\nvar vm = new Vue({\n  mixins: [mixin],\n  methods: {\n    bar: function () {\n      console.log('bar')\n    },\n    conflicting: function () {\n      console.log('from self')\n    }\n  }\n})\n\nvm.foo() // => \"foo\"\nvm.bar() // => \"bar\"\nvm.conflicting() // => \"from self\"\n```\n\nNote that the same merge strategies are used in `Vue.extend()`.\n\n## Global Mixin\n\nYou can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect **every** Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:\n\n``` js\n// inject a handler for `myOption` custom option\nVue.mixin({\n  created: function () {\n    var myOption = this.$options.myOption\n    if (myOption) {\n      console.log(myOption)\n    }\n  }\n})\n\nnew Vue({\n  myOption: 'hello!'\n})\n// => \"hello!\"\n```\n\n<p class=\"tip\">Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It's also a good idea to ship them as [Plugins](plugins.html) to avoid duplicate application.</p>\n\n## Custom Option Merge Strategies\n\nWhen custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to `Vue.config.optionMergeStrategies`:\n\n``` js\nVue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {\n  // return mergedVal\n}\n```\n\nFor most object-based options, you can use the same strategy used by `methods`:\n\n``` js\nvar strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods\n```\n\nA more advanced example can be found on [Vuex](https://github.com/vuejs/vuex)'s 1.x merging strategy:\n\n``` js\nconst merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {\n  if (!toVal) return fromVal\n  if (!fromVal) return toVal\n  return {\n    getters: merge(toVal.getters, fromVal.getters),\n    state: merge(toVal.state, fromVal.state),\n    actions: merge(toVal.actions, fromVal.actions)\n  }\n}\n```\n","date":"2020-09-25T23:55:41.138Z","updated":"2020-09-25T23:55:41.138Z","path":"v2/guide/mixins.html","comments":1,"layout":"page","_id":"ckfl66gyn002dc2v5qjb7w6fx","content":"<h2 id=\"Basics\"><a href=\"#Basics\" class=\"headerlink\" title=\"Basics\"></a>Basics</h2><p>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be “mixed” into the component’s own options.</p>\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/next-level-vue/mixins\" target=\"_blank\" rel=\"noopener\" title=\"Mixins Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\n<p>Example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// define a mixin object</span>\n<span class=\"hljs-keyword\">var</span> myMixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.hello()\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">hello</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello from mixin!'</span>)\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-comment\">// define a component that uses this mixin</span>\n<span class=\"hljs-keyword\">var</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [myMixin]\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> component = <span class=\"hljs-keyword\">new</span> Component() <span class=\"hljs-comment\">// =&gt; \"hello from mixin!\"</span></code></pre>\n<h2 id=\"Option-Merging\"><a href=\"#Option-Merging\" class=\"headerlink\" title=\"Option Merging\"></a>Option Merging</h2><p>When a mixin and the component itself contain overlapping options, they will be “merged” using appropriate strategies.</p>\n<p>For example, data objects undergo a recursive merge, with the component’s data taking priority in cases of conflicts.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'hello'</span>,\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'abc'</span>\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [mixin],\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'goodbye'</span>,\n      <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">'def'</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$data)\n    <span class=\"hljs-comment\">// =&gt; &#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125;</span>\n  &#125;\n&#125;)</code></pre>\n<p>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called <strong>before</strong> the component’s own hooks.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'mixin hook called'</span>)\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [mixin],\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'component hook called'</span>)\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// =&gt; \"mixin hook called\"</span>\n<span class=\"hljs-comment\">// =&gt; \"component hook called\"</span></code></pre>\n<p>Options that expect object values, for example <code>methods</code>, <code>components</code> and <code>directives</code>, will be merged into the same object. The component’s options will take priority when there are conflicting keys in these objects:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'foo'</span>)\n    &#125;,\n    <span class=\"hljs-attr\">conflicting</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'from mixin'</span>)\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [mixin],\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'bar'</span>)\n    &#125;,\n    <span class=\"hljs-attr\">conflicting</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'from self'</span>)\n    &#125;\n  &#125;\n&#125;)\n\nvm.foo() <span class=\"hljs-comment\">// =&gt; \"foo\"</span>\nvm.bar() <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\nvm.conflicting() <span class=\"hljs-comment\">// =&gt; \"from self\"</span></code></pre>\n<p>Note that the same merge strategies are used in <code>Vue.extend()</code>.</p>\n<h2 id=\"Global-Mixin\"><a href=\"#Global-Mixin\" class=\"headerlink\" title=\"Global Mixin\"></a>Global Mixin</h2><p>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect <strong>every</strong> Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// inject a handler for `myOption` custom option</span>\nVue.mixin(&#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> myOption = <span class=\"hljs-keyword\">this</span>.$options.myOption\n    <span class=\"hljs-keyword\">if</span> (myOption) &#123;\n      <span class=\"hljs-built_in\">console</span>.log(myOption)\n    &#125;\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">myOption</span>: <span class=\"hljs-string\">'hello!'</span>\n&#125;)\n<span class=\"hljs-comment\">// =&gt; \"hello!\"</span></code></pre>\n<p class=\"tip\">Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It’s also a good idea to ship them as <a href=\"plugins.html\">Plugins</a> to avoid duplicate application.</p>\n\n<h2 id=\"Custom-Option-Merge-Strategies\"><a href=\"#Custom-Option-Merge-Strategies\" class=\"headerlink\" title=\"Custom Option Merge Strategies\"></a>Custom Option Merge Strategies</h2><p>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to <code>Vue.config.optionMergeStrategies</code>:</p>\n<pre><code class=\"hljs js\">Vue.config.optionMergeStrategies.myOption = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">toVal, fromVal</span>) </span>&#123;\n  <span class=\"hljs-comment\">// return mergedVal</span>\n&#125;</code></pre>\n<p>For most object-based options, you can use the same strategy used by <code>methods</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods</code></pre>\n<p>A more advanced example can be found on <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a>‘s 1.x merging strategy:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">toVal, fromVal</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (!toVal) <span class=\"hljs-keyword\">return</span> fromVal\n  <span class=\"hljs-keyword\">if</span> (!fromVal) <span class=\"hljs-keyword\">return</span> toVal\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">getters</span>: merge(toVal.getters, fromVal.getters),\n    <span class=\"hljs-attr\">state</span>: merge(toVal.state, fromVal.state),\n    <span class=\"hljs-attr\">actions</span>: merge(toVal.actions, fromVal.actions)\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Basics\"><a href=\"#Basics\" class=\"headerlink\" title=\"Basics\"></a>Basics</h2><p>Mixins are a flexible way to distribute reusable functionalities for Vue components. A mixin object can contain any component options. When a component uses a mixin, all options in the mixin will be “mixed” into the component’s own options.</p>\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/next-level-vue/mixins\" target=\"_blank\" rel=\"noopener\" title=\"Mixins Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\n<p>Example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// define a mixin object</span>\n<span class=\"hljs-keyword\">var</span> myMixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.hello()\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">hello</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'hello from mixin!'</span>)\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-comment\">// define a component that uses this mixin</span>\n<span class=\"hljs-keyword\">var</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [myMixin]\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> component = <span class=\"hljs-keyword\">new</span> Component() <span class=\"hljs-comment\">// =&gt; \"hello from mixin!\"</span></code></pre>\n<h2 id=\"Option-Merging\"><a href=\"#Option-Merging\" class=\"headerlink\" title=\"Option Merging\"></a>Option Merging</h2><p>When a mixin and the component itself contain overlapping options, they will be “merged” using appropriate strategies.</p>\n<p>For example, data objects undergo a recursive merge, with the component’s data taking priority in cases of conflicts.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'hello'</span>,\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'abc'</span>\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [mixin],\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'goodbye'</span>,\n      <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-string\">'def'</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$data)\n    <span class=\"hljs-comment\">// =&gt; &#123; message: \"goodbye\", foo: \"abc\", bar: \"def\" &#125;</span>\n  &#125;\n&#125;)</code></pre>\n<p>Hook functions with the same name are merged into an array so that all of them will be called. Mixin hooks will be called <strong>before</strong> the component’s own hooks.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'mixin hook called'</span>)\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [mixin],\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'component hook called'</span>)\n  &#125;\n&#125;)\n\n<span class=\"hljs-comment\">// =&gt; \"mixin hook called\"</span>\n<span class=\"hljs-comment\">// =&gt; \"component hook called\"</span></code></pre>\n<p>Options that expect object values, for example <code>methods</code>, <code>components</code> and <code>directives</code>, will be merged into the same object. The component’s options will take priority when there are conflicting keys in these objects:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'foo'</span>)\n    &#125;,\n    <span class=\"hljs-attr\">conflicting</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'from mixin'</span>)\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">mixins</span>: [mixin],\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'bar'</span>)\n    &#125;,\n    <span class=\"hljs-attr\">conflicting</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'from self'</span>)\n    &#125;\n  &#125;\n&#125;)\n\nvm.foo() <span class=\"hljs-comment\">// =&gt; \"foo\"</span>\nvm.bar() <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\nvm.conflicting() <span class=\"hljs-comment\">// =&gt; \"from self\"</span></code></pre>\n<p>Note that the same merge strategies are used in <code>Vue.extend()</code>.</p>\n<h2 id=\"Global-Mixin\"><a href=\"#Global-Mixin\" class=\"headerlink\" title=\"Global Mixin\"></a>Global Mixin</h2><p>You can also apply a mixin globally. Use with caution! Once you apply a mixin globally, it will affect <strong>every</strong> Vue instance created afterwards. When used properly, this can be used to inject processing logic for custom options:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// inject a handler for `myOption` custom option</span>\nVue.mixin(&#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> myOption = <span class=\"hljs-keyword\">this</span>.$options.myOption\n    <span class=\"hljs-keyword\">if</span> (myOption) &#123;\n      <span class=\"hljs-built_in\">console</span>.log(myOption)\n    &#125;\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">myOption</span>: <span class=\"hljs-string\">'hello!'</span>\n&#125;)\n<span class=\"hljs-comment\">// =&gt; \"hello!\"</span></code></pre>\n<p class=\"tip\">Use global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components. In most cases, you should only use it for custom option handling like demonstrated in the example above. It’s also a good idea to ship them as <a href=\"plugins.html\">Plugins</a> to avoid duplicate application.</p>\n\n<h2 id=\"Custom-Option-Merge-Strategies\"><a href=\"#Custom-Option-Merge-Strategies\" class=\"headerlink\" title=\"Custom Option Merge Strategies\"></a>Custom Option Merge Strategies</h2><p>When custom options are merged, they use the default strategy which overwrites the existing value. If you want a custom option to be merged using custom logic, you need to attach a function to <code>Vue.config.optionMergeStrategies</code>:</p>\n<pre><code class=\"hljs js\">Vue.config.optionMergeStrategies.myOption = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">toVal, fromVal</span>) </span>&#123;\n  <span class=\"hljs-comment\">// return mergedVal</span>\n&#125;</code></pre>\n<p>For most object-based options, you can use the same strategy used by <code>methods</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> strategies = Vue.config.optionMergeStrategies\nstrategies.myOption = strategies.methods</code></pre>\n<p>A more advanced example can be found on <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a>‘s 1.x merging strategy:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">toVal, fromVal</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (!toVal) <span class=\"hljs-keyword\">return</span> fromVal\n  <span class=\"hljs-keyword\">if</span> (!fromVal) <span class=\"hljs-keyword\">return</span> toVal\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">getters</span>: merge(toVal.getters, fromVal.getters),\n    <span class=\"hljs-attr\">state</span>: merge(toVal.state, fromVal.state),\n    <span class=\"hljs-attr\">actions</span>: merge(toVal.actions, fromVal.actions)\n  &#125;\n&#125;</code></pre>\n"},{"title":"Plugins","type":"guide","order":304,"_content":"\nPlugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:\n\n1. Add some global methods or properties. e.g. [vue-custom-element](https://github.com/karol-f/vue-custom-element)\n\n2. Add one or more global assets: directives/filters/transitions etc. e.g. [vue-touch](https://github.com/vuejs/vue-touch)\n\n3. Add some component options by global mixin. e.g. [vue-router](https://github.com/vuejs/vue-router)\n\n4. Add some Vue instance methods by attaching them to Vue.prototype.\n\n5. A library that provides an API of its own, while at the same time injecting some combination of the above. e.g. [vue-router](https://github.com/vuejs/vue-router)\n\n## Using a Plugin\n\nUse plugins by calling the `Vue.use()` global method. This has to be done before you start your app by calling `new Vue()`:\n\n``` js\n// calls `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n\nnew Vue({\n  //... options\n})\n```\n\nYou can optionally pass in some options:\n\n``` js\nVue.use(MyPlugin, { someOption: true })\n```\n\n`Vue.use` automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.\n\nSome plugins provided by Vue.js official plugins such as `vue-router` automatically calls `Vue.use()` if `Vue` is available as a global variable. However in a module environment such as CommonJS, you always need to call `Vue.use()` explicitly:\n\n``` js\n// When using CommonJS via Browserify or Webpack\nvar Vue = require('vue')\nvar VueRouter = require('vue-router')\n\n// Don't forget to call this\nVue.use(VueRouter)\n```\n\nCheckout [awesome-vue](https://github.com/vuejs/awesome-vue#components--libraries) for a huge collection of community-contributed plugins and libraries.\n\n## Writing a Plugin\n\nA Vue.js plugin should expose an `install` method. The method will be called with the `Vue` constructor as the first argument, along with possible options:\n\n``` js\nMyPlugin.install = function (Vue, options) {\n  // 1. add global method or property\n  Vue.myGlobalMethod = function () {\n    // some logic ...\n  }\n\n  // 2. add a global asset\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // some logic ...\n    }\n    ...\n  })\n\n  // 3. inject some component options\n  Vue.mixin({\n    created: function () {\n      // some logic ...\n    }\n    ...\n  })\n\n  // 4. add an instance method\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // some logic ...\n  }\n}\n```\n","source":"v2/guide/plugins.md","raw":"---\ntitle: Plugins\ntype: guide\norder: 304\n---\n\nPlugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:\n\n1. Add some global methods or properties. e.g. [vue-custom-element](https://github.com/karol-f/vue-custom-element)\n\n2. Add one or more global assets: directives/filters/transitions etc. e.g. [vue-touch](https://github.com/vuejs/vue-touch)\n\n3. Add some component options by global mixin. e.g. [vue-router](https://github.com/vuejs/vue-router)\n\n4. Add some Vue instance methods by attaching them to Vue.prototype.\n\n5. A library that provides an API of its own, while at the same time injecting some combination of the above. e.g. [vue-router](https://github.com/vuejs/vue-router)\n\n## Using a Plugin\n\nUse plugins by calling the `Vue.use()` global method. This has to be done before you start your app by calling `new Vue()`:\n\n``` js\n// calls `MyPlugin.install(Vue)`\nVue.use(MyPlugin)\n\nnew Vue({\n  //... options\n})\n```\n\nYou can optionally pass in some options:\n\n``` js\nVue.use(MyPlugin, { someOption: true })\n```\n\n`Vue.use` automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.\n\nSome plugins provided by Vue.js official plugins such as `vue-router` automatically calls `Vue.use()` if `Vue` is available as a global variable. However in a module environment such as CommonJS, you always need to call `Vue.use()` explicitly:\n\n``` js\n// When using CommonJS via Browserify or Webpack\nvar Vue = require('vue')\nvar VueRouter = require('vue-router')\n\n// Don't forget to call this\nVue.use(VueRouter)\n```\n\nCheckout [awesome-vue](https://github.com/vuejs/awesome-vue#components--libraries) for a huge collection of community-contributed plugins and libraries.\n\n## Writing a Plugin\n\nA Vue.js plugin should expose an `install` method. The method will be called with the `Vue` constructor as the first argument, along with possible options:\n\n``` js\nMyPlugin.install = function (Vue, options) {\n  // 1. add global method or property\n  Vue.myGlobalMethod = function () {\n    // some logic ...\n  }\n\n  // 2. add a global asset\n  Vue.directive('my-directive', {\n    bind (el, binding, vnode, oldVnode) {\n      // some logic ...\n    }\n    ...\n  })\n\n  // 3. inject some component options\n  Vue.mixin({\n    created: function () {\n      // some logic ...\n    }\n    ...\n  })\n\n  // 4. add an instance method\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // some logic ...\n  }\n}\n```\n","date":"2020-09-25T23:55:41.139Z","updated":"2020-09-25T23:55:41.139Z","path":"v2/guide/plugins.html","comments":1,"layout":"page","_id":"ckfl66gyn002ec2v512xwgtow","content":"<p>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</p>\n<ol>\n<li><p>Add some global methods or properties. e.g. <a href=\"https://github.com/karol-f/vue-custom-element\" target=\"_blank\" rel=\"noopener\">vue-custom-element</a></p>\n</li>\n<li><p>Add one or more global assets: directives/filters/transitions etc. e.g. <a href=\"https://github.com/vuejs/vue-touch\" target=\"_blank\" rel=\"noopener\">vue-touch</a></p>\n</li>\n<li><p>Add some component options by global mixin. e.g. <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a></p>\n</li>\n<li><p>Add some Vue instance methods by attaching them to Vue.prototype.</p>\n</li>\n<li><p>A library that provides an API of its own, while at the same time injecting some combination of the above. e.g. <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a></p>\n</li>\n</ol>\n<h2 id=\"Using-a-Plugin\"><a href=\"#Using-a-Plugin\" class=\"headerlink\" title=\"Using a Plugin\"></a>Using a Plugin</h2><p>Use plugins by calling the <code>Vue.use()</code> global method. This has to be done before you start your app by calling <code>new Vue()</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// calls `MyPlugin.install(Vue)`</span>\nVue.use(MyPlugin)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">//... options</span>\n&#125;)</code></pre>\n<p>You can optionally pass in some options:</p>\n<pre><code class=\"hljs js\">Vue.use(MyPlugin, &#123; <span class=\"hljs-attr\">someOption</span>: <span class=\"hljs-literal\">true</span> &#125;)</code></pre>\n<p><code>Vue.use</code> automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.</p>\n<p>Some plugins provided by Vue.js official plugins such as <code>vue-router</code> automatically calls <code>Vue.use()</code> if <code>Vue</code> is available as a global variable. However in a module environment such as CommonJS, you always need to call <code>Vue.use()</code> explicitly:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// When using CommonJS via Browserify or Webpack</span>\n<span class=\"hljs-keyword\">var</span> Vue = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'vue'</span>)\n<span class=\"hljs-keyword\">var</span> VueRouter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'vue-router'</span>)\n\n<span class=\"hljs-comment\">// Don't forget to call this</span>\nVue.use(VueRouter)</code></pre>\n<p>Checkout <a href=\"https://github.com/vuejs/awesome-vue#components--libraries\" target=\"_blank\" rel=\"noopener\">awesome-vue</a> for a huge collection of community-contributed plugins and libraries.</p>\n<h2 id=\"Writing-a-Plugin\"><a href=\"#Writing-a-Plugin\" class=\"headerlink\" title=\"Writing a Plugin\"></a>Writing a Plugin</h2><p>A Vue.js plugin should expose an <code>install</code> method. The method will be called with the <code>Vue</code> constructor as the first argument, along with possible options:</p>\n<pre><code class=\"hljs js\">MyPlugin.install = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Vue, options</span>) </span>&#123;\n  <span class=\"hljs-comment\">// 1. add global method or property</span>\n  Vue.myGlobalMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// some logic ...</span>\n  &#125;\n\n  <span class=\"hljs-comment\">// 2. add a global asset</span>\n  Vue.directive(<span class=\"hljs-string\">'my-directive'</span>, &#123;\n    bind (el, binding, vnode, oldVnode) &#123;\n      <span class=\"hljs-comment\">// some logic ...</span>\n    &#125;\n    ...\n  &#125;)\n\n  <span class=\"hljs-comment\">// 3. inject some component options</span>\n  Vue.mixin(&#123;\n    <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// some logic ...</span>\n    &#125;\n    ...\n  &#125;)\n\n  <span class=\"hljs-comment\">// 4. add an instance method</span>\n  Vue.prototype.$myMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">methodOptions</span>) </span>&#123;\n    <span class=\"hljs-comment\">// some logic ...</span>\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>Plugins usually add global-level functionality to Vue. There is no strictly defined scope for a plugin - there are typically several types of plugins:</p>\n<ol>\n<li><p>Add some global methods or properties. e.g. <a href=\"https://github.com/karol-f/vue-custom-element\" target=\"_blank\" rel=\"noopener\">vue-custom-element</a></p>\n</li>\n<li><p>Add one or more global assets: directives/filters/transitions etc. e.g. <a href=\"https://github.com/vuejs/vue-touch\" target=\"_blank\" rel=\"noopener\">vue-touch</a></p>\n</li>\n<li><p>Add some component options by global mixin. e.g. <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a></p>\n</li>\n<li><p>Add some Vue instance methods by attaching them to Vue.prototype.</p>\n</li>\n<li><p>A library that provides an API of its own, while at the same time injecting some combination of the above. e.g. <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a></p>\n</li>\n</ol>\n<h2 id=\"Using-a-Plugin\"><a href=\"#Using-a-Plugin\" class=\"headerlink\" title=\"Using a Plugin\"></a>Using a Plugin</h2><p>Use plugins by calling the <code>Vue.use()</code> global method. This has to be done before you start your app by calling <code>new Vue()</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// calls `MyPlugin.install(Vue)`</span>\nVue.use(MyPlugin)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">//... options</span>\n&#125;)</code></pre>\n<p>You can optionally pass in some options:</p>\n<pre><code class=\"hljs js\">Vue.use(MyPlugin, &#123; <span class=\"hljs-attr\">someOption</span>: <span class=\"hljs-literal\">true</span> &#125;)</code></pre>\n<p><code>Vue.use</code> automatically prevents you from using the same plugin more than once, so calling it multiple times on the same plugin will install the plugin only once.</p>\n<p>Some plugins provided by Vue.js official plugins such as <code>vue-router</code> automatically calls <code>Vue.use()</code> if <code>Vue</code> is available as a global variable. However in a module environment such as CommonJS, you always need to call <code>Vue.use()</code> explicitly:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// When using CommonJS via Browserify or Webpack</span>\n<span class=\"hljs-keyword\">var</span> Vue = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'vue'</span>)\n<span class=\"hljs-keyword\">var</span> VueRouter = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'vue-router'</span>)\n\n<span class=\"hljs-comment\">// Don't forget to call this</span>\nVue.use(VueRouter)</code></pre>\n<p>Checkout <a href=\"https://github.com/vuejs/awesome-vue#components--libraries\" target=\"_blank\" rel=\"noopener\">awesome-vue</a> for a huge collection of community-contributed plugins and libraries.</p>\n<h2 id=\"Writing-a-Plugin\"><a href=\"#Writing-a-Plugin\" class=\"headerlink\" title=\"Writing a Plugin\"></a>Writing a Plugin</h2><p>A Vue.js plugin should expose an <code>install</code> method. The method will be called with the <code>Vue</code> constructor as the first argument, along with possible options:</p>\n<pre><code class=\"hljs js\">MyPlugin.install = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Vue, options</span>) </span>&#123;\n  <span class=\"hljs-comment\">// 1. add global method or property</span>\n  Vue.myGlobalMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// some logic ...</span>\n  &#125;\n\n  <span class=\"hljs-comment\">// 2. add a global asset</span>\n  Vue.directive(<span class=\"hljs-string\">'my-directive'</span>, &#123;\n    bind (el, binding, vnode, oldVnode) &#123;\n      <span class=\"hljs-comment\">// some logic ...</span>\n    &#125;\n    ...\n  &#125;)\n\n  <span class=\"hljs-comment\">// 3. inject some component options</span>\n  Vue.mixin(&#123;\n    <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// some logic ...</span>\n    &#125;\n    ...\n  &#125;)\n\n  <span class=\"hljs-comment\">// 4. add an instance method</span>\n  Vue.prototype.$myMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">methodOptions</span>) </span>&#123;\n    <span class=\"hljs-comment\">// some logic ...</span>\n  &#125;\n&#125;</code></pre>\n"},{"title":"Reactivity in Depth","type":"guide","order":601,"_content":"\nNow it's time to take a deep dive! One of Vue's most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it's also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue's reactivity system.\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue Reactivity\">Watch a video explanation on Vue Mastery</a></div>\n\n## How Changes Are Tracked\n\nWhen you pass a plain JavaScript object to a Vue instance as its `data` option, Vue will walk through all of its properties and convert them to [getter/setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters) using [`Object.defineProperty`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty). This is an ES5-only and un-shimmable feature, which is why Vue doesn't support IE8 and below.\n\nThe getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install [vue-devtools](https://github.com/vuejs/vue-devtools) for a more inspection-friendly interface.\n\nEvery component instance has a corresponding **watcher** instance, which records any properties \"touched\" during the component's render as dependencies. Later on when a dependency's setter is triggered, it notifies the watcher, which in turn causes the component to re-render.\n\n![Reactivity Cycle](/images/data.png)\n\n## Change Detection Caveats\n\nDue to limitations in JavaScript, there are types of changes that Vue **cannot detect**. However, there are ways to circumvent them to preserve reactivity.\n\n### For Objects\n\nVue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the `data` object in order for Vue to convert it and make it reactive. For example:\n\n``` js\nvar vm = new Vue({\n  data: {\n    a: 1\n  }\n})\n// `vm.a` is now reactive\n\nvm.b = 2\n// `vm.b` is NOT reactive\n```\n\nVue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it's possible to add reactive properties to a nested object using the `Vue.set(object, propertyName, value)` method:\n\n``` js\nVue.set(vm.someObject, 'b', 2)\n```\n\nYou can also use the `vm.$set` instance method, which is an alias to the global `Vue.set`:\n\n``` js\nthis.$set(this.someObject, 'b', 2)\n```\n\nSometimes you may want to assign a number of properties to an existing object, for example using `Object.assign()` or `_.extend()`. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:\n\n``` js\n// instead of `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n```\n\n### For Arrays\n\nVue cannot detect the following changes to an array:\n\n1. When you directly set an item with the index, e.g. `vm.items[indexOfItem] = newValue`\n2. When you modify the length of the array, e.g. `vm.items.length = newLength`\n\nFor example:\n\n``` js\nvar vm = new Vue({\n  data: {\n    items: ['a', 'b', 'c']\n  }\n})\nvm.items[1] = 'x' // is NOT reactive\nvm.items.length = 2 // is NOT reactive\n```\n\nTo overcome caveat 1, both of the following will accomplish the same as `vm.items[indexOfItem] = newValue`, but will also trigger state updates in the reactivity system:\n\n``` js\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n```\n``` js\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n```\n\nYou can also use the [`vm.$set`](https://vuejs.org/v2/api/#vm-set) instance method, which is an alias for the global `Vue.set`:\n\n``` js\nvm.$set(vm.items, indexOfItem, newValue)\n```\n\nTo deal with caveat 2, you can use `splice`:\n\n``` js\nvm.items.splice(newLength)\n```\n\n## Declaring Reactive Properties\n\nSince Vue doesn't allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:\n\n``` js\nvar vm = new Vue({\n  data: {\n    // declare message with an empty value\n    message: ''\n  },\n  template: '<div>{{ message }}</div>'\n})\n// set `message` later\nvm.message = 'Hello!'\n```\n\nIf you don't declare `message` in the data option, Vue will warn you that the render function is trying to access a property that doesn't exist.\n\nThere are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the `data` object is like the schema for your component's state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.\n\n## Async Update Queue\n\nIn case you haven't noticed yet, Vue performs DOM updates **asynchronously**. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop \"tick\", Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native `Promise.then`, `MutationObserver`, and `setImmediate` for the asynchronous queuing and falls back to `setTimeout(fn, 0)`.\n\nFor example, when you set `vm.someData = 'new value'`, the component will not re-render immediately. It will update in the next \"tick\", when the queue is flushed. Most of the time we don't need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a \"data-driven\" fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use `Vue.nextTick(callback)` immediately after the data is changed. The callback will be called after the DOM has been updated. For example:\n\n``` html\n<div id=\"example\">{{ message }}</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // change data\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n```\n\nThere is also the `vm.$nextTick()` instance method, which is especially handy inside components, because it doesn't need global `Vue` and its callback's `this` context will be automatically bound to the current Vue instance:\n\n``` js\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: 'not updated'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = 'updated'\n      console.log(this.$el.textContent) // => 'not updated'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => 'updated'\n      })\n    }\n  }\n})\n```\n\nSince `$nextTick()` returns a promise, you can achieve the same as the above using the new [ES2017 async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) syntax:\n\n``` js\n  methods: {\n    updateMessage: async function () {\n      this.message = 'updated'\n      console.log(this.$el.textContent) // => 'not updated'\n      await this.$nextTick()\n      console.log(this.$el.textContent) // => 'updated'\n    }\n  }\n```\n","source":"v2/guide/reactivity.md","raw":"---\ntitle: Reactivity in Depth\ntype: guide\norder: 601\n---\n\nNow it's time to take a deep dive! One of Vue's most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it's also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue's reactivity system.\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue Reactivity\">Watch a video explanation on Vue Mastery</a></div>\n\n## How Changes Are Tracked\n\nWhen you pass a plain JavaScript object to a Vue instance as its `data` option, Vue will walk through all of its properties and convert them to [getter/setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters) using [`Object.defineProperty`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty). This is an ES5-only and un-shimmable feature, which is why Vue doesn't support IE8 and below.\n\nThe getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install [vue-devtools](https://github.com/vuejs/vue-devtools) for a more inspection-friendly interface.\n\nEvery component instance has a corresponding **watcher** instance, which records any properties \"touched\" during the component's render as dependencies. Later on when a dependency's setter is triggered, it notifies the watcher, which in turn causes the component to re-render.\n\n![Reactivity Cycle](/images/data.png)\n\n## Change Detection Caveats\n\nDue to limitations in JavaScript, there are types of changes that Vue **cannot detect**. However, there are ways to circumvent them to preserve reactivity.\n\n### For Objects\n\nVue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the `data` object in order for Vue to convert it and make it reactive. For example:\n\n``` js\nvar vm = new Vue({\n  data: {\n    a: 1\n  }\n})\n// `vm.a` is now reactive\n\nvm.b = 2\n// `vm.b` is NOT reactive\n```\n\nVue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it's possible to add reactive properties to a nested object using the `Vue.set(object, propertyName, value)` method:\n\n``` js\nVue.set(vm.someObject, 'b', 2)\n```\n\nYou can also use the `vm.$set` instance method, which is an alias to the global `Vue.set`:\n\n``` js\nthis.$set(this.someObject, 'b', 2)\n```\n\nSometimes you may want to assign a number of properties to an existing object, for example using `Object.assign()` or `_.extend()`. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:\n\n``` js\n// instead of `Object.assign(this.someObject, { a: 1, b: 2 })`\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n```\n\n### For Arrays\n\nVue cannot detect the following changes to an array:\n\n1. When you directly set an item with the index, e.g. `vm.items[indexOfItem] = newValue`\n2. When you modify the length of the array, e.g. `vm.items.length = newLength`\n\nFor example:\n\n``` js\nvar vm = new Vue({\n  data: {\n    items: ['a', 'b', 'c']\n  }\n})\nvm.items[1] = 'x' // is NOT reactive\nvm.items.length = 2 // is NOT reactive\n```\n\nTo overcome caveat 1, both of the following will accomplish the same as `vm.items[indexOfItem] = newValue`, but will also trigger state updates in the reactivity system:\n\n``` js\n// Vue.set\nVue.set(vm.items, indexOfItem, newValue)\n```\n``` js\n// Array.prototype.splice\nvm.items.splice(indexOfItem, 1, newValue)\n```\n\nYou can also use the [`vm.$set`](https://vuejs.org/v2/api/#vm-set) instance method, which is an alias for the global `Vue.set`:\n\n``` js\nvm.$set(vm.items, indexOfItem, newValue)\n```\n\nTo deal with caveat 2, you can use `splice`:\n\n``` js\nvm.items.splice(newLength)\n```\n\n## Declaring Reactive Properties\n\nSince Vue doesn't allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:\n\n``` js\nvar vm = new Vue({\n  data: {\n    // declare message with an empty value\n    message: ''\n  },\n  template: '<div>{{ message }}</div>'\n})\n// set `message` later\nvm.message = 'Hello!'\n```\n\nIf you don't declare `message` in the data option, Vue will warn you that the render function is trying to access a property that doesn't exist.\n\nThere are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the `data` object is like the schema for your component's state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.\n\n## Async Update Queue\n\nIn case you haven't noticed yet, Vue performs DOM updates **asynchronously**. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop \"tick\", Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native `Promise.then`, `MutationObserver`, and `setImmediate` for the asynchronous queuing and falls back to `setTimeout(fn, 0)`.\n\nFor example, when you set `vm.someData = 'new value'`, the component will not re-render immediately. It will update in the next \"tick\", when the queue is flushed. Most of the time we don't need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a \"data-driven\" fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use `Vue.nextTick(callback)` immediately after the data is changed. The callback will be called after the DOM has been updated. For example:\n\n``` html\n<div id=\"example\">{{ message }}</div>\n```\n\n``` js\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // change data\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n```\n\nThere is also the `vm.$nextTick()` instance method, which is especially handy inside components, because it doesn't need global `Vue` and its callback's `this` context will be automatically bound to the current Vue instance:\n\n``` js\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: 'not updated'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = 'updated'\n      console.log(this.$el.textContent) // => 'not updated'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => 'updated'\n      })\n    }\n  }\n})\n```\n\nSince `$nextTick()` returns a promise, you can achieve the same as the above using the new [ES2017 async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) syntax:\n\n``` js\n  methods: {\n    updateMessage: async function () {\n      this.message = 'updated'\n      console.log(this.$el.textContent) // => 'not updated'\n      await this.$nextTick()\n      console.log(this.$el.textContent) // => 'updated'\n    }\n  }\n```\n","date":"2020-09-25T23:55:41.139Z","updated":"2020-09-25T23:55:41.139Z","path":"v2/guide/reactivity.html","comments":1,"layout":"page","_id":"ckfl66gyn002fc2v5i9ozyko2","content":"<p>Now it’s time to take a deep dive! One of Vue’s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue’s reactivity system.</p>\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue Reactivity\">Watch a video explanation on Vue Mastery</a></div>\n\n<h2 id=\"How-Changes-Are-Tracked\"><a href=\"#How-Changes-Are-Tracked\" class=\"headerlink\" title=\"How Changes Are Tracked\"></a>How Changes Are Tracked</h2><p>When you pass a plain JavaScript object to a Vue instance as its <code>data</code> option, Vue will walk through all of its properties and convert them to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters\" target=\"_blank\" rel=\"noopener\">getter/setters</a> using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener\"><code>Object.defineProperty</code></a>. This is an ES5-only and un-shimmable feature, which is why Vue doesn’t support IE8 and below.</p>\n<p>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> for a more inspection-friendly interface.</p>\n<p>Every component instance has a corresponding <strong>watcher</strong> instance, which records any properties “touched” during the component’s render as dependencies. Later on when a dependency’s setter is triggered, it notifies the watcher, which in turn causes the component to re-render.</p>\n<p><img src=\"/images/data.png\" alt=\"Reactivity Cycle\"></p>\n<h2 id=\"Change-Detection-Caveats\"><a href=\"#Change-Detection-Caveats\" class=\"headerlink\" title=\"Change Detection Caveats\"></a>Change Detection Caveats</h2><p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong>. However, there are ways to circumvent them to preserve reactivity.</p>\n<h3 id=\"For-Objects\"><a href=\"#For-Objects\" class=\"headerlink\" title=\"For Objects\"></a>For Objects</h3><p>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the <code>data</code> object in order for Vue to convert it and make it reactive. For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// `vm.a` is now reactive</span>\n\nvm.b = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-comment\">// `vm.b` is NOT reactive</span></code></pre>\n<p>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it’s possible to add reactive properties to a nested object using the <code>Vue.set(object, propertyName, value)</code> method:</p>\n<pre><code class=\"hljs js\">Vue.set(vm.someObject, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-number\">2</span>)</code></pre>\n<p>You can also use the <code>vm.$set</code> instance method, which is an alias to the global <code>Vue.set</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$<span class=\"hljs-keyword\">set</span>(this.someObject, 'b', 2)</code></pre>\n<p>Sometimes you may want to assign a number of properties to an existing object, for example using <code>Object.assign()</code> or <code>_.extend()</code>. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// instead of `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span>\n<span class=\"hljs-keyword\">this</span>.someObject = <span class=\"hljs-built_in\">Object</span>.assign(&#123;&#125;, <span class=\"hljs-keyword\">this</span>.someObject, &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;)</code></pre>\n<h3 id=\"For-Arrays\"><a href=\"#For-Arrays\" class=\"headerlink\" title=\"For Arrays\"></a>For Arrays</h3><p>Vue cannot detect the following changes to an array:</p>\n<ol>\n<li>When you directly set an item with the index, e.g. <code>vm.items[indexOfItem] = newValue</code></li>\n<li>When you modify the length of the array, e.g. <code>vm.items.length = newLength</code></li>\n</ol>\n<p>For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">items</span>: [<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span>]\n  &#125;\n&#125;)\nvm.items[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">'x'</span> <span class=\"hljs-comment\">// is NOT reactive</span>\nvm.items.length = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// is NOT reactive</span></code></pre>\n<p>To overcome caveat 1, both of the following will accomplish the same as <code>vm.items[indexOfItem] = newValue</code>, but will also trigger state updates in the reactivity system:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Vue.set</span>\nVue.set(vm.items, indexOfItem, newValue)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Array.prototype.splice</span>\nvm.items.splice(indexOfItem, <span class=\"hljs-number\">1</span>, newValue)</code></pre>\n<p>You can also use the <a href=\"https://vuejs.org/v2/api/#vm-set\"><code>vm.$set</code></a> instance method, which is an alias for the global <code>Vue.set</code>:</p>\n<pre><code class=\"hljs js\">vm.$<span class=\"hljs-keyword\">set</span>(vm.items, indexOfItem, newValue)</code></pre>\n<p>To deal with caveat 2, you can use <code>splice</code>:</p>\n<pre><code class=\"hljs js\">vm.items.splice(newLength)</code></pre>\n<h2 id=\"Declaring-Reactive-Properties\"><a href=\"#Declaring-Reactive-Properties\" class=\"headerlink\" title=\"Declaring Reactive Properties\"></a>Declaring Reactive Properties</h2><p>Since Vue doesn’t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-comment\">// declare message with an empty value</span>\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">''</span>\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n<span class=\"hljs-comment\">// set `message` later</span>\nvm.message = <span class=\"hljs-string\">'Hello!'</span></code></pre>\n<p>If you don’t declare <code>message</code> in the data option, Vue will warn you that the render function is trying to access a property that doesn’t exist.</p>\n<p>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the <code>data</code> object is like the schema for your component’s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.</p>\n<h2 id=\"Async-Update-Queue\"><a href=\"#Async-Update-Queue\" class=\"headerlink\" title=\"Async Update Queue\"></a>Async Update Queue</h2><p>In case you haven’t noticed yet, Vue performs DOM updates <strong>asynchronously</strong>. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop “tick”, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native <code>Promise.then</code>, <code>MutationObserver</code>, and <code>setImmediate</code> for the asynchronous queuing and falls back to <code>setTimeout(fn, 0)</code>.</p>\n<p>For example, when you set <code>vm.someData = &#39;new value&#39;</code>, the component will not re-render immediately. It will update in the next “tick”, when the queue is flushed. Most of the time we don’t need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a “data-driven” fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use <code>Vue.nextTick(callback)</code> immediately after the data is changed. The callback will be called after the DOM has been updated. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example\"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'123'</span>\n  &#125;\n&#125;)\nvm.message = <span class=\"hljs-string\">'new message'</span> <span class=\"hljs-comment\">// change data</span>\nvm.$el.textContent === <span class=\"hljs-string\">'new message'</span> <span class=\"hljs-comment\">// false</span>\nVue.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  vm.$el.textContent === <span class=\"hljs-string\">'new message'</span> <span class=\"hljs-comment\">// true</span>\n&#125;)</code></pre>\n<p>There is also the <code>vm.$nextTick()</code> instance method, which is especially handy inside components, because it doesn’t need global <code>Vue</code> and its callback’s <code>this</code> context will be automatically bound to the current Vue instance:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'example'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'not updated'</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">updateMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'updated'</span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'not updated'</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'updated'</span>\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Since <code>$nextTick()</code> returns a promise, you can achieve the same as the above using the new <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\" rel=\"noopener\">ES2017 async/await</a> syntax:</p>\n<pre><code class=\"hljs js\">methods: &#123;\n  <span class=\"hljs-attr\">updateMessage</span>: <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'updated'</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'not updated'</span>\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.$nextTick()\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'updated'</span>\n  &#125;\n&#125;</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>Now it’s time to take a deep dive! One of Vue’s most distinct features is the unobtrusive reactivity system. Models are just plain JavaScript objects. When you modify them, the view updates. It makes state management simple and intuitive, but it’s also important to understand how it works to avoid some common gotchas. In this section, we are going to dig into some of the lower-level details of Vue’s reactivity system.</p>\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vue Reactivity\">Watch a video explanation on Vue Mastery</a></div>\n\n<h2 id=\"How-Changes-Are-Tracked\"><a href=\"#How-Changes-Are-Tracked\" class=\"headerlink\" title=\"How Changes Are Tracked\"></a>How Changes Are Tracked</h2><p>When you pass a plain JavaScript object to a Vue instance as its <code>data</code> option, Vue will walk through all of its properties and convert them to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Defining_getters_and_setters\" target=\"_blank\" rel=\"noopener\">getter/setters</a> using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\" target=\"_blank\" rel=\"noopener\"><code>Object.defineProperty</code></a>. This is an ES5-only and un-shimmable feature, which is why Vue doesn’t support IE8 and below.</p>\n<p>The getter/setters are invisible to the user, but under the hood they enable Vue to perform dependency-tracking and change-notification when properties are accessed or modified. One caveat is that browser consoles format getter/setters differently when converted data objects are logged, so you may want to install <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> for a more inspection-friendly interface.</p>\n<p>Every component instance has a corresponding <strong>watcher</strong> instance, which records any properties “touched” during the component’s render as dependencies. Later on when a dependency’s setter is triggered, it notifies the watcher, which in turn causes the component to re-render.</p>\n<p><img src=\"/images/data.png\" alt=\"Reactivity Cycle\"></p>\n<h2 id=\"Change-Detection-Caveats\"><a href=\"#Change-Detection-Caveats\" class=\"headerlink\" title=\"Change Detection Caveats\"></a>Change Detection Caveats</h2><p>Due to limitations in JavaScript, there are types of changes that Vue <strong>cannot detect</strong>. However, there are ways to circumvent them to preserve reactivity.</p>\n<h3 id=\"For-Objects\"><a href=\"#For-Objects\" class=\"headerlink\" title=\"For Objects\"></a>For Objects</h3><p>Vue cannot detect property addition or deletion. Since Vue performs the getter/setter conversion process during instance initialization, a property must be present in the <code>data</code> object in order for Vue to convert it and make it reactive. For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// `vm.a` is now reactive</span>\n\nvm.b = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-comment\">// `vm.b` is NOT reactive</span></code></pre>\n<p>Vue does not allow dynamically adding new root-level reactive properties to an already created instance. However, it’s possible to add reactive properties to a nested object using the <code>Vue.set(object, propertyName, value)</code> method:</p>\n<pre><code class=\"hljs js\">Vue.set(vm.someObject, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-number\">2</span>)</code></pre>\n<p>You can also use the <code>vm.$set</code> instance method, which is an alias to the global <code>Vue.set</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.$<span class=\"hljs-keyword\">set</span>(this.someObject, 'b', 2)</code></pre>\n<p>Sometimes you may want to assign a number of properties to an existing object, for example using <code>Object.assign()</code> or <code>_.extend()</code>. However, new properties added to the object will not trigger changes. In such cases, create a fresh object with properties from both the original object and the mixin object:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// instead of `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span>\n<span class=\"hljs-keyword\">this</span>.someObject = <span class=\"hljs-built_in\">Object</span>.assign(&#123;&#125;, <span class=\"hljs-keyword\">this</span>.someObject, &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;)</code></pre>\n<h3 id=\"For-Arrays\"><a href=\"#For-Arrays\" class=\"headerlink\" title=\"For Arrays\"></a>For Arrays</h3><p>Vue cannot detect the following changes to an array:</p>\n<ol>\n<li>When you directly set an item with the index, e.g. <code>vm.items[indexOfItem] = newValue</code></li>\n<li>When you modify the length of the array, e.g. <code>vm.items.length = newLength</code></li>\n</ol>\n<p>For example:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">items</span>: [<span class=\"hljs-string\">'a'</span>, <span class=\"hljs-string\">'b'</span>, <span class=\"hljs-string\">'c'</span>]\n  &#125;\n&#125;)\nvm.items[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-string\">'x'</span> <span class=\"hljs-comment\">// is NOT reactive</span>\nvm.items.length = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// is NOT reactive</span></code></pre>\n<p>To overcome caveat 1, both of the following will accomplish the same as <code>vm.items[indexOfItem] = newValue</code>, but will also trigger state updates in the reactivity system:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Vue.set</span>\nVue.set(vm.items, indexOfItem, newValue)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Array.prototype.splice</span>\nvm.items.splice(indexOfItem, <span class=\"hljs-number\">1</span>, newValue)</code></pre>\n<p>You can also use the <a href=\"https://vuejs.org/v2/api/#vm-set\"><code>vm.$set</code></a> instance method, which is an alias for the global <code>Vue.set</code>:</p>\n<pre><code class=\"hljs js\">vm.$<span class=\"hljs-keyword\">set</span>(vm.items, indexOfItem, newValue)</code></pre>\n<p>To deal with caveat 2, you can use <code>splice</code>:</p>\n<pre><code class=\"hljs js\">vm.items.splice(newLength)</code></pre>\n<h2 id=\"Declaring-Reactive-Properties\"><a href=\"#Declaring-Reactive-Properties\" class=\"headerlink\" title=\"Declaring Reactive Properties\"></a>Declaring Reactive Properties</h2><p>Since Vue doesn’t allow dynamically adding root-level reactive properties, you have to initialize Vue instances by declaring all root-level reactive data properties upfront, even with an empty value:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-comment\">// declare message with an empty value</span>\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">''</span>\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n<span class=\"hljs-comment\">// set `message` later</span>\nvm.message = <span class=\"hljs-string\">'Hello!'</span></code></pre>\n<p>If you don’t declare <code>message</code> in the data option, Vue will warn you that the render function is trying to access a property that doesn’t exist.</p>\n<p>There are technical reasons behind this restriction - it eliminates a class of edge cases in the dependency tracking system, and also makes Vue instances play nicer with type checking systems. But there is also an important consideration in terms of code maintainability: the <code>data</code> object is like the schema for your component’s state. Declaring all reactive properties upfront makes the component code easier to understand when revisited later or read by another developer.</p>\n<h2 id=\"Async-Update-Queue\"><a href=\"#Async-Update-Queue\" class=\"headerlink\" title=\"Async Update Queue\"></a>Async Update Queue</h2><p>In case you haven’t noticed yet, Vue performs DOM updates <strong>asynchronously</strong>. Whenever a data change is observed, it will open a queue and buffer all the data changes that happen in the same event loop. If the same watcher is triggered multiple times, it will be pushed into the queue only once. This buffered de-duplication is important in avoiding unnecessary calculations and DOM manipulations. Then, in the next event loop “tick”, Vue flushes the queue and performs the actual (already de-duped) work. Internally Vue tries native <code>Promise.then</code>, <code>MutationObserver</code>, and <code>setImmediate</code> for the asynchronous queuing and falls back to <code>setTimeout(fn, 0)</code>.</p>\n<p>For example, when you set <code>vm.someData = &#39;new value&#39;</code>, the component will not re-render immediately. It will update in the next “tick”, when the queue is flushed. Most of the time we don’t need to care about this, but it can be tricky when you want to do something that depends on the post-update DOM state. Although Vue.js generally encourages developers to think in a “data-driven” fashion and avoid touching the DOM directly, sometimes it might be necessary to get your hands dirty. In order to wait until Vue.js has finished updating the DOM after a data change, you can use <code>Vue.nextTick(callback)</code> immediately after the data is changed. The callback will be called after the DOM has been updated. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"example\"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#example'</span>,\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'123'</span>\n  &#125;\n&#125;)\nvm.message = <span class=\"hljs-string\">'new message'</span> <span class=\"hljs-comment\">// change data</span>\nvm.$el.textContent === <span class=\"hljs-string\">'new message'</span> <span class=\"hljs-comment\">// false</span>\nVue.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  vm.$el.textContent === <span class=\"hljs-string\">'new message'</span> <span class=\"hljs-comment\">// true</span>\n&#125;)</code></pre>\n<p>There is also the <code>vm.$nextTick()</code> instance method, which is especially handy inside components, because it doesn’t need global <code>Vue</code> and its callback’s <code>this</code> context will be automatically bound to the current Vue instance:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'example'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'not updated'</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">updateMessage</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'updated'</span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'not updated'</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'updated'</span>\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Since <code>$nextTick()</code> returns a promise, you can achieve the same as the above using the new <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\" rel=\"noopener\">ES2017 async/await</a> syntax:</p>\n<pre><code class=\"hljs js\">methods: &#123;\n  <span class=\"hljs-attr\">updateMessage</span>: <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'updated'</span>\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'not updated'</span>\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">this</span>.$nextTick()\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$el.textContent) <span class=\"hljs-comment\">// =&gt; 'updated'</span>\n  &#125;\n&#125;</code></pre>\n"},{"title":"Render Functions & JSX","type":"guide","order":303,"_content":"\n## Basics\n\nVue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That's where you can use the **render function**, a closer-to-the-compiler alternative to templates.\n\nLet's dive into a simple example where a `render` function would be practical. Say you want to generate anchored headings:\n\n``` html\n<h1>\n  <a name=\"hello-world\" href=\"#hello-world\">\n    Hello world!\n  </a>\n</h1>\n```\n\nFor the HTML above, you decide you want this component interface:\n\n``` html\n<anchored-heading :level=\"1\">Hello world!</anchored-heading>\n```\n\nWhen you get started with a component that only generates a heading based on the `level` prop, you quickly arrive at this:\n\n``` html\n<script type=\"text/x-template\" id=\"anchored-heading-template\">\n  <h1 v-if=\"level === 1\">\n    <slot></slot>\n  </h1>\n  <h2 v-else-if=\"level === 2\">\n    <slot></slot>\n  </h2>\n  <h3 v-else-if=\"level === 3\">\n    <slot></slot>\n  </h3>\n  <h4 v-else-if=\"level === 4\">\n    <slot></slot>\n  </h4>\n  <h5 v-else-if=\"level === 5\">\n    <slot></slot>\n  </h5>\n  <h6 v-else-if=\"level === 6\">\n    <slot></slot>\n  </h6>\n</script>\n```\n\n``` js\nVue.component('anchored-heading', {\n  template: '#anchored-heading-template',\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\nThat template doesn't feel great. It's not only verbose, but we're duplicating `<slot></slot>` for every heading level and will have to do the same when we add the anchor element.\n\nWhile templates work great for most components, it's clear that this isn't one of them. So let's try rewriting it with a `render` function:\n\n``` js\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    return createElement(\n      'h' + this.level,   // tag name\n      this.$slots.default // array of children\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\nMuch simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a `v-slot` directive into a component, like the `Hello world!` inside of `anchored-heading`, those children are stored on the component instance at `$slots.default`. If you haven't already, **it's recommended to read through the [instance properties API](../api/#Instance-Properties) before diving into render functions.**\n\n## Nodes, Trees, and the Virtual DOM\n\nBefore we dive into render functions, it’s important to know a little about how browsers work. Take this HTML for example:\n\n```html\n<div>\n  <h1>My title</h1>\n  Some text content\n  <!-- TODO: Add tagline  -->\n</div>\n```\n\nWhen a browser reads this code, it builds a [tree of \"DOM nodes\"](https://javascript.info/dom-nodes) to help it keep track of everything, just as you might build a family tree to keep track of your extended family.\n\nThe tree of DOM nodes for the HTML above looks like this:\n\n![DOM Tree Visualization](/images/dom-tree.png)\n\nEvery element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page. And as in a family tree, each node can have children (i.e. each piece can contain other pieces).\n\nUpdating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:\n\n```html\n<h1>{{ blogTitle }}</h1>\n```\n\nOr a render function:\n\n``` js\nrender: function (createElement) {\n  return createElement('h1', this.blogTitle)\n}\n```\n\nAnd in both cases, Vue automatically keeps the page updated, even when `blogTitle` changes.\n\n### The Virtual DOM\n\nVue accomplishes this by building a **virtual DOM** to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:\n\n``` js\nreturn createElement('h1', this.blogTitle)\n```\n\nWhat is `createElement` actually returning? It's not _exactly_ a real DOM element. It could perhaps more accurately be named `createNodeDescription`, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a \"virtual node\", usually abbreviated to **VNode**. \"Virtual DOM\" is what we call the entire tree of VNodes, built by a tree of Vue components.\n\n## `createElement` Arguments\n\nThe next thing you'll have to become familiar with is how to use template features in the `createElement` function. Here are the arguments that `createElement` accepts:\n\n``` js\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // An HTML tag name, component options, or async\n  // function resolving to one of these. Required.\n  'div',\n\n  // {Object}\n  // A data object corresponding to the attributes\n  // you would use in a template. Optional.\n  {\n    // (see details in the next section below)\n  },\n\n  // {String | Array}\n  // Children VNodes, built using `createElement()`,\n  // or using strings to get 'text VNodes'. Optional.\n  [\n    'Some text comes first.',\n    createElement('h1', 'A headline'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n```\n\n### The Data Object In-Depth\n\nOne thing to note: similar to how `v-bind:class` and `v-bind:style` have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as `innerHTML` (this would replace the `v-html` directive):\n\n``` js\n{\n  // Same API as `v-bind:class`, accepting either\n  // a string, object, or array of strings and objects.\n  class: {\n    foo: true,\n    bar: false\n  },\n  // Same API as `v-bind:style`, accepting either\n  // a string, object, or array of objects.\n  style: {\n    color: 'red',\n    fontSize: '14px'\n  },\n  // Normal HTML attributes\n  attrs: {\n    id: 'foo'\n  },\n  // Component props\n  props: {\n    myProp: 'bar'\n  },\n  // DOM properties\n  domProps: {\n    innerHTML: 'baz'\n  },\n  // Event handlers are nested under `on`, though\n  // modifiers such as in `v-on:keyup.enter` are not\n  // supported. You'll have to manually check the\n  // keyCode in the handler instead.\n  on: {\n    click: this.clickHandler\n  },\n  // For components only. Allows you to listen to\n  // native events, rather than events emitted from\n  // the component using `vm.$emit`.\n  nativeOn: {\n    click: this.nativeClickHandler\n  },\n  // Custom directives. Note that the `binding`'s\n  // `oldValue` cannot be set, as Vue keeps track\n  // of it for you.\n  directives: [\n    {\n      name: 'my-custom-directive',\n      value: '2',\n      expression: '1 + 1',\n      arg: 'foo',\n      modifiers: {\n        bar: true\n      }\n    }\n  ],\n  // Scoped slots in the form of\n  // { name: props => VNode | Array<VNode> }\n  scopedSlots: {\n    default: props => createElement('span', props.text)\n  },\n  // The name of the slot, if this component is the\n  // child of another component\n  slot: 'name-of-slot',\n  // Other special top-level properties\n  key: 'myKey',\n  ref: 'myRef',\n  // If you are applying the same ref name to multiple\n  // elements in the render function. This will make `$refs.myRef` become an\n  // array\n  refInFor: true\n}\n```\n\n### Complete Example\n\nWith this knowledge, we can now finish the component we started:\n\n``` js\nvar getChildrenTextContent = function (children) {\n  return children.map(function (node) {\n    return node.children\n      ? getChildrenTextContent(node.children)\n      : node.text\n  }).join('')\n}\n\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    // create kebab-case id\n    var headingId = getChildrenTextContent(this.$slots.default)\n      .toLowerCase()\n      .replace(/\\W+/g, '-')\n      .replace(/(^-|-$)/g, '')\n\n    return createElement(\n      'h' + this.level,\n      [\n        createElement('a', {\n          attrs: {\n            name: headingId,\n            href: '#' + headingId\n          }\n        }, this.$slots.default)\n      ]\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n### Constraints\n\n#### VNodes Must Be Unique\n\nAll VNodes in the component tree must be unique. That means the following render function is invalid:\n\n``` js\nrender: function (createElement) {\n  var myParagraphVNode = createElement('p', 'hi')\n  return createElement('div', [\n    // Yikes - duplicate VNodes!\n    myParagraphVNode, myParagraphVNode\n  ])\n}\n```\n\nIf you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:\n\n``` js\nrender: function (createElement) {\n  return createElement('div',\n    Array.apply(null, { length: 20 }).map(function () {\n      return createElement('p', 'hi')\n    })\n  )\n}\n```\n\n## Replacing Template Features with Plain JavaScript\n\n### `v-if` and `v-for`\n\nWherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using `v-if` and `v-for`:\n\n``` html\n<ul v-if=\"items.length\">\n  <li v-for=\"item in items\">{{ item.name }}</li>\n</ul>\n<p v-else>No items found.</p>\n```\n\nThis could be rewritten with JavaScript's `if`/`else` and `map` in a render function:\n\n``` js\nprops: ['items'],\nrender: function (createElement) {\n  if (this.items.length) {\n    return createElement('ul', this.items.map(function (item) {\n      return createElement('li', item.name)\n    }))\n  } else {\n    return createElement('p', 'No items found.')\n  }\n}\n```\n\n### `v-model`\n\nThere is no direct `v-model` counterpart in render functions - you will have to implement the logic yourself:\n\n``` js\nprops: ['value'],\nrender: function (createElement) {\n  var self = this\n  return createElement('input', {\n    domProps: {\n      value: self.value\n    },\n    on: {\n      input: function (event) {\n        self.$emit('input', event.target.value)\n      }\n    }\n  })\n}\n```\n\nThis is the cost of going lower-level, but it also gives you much more control over the interaction details compared to `v-model`.\n\n### Event & Key Modifiers\n\nFor the `.passive`, `.capture` and `.once` event modifiers, Vue offers prefixes that can be used with `on`:\n\n| Modifier(s) | Prefix |\n| ------ | ------ |\n| `.passive` | `&` |\n| `.capture` | `!` |\n| `.once` | `~` |\n| `.capture.once` or<br>`.once.capture` | `~!` |\n\nFor example:\n\n```javascript\non: {\n  '!click': this.doThisInCapturingMode,\n  '~keyup': this.doThisOnce,\n  '~!mouseover': this.doThisOnceInCapturingMode\n}\n```\n\nFor all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the handler:\n\n| Modifier(s) | Equivalent in Handler |\n| ------ | ------ |\n| `.stop` | `event.stopPropagation()` |\n| `.prevent` | `event.preventDefault()` |\n| `.self` | `if (event.target !== event.currentTarget) return` |\n| Keys:<br>`.enter`, `.13` | `if (event.keyCode !== 13) return` (change `13` to [another key code](http://keycode.info/) for other key modifiers) |\n| Modifiers Keys:<br>`.ctrl`, `.alt`, `.shift`, `.meta` | `if (!event.ctrlKey) return` (change `ctrlKey` to `altKey`, `shiftKey`, or `metaKey`, respectively) |\n\nHere's an example with all of these modifiers used together:\n\n```javascript\non: {\n  keyup: function (event) {\n    // Abort if the element emitting the event is not\n    // the element the event is bound to\n    if (event.target !== event.currentTarget) return\n    // Abort if the key that went up is not the enter\n    // key (13) and the shift key was not held down\n    // at the same time\n    if (!event.shiftKey || event.keyCode !== 13) return\n    // Stop event propagation\n    event.stopPropagation()\n    // Prevent the default keyup handler for this element\n    event.preventDefault()\n    // ...\n  }\n}\n```\n\n### Slots\n\nYou can access static slot contents as Arrays of VNodes from [`this.$slots`](../api/#vm-slots):\n\n``` js\nrender: function (createElement) {\n  // `<div><slot></slot></div>`\n  return createElement('div', this.$slots.default)\n}\n```\n\nAnd access scoped slots as functions that return VNodes from [`this.$scopedSlots`](../api/#vm-scopedSlots):\n\n``` js\nprops: ['message'],\nrender: function (createElement) {\n  // `<div><slot :text=\"message\"></slot></div>`\n  return createElement('div', [\n    this.$scopedSlots.default({\n      text: this.message\n    })\n  ])\n}\n```\n\nTo pass scoped slots to a child component using render functions, use the `scopedSlots` field in VNode data:\n\n``` js\nrender: function (createElement) {\n  // `<div><child v-slot=\"props\"><span>{{ props.text }}</span></child></div>`\n  return createElement('div', [\n    createElement('child', {\n      // pass `scopedSlots` in the data object\n      // in the form of { name: props => VNode | Array<VNode> }\n      scopedSlots: {\n        default: function (props) {\n          return createElement('span', props.text)\n        }\n      }\n    })\n  ])\n}\n```\n\n## JSX\n\nIf you're writing a lot of `render` functions, it might feel painful to write something like this:\n\n``` js\ncreateElement(\n  'anchored-heading', {\n    props: {\n      level: 1\n    }\n  }, [\n    createElement('span', 'Hello'),\n    ' world!'\n  ]\n)\n```\n\nEspecially when the template version is so simple in comparison:\n\n``` html\n<anchored-heading :level=\"1\">\n  <span>Hello</span> world!\n</anchored-heading>\n```\n\nThat's why there's a [Babel plugin](https://github.com/vuejs/jsx) to use JSX with Vue, getting us back to a syntax that's closer to templates:\n\n``` js\nimport AnchoredHeading from './AnchoredHeading.vue'\n\nnew Vue({\n  el: '#demo',\n  render: function (h) {\n    return (\n      <AnchoredHeading level={1}>\n        <span>Hello</span> world!\n      </AnchoredHeading>\n    )\n  }\n})\n```\n\n<p class=\"tip\">Aliasing `createElement` to `h` is a common convention you'll see in the Vue ecosystem and is actually required for JSX. Starting with [version 3.4.0](https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection) of the Babel plugin for Vue, we automatically inject `const h = this.$createElement` in any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the `(h)` parameter. With prior versions of the plugin, your app would throw an error if `h` was not available in the scope.</p>\n\nFor more on how JSX maps to JavaScript, see the [usage docs](https://github.com/vuejs/jsx#installation).\n\n## Functional Components\n\nThe anchored heading component we created earlier is relatively simple. It doesn't manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it's only a function with some props.\n\nIn cases like this, we can mark components as `functional`, which means that they're stateless (no [reactive data](../api/#Options-Data)) and instanceless (no `this` context). A **functional component** looks like this:\n\n``` js\nVue.component('my-component', {\n  functional: true,\n  // Props are optional\n  props: {\n    // ...\n  },\n  // To compensate for the lack of an instance,\n  // we are now provided a 2nd context argument.\n  render: function (createElement, context) {\n    // ...\n  }\n})\n```\n\n> Note: in versions before 2.3.0, the `props` option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the `props` option and all attributes found on the component node will be implicitly extracted as props.\n> \n> The reference will be HTMLElement when used with functional components because they’re stateless and instanceless.\n\nIn 2.5.0+, if you are using [single-file components](single-file-components.html), template-based functional components can be declared with:\n\n``` html\n<template functional>\n</template>\n```\n\nEverything the component needs is passed through `context`, which is an object containing:\n\n- `props`: An object of the provided props\n- `children`: An array of the VNode children\n- `slots`: A function returning a slots object\n- `scopedSlots`: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as functions.\n- `data`: The entire [data object](#The-Data-Object-In-Depth), passed to the component as the 2nd argument of `createElement`\n- `parent`: A reference to the parent component\n- `listeners`: (2.3.0+) An object containing parent-registered event listeners. This is an alias to `data.on`\n- `injections`: (2.3.0+) if using the [`inject`](../api/#provide-inject) option, this will contain resolved injections.\n\nAfter adding `functional: true`, updating the render function of our anchored heading component would require adding the `context` argument, updating `this.$slots.default` to `context.children`, then updating `this.level` to `context.props.level`.\n\nSince functional components are just functions, they're much cheaper to render.\n\nThey're also very useful as wrapper components. For example, when you need to:\n\n- Programmatically choose one of several other components to delegate to\n- Manipulate children, props, or data before passing them on to a child component\n\nHere's an example of a `smart-list` component that delegates to more specific components, depending on the props passed to it:\n\n``` js\nvar EmptyList = { /* ... */ }\nvar TableList = { /* ... */ }\nvar OrderedList = { /* ... */ }\nvar UnorderedList = { /* ... */ }\n\nVue.component('smart-list', {\n  functional: true,\n  props: {\n    items: {\n      type: Array,\n      required: true\n    },\n    isOrdered: Boolean\n  },\n  render: function (createElement, context) {\n    function appropriateListComponent () {\n      var items = context.props.items\n\n      if (items.length === 0)           return EmptyList\n      if (typeof items[0] === 'object') return TableList\n      if (context.props.isOrdered)      return OrderedList\n\n      return UnorderedList\n    }\n\n    return createElement(\n      appropriateListComponent(),\n      context.data,\n      context.children\n    )\n  }\n})\n```\n\n### Passing Attributes and Events to Child Elements/Components\n\nOn normal components, attributes not defined as props are automatically added to the root element of the component, replacing or [intelligently merging with](class-and-style.html) any existing attributes of the same name.\n\nFunctional components, however, require you to explicitly define this behavior:\n\n```js\nVue.component('my-functional-button', {\n  functional: true,\n  render: function (createElement, context) {\n    // Transparently pass any attributes, event listeners, children, etc.\n    return createElement('button', context.data, context.children)\n  }\n})\n```\n\nBy passing `context.data` as the second argument to `createElement`, we are passing down any attributes or event listeners used on `my-functional-button`. It's so transparent, in fact, that events don't even require the `.native` modifier.\n\nIf you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use `data.attrs` to pass along any HTML attributes and `listeners` _(the alias for `data.on`)_ to pass along any event listeners.\n\n```html\n<template functional>\n  <button\n    class=\"btn btn-primary\"\n    v-bind=\"data.attrs\"\n    v-on=\"listeners\"\n  >\n    <slot/>\n  </button>\n</template>\n```\n\n### `slots()` vs `children`\n\nYou may wonder why we need both `slots()` and `children`. Wouldn't `slots().default` be the same as `children`? In some cases, yes - but what if you have a functional component with the following children?\n\n``` html\n<my-functional-component>\n  <p v-slot:foo>\n    first\n  </p>\n  <p>second</p>\n</my-functional-component>\n```\n\nFor this component, `children` will give you both paragraphs, `slots().default` will give you only the second, and `slots().foo` will give you only the first. Having both `children` and `slots()` therefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by passing along `children`.\n\n## Template Compilation\n\nYou may be interested to know that Vue's templates actually compile to render functions. This is an implementation detail you usually don't need to know about, but if you'd like to see how specific template features are compiled, you may find it interesting. Below is a little demo using `Vue.compile` to live-compile a template string:\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-template-compilation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","source":"v2/guide/render-function.md","raw":"---\ntitle: Render Functions & JSX\ntype: guide\norder: 303\n---\n\n## Basics\n\nVue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That's where you can use the **render function**, a closer-to-the-compiler alternative to templates.\n\nLet's dive into a simple example where a `render` function would be practical. Say you want to generate anchored headings:\n\n``` html\n<h1>\n  <a name=\"hello-world\" href=\"#hello-world\">\n    Hello world!\n  </a>\n</h1>\n```\n\nFor the HTML above, you decide you want this component interface:\n\n``` html\n<anchored-heading :level=\"1\">Hello world!</anchored-heading>\n```\n\nWhen you get started with a component that only generates a heading based on the `level` prop, you quickly arrive at this:\n\n``` html\n<script type=\"text/x-template\" id=\"anchored-heading-template\">\n  <h1 v-if=\"level === 1\">\n    <slot></slot>\n  </h1>\n  <h2 v-else-if=\"level === 2\">\n    <slot></slot>\n  </h2>\n  <h3 v-else-if=\"level === 3\">\n    <slot></slot>\n  </h3>\n  <h4 v-else-if=\"level === 4\">\n    <slot></slot>\n  </h4>\n  <h5 v-else-if=\"level === 5\">\n    <slot></slot>\n  </h5>\n  <h6 v-else-if=\"level === 6\">\n    <slot></slot>\n  </h6>\n</script>\n```\n\n``` js\nVue.component('anchored-heading', {\n  template: '#anchored-heading-template',\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\nThat template doesn't feel great. It's not only verbose, but we're duplicating `<slot></slot>` for every heading level and will have to do the same when we add the anchor element.\n\nWhile templates work great for most components, it's clear that this isn't one of them. So let's try rewriting it with a `render` function:\n\n``` js\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    return createElement(\n      'h' + this.level,   // tag name\n      this.$slots.default // array of children\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\nMuch simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a `v-slot` directive into a component, like the `Hello world!` inside of `anchored-heading`, those children are stored on the component instance at `$slots.default`. If you haven't already, **it's recommended to read through the [instance properties API](../api/#Instance-Properties) before diving into render functions.**\n\n## Nodes, Trees, and the Virtual DOM\n\nBefore we dive into render functions, it’s important to know a little about how browsers work. Take this HTML for example:\n\n```html\n<div>\n  <h1>My title</h1>\n  Some text content\n  <!-- TODO: Add tagline  -->\n</div>\n```\n\nWhen a browser reads this code, it builds a [tree of \"DOM nodes\"](https://javascript.info/dom-nodes) to help it keep track of everything, just as you might build a family tree to keep track of your extended family.\n\nThe tree of DOM nodes for the HTML above looks like this:\n\n![DOM Tree Visualization](/images/dom-tree.png)\n\nEvery element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page. And as in a family tree, each node can have children (i.e. each piece can contain other pieces).\n\nUpdating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:\n\n```html\n<h1>{{ blogTitle }}</h1>\n```\n\nOr a render function:\n\n``` js\nrender: function (createElement) {\n  return createElement('h1', this.blogTitle)\n}\n```\n\nAnd in both cases, Vue automatically keeps the page updated, even when `blogTitle` changes.\n\n### The Virtual DOM\n\nVue accomplishes this by building a **virtual DOM** to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:\n\n``` js\nreturn createElement('h1', this.blogTitle)\n```\n\nWhat is `createElement` actually returning? It's not _exactly_ a real DOM element. It could perhaps more accurately be named `createNodeDescription`, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a \"virtual node\", usually abbreviated to **VNode**. \"Virtual DOM\" is what we call the entire tree of VNodes, built by a tree of Vue components.\n\n## `createElement` Arguments\n\nThe next thing you'll have to become familiar with is how to use template features in the `createElement` function. Here are the arguments that `createElement` accepts:\n\n``` js\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // An HTML tag name, component options, or async\n  // function resolving to one of these. Required.\n  'div',\n\n  // {Object}\n  // A data object corresponding to the attributes\n  // you would use in a template. Optional.\n  {\n    // (see details in the next section below)\n  },\n\n  // {String | Array}\n  // Children VNodes, built using `createElement()`,\n  // or using strings to get 'text VNodes'. Optional.\n  [\n    'Some text comes first.',\n    createElement('h1', 'A headline'),\n    createElement(MyComponent, {\n      props: {\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n```\n\n### The Data Object In-Depth\n\nOne thing to note: similar to how `v-bind:class` and `v-bind:style` have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as `innerHTML` (this would replace the `v-html` directive):\n\n``` js\n{\n  // Same API as `v-bind:class`, accepting either\n  // a string, object, or array of strings and objects.\n  class: {\n    foo: true,\n    bar: false\n  },\n  // Same API as `v-bind:style`, accepting either\n  // a string, object, or array of objects.\n  style: {\n    color: 'red',\n    fontSize: '14px'\n  },\n  // Normal HTML attributes\n  attrs: {\n    id: 'foo'\n  },\n  // Component props\n  props: {\n    myProp: 'bar'\n  },\n  // DOM properties\n  domProps: {\n    innerHTML: 'baz'\n  },\n  // Event handlers are nested under `on`, though\n  // modifiers such as in `v-on:keyup.enter` are not\n  // supported. You'll have to manually check the\n  // keyCode in the handler instead.\n  on: {\n    click: this.clickHandler\n  },\n  // For components only. Allows you to listen to\n  // native events, rather than events emitted from\n  // the component using `vm.$emit`.\n  nativeOn: {\n    click: this.nativeClickHandler\n  },\n  // Custom directives. Note that the `binding`'s\n  // `oldValue` cannot be set, as Vue keeps track\n  // of it for you.\n  directives: [\n    {\n      name: 'my-custom-directive',\n      value: '2',\n      expression: '1 + 1',\n      arg: 'foo',\n      modifiers: {\n        bar: true\n      }\n    }\n  ],\n  // Scoped slots in the form of\n  // { name: props => VNode | Array<VNode> }\n  scopedSlots: {\n    default: props => createElement('span', props.text)\n  },\n  // The name of the slot, if this component is the\n  // child of another component\n  slot: 'name-of-slot',\n  // Other special top-level properties\n  key: 'myKey',\n  ref: 'myRef',\n  // If you are applying the same ref name to multiple\n  // elements in the render function. This will make `$refs.myRef` become an\n  // array\n  refInFor: true\n}\n```\n\n### Complete Example\n\nWith this knowledge, we can now finish the component we started:\n\n``` js\nvar getChildrenTextContent = function (children) {\n  return children.map(function (node) {\n    return node.children\n      ? getChildrenTextContent(node.children)\n      : node.text\n  }).join('')\n}\n\nVue.component('anchored-heading', {\n  render: function (createElement) {\n    // create kebab-case id\n    var headingId = getChildrenTextContent(this.$slots.default)\n      .toLowerCase()\n      .replace(/\\W+/g, '-')\n      .replace(/(^-|-$)/g, '')\n\n    return createElement(\n      'h' + this.level,\n      [\n        createElement('a', {\n          attrs: {\n            name: headingId,\n            href: '#' + headingId\n          }\n        }, this.$slots.default)\n      ]\n    )\n  },\n  props: {\n    level: {\n      type: Number,\n      required: true\n    }\n  }\n})\n```\n\n### Constraints\n\n#### VNodes Must Be Unique\n\nAll VNodes in the component tree must be unique. That means the following render function is invalid:\n\n``` js\nrender: function (createElement) {\n  var myParagraphVNode = createElement('p', 'hi')\n  return createElement('div', [\n    // Yikes - duplicate VNodes!\n    myParagraphVNode, myParagraphVNode\n  ])\n}\n```\n\nIf you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:\n\n``` js\nrender: function (createElement) {\n  return createElement('div',\n    Array.apply(null, { length: 20 }).map(function () {\n      return createElement('p', 'hi')\n    })\n  )\n}\n```\n\n## Replacing Template Features with Plain JavaScript\n\n### `v-if` and `v-for`\n\nWherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using `v-if` and `v-for`:\n\n``` html\n<ul v-if=\"items.length\">\n  <li v-for=\"item in items\">{{ item.name }}</li>\n</ul>\n<p v-else>No items found.</p>\n```\n\nThis could be rewritten with JavaScript's `if`/`else` and `map` in a render function:\n\n``` js\nprops: ['items'],\nrender: function (createElement) {\n  if (this.items.length) {\n    return createElement('ul', this.items.map(function (item) {\n      return createElement('li', item.name)\n    }))\n  } else {\n    return createElement('p', 'No items found.')\n  }\n}\n```\n\n### `v-model`\n\nThere is no direct `v-model` counterpart in render functions - you will have to implement the logic yourself:\n\n``` js\nprops: ['value'],\nrender: function (createElement) {\n  var self = this\n  return createElement('input', {\n    domProps: {\n      value: self.value\n    },\n    on: {\n      input: function (event) {\n        self.$emit('input', event.target.value)\n      }\n    }\n  })\n}\n```\n\nThis is the cost of going lower-level, but it also gives you much more control over the interaction details compared to `v-model`.\n\n### Event & Key Modifiers\n\nFor the `.passive`, `.capture` and `.once` event modifiers, Vue offers prefixes that can be used with `on`:\n\n| Modifier(s) | Prefix |\n| ------ | ------ |\n| `.passive` | `&` |\n| `.capture` | `!` |\n| `.once` | `~` |\n| `.capture.once` or<br>`.once.capture` | `~!` |\n\nFor example:\n\n```javascript\non: {\n  '!click': this.doThisInCapturingMode,\n  '~keyup': this.doThisOnce,\n  '~!mouseover': this.doThisOnceInCapturingMode\n}\n```\n\nFor all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the handler:\n\n| Modifier(s) | Equivalent in Handler |\n| ------ | ------ |\n| `.stop` | `event.stopPropagation()` |\n| `.prevent` | `event.preventDefault()` |\n| `.self` | `if (event.target !== event.currentTarget) return` |\n| Keys:<br>`.enter`, `.13` | `if (event.keyCode !== 13) return` (change `13` to [another key code](http://keycode.info/) for other key modifiers) |\n| Modifiers Keys:<br>`.ctrl`, `.alt`, `.shift`, `.meta` | `if (!event.ctrlKey) return` (change `ctrlKey` to `altKey`, `shiftKey`, or `metaKey`, respectively) |\n\nHere's an example with all of these modifiers used together:\n\n```javascript\non: {\n  keyup: function (event) {\n    // Abort if the element emitting the event is not\n    // the element the event is bound to\n    if (event.target !== event.currentTarget) return\n    // Abort if the key that went up is not the enter\n    // key (13) and the shift key was not held down\n    // at the same time\n    if (!event.shiftKey || event.keyCode !== 13) return\n    // Stop event propagation\n    event.stopPropagation()\n    // Prevent the default keyup handler for this element\n    event.preventDefault()\n    // ...\n  }\n}\n```\n\n### Slots\n\nYou can access static slot contents as Arrays of VNodes from [`this.$slots`](../api/#vm-slots):\n\n``` js\nrender: function (createElement) {\n  // `<div><slot></slot></div>`\n  return createElement('div', this.$slots.default)\n}\n```\n\nAnd access scoped slots as functions that return VNodes from [`this.$scopedSlots`](../api/#vm-scopedSlots):\n\n``` js\nprops: ['message'],\nrender: function (createElement) {\n  // `<div><slot :text=\"message\"></slot></div>`\n  return createElement('div', [\n    this.$scopedSlots.default({\n      text: this.message\n    })\n  ])\n}\n```\n\nTo pass scoped slots to a child component using render functions, use the `scopedSlots` field in VNode data:\n\n``` js\nrender: function (createElement) {\n  // `<div><child v-slot=\"props\"><span>{{ props.text }}</span></child></div>`\n  return createElement('div', [\n    createElement('child', {\n      // pass `scopedSlots` in the data object\n      // in the form of { name: props => VNode | Array<VNode> }\n      scopedSlots: {\n        default: function (props) {\n          return createElement('span', props.text)\n        }\n      }\n    })\n  ])\n}\n```\n\n## JSX\n\nIf you're writing a lot of `render` functions, it might feel painful to write something like this:\n\n``` js\ncreateElement(\n  'anchored-heading', {\n    props: {\n      level: 1\n    }\n  }, [\n    createElement('span', 'Hello'),\n    ' world!'\n  ]\n)\n```\n\nEspecially when the template version is so simple in comparison:\n\n``` html\n<anchored-heading :level=\"1\">\n  <span>Hello</span> world!\n</anchored-heading>\n```\n\nThat's why there's a [Babel plugin](https://github.com/vuejs/jsx) to use JSX with Vue, getting us back to a syntax that's closer to templates:\n\n``` js\nimport AnchoredHeading from './AnchoredHeading.vue'\n\nnew Vue({\n  el: '#demo',\n  render: function (h) {\n    return (\n      <AnchoredHeading level={1}>\n        <span>Hello</span> world!\n      </AnchoredHeading>\n    )\n  }\n})\n```\n\n<p class=\"tip\">Aliasing `createElement` to `h` is a common convention you'll see in the Vue ecosystem and is actually required for JSX. Starting with [version 3.4.0](https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection) of the Babel plugin for Vue, we automatically inject `const h = this.$createElement` in any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the `(h)` parameter. With prior versions of the plugin, your app would throw an error if `h` was not available in the scope.</p>\n\nFor more on how JSX maps to JavaScript, see the [usage docs](https://github.com/vuejs/jsx#installation).\n\n## Functional Components\n\nThe anchored heading component we created earlier is relatively simple. It doesn't manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it's only a function with some props.\n\nIn cases like this, we can mark components as `functional`, which means that they're stateless (no [reactive data](../api/#Options-Data)) and instanceless (no `this` context). A **functional component** looks like this:\n\n``` js\nVue.component('my-component', {\n  functional: true,\n  // Props are optional\n  props: {\n    // ...\n  },\n  // To compensate for the lack of an instance,\n  // we are now provided a 2nd context argument.\n  render: function (createElement, context) {\n    // ...\n  }\n})\n```\n\n> Note: in versions before 2.3.0, the `props` option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the `props` option and all attributes found on the component node will be implicitly extracted as props.\n> \n> The reference will be HTMLElement when used with functional components because they’re stateless and instanceless.\n\nIn 2.5.0+, if you are using [single-file components](single-file-components.html), template-based functional components can be declared with:\n\n``` html\n<template functional>\n</template>\n```\n\nEverything the component needs is passed through `context`, which is an object containing:\n\n- `props`: An object of the provided props\n- `children`: An array of the VNode children\n- `slots`: A function returning a slots object\n- `scopedSlots`: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as functions.\n- `data`: The entire [data object](#The-Data-Object-In-Depth), passed to the component as the 2nd argument of `createElement`\n- `parent`: A reference to the parent component\n- `listeners`: (2.3.0+) An object containing parent-registered event listeners. This is an alias to `data.on`\n- `injections`: (2.3.0+) if using the [`inject`](../api/#provide-inject) option, this will contain resolved injections.\n\nAfter adding `functional: true`, updating the render function of our anchored heading component would require adding the `context` argument, updating `this.$slots.default` to `context.children`, then updating `this.level` to `context.props.level`.\n\nSince functional components are just functions, they're much cheaper to render.\n\nThey're also very useful as wrapper components. For example, when you need to:\n\n- Programmatically choose one of several other components to delegate to\n- Manipulate children, props, or data before passing them on to a child component\n\nHere's an example of a `smart-list` component that delegates to more specific components, depending on the props passed to it:\n\n``` js\nvar EmptyList = { /* ... */ }\nvar TableList = { /* ... */ }\nvar OrderedList = { /* ... */ }\nvar UnorderedList = { /* ... */ }\n\nVue.component('smart-list', {\n  functional: true,\n  props: {\n    items: {\n      type: Array,\n      required: true\n    },\n    isOrdered: Boolean\n  },\n  render: function (createElement, context) {\n    function appropriateListComponent () {\n      var items = context.props.items\n\n      if (items.length === 0)           return EmptyList\n      if (typeof items[0] === 'object') return TableList\n      if (context.props.isOrdered)      return OrderedList\n\n      return UnorderedList\n    }\n\n    return createElement(\n      appropriateListComponent(),\n      context.data,\n      context.children\n    )\n  }\n})\n```\n\n### Passing Attributes and Events to Child Elements/Components\n\nOn normal components, attributes not defined as props are automatically added to the root element of the component, replacing or [intelligently merging with](class-and-style.html) any existing attributes of the same name.\n\nFunctional components, however, require you to explicitly define this behavior:\n\n```js\nVue.component('my-functional-button', {\n  functional: true,\n  render: function (createElement, context) {\n    // Transparently pass any attributes, event listeners, children, etc.\n    return createElement('button', context.data, context.children)\n  }\n})\n```\n\nBy passing `context.data` as the second argument to `createElement`, we are passing down any attributes or event listeners used on `my-functional-button`. It's so transparent, in fact, that events don't even require the `.native` modifier.\n\nIf you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use `data.attrs` to pass along any HTML attributes and `listeners` _(the alias for `data.on`)_ to pass along any event listeners.\n\n```html\n<template functional>\n  <button\n    class=\"btn btn-primary\"\n    v-bind=\"data.attrs\"\n    v-on=\"listeners\"\n  >\n    <slot/>\n  </button>\n</template>\n```\n\n### `slots()` vs `children`\n\nYou may wonder why we need both `slots()` and `children`. Wouldn't `slots().default` be the same as `children`? In some cases, yes - but what if you have a functional component with the following children?\n\n``` html\n<my-functional-component>\n  <p v-slot:foo>\n    first\n  </p>\n  <p>second</p>\n</my-functional-component>\n```\n\nFor this component, `children` will give you both paragraphs, `slots().default` will give you only the second, and `slots().foo` will give you only the first. Having both `children` and `slots()` therefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by passing along `children`.\n\n## Template Compilation\n\nYou may be interested to know that Vue's templates actually compile to render functions. This is an implementation detail you usually don't need to know about, but if you'd like to see how specific template features are compiled, you may find it interesting. Below is a little demo using `Vue.compile` to live-compile a template string:\n\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-template-compilation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","date":"2020-09-25T23:55:41.139Z","updated":"2020-09-25T23:55:41.139Z","path":"v2/guide/render-function.html","comments":1,"layout":"page","_id":"ckfl66gyo002gc2v5oubntfao","content":"<h2 id=\"Basics\"><a href=\"#Basics\" class=\"headerlink\" title=\"Basics\"></a>Basics</h2><p>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That’s where you can use the <strong>render function</strong>, a closer-to-the-compiler alternative to templates.</p>\n<p>Let’s dive into a simple example where a <code>render</code> function would be practical. Say you want to generate anchored headings:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"hello-world\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#hello-world\"</span>&gt;</span>\n    Hello world!\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>For the HTML above, you decide you want this component interface:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">anchored-heading</span> <span class=\"hljs-attr\">:level</span>=<span class=\"hljs-string\">\"1\"</span>&gt;</span>Hello world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">anchored-heading</span>&gt;</span></code></pre>\n<p>When you get started with a component that only generates a heading based on the <code>level</code> prop, you quickly arrive at this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/x-template\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"anchored-heading-template\"</span>&gt;</span><span class=\"xml\">\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"level === 1\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 2\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 3\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 4\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h5</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 5\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h5</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h6</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 6\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h6</span>&gt;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'#anchored-heading-template'</span>,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">level</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>That template doesn’t feel great. It’s not only verbose, but we’re duplicating <code>&lt;slot&gt;&lt;/slot&gt;</code> for every heading level and will have to do the same when we add the anchor element.</p>\n<p>While templates work great for most components, it’s clear that this isn’t one of them. So let’s try rewriting it with a <code>render</code> function:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> createElement(\n      <span class=\"hljs-string\">'h'</span> + <span class=\"hljs-keyword\">this</span>.level,   <span class=\"hljs-comment\">// tag name</span>\n      <span class=\"hljs-keyword\">this</span>.$slots.default <span class=\"hljs-comment\">// array of children</span>\n    )\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">level</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a <code>v-slot</code> directive into a component, like the <code>Hello world!</code> inside of <code>anchored-heading</code>, those children are stored on the component instance at <code>$slots.default</code>. If you haven’t already, <strong>it’s recommended to read through the <a href=\"../api/#Instance-Properties\">instance properties API</a> before diving into render functions.</strong></p>\n<h2 id=\"Nodes-Trees-and-the-Virtual-DOM\"><a href=\"#Nodes-Trees-and-the-Virtual-DOM\" class=\"headerlink\" title=\"Nodes, Trees, and the Virtual DOM\"></a>Nodes, Trees, and the Virtual DOM</h2><p>Before we dive into render functions, it’s important to know a little about how browsers work. Take this HTML for example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>My title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  Some text content\n  <span class=\"hljs-comment\">&lt;!-- <span class=\"hljs-doctag\">TODO:</span> Add tagline  --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>When a browser reads this code, it builds a <a href=\"https://javascript.info/dom-nodes\" target=\"_blank\" rel=\"noopener\">tree of “DOM nodes”</a> to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</p>\n<p>The tree of DOM nodes for the HTML above looks like this:</p>\n<p><img src=\"/images/dom-tree.png\" alt=\"DOM Tree Visualization\"></p>\n<p>Every element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page. And as in a family tree, each node can have children (i.e. each piece can contain other pieces).</p>\n<p>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123; blogTitle &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>Or a render function:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'h1'</span>, <span class=\"hljs-keyword\">this</span>.blogTitle)\n&#125;</code></pre>\n<p>And in both cases, Vue automatically keeps the page updated, even when <code>blogTitle</code> changes.</p>\n<h3 id=\"The-Virtual-DOM\"><a href=\"#The-Virtual-DOM\" class=\"headerlink\" title=\"The Virtual DOM\"></a>The Virtual DOM</h3><p>Vue accomplishes this by building a <strong>virtual DOM</strong> to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'h1'</span>, <span class=\"hljs-keyword\">this</span>.blogTitle)</code></pre>\n<p>What is <code>createElement</code> actually returning? It’s not <em>exactly</em> a real DOM element. It could perhaps more accurately be named <code>createNodeDescription</code>, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a “virtual node”, usually abbreviated to <strong>VNode</strong>. “Virtual DOM” is what we call the entire tree of VNodes, built by a tree of Vue components.</p>\n<h2 id=\"createElement-Arguments\"><a href=\"#createElement-Arguments\" class=\"headerlink\" title=\"createElement Arguments\"></a><code>createElement</code> Arguments</h2><p>The next thing you’ll have to become familiar with is how to use template features in the <code>createElement</code> function. Here are the arguments that <code>createElement</code> accepts:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// @returns &#123;VNode&#125;</span>\ncreateElement(\n  <span class=\"hljs-comment\">// &#123;String | Object | Function&#125;</span>\n  <span class=\"hljs-comment\">// An HTML tag name, component options, or async</span>\n  <span class=\"hljs-comment\">// function resolving to one of these. Required.</span>\n  <span class=\"hljs-string\">'div'</span>,\n\n  <span class=\"hljs-comment\">// &#123;Object&#125;</span>\n  <span class=\"hljs-comment\">// A data object corresponding to the attributes</span>\n  <span class=\"hljs-comment\">// you would use in a template. Optional.</span>\n  &#123;\n    <span class=\"hljs-comment\">// (see details in the next section below)</span>\n  &#125;,\n\n  <span class=\"hljs-comment\">// &#123;String | Array&#125;</span>\n  <span class=\"hljs-comment\">// Children VNodes, built using `createElement()`,</span>\n  <span class=\"hljs-comment\">// or using strings to get 'text VNodes'. Optional.</span>\n  [\n    <span class=\"hljs-string\">'Some text comes first.'</span>,\n    createElement(<span class=\"hljs-string\">'h1'</span>, <span class=\"hljs-string\">'A headline'</span>),\n    createElement(MyComponent, &#123;\n      <span class=\"hljs-attr\">props</span>: &#123;\n        <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">'foobar'</span>\n      &#125;\n    &#125;)\n  ]\n)</code></pre>\n<h3 id=\"The-Data-Object-In-Depth\"><a href=\"#The-Data-Object-In-Depth\" class=\"headerlink\" title=\"The Data Object In-Depth\"></a>The Data Object In-Depth</h3><p>One thing to note: similar to how <code>v-bind:class</code> and <code>v-bind:style</code> have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as <code>innerHTML</code> (this would replace the <code>v-html</code> directive):</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-comment\">// Same API as `v-bind:class`, accepting either</span>\n  <span class=\"hljs-comment\">// a string, object, or array of strings and objects.</span>\n  <span class=\"hljs-attr\">class</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Same API as `v-bind:style`, accepting either</span>\n  <span class=\"hljs-comment\">// a string, object, or array of objects.</span>\n  <span class=\"hljs-attr\">style</span>: &#123;\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span>,\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">'14px'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Normal HTML attributes</span>\n  <span class=\"hljs-attr\">attrs</span>: &#123;\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'foo'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Component props</span>\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">myProp</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// DOM properties</span>\n  <span class=\"hljs-attr\">domProps</span>: &#123;\n    <span class=\"hljs-attr\">innerHTML</span>: <span class=\"hljs-string\">'baz'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Event handlers are nested under `on`, though</span>\n  <span class=\"hljs-comment\">// modifiers such as in `v-on:keyup.enter` are not</span>\n  <span class=\"hljs-comment\">// supported. You'll have to manually check the</span>\n  <span class=\"hljs-comment\">// keyCode in the handler instead.</span>\n  <span class=\"hljs-attr\">on</span>: &#123;\n    <span class=\"hljs-attr\">click</span>: <span class=\"hljs-keyword\">this</span>.clickHandler\n  &#125;,\n  <span class=\"hljs-comment\">// For components only. Allows you to listen to</span>\n  <span class=\"hljs-comment\">// native events, rather than events emitted from</span>\n  <span class=\"hljs-comment\">// the component using `vm.$emit`.</span>\n  <span class=\"hljs-attr\">nativeOn</span>: &#123;\n    <span class=\"hljs-attr\">click</span>: <span class=\"hljs-keyword\">this</span>.nativeClickHandler\n  &#125;,\n  <span class=\"hljs-comment\">// Custom directives. Note that the `binding`'s</span>\n  <span class=\"hljs-comment\">// `oldValue` cannot be set, as Vue keeps track</span>\n  <span class=\"hljs-comment\">// of it for you.</span>\n  <span class=\"hljs-attr\">directives</span>: [\n    &#123;\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'my-custom-directive'</span>,\n      <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'2'</span>,\n      <span class=\"hljs-attr\">expression</span>: <span class=\"hljs-string\">'1 + 1'</span>,\n      <span class=\"hljs-attr\">arg</span>: <span class=\"hljs-string\">'foo'</span>,\n      <span class=\"hljs-attr\">modifiers</span>: &#123;\n        <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-literal\">true</span>\n      &#125;\n    &#125;\n  ],\n  <span class=\"hljs-comment\">// Scoped slots in the form of</span>\n  <span class=\"hljs-comment\">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span>\n  <span class=\"hljs-attr\">scopedSlots</span>: &#123;\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> createElement(<span class=\"hljs-string\">'span'</span>, props.text)\n  &#125;,\n  <span class=\"hljs-comment\">// The name of the slot, if this component is the</span>\n  <span class=\"hljs-comment\">// child of another component</span>\n  <span class=\"hljs-attr\">slot</span>: <span class=\"hljs-string\">'name-of-slot'</span>,\n  <span class=\"hljs-comment\">// Other special top-level properties</span>\n  <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'myKey'</span>,\n  <span class=\"hljs-attr\">ref</span>: <span class=\"hljs-string\">'myRef'</span>,\n  <span class=\"hljs-comment\">// If you are applying the same ref name to multiple</span>\n  <span class=\"hljs-comment\">// elements in the render function. This will make `$refs.myRef` become an</span>\n  <span class=\"hljs-comment\">// array</span>\n  <span class=\"hljs-attr\">refInFor</span>: <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n<h3 id=\"Complete-Example\"><a href=\"#Complete-Example\" class=\"headerlink\" title=\"Complete Example\"></a>Complete Example</h3><p>With this knowledge, we can now finish the component we started:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> getChildrenTextContent = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">children</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> children.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">node</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> node.children\n      ? getChildrenTextContent(node.children)\n      : node.text\n  &#125;).join(<span class=\"hljs-string\">''</span>)\n&#125;\n\nVue.component(<span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-comment\">// create kebab-case id</span>\n    <span class=\"hljs-keyword\">var</span> headingId = getChildrenTextContent(<span class=\"hljs-keyword\">this</span>.$slots.default)\n      .toLowerCase()\n      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">'-'</span>)\n      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">''</span>)\n\n    <span class=\"hljs-keyword\">return</span> createElement(\n      <span class=\"hljs-string\">'h'</span> + <span class=\"hljs-keyword\">this</span>.level,\n      [\n        createElement(<span class=\"hljs-string\">'a'</span>, &#123;\n          <span class=\"hljs-attr\">attrs</span>: &#123;\n            <span class=\"hljs-attr\">name</span>: headingId,\n            <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">'#'</span> + headingId\n          &#125;\n        &#125;, <span class=\"hljs-keyword\">this</span>.$slots.default)\n      ]\n    )\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">level</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"Constraints\"><a href=\"#Constraints\" class=\"headerlink\" title=\"Constraints\"></a>Constraints</h3><h4 id=\"VNodes-Must-Be-Unique\"><a href=\"#VNodes-Must-Be-Unique\" class=\"headerlink\" title=\"VNodes Must Be Unique\"></a>VNodes Must Be Unique</h4><p>All VNodes in the component tree must be unique. That means the following render function is invalid:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> myParagraphVNode = createElement(<span class=\"hljs-string\">'p'</span>, <span class=\"hljs-string\">'hi'</span>)\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n    <span class=\"hljs-comment\">// Yikes - duplicate VNodes!</span>\n    myParagraphVNode, myParagraphVNode\n  ])\n&#125;</code></pre>\n<p>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>,\n    <span class=\"hljs-built_in\">Array</span>.apply(<span class=\"hljs-literal\">null</span>, &#123; <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">20</span> &#125;).map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'p'</span>, <span class=\"hljs-string\">'hi'</span>)\n    &#125;)\n  )\n&#125;</code></pre>\n<h2 id=\"Replacing-Template-Features-with-Plain-JavaScript\"><a href=\"#Replacing-Template-Features-with-Plain-JavaScript\" class=\"headerlink\" title=\"Replacing Template Features with Plain JavaScript\"></a>Replacing Template Features with Plain JavaScript</h2><h3 id=\"v-if-and-v-for\"><a href=\"#v-if-and-v-for\" class=\"headerlink\" title=\"v-if and v-for\"></a><code>v-if</code> and <code>v-for</code></h3><p>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using <code>v-if</code> and <code>v-for</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"items.length\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>No items found.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>This could be rewritten with JavaScript’s <code>if</code>/<code>else</code> and <code>map</code> in a render function:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'items'</span>],\n<span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.items.length) &#123;\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'ul'</span>, <span class=\"hljs-keyword\">this</span>.items.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'li'</span>, item.name)\n    &#125;))\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'p'</span>, <span class=\"hljs-string\">'No items found.'</span>)\n  &#125;\n&#125;</code></pre>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a><code>v-model</code></h3><p>There is no direct <code>v-model</code> counterpart in render functions - you will have to implement the logic yourself:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'value'</span>],\n<span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'input'</span>, &#123;\n    <span class=\"hljs-attr\">domProps</span>: &#123;\n      <span class=\"hljs-attr\">value</span>: self.value\n    &#125;,\n    <span class=\"hljs-attr\">on</span>: &#123;\n      <span class=\"hljs-attr\">input</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n        self.$emit(<span class=\"hljs-string\">'input'</span>, event.target.value)\n      &#125;\n    &#125;\n  &#125;)\n&#125;</code></pre>\n<p>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to <code>v-model</code>.</p>\n<h3 id=\"Event-amp-Key-Modifiers\"><a href=\"#Event-amp-Key-Modifiers\" class=\"headerlink\" title=\"Event &amp; Key Modifiers\"></a>Event &amp; Key Modifiers</h3><p>For the <code>.passive</code>, <code>.capture</code> and <code>.once</code> event modifiers, Vue offers prefixes that can be used with <code>on</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Prefix</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.passive</code></td>\n<td><code>&amp;</code></td>\n</tr>\n<tr>\n<td><code>.capture</code></td>\n<td><code>!</code></td>\n</tr>\n<tr>\n<td><code>.once</code></td>\n<td><code>~</code></td>\n</tr>\n<tr>\n<td><code>.capture.once</code> or<br><code>.once.capture</code></td>\n<td><code>~!</code></td>\n</tr>\n</tbody>\n</table>\n<p>For example:</p>\n<pre><code class=\"hljs javascript\">on: &#123;\n  <span class=\"hljs-string\">'!click'</span>: <span class=\"hljs-keyword\">this</span>.doThisInCapturingMode,\n  <span class=\"hljs-string\">'~keyup'</span>: <span class=\"hljs-keyword\">this</span>.doThisOnce,\n  <span class=\"hljs-string\">'~!mouseover'</span>: <span class=\"hljs-keyword\">this</span>.doThisOnceInCapturingMode\n&#125;</code></pre>\n<p>For all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the handler:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Equivalent in Handler</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.stop</code></td>\n<td><code>event.stopPropagation()</code></td>\n</tr>\n<tr>\n<td><code>.prevent</code></td>\n<td><code>event.preventDefault()</code></td>\n</tr>\n<tr>\n<td><code>.self</code></td>\n<td><code>if (event.target !== event.currentTarget) return</code></td>\n</tr>\n<tr>\n<td>Keys:<br><code>.enter</code>, <code>.13</code></td>\n<td><code>if (event.keyCode !== 13) return</code> (change <code>13</code> to <a href=\"http://keycode.info/\" target=\"_blank\" rel=\"noopener\">another key code</a> for other key modifiers)</td>\n</tr>\n<tr>\n<td>Modifiers Keys:<br><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>\n<td><code>if (!event.ctrlKey) return</code> (change <code>ctrlKey</code> to <code>altKey</code>, <code>shiftKey</code>, or <code>metaKey</code>, respectively)</td>\n</tr>\n</tbody>\n</table>\n<p>Here’s an example with all of these modifiers used together:</p>\n<pre><code class=\"hljs javascript\">on: &#123;\n  <span class=\"hljs-attr\">keyup</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n    <span class=\"hljs-comment\">// Abort if the element emitting the event is not</span>\n    <span class=\"hljs-comment\">// the element the event is bound to</span>\n    <span class=\"hljs-keyword\">if</span> (event.target !== event.currentTarget) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-comment\">// Abort if the key that went up is not the enter</span>\n    <span class=\"hljs-comment\">// key (13) and the shift key was not held down</span>\n    <span class=\"hljs-comment\">// at the same time</span>\n    <span class=\"hljs-keyword\">if</span> (!event.shiftKey || event.keyCode !== <span class=\"hljs-number\">13</span>) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-comment\">// Stop event propagation</span>\n    event.stopPropagation()\n    <span class=\"hljs-comment\">// Prevent the default keyup handler for this element</span>\n    event.preventDefault()\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h3><p>You can access static slot contents as Arrays of VNodes from <a href=\"../api/#vm-slots\"><code>this.$slots</code></a>:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, <span class=\"hljs-keyword\">this</span>.$slots.default)\n&#125;</code></pre>\n<p>And access scoped slots as functions that return VNodes from <a href=\"../api/#vm-scopedSlots\"><code>this.$scopedSlots</code></a>:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'message'</span>],\n<span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `&lt;div&gt;&lt;slot :text=\"message\"&gt;&lt;/slot&gt;&lt;/div&gt;`</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n    <span class=\"hljs-keyword\">this</span>.$scopedSlots.default(&#123;\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-keyword\">this</span>.message\n    &#125;)\n  ])\n&#125;</code></pre>\n<p>To pass scoped slots to a child component using render functions, use the <code>scopedSlots</code> field in VNode data:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `&lt;div&gt;&lt;child v-slot=\"props\"&gt;&lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;`</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n    createElement(<span class=\"hljs-string\">'child'</span>, &#123;\n      <span class=\"hljs-comment\">// pass `scopedSlots` in the data object</span>\n      <span class=\"hljs-comment\">// in the form of &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span>\n      <span class=\"hljs-attr\">scopedSlots</span>: &#123;\n        <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">props</span>) </span>&#123;\n          <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'span'</span>, props.text)\n        &#125;\n      &#125;\n    &#125;)\n  ])\n&#125;</code></pre>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>If you’re writing a lot of <code>render</code> functions, it might feel painful to write something like this:</p>\n<pre><code class=\"hljs js\">createElement(\n  <span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n    <span class=\"hljs-attr\">props</span>: &#123;\n      <span class=\"hljs-attr\">level</span>: <span class=\"hljs-number\">1</span>\n    &#125;\n  &#125;, [\n    createElement(<span class=\"hljs-string\">'span'</span>, <span class=\"hljs-string\">'Hello'</span>),\n    <span class=\"hljs-string\">' world!'</span>\n  ]\n)</code></pre>\n<p>Especially when the template version is so simple in comparison:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">anchored-heading</span> <span class=\"hljs-attr\">:level</span>=<span class=\"hljs-string\">\"1\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span> world!\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">anchored-heading</span>&gt;</span></code></pre>\n<p>That’s why there’s a <a href=\"https://github.com/vuejs/jsx\" target=\"_blank\" rel=\"noopener\">Babel plugin</a> to use JSX with Vue, getting us back to a syntax that’s closer to templates:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> AnchoredHeading <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./AnchoredHeading.vue'</span>\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#demo'</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">h</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AnchoredHeading</span> <span class=\"hljs-attr\">level</span>=<span class=\"hljs-string\">&#123;1&#125;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span> world!\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">AnchoredHeading</span>&gt;</span></span>\n    )\n  &#125;\n&#125;)</code></pre>\n<p class=\"tip\">Aliasing <code>createElement</code> to <code>h</code> is a common convention you’ll see in the Vue ecosystem and is actually required for JSX. Starting with <a href=\"https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection\" target=\"_blank\" rel=\"noopener\">version 3.4.0</a> of the Babel plugin for Vue, we automatically inject <code>const h = this.$createElement</code> in any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the <code>(h)</code> parameter. With prior versions of the plugin, your app would throw an error if <code>h</code> was not available in the scope.</p>\n\n<p>For more on how JSX maps to JavaScript, see the <a href=\"https://github.com/vuejs/jsx#installation\" target=\"_blank\" rel=\"noopener\">usage docs</a>.</p>\n<h2 id=\"Functional-Components\"><a href=\"#Functional-Components\" class=\"headerlink\" title=\"Functional Components\"></a>Functional Components</h2><p>The anchored heading component we created earlier is relatively simple. It doesn’t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it’s only a function with some props.</p>\n<p>In cases like this, we can mark components as <code>functional</code>, which means that they’re stateless (no <a href=\"../api/#Options-Data\">reactive data</a>) and instanceless (no <code>this</code> context). A <strong>functional component</strong> looks like this:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">functional</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-comment\">// Props are optional</span>\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n  <span class=\"hljs-comment\">// To compensate for the lack of an instance,</span>\n  <span class=\"hljs-comment\">// we are now provided a 2nd context argument.</span>\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement, context</span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;)</code></pre>\n<blockquote>\n<p>Note: in versions before 2.3.0, the <code>props</code> option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the <code>props</code> option and all attributes found on the component node will be implicitly extracted as props.</p>\n<p>The reference will be HTMLElement when used with functional components because they’re stateless and instanceless.</p>\n</blockquote>\n<p>In 2.5.0+, if you are using <a href=\"single-file-components.html\">single-file components</a>, template-based functional components can be declared with:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">functional</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Everything the component needs is passed through <code>context</code>, which is an object containing:</p>\n<ul>\n<li><code>props</code>: An object of the provided props</li>\n<li><code>children</code>: An array of the VNode children</li>\n<li><code>slots</code>: A function returning a slots object</li>\n<li><code>scopedSlots</code>: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as functions.</li>\n<li><code>data</code>: The entire <a href=\"#The-Data-Object-In-Depth\">data object</a>, passed to the component as the 2nd argument of <code>createElement</code></li>\n<li><code>parent</code>: A reference to the parent component</li>\n<li><code>listeners</code>: (2.3.0+) An object containing parent-registered event listeners. This is an alias to <code>data.on</code></li>\n<li><code>injections</code>: (2.3.0+) if using the <a href=\"../api/#provide-inject\"><code>inject</code></a> option, this will contain resolved injections.</li>\n</ul>\n<p>After adding <code>functional: true</code>, updating the render function of our anchored heading component would require adding the <code>context</code> argument, updating <code>this.$slots.default</code> to <code>context.children</code>, then updating <code>this.level</code> to <code>context.props.level</code>.</p>\n<p>Since functional components are just functions, they’re much cheaper to render.</p>\n<p>They’re also very useful as wrapper components. For example, when you need to:</p>\n<ul>\n<li>Programmatically choose one of several other components to delegate to</li>\n<li>Manipulate children, props, or data before passing them on to a child component</li>\n</ul>\n<p>Here’s an example of a <code>smart-list</code> component that delegates to more specific components, depending on the props passed to it:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> EmptyList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> TableList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> OrderedList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> UnorderedList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n\nVue.component(<span class=\"hljs-string\">'smart-list'</span>, &#123;\n  <span class=\"hljs-attr\">functional</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">items</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Array</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">isOrdered</span>: <span class=\"hljs-built_in\">Boolean</span>\n  &#125;,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement, context</span>) </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">appropriateListComponent</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> items = context.props.items\n\n      <span class=\"hljs-keyword\">if</span> (items.length === <span class=\"hljs-number\">0</span>)           <span class=\"hljs-keyword\">return</span> EmptyList\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> items[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">'object'</span>) <span class=\"hljs-keyword\">return</span> TableList\n      <span class=\"hljs-keyword\">if</span> (context.props.isOrdered)      <span class=\"hljs-keyword\">return</span> OrderedList\n\n      <span class=\"hljs-keyword\">return</span> UnorderedList\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> createElement(\n      appropriateListComponent(),\n      context.data,\n      context.children\n    )\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"Passing-Attributes-and-Events-to-Child-Elements-Components\"><a href=\"#Passing-Attributes-and-Events-to-Child-Elements-Components\" class=\"headerlink\" title=\"Passing Attributes and Events to Child Elements/Components\"></a>Passing Attributes and Events to Child Elements/Components</h3><p>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or <a href=\"class-and-style.html\">intelligently merging with</a> any existing attributes of the same name.</p>\n<p>Functional components, however, require you to explicitly define this behavior:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-functional-button'</span>, &#123;\n  <span class=\"hljs-attr\">functional</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement, context</span>) </span>&#123;\n    <span class=\"hljs-comment\">// Transparently pass any attributes, event listeners, children, etc.</span>\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'button'</span>, context.data, context.children)\n  &#125;\n&#125;)</code></pre>\n<p>By passing <code>context.data</code> as the second argument to <code>createElement</code>, we are passing down any attributes or event listeners used on <code>my-functional-button</code>. It’s so transparent, in fact, that events don’t even require the <code>.native</code> modifier.</p>\n<p>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use <code>data.attrs</code> to pass along any HTML attributes and <code>listeners</code> <em>(the alias for <code>data.on</code>)</em> to pass along any event listeners.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">functional</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n    <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-primary\"</span>\n    <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"data.attrs\"</span>\n    <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"listeners\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<h3 id=\"slots-vs-children\"><a href=\"#slots-vs-children\" class=\"headerlink\" title=\"slots() vs children\"></a><code>slots()</code> vs <code>children</code></h3><p>You may wonder why we need both <code>slots()</code> and <code>children</code>. Wouldn’t <code>slots().default</code> be the same as <code>children</code>? In some cases, yes - but what if you have a functional component with the following children?</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-functional-component</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-slot:foo</span>&gt;</span>\n    first\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>second<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-functional-component</span>&gt;</span></code></pre>\n<p>For this component, <code>children</code> will give you both paragraphs, <code>slots().default</code> will give you only the second, and <code>slots().foo</code> will give you only the first. Having both <code>children</code> and <code>slots()</code> therefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by passing along <code>children</code>.</p>\n<h2 id=\"Template-Compilation\"><a href=\"#Template-Compilation\" class=\"headerlink\" title=\"Template Compilation\"></a>Template Compilation</h2><p>You may be interested to know that Vue’s templates actually compile to render functions. This is an implementation detail you usually don’t need to know about, but if you’d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using <code>Vue.compile</code> to live-compile a template string:</p>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-template-compilation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Basics\"><a href=\"#Basics\" class=\"headerlink\" title=\"Basics\"></a>Basics</h2><p>Vue recommends using templates to build your HTML in the vast majority of cases. There are situations however, where you really need the full programmatic power of JavaScript. That’s where you can use the <strong>render function</strong>, a closer-to-the-compiler alternative to templates.</p>\n<p>Let’s dive into a simple example where a <code>render</code> function would be practical. Say you want to generate anchored headings:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"hello-world\"</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">\"#hello-world\"</span>&gt;</span>\n    Hello world!\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>For the HTML above, you decide you want this component interface:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">anchored-heading</span> <span class=\"hljs-attr\">:level</span>=<span class=\"hljs-string\">\"1\"</span>&gt;</span>Hello world!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">anchored-heading</span>&gt;</span></code></pre>\n<p>When you get started with a component that only generates a heading based on the <code>level</code> prop, you quickly arrive at this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text/x-template\"</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"anchored-heading-template\"</span>&gt;</span><span class=\"xml\">\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"level === 1\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h2</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 2\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h2</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h3</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 3\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h3</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h4</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 4\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h4</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h5</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 5\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h5</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h6</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"level === 6\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h6</span>&gt;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'#anchored-heading-template'</span>,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">level</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>That template doesn’t feel great. It’s not only verbose, but we’re duplicating <code>&lt;slot&gt;&lt;/slot&gt;</code> for every heading level and will have to do the same when we add the anchor element.</p>\n<p>While templates work great for most components, it’s clear that this isn’t one of them. So let’s try rewriting it with a <code>render</code> function:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> createElement(\n      <span class=\"hljs-string\">'h'</span> + <span class=\"hljs-keyword\">this</span>.level,   <span class=\"hljs-comment\">// tag name</span>\n      <span class=\"hljs-keyword\">this</span>.$slots.default <span class=\"hljs-comment\">// array of children</span>\n    )\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">level</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Much simpler! Sort of. The code is shorter, but also requires greater familiarity with Vue instance properties. In this case, you have to know that when you pass children without a <code>v-slot</code> directive into a component, like the <code>Hello world!</code> inside of <code>anchored-heading</code>, those children are stored on the component instance at <code>$slots.default</code>. If you haven’t already, <strong>it’s recommended to read through the <a href=\"../api/#Instance-Properties\">instance properties API</a> before diving into render functions.</strong></p>\n<h2 id=\"Nodes-Trees-and-the-Virtual-DOM\"><a href=\"#Nodes-Trees-and-the-Virtual-DOM\" class=\"headerlink\" title=\"Nodes, Trees, and the Virtual DOM\"></a>Nodes, Trees, and the Virtual DOM</h2><p>Before we dive into render functions, it’s important to know a little about how browsers work. Take this HTML for example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>My title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  Some text content\n  <span class=\"hljs-comment\">&lt;!-- <span class=\"hljs-doctag\">TODO:</span> Add tagline  --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>When a browser reads this code, it builds a <a href=\"https://javascript.info/dom-nodes\" target=\"_blank\" rel=\"noopener\">tree of “DOM nodes”</a> to help it keep track of everything, just as you might build a family tree to keep track of your extended family.</p>\n<p>The tree of DOM nodes for the HTML above looks like this:</p>\n<p><img src=\"/images/dom-tree.png\" alt=\"DOM Tree Visualization\"></p>\n<p>Every element is a node. Every piece of text is a node. Even comments are nodes! A node is just a piece of the page. And as in a family tree, each node can have children (i.e. each piece can contain other pieces).</p>\n<p>Updating all these nodes efficiently can be difficult, but thankfully, you never have to do it manually. Instead, you tell Vue what HTML you want on the page, in a template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123; blogTitle &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span></code></pre>\n<p>Or a render function:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'h1'</span>, <span class=\"hljs-keyword\">this</span>.blogTitle)\n&#125;</code></pre>\n<p>And in both cases, Vue automatically keeps the page updated, even when <code>blogTitle</code> changes.</p>\n<h3 id=\"The-Virtual-DOM\"><a href=\"#The-Virtual-DOM\" class=\"headerlink\" title=\"The Virtual DOM\"></a>The Virtual DOM</h3><p>Vue accomplishes this by building a <strong>virtual DOM</strong> to keep track of the changes it needs to make to the real DOM. Taking a closer look at this line:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'h1'</span>, <span class=\"hljs-keyword\">this</span>.blogTitle)</code></pre>\n<p>What is <code>createElement</code> actually returning? It’s not <em>exactly</em> a real DOM element. It could perhaps more accurately be named <code>createNodeDescription</code>, as it contains information describing to Vue what kind of node it should render on the page, including descriptions of any child nodes. We call this node description a “virtual node”, usually abbreviated to <strong>VNode</strong>. “Virtual DOM” is what we call the entire tree of VNodes, built by a tree of Vue components.</p>\n<h2 id=\"createElement-Arguments\"><a href=\"#createElement-Arguments\" class=\"headerlink\" title=\"createElement Arguments\"></a><code>createElement</code> Arguments</h2><p>The next thing you’ll have to become familiar with is how to use template features in the <code>createElement</code> function. Here are the arguments that <code>createElement</code> accepts:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// @returns &#123;VNode&#125;</span>\ncreateElement(\n  <span class=\"hljs-comment\">// &#123;String | Object | Function&#125;</span>\n  <span class=\"hljs-comment\">// An HTML tag name, component options, or async</span>\n  <span class=\"hljs-comment\">// function resolving to one of these. Required.</span>\n  <span class=\"hljs-string\">'div'</span>,\n\n  <span class=\"hljs-comment\">// &#123;Object&#125;</span>\n  <span class=\"hljs-comment\">// A data object corresponding to the attributes</span>\n  <span class=\"hljs-comment\">// you would use in a template. Optional.</span>\n  &#123;\n    <span class=\"hljs-comment\">// (see details in the next section below)</span>\n  &#125;,\n\n  <span class=\"hljs-comment\">// &#123;String | Array&#125;</span>\n  <span class=\"hljs-comment\">// Children VNodes, built using `createElement()`,</span>\n  <span class=\"hljs-comment\">// or using strings to get 'text VNodes'. Optional.</span>\n  [\n    <span class=\"hljs-string\">'Some text comes first.'</span>,\n    createElement(<span class=\"hljs-string\">'h1'</span>, <span class=\"hljs-string\">'A headline'</span>),\n    createElement(MyComponent, &#123;\n      <span class=\"hljs-attr\">props</span>: &#123;\n        <span class=\"hljs-attr\">someProp</span>: <span class=\"hljs-string\">'foobar'</span>\n      &#125;\n    &#125;)\n  ]\n)</code></pre>\n<h3 id=\"The-Data-Object-In-Depth\"><a href=\"#The-Data-Object-In-Depth\" class=\"headerlink\" title=\"The Data Object In-Depth\"></a>The Data Object In-Depth</h3><p>One thing to note: similar to how <code>v-bind:class</code> and <code>v-bind:style</code> have special treatment in templates, they have their own top-level fields in VNode data objects. This object also allows you to bind normal HTML attributes as well as DOM properties such as <code>innerHTML</code> (this would replace the <code>v-html</code> directive):</p>\n<pre><code class=\"hljs js\">&#123;\n  <span class=\"hljs-comment\">// Same API as `v-bind:class`, accepting either</span>\n  <span class=\"hljs-comment\">// a string, object, or array of strings and objects.</span>\n  <span class=\"hljs-attr\">class</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Same API as `v-bind:style`, accepting either</span>\n  <span class=\"hljs-comment\">// a string, object, or array of objects.</span>\n  <span class=\"hljs-attr\">style</span>: &#123;\n    <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span>,\n    <span class=\"hljs-attr\">fontSize</span>: <span class=\"hljs-string\">'14px'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Normal HTML attributes</span>\n  <span class=\"hljs-attr\">attrs</span>: &#123;\n    <span class=\"hljs-attr\">id</span>: <span class=\"hljs-string\">'foo'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Component props</span>\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">myProp</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// DOM properties</span>\n  <span class=\"hljs-attr\">domProps</span>: &#123;\n    <span class=\"hljs-attr\">innerHTML</span>: <span class=\"hljs-string\">'baz'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// Event handlers are nested under `on`, though</span>\n  <span class=\"hljs-comment\">// modifiers such as in `v-on:keyup.enter` are not</span>\n  <span class=\"hljs-comment\">// supported. You'll have to manually check the</span>\n  <span class=\"hljs-comment\">// keyCode in the handler instead.</span>\n  <span class=\"hljs-attr\">on</span>: &#123;\n    <span class=\"hljs-attr\">click</span>: <span class=\"hljs-keyword\">this</span>.clickHandler\n  &#125;,\n  <span class=\"hljs-comment\">// For components only. Allows you to listen to</span>\n  <span class=\"hljs-comment\">// native events, rather than events emitted from</span>\n  <span class=\"hljs-comment\">// the component using `vm.$emit`.</span>\n  <span class=\"hljs-attr\">nativeOn</span>: &#123;\n    <span class=\"hljs-attr\">click</span>: <span class=\"hljs-keyword\">this</span>.nativeClickHandler\n  &#125;,\n  <span class=\"hljs-comment\">// Custom directives. Note that the `binding`'s</span>\n  <span class=\"hljs-comment\">// `oldValue` cannot be set, as Vue keeps track</span>\n  <span class=\"hljs-comment\">// of it for you.</span>\n  <span class=\"hljs-attr\">directives</span>: [\n    &#123;\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'my-custom-directive'</span>,\n      <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">'2'</span>,\n      <span class=\"hljs-attr\">expression</span>: <span class=\"hljs-string\">'1 + 1'</span>,\n      <span class=\"hljs-attr\">arg</span>: <span class=\"hljs-string\">'foo'</span>,\n      <span class=\"hljs-attr\">modifiers</span>: &#123;\n        <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-literal\">true</span>\n      &#125;\n    &#125;\n  ],\n  <span class=\"hljs-comment\">// Scoped slots in the form of</span>\n  <span class=\"hljs-comment\">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span>\n  <span class=\"hljs-attr\">scopedSlots</span>: &#123;\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">props</span> =&gt;</span> createElement(<span class=\"hljs-string\">'span'</span>, props.text)\n  &#125;,\n  <span class=\"hljs-comment\">// The name of the slot, if this component is the</span>\n  <span class=\"hljs-comment\">// child of another component</span>\n  <span class=\"hljs-attr\">slot</span>: <span class=\"hljs-string\">'name-of-slot'</span>,\n  <span class=\"hljs-comment\">// Other special top-level properties</span>\n  <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">'myKey'</span>,\n  <span class=\"hljs-attr\">ref</span>: <span class=\"hljs-string\">'myRef'</span>,\n  <span class=\"hljs-comment\">// If you are applying the same ref name to multiple</span>\n  <span class=\"hljs-comment\">// elements in the render function. This will make `$refs.myRef` become an</span>\n  <span class=\"hljs-comment\">// array</span>\n  <span class=\"hljs-attr\">refInFor</span>: <span class=\"hljs-literal\">true</span>\n&#125;</code></pre>\n<h3 id=\"Complete-Example\"><a href=\"#Complete-Example\" class=\"headerlink\" title=\"Complete Example\"></a>Complete Example</h3><p>With this knowledge, we can now finish the component we started:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> getChildrenTextContent = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">children</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> children.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">node</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> node.children\n      ? getChildrenTextContent(node.children)\n      : node.text\n  &#125;).join(<span class=\"hljs-string\">''</span>)\n&#125;\n\nVue.component(<span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-comment\">// create kebab-case id</span>\n    <span class=\"hljs-keyword\">var</span> headingId = getChildrenTextContent(<span class=\"hljs-keyword\">this</span>.$slots.default)\n      .toLowerCase()\n      .replace(<span class=\"hljs-regexp\">/\\W+/g</span>, <span class=\"hljs-string\">'-'</span>)\n      .replace(<span class=\"hljs-regexp\">/(^-|-$)/g</span>, <span class=\"hljs-string\">''</span>)\n\n    <span class=\"hljs-keyword\">return</span> createElement(\n      <span class=\"hljs-string\">'h'</span> + <span class=\"hljs-keyword\">this</span>.level,\n      [\n        createElement(<span class=\"hljs-string\">'a'</span>, &#123;\n          <span class=\"hljs-attr\">attrs</span>: &#123;\n            <span class=\"hljs-attr\">name</span>: headingId,\n            <span class=\"hljs-attr\">href</span>: <span class=\"hljs-string\">'#'</span> + headingId\n          &#125;\n        &#125;, <span class=\"hljs-keyword\">this</span>.$slots.default)\n      ]\n    )\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">level</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"Constraints\"><a href=\"#Constraints\" class=\"headerlink\" title=\"Constraints\"></a>Constraints</h3><h4 id=\"VNodes-Must-Be-Unique\"><a href=\"#VNodes-Must-Be-Unique\" class=\"headerlink\" title=\"VNodes Must Be Unique\"></a>VNodes Must Be Unique</h4><p>All VNodes in the component tree must be unique. That means the following render function is invalid:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> myParagraphVNode = createElement(<span class=\"hljs-string\">'p'</span>, <span class=\"hljs-string\">'hi'</span>)\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n    <span class=\"hljs-comment\">// Yikes - duplicate VNodes!</span>\n    myParagraphVNode, myParagraphVNode\n  ])\n&#125;</code></pre>\n<p>If you really want to duplicate the same element/component many times, you can do so with a factory function. For example, the following render function is a perfectly valid way of rendering 20 identical paragraphs:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>,\n    <span class=\"hljs-built_in\">Array</span>.apply(<span class=\"hljs-literal\">null</span>, &#123; <span class=\"hljs-attr\">length</span>: <span class=\"hljs-number\">20</span> &#125;).map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'p'</span>, <span class=\"hljs-string\">'hi'</span>)\n    &#125;)\n  )\n&#125;</code></pre>\n<h2 id=\"Replacing-Template-Features-with-Plain-JavaScript\"><a href=\"#Replacing-Template-Features-with-Plain-JavaScript\" class=\"headerlink\" title=\"Replacing Template Features with Plain JavaScript\"></a>Replacing Template Features with Plain JavaScript</h2><h3 id=\"v-if-and-v-for\"><a href=\"#v-if-and-v-for\" class=\"headerlink\" title=\"v-if and v-for\"></a><code>v-if</code> and <code>v-for</code></h3><p>Wherever something can be easily accomplished in plain JavaScript, Vue render functions do not provide a proprietary alternative. For example, in a template using <code>v-if</code> and <code>v-for</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"items.length\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>No items found.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>This could be rewritten with JavaScript’s <code>if</code>/<code>else</code> and <code>map</code> in a render function:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'items'</span>],\n<span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.items.length) &#123;\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'ul'</span>, <span class=\"hljs-keyword\">this</span>.items.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'li'</span>, item.name)\n    &#125;))\n  &#125; <span class=\"hljs-keyword\">else</span> &#123;\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'p'</span>, <span class=\"hljs-string\">'No items found.'</span>)\n  &#125;\n&#125;</code></pre>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a><code>v-model</code></h3><p>There is no direct <code>v-model</code> counterpart in render functions - you will have to implement the logic yourself:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'value'</span>],\n<span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'input'</span>, &#123;\n    <span class=\"hljs-attr\">domProps</span>: &#123;\n      <span class=\"hljs-attr\">value</span>: self.value\n    &#125;,\n    <span class=\"hljs-attr\">on</span>: &#123;\n      <span class=\"hljs-attr\">input</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n        self.$emit(<span class=\"hljs-string\">'input'</span>, event.target.value)\n      &#125;\n    &#125;\n  &#125;)\n&#125;</code></pre>\n<p>This is the cost of going lower-level, but it also gives you much more control over the interaction details compared to <code>v-model</code>.</p>\n<h3 id=\"Event-amp-Key-Modifiers\"><a href=\"#Event-amp-Key-Modifiers\" class=\"headerlink\" title=\"Event &amp; Key Modifiers\"></a>Event &amp; Key Modifiers</h3><p>For the <code>.passive</code>, <code>.capture</code> and <code>.once</code> event modifiers, Vue offers prefixes that can be used with <code>on</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Prefix</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.passive</code></td>\n<td><code>&amp;</code></td>\n</tr>\n<tr>\n<td><code>.capture</code></td>\n<td><code>!</code></td>\n</tr>\n<tr>\n<td><code>.once</code></td>\n<td><code>~</code></td>\n</tr>\n<tr>\n<td><code>.capture.once</code> or<br><code>.once.capture</code></td>\n<td><code>~!</code></td>\n</tr>\n</tbody>\n</table>\n<p>For example:</p>\n<pre><code class=\"hljs javascript\">on: &#123;\n  <span class=\"hljs-string\">'!click'</span>: <span class=\"hljs-keyword\">this</span>.doThisInCapturingMode,\n  <span class=\"hljs-string\">'~keyup'</span>: <span class=\"hljs-keyword\">this</span>.doThisOnce,\n  <span class=\"hljs-string\">'~!mouseover'</span>: <span class=\"hljs-keyword\">this</span>.doThisOnceInCapturingMode\n&#125;</code></pre>\n<p>For all other event and key modifiers, no proprietary prefix is necessary, because you can use event methods in the handler:</p>\n<table>\n<thead>\n<tr>\n<th>Modifier(s)</th>\n<th>Equivalent in Handler</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.stop</code></td>\n<td><code>event.stopPropagation()</code></td>\n</tr>\n<tr>\n<td><code>.prevent</code></td>\n<td><code>event.preventDefault()</code></td>\n</tr>\n<tr>\n<td><code>.self</code></td>\n<td><code>if (event.target !== event.currentTarget) return</code></td>\n</tr>\n<tr>\n<td>Keys:<br><code>.enter</code>, <code>.13</code></td>\n<td><code>if (event.keyCode !== 13) return</code> (change <code>13</code> to <a href=\"http://keycode.info/\" target=\"_blank\" rel=\"noopener\">another key code</a> for other key modifiers)</td>\n</tr>\n<tr>\n<td>Modifiers Keys:<br><code>.ctrl</code>, <code>.alt</code>, <code>.shift</code>, <code>.meta</code></td>\n<td><code>if (!event.ctrlKey) return</code> (change <code>ctrlKey</code> to <code>altKey</code>, <code>shiftKey</code>, or <code>metaKey</code>, respectively)</td>\n</tr>\n</tbody>\n</table>\n<p>Here’s an example with all of these modifiers used together:</p>\n<pre><code class=\"hljs javascript\">on: &#123;\n  <span class=\"hljs-attr\">keyup</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>&#123;\n    <span class=\"hljs-comment\">// Abort if the element emitting the event is not</span>\n    <span class=\"hljs-comment\">// the element the event is bound to</span>\n    <span class=\"hljs-keyword\">if</span> (event.target !== event.currentTarget) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-comment\">// Abort if the key that went up is not the enter</span>\n    <span class=\"hljs-comment\">// key (13) and the shift key was not held down</span>\n    <span class=\"hljs-comment\">// at the same time</span>\n    <span class=\"hljs-keyword\">if</span> (!event.shiftKey || event.keyCode !== <span class=\"hljs-number\">13</span>) <span class=\"hljs-keyword\">return</span>\n    <span class=\"hljs-comment\">// Stop event propagation</span>\n    event.stopPropagation()\n    <span class=\"hljs-comment\">// Prevent the default keyup handler for this element</span>\n    event.preventDefault()\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n<h3 id=\"Slots\"><a href=\"#Slots\" class=\"headerlink\" title=\"Slots\"></a>Slots</h3><p>You can access static slot contents as Arrays of VNodes from <a href=\"../api/#vm-slots\"><code>this.$slots</code></a>:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, <span class=\"hljs-keyword\">this</span>.$slots.default)\n&#125;</code></pre>\n<p>And access scoped slots as functions that return VNodes from <a href=\"../api/#vm-scopedSlots\"><code>this.$scopedSlots</code></a>:</p>\n<pre><code class=\"hljs js\">props: [<span class=\"hljs-string\">'message'</span>],\n<span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `&lt;div&gt;&lt;slot :text=\"message\"&gt;&lt;/slot&gt;&lt;/div&gt;`</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n    <span class=\"hljs-keyword\">this</span>.$scopedSlots.default(&#123;\n      <span class=\"hljs-attr\">text</span>: <span class=\"hljs-keyword\">this</span>.message\n    &#125;)\n  ])\n&#125;</code></pre>\n<p>To pass scoped slots to a child component using render functions, use the <code>scopedSlots</code> field in VNode data:</p>\n<pre><code class=\"hljs js\">render: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `&lt;div&gt;&lt;child v-slot=\"props\"&gt;&lt;span&gt;&#123;&#123; props.text &#125;&#125;&lt;/span&gt;&lt;/child&gt;&lt;/div&gt;`</span>\n  <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n    createElement(<span class=\"hljs-string\">'child'</span>, &#123;\n      <span class=\"hljs-comment\">// pass `scopedSlots` in the data object</span>\n      <span class=\"hljs-comment\">// in the form of &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span>\n      <span class=\"hljs-attr\">scopedSlots</span>: &#123;\n        <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">props</span>) </span>&#123;\n          <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'span'</span>, props.text)\n        &#125;\n      &#125;\n    &#125;)\n  ])\n&#125;</code></pre>\n<h2 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h2><p>If you’re writing a lot of <code>render</code> functions, it might feel painful to write something like this:</p>\n<pre><code class=\"hljs js\">createElement(\n  <span class=\"hljs-string\">'anchored-heading'</span>, &#123;\n    <span class=\"hljs-attr\">props</span>: &#123;\n      <span class=\"hljs-attr\">level</span>: <span class=\"hljs-number\">1</span>\n    &#125;\n  &#125;, [\n    createElement(<span class=\"hljs-string\">'span'</span>, <span class=\"hljs-string\">'Hello'</span>),\n    <span class=\"hljs-string\">' world!'</span>\n  ]\n)</code></pre>\n<p>Especially when the template version is so simple in comparison:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">anchored-heading</span> <span class=\"hljs-attr\">:level</span>=<span class=\"hljs-string\">\"1\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span> world!\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">anchored-heading</span>&gt;</span></code></pre>\n<p>That’s why there’s a <a href=\"https://github.com/vuejs/jsx\" target=\"_blank\" rel=\"noopener\">Babel plugin</a> to use JSX with Vue, getting us back to a syntax that’s closer to templates:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> AnchoredHeading <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./AnchoredHeading.vue'</span>\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#demo'</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">h</span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AnchoredHeading</span> <span class=\"hljs-attr\">level</span>=<span class=\"hljs-string\">&#123;1&#125;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span> world!\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">AnchoredHeading</span>&gt;</span></span>\n    )\n  &#125;\n&#125;)</code></pre>\n<p class=\"tip\">Aliasing <code>createElement</code> to <code>h</code> is a common convention you’ll see in the Vue ecosystem and is actually required for JSX. Starting with <a href=\"https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection\" target=\"_blank\" rel=\"noopener\">version 3.4.0</a> of the Babel plugin for Vue, we automatically inject <code>const h = this.$createElement</code> in any method and getter (not functions or arrow functions), declared in ES2015 syntax that has JSX, so you can drop the <code>(h)</code> parameter. With prior versions of the plugin, your app would throw an error if <code>h</code> was not available in the scope.</p>\n\n<p>For more on how JSX maps to JavaScript, see the <a href=\"https://github.com/vuejs/jsx#installation\" target=\"_blank\" rel=\"noopener\">usage docs</a>.</p>\n<h2 id=\"Functional-Components\"><a href=\"#Functional-Components\" class=\"headerlink\" title=\"Functional Components\"></a>Functional Components</h2><p>The anchored heading component we created earlier is relatively simple. It doesn’t manage any state, watch any state passed to it, and it has no lifecycle methods. Really, it’s only a function with some props.</p>\n<p>In cases like this, we can mark components as <code>functional</code>, which means that they’re stateless (no <a href=\"../api/#Options-Data\">reactive data</a>) and instanceless (no <code>this</code> context). A <strong>functional component</strong> looks like this:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">functional</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-comment\">// Props are optional</span>\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n  <span class=\"hljs-comment\">// To compensate for the lack of an instance,</span>\n  <span class=\"hljs-comment\">// we are now provided a 2nd context argument.</span>\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement, context</span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;)</code></pre>\n<blockquote>\n<p>Note: in versions before 2.3.0, the <code>props</code> option is required if you wish to accept props in a functional component. In 2.3.0+ you can omit the <code>props</code> option and all attributes found on the component node will be implicitly extracted as props.</p>\n<p>The reference will be HTMLElement when used with functional components because they’re stateless and instanceless.</p>\n</blockquote>\n<p>In 2.5.0+, if you are using <a href=\"single-file-components.html\">single-file components</a>, template-based functional components can be declared with:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">functional</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<p>Everything the component needs is passed through <code>context</code>, which is an object containing:</p>\n<ul>\n<li><code>props</code>: An object of the provided props</li>\n<li><code>children</code>: An array of the VNode children</li>\n<li><code>slots</code>: A function returning a slots object</li>\n<li><code>scopedSlots</code>: (2.6.0+) An object that exposes passed-in scoped slots. Also exposes normal slots as functions.</li>\n<li><code>data</code>: The entire <a href=\"#The-Data-Object-In-Depth\">data object</a>, passed to the component as the 2nd argument of <code>createElement</code></li>\n<li><code>parent</code>: A reference to the parent component</li>\n<li><code>listeners</code>: (2.3.0+) An object containing parent-registered event listeners. This is an alias to <code>data.on</code></li>\n<li><code>injections</code>: (2.3.0+) if using the <a href=\"../api/#provide-inject\"><code>inject</code></a> option, this will contain resolved injections.</li>\n</ul>\n<p>After adding <code>functional: true</code>, updating the render function of our anchored heading component would require adding the <code>context</code> argument, updating <code>this.$slots.default</code> to <code>context.children</code>, then updating <code>this.level</code> to <code>context.props.level</code>.</p>\n<p>Since functional components are just functions, they’re much cheaper to render.</p>\n<p>They’re also very useful as wrapper components. For example, when you need to:</p>\n<ul>\n<li>Programmatically choose one of several other components to delegate to</li>\n<li>Manipulate children, props, or data before passing them on to a child component</li>\n</ul>\n<p>Here’s an example of a <code>smart-list</code> component that delegates to more specific components, depending on the props passed to it:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> EmptyList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> TableList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> OrderedList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n<span class=\"hljs-keyword\">var</span> UnorderedList = &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n\nVue.component(<span class=\"hljs-string\">'smart-list'</span>, &#123;\n  <span class=\"hljs-attr\">functional</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">items</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Array</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-attr\">isOrdered</span>: <span class=\"hljs-built_in\">Boolean</span>\n  &#125;,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement, context</span>) </span>&#123;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">appropriateListComponent</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> items = context.props.items\n\n      <span class=\"hljs-keyword\">if</span> (items.length === <span class=\"hljs-number\">0</span>)           <span class=\"hljs-keyword\">return</span> EmptyList\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> items[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-string\">'object'</span>) <span class=\"hljs-keyword\">return</span> TableList\n      <span class=\"hljs-keyword\">if</span> (context.props.isOrdered)      <span class=\"hljs-keyword\">return</span> OrderedList\n\n      <span class=\"hljs-keyword\">return</span> UnorderedList\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> createElement(\n      appropriateListComponent(),\n      context.data,\n      context.children\n    )\n  &#125;\n&#125;)</code></pre>\n<h3 id=\"Passing-Attributes-and-Events-to-Child-Elements-Components\"><a href=\"#Passing-Attributes-and-Events-to-Child-Elements-Components\" class=\"headerlink\" title=\"Passing Attributes and Events to Child Elements/Components\"></a>Passing Attributes and Events to Child Elements/Components</h3><p>On normal components, attributes not defined as props are automatically added to the root element of the component, replacing or <a href=\"class-and-style.html\">intelligently merging with</a> any existing attributes of the same name.</p>\n<p>Functional components, however, require you to explicitly define this behavior:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-functional-button'</span>, &#123;\n  <span class=\"hljs-attr\">functional</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement, context</span>) </span>&#123;\n    <span class=\"hljs-comment\">// Transparently pass any attributes, event listeners, children, etc.</span>\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'button'</span>, context.data, context.children)\n  &#125;\n&#125;)</code></pre>\n<p>By passing <code>context.data</code> as the second argument to <code>createElement</code>, we are passing down any attributes or event listeners used on <code>my-functional-button</code>. It’s so transparent, in fact, that events don’t even require the <code>.native</code> modifier.</p>\n<p>If you are using template-based functional components, you will also have to manually add attributes and listeners. Since we have access to the individual context contents, we can use <code>data.attrs</code> to pass along any HTML attributes and <code>listeners</code> <em>(the alias for <code>data.on</code>)</em> to pass along any event listeners.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">functional</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>\n    <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-primary\"</span>\n    <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"data.attrs\"</span>\n    <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"listeners\"</span>\n  &gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span>/&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<h3 id=\"slots-vs-children\"><a href=\"#slots-vs-children\" class=\"headerlink\" title=\"slots() vs children\"></a><code>slots()</code> vs <code>children</code></h3><p>You may wonder why we need both <code>slots()</code> and <code>children</code>. Wouldn’t <code>slots().default</code> be the same as <code>children</code>? In some cases, yes - but what if you have a functional component with the following children?</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-functional-component</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-slot:foo</span>&gt;</span>\n    first\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>second<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-functional-component</span>&gt;</span></code></pre>\n<p>For this component, <code>children</code> will give you both paragraphs, <code>slots().default</code> will give you only the second, and <code>slots().foo</code> will give you only the first. Having both <code>children</code> and <code>slots()</code> therefore allows you to choose whether this component knows about a slot system or perhaps delegates that responsibility to another component by passing along <code>children</code>.</p>\n<h2 id=\"Template-Compilation\"><a href=\"#Template-Compilation\" class=\"headerlink\" title=\"Template Compilation\"></a>Template Compilation</h2><p>You may be interested to know that Vue’s templates actually compile to render functions. This is an implementation detail you usually don’t need to know about, but if you’d like to see how specific template features are compiled, you may find it interesting. Below is a little demo using <code>Vue.compile</code> to live-compile a template string:</p>\n<iframe src=\"https://codesandbox.io/embed/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-template-compilation?codemirror=1&hidedevtools=1&hidenavigation=1&theme=light&view=preview\" style=\"width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;\" title=\"vue-20-template-compilation\" allow=\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\" sandbox=\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\"></iframe>\n"},{"title":"Single File Components","type":"guide","order":401,"_content":"\n## Introduction\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/introduction-to-single-file-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Single File Components lesson\">Watch a free video lesson on Vue School</a></div>\n\nIn many Vue projects, global components will be defined using `Vue.component`, followed by `new Vue({ el: '#container' })` to target a container element in the body of every page.\n\nThis can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:\n\n- **Global definitions** force unique names for every component\n- **String templates** lack syntax highlighting and require ugly slashes for multiline HTML\n- **No CSS support** means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out\n- **No build step** restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel\n\nAll of these are solved by **single-file components** with a `.vue` extension, made possible with build tools such as Webpack or Browserify.\n\nHere's an example of a file we'll call `Hello.vue`:\n\n<a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component.png\" alt=\"Single-file component example (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a>\n\nNow we get:\n\n- [Complete syntax highlighting](https://github.com/vuejs/awesome-vue#source-code-editing)\n- [CommonJS modules](https://webpack.js.org/concepts/modules/#what-is-a-webpack-module)\n- [Component-scoped CSS](https://vue-loader.vuejs.org/en/features/scoped-css.html)\n\nAs promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components.\n\n<a href=\"https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component-with-preprocessors.png\" alt=\"Single-file component example with preprocessors (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a>\n\nThese specific languages are only examples. You could as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with `vue-loader`, it also has first-class support for CSS Modules.\n\n### What About Separation of Concerns?\n\nOne important thing to note is that **separation of concerns is not equal to separation of file types.** In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.\n\nEven if you don't like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:\n\n``` html\n<!-- my-component.vue -->\n<template>\n  <div>This will be pre-compiled</div>\n</template>\n<script src=\"./my-component.js\"></script>\n<style src=\"./my-component.css\"></style>\n```\n\n## Getting Started\n\n### Example Sandbox\n\nIf you want to dive right in and start playing with single-file components, check out [this simple todo app](https://codesandbox.io/s/o29j95wx9) on CodeSandbox.\n\n### For Users New to Module Build Systems in JavaScript\n\nWith `.vue` components, we're entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven't already:\n\n- **Node Package Manager (NPM)**: Read the [Getting Started guide](https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry) section about how to get packages from the registry.\n\n- **Modern JavaScript with ES2015/16**: Read through Babel's [Learn ES2015 guide](https://babeljs.io/docs/learn-es2015/). You don't have to memorize every feature right now, but keep this page as a reference you can come back to.\n\nAfter you've taken a day to dive into these resources, we recommend checking out [Vue CLI 3](https://cli.vuejs.org/). Follow the instructions and you should have a Vue project with `.vue` components, ES2015, Webpack and hot-reloading in no time!\n\n### For Advanced Users\n\nThe CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own [config options](https://cli.vuejs.org/config/).\n\nIn case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with [vue-loader](https://vue-loader.vuejs.org). To learn more about webpack itself, check out [their official docs](https://webpack.js.org/configuration/) and [Webpack Academy](https://webpack.academy/p/the-core-concepts).\n","source":"v2/guide/single-file-components.md","raw":"---\ntitle: Single File Components\ntype: guide\norder: 401\n---\n\n## Introduction\n\n<div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/introduction-to-single-file-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Single File Components lesson\">Watch a free video lesson on Vue School</a></div>\n\nIn many Vue projects, global components will be defined using `Vue.component`, followed by `new Vue({ el: '#container' })` to target a container element in the body of every page.\n\nThis can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:\n\n- **Global definitions** force unique names for every component\n- **String templates** lack syntax highlighting and require ugly slashes for multiline HTML\n- **No CSS support** means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out\n- **No build step** restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel\n\nAll of these are solved by **single-file components** with a `.vue` extension, made possible with build tools such as Webpack or Browserify.\n\nHere's an example of a file we'll call `Hello.vue`:\n\n<a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component.png\" alt=\"Single-file component example (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a>\n\nNow we get:\n\n- [Complete syntax highlighting](https://github.com/vuejs/awesome-vue#source-code-editing)\n- [CommonJS modules](https://webpack.js.org/concepts/modules/#what-is-a-webpack-module)\n- [Component-scoped CSS](https://vue-loader.vuejs.org/en/features/scoped-css.html)\n\nAs promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components.\n\n<a href=\"https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component-with-preprocessors.png\" alt=\"Single-file component example with preprocessors (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a>\n\nThese specific languages are only examples. You could as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with `vue-loader`, it also has first-class support for CSS Modules.\n\n### What About Separation of Concerns?\n\nOne important thing to note is that **separation of concerns is not equal to separation of file types.** In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.\n\nEven if you don't like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:\n\n``` html\n<!-- my-component.vue -->\n<template>\n  <div>This will be pre-compiled</div>\n</template>\n<script src=\"./my-component.js\"></script>\n<style src=\"./my-component.css\"></style>\n```\n\n## Getting Started\n\n### Example Sandbox\n\nIf you want to dive right in and start playing with single-file components, check out [this simple todo app](https://codesandbox.io/s/o29j95wx9) on CodeSandbox.\n\n### For Users New to Module Build Systems in JavaScript\n\nWith `.vue` components, we're entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven't already:\n\n- **Node Package Manager (NPM)**: Read the [Getting Started guide](https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry) section about how to get packages from the registry.\n\n- **Modern JavaScript with ES2015/16**: Read through Babel's [Learn ES2015 guide](https://babeljs.io/docs/learn-es2015/). You don't have to memorize every feature right now, but keep this page as a reference you can come back to.\n\nAfter you've taken a day to dive into these resources, we recommend checking out [Vue CLI 3](https://cli.vuejs.org/). Follow the instructions and you should have a Vue project with `.vue` components, ES2015, Webpack and hot-reloading in no time!\n\n### For Advanced Users\n\nThe CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own [config options](https://cli.vuejs.org/config/).\n\nIn case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with [vue-loader](https://vue-loader.vuejs.org). To learn more about webpack itself, check out [their official docs](https://webpack.js.org/configuration/) and [Webpack Academy](https://webpack.academy/p/the-core-concepts).\n","date":"2020-09-25T23:55:41.140Z","updated":"2020-09-25T23:55:41.140Z","path":"v2/guide/single-file-components.html","comments":1,"layout":"page","_id":"ckfl66gyo002hc2v5yyalwuy5","content":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/introduction-to-single-file-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Single File Components lesson\">Watch a free video lesson on Vue School</a></div>\n\n<p>In many Vue projects, global components will be defined using <code>Vue.component</code>, followed by <code>new Vue({ el: &#39;#container&#39; })</code> to target a container element in the body of every page.</p>\n<p>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:</p>\n<ul>\n<li><strong>Global definitions</strong> force unique names for every component</li>\n<li><strong>String templates</strong> lack syntax highlighting and require ugly slashes for multiline HTML</li>\n<li><strong>No CSS support</strong> means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out</li>\n<li><strong>No build step</strong> restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel</li>\n</ul>\n<p>All of these are solved by <strong>single-file components</strong> with a <code>.vue</code> extension, made possible with build tools such as Webpack or Browserify.</p>\n<p>Here’s an example of a file we’ll call <code>Hello.vue</code>:</p>\n<p><a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component.png\" alt=\"Single-file component example (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a></p>\n<p>Now we get:</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue#source-code-editing\" target=\"_blank\" rel=\"noopener\">Complete syntax highlighting</a></li>\n<li><a href=\"https://webpack.js.org/concepts/modules/#what-is-a-webpack-module\" target=\"_blank\" rel=\"noopener\">CommonJS modules</a></li>\n<li><a href=\"https://vue-loader.vuejs.org/en/features/scoped-css.html\" target=\"_blank\" rel=\"noopener\">Component-scoped CSS</a></li>\n</ul>\n<p>As promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components.</p>\n<p><a href=\"https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component-with-preprocessors.png\" alt=\"Single-file component example with preprocessors (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a></p>\n<p>These specific languages are only examples. You could as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with <code>vue-loader</code>, it also has first-class support for CSS Modules.</p>\n<h3 id=\"What-About-Separation-of-Concerns\"><a href=\"#What-About-Separation-of-Concerns\" class=\"headerlink\" title=\"What About Separation of Concerns?\"></a>What About Separation of Concerns?</h3><p>One important thing to note is that <strong>separation of concerns is not equal to separation of file types.</strong> In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</p>\n<p>Even if you don’t like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- my-component.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>This will be pre-compiled<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./my-component.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./my-component.css\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><h3 id=\"Example-Sandbox\"><a href=\"#Example-Sandbox\" class=\"headerlink\" title=\"Example Sandbox\"></a>Example Sandbox</h3><p>If you want to dive right in and start playing with single-file components, check out <a href=\"https://codesandbox.io/s/o29j95wx9\" target=\"_blank\" rel=\"noopener\">this simple todo app</a> on CodeSandbox.</p>\n<h3 id=\"For-Users-New-to-Module-Build-Systems-in-JavaScript\"><a href=\"#For-Users-New-to-Module-Build-Systems-in-JavaScript\" class=\"headerlink\" title=\"For Users New to Module Build Systems in JavaScript\"></a>For Users New to Module Build Systems in JavaScript</h3><p>With <code>.vue</code> components, we’re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven’t already:</p>\n<ul>\n<li><p><strong>Node Package Manager (NPM)</strong>: Read the <a href=\"https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry\" target=\"_blank\" rel=\"noopener\">Getting Started guide</a> section about how to get packages from the registry.</p>\n</li>\n<li><p><strong>Modern JavaScript with ES2015/16</strong>: Read through Babel’s <a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"noopener\">Learn ES2015 guide</a>. You don’t have to memorize every feature right now, but keep this page as a reference you can come back to.</p>\n</li>\n</ul>\n<p>After you’ve taken a day to dive into these resources, we recommend checking out <a href=\"https://cli.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue CLI 3</a>. Follow the instructions and you should have a Vue project with <code>.vue</code> components, ES2015, Webpack and hot-reloading in no time!</p>\n<h3 id=\"For-Advanced-Users\"><a href=\"#For-Advanced-Users\" class=\"headerlink\" title=\"For Advanced Users\"></a>For Advanced Users</h3><p>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own <a href=\"https://cli.vuejs.org/config/\" target=\"_blank\" rel=\"noopener\">config options</a>.</p>\n<p>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with <a href=\"https://vue-loader.vuejs.org\" target=\"_blank\" rel=\"noopener\">vue-loader</a>. To learn more about webpack itself, check out <a href=\"https://webpack.js.org/configuration/\" target=\"_blank\" rel=\"noopener\">their official docs</a> and <a href=\"https://webpack.academy/p/the-core-concepts\" target=\"_blank\" rel=\"noopener\">Webpack Academy</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><div class=\"vueschool\"><a href=\"https://vueschool.io/lessons/introduction-to-single-file-components?friend=vuejs\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Free Vue.js Single File Components lesson\">Watch a free video lesson on Vue School</a></div>\n\n<p>In many Vue projects, global components will be defined using <code>Vue.component</code>, followed by <code>new Vue({ el: &#39;#container&#39; })</code> to target a container element in the body of every page.</p>\n<p>This can work very well for small to medium-sized projects, where JavaScript is only used to enhance certain views. In more complex projects however, or when your frontend is entirely driven by JavaScript, these disadvantages become apparent:</p>\n<ul>\n<li><strong>Global definitions</strong> force unique names for every component</li>\n<li><strong>String templates</strong> lack syntax highlighting and require ugly slashes for multiline HTML</li>\n<li><strong>No CSS support</strong> means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out</li>\n<li><strong>No build step</strong> restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel</li>\n</ul>\n<p>All of these are solved by <strong>single-file components</strong> with a <code>.vue</code> extension, made possible with build tools such as Webpack or Browserify.</p>\n<p>Here’s an example of a file we’ll call <code>Hello.vue</code>:</p>\n<p><a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-single-file-components\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component.png\" alt=\"Single-file component example (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a></p>\n<p>Now we get:</p>\n<ul>\n<li><a href=\"https://github.com/vuejs/awesome-vue#source-code-editing\" target=\"_blank\" rel=\"noopener\">Complete syntax highlighting</a></li>\n<li><a href=\"https://webpack.js.org/concepts/modules/#what-is-a-webpack-module\" target=\"_blank\" rel=\"noopener\">CommonJS modules</a></li>\n<li><a href=\"https://vue-loader.vuejs.org/en/features/scoped-css.html\" target=\"_blank\" rel=\"noopener\">Component-scoped CSS</a></li>\n</ul>\n<p>As promised, we can also use preprocessors such as Pug, Babel (with ES2015 modules), and Stylus for cleaner and more feature-rich components.</p>\n<p><a href=\"https://gist.github.com/chrisvfritz/1c9f2daea9bc078dcb47e9a82e5f7587\" target=\"_blank\" rel=\"noopener noreferrer\"><img src=\"/images/vue-component-with-preprocessors.png\" alt=\"Single-file component example with preprocessors (click for code as text)\" style=\"display: block; margin: 30px auto;\"></a></p>\n<p>These specific languages are only examples. You could as easily use Bublé, TypeScript, SCSS, PostCSS - or whatever other preprocessors that help you be productive. If using Webpack with <code>vue-loader</code>, it also has first-class support for CSS Modules.</p>\n<h3 id=\"What-About-Separation-of-Concerns\"><a href=\"#What-About-Separation-of-Concerns\" class=\"headerlink\" title=\"What About Separation of Concerns?\"></a>What About Separation of Concerns?</h3><p>One important thing to note is that <strong>separation of concerns is not equal to separation of file types.</strong> In modern UI development, we have found that instead of dividing the codebase into three huge layers that interweave with one another, it makes much more sense to divide them into loosely-coupled components and compose them. Inside a component, its template, logic and styles are inherently coupled, and collocating them actually makes the component more cohesive and maintainable.</p>\n<p>Even if you don’t like the idea of Single-File Components, you can still leverage its hot-reloading and pre-compilation features by separating your JavaScript and CSS into separate files:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- my-component.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>This will be pre-compiled<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./my-component.js\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"./my-component.css\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><h3 id=\"Example-Sandbox\"><a href=\"#Example-Sandbox\" class=\"headerlink\" title=\"Example Sandbox\"></a>Example Sandbox</h3><p>If you want to dive right in and start playing with single-file components, check out <a href=\"https://codesandbox.io/s/o29j95wx9\" target=\"_blank\" rel=\"noopener\">this simple todo app</a> on CodeSandbox.</p>\n<h3 id=\"For-Users-New-to-Module-Build-Systems-in-JavaScript\"><a href=\"#For-Users-New-to-Module-Build-Systems-in-JavaScript\" class=\"headerlink\" title=\"For Users New to Module Build Systems in JavaScript\"></a>For Users New to Module Build Systems in JavaScript</h3><p>With <code>.vue</code> components, we’re entering the realm of advanced JavaScript applications. That means learning to use a few additional tools if you haven’t already:</p>\n<ul>\n<li><p><strong>Node Package Manager (NPM)</strong>: Read the <a href=\"https://docs.npmjs.com/packages-and-modules/getting-packages-from-the-registry\" target=\"_blank\" rel=\"noopener\">Getting Started guide</a> section about how to get packages from the registry.</p>\n</li>\n<li><p><strong>Modern JavaScript with ES2015/16</strong>: Read through Babel’s <a href=\"https://babeljs.io/docs/learn-es2015/\" target=\"_blank\" rel=\"noopener\">Learn ES2015 guide</a>. You don’t have to memorize every feature right now, but keep this page as a reference you can come back to.</p>\n</li>\n</ul>\n<p>After you’ve taken a day to dive into these resources, we recommend checking out <a href=\"https://cli.vuejs.org/\" target=\"_blank\" rel=\"noopener\">Vue CLI 3</a>. Follow the instructions and you should have a Vue project with <code>.vue</code> components, ES2015, Webpack and hot-reloading in no time!</p>\n<h3 id=\"For-Advanced-Users\"><a href=\"#For-Advanced-Users\" class=\"headerlink\" title=\"For Advanced Users\"></a>For Advanced Users</h3><p>The CLI takes care of most of the tooling configurations for you, but also allows fine-grained customization through its own <a href=\"https://cli.vuejs.org/config/\" target=\"_blank\" rel=\"noopener\">config options</a>.</p>\n<p>In case you prefer setting up your own build setup from scratch, you will need to manually configure webpack with <a href=\"https://vue-loader.vuejs.org\" target=\"_blank\" rel=\"noopener\">vue-loader</a>. To learn more about webpack itself, check out <a href=\"https://webpack.js.org/configuration/\" target=\"_blank\" rel=\"noopener\">their official docs</a> and <a href=\"https://webpack.academy/p/the-core-concepts\" target=\"_blank\" rel=\"noopener\">Webpack Academy</a>.</p>\n"},{"title":"State Management","type":"guide","order":502,"_content":"\n## Official Flux-Like Implementation\n\nLarge applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers [vuex](https://github.com/vuejs/vuex): our own Elm-inspired state management library. It even integrates into [vue-devtools](https://github.com/vuejs/vue-devtools), providing zero-setup access to [time travel debugging](https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif).\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/mastering-vuex/intro-to-vuex/\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vuex Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\n### Information for React Developers\n\nIf you're coming from React, you may be wondering how vuex compares to [redux](https://github.com/reactjs/redux), the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via [simple bindings](https://classic.yarnpkg.com/en/packages?q=redux%20vue&p=1). Vuex is different in that it _knows_ it's in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.\n\n## Simple State Management from Scratch\n\nIt is often overlooked that the source of truth in Vue applications is the raw `data` object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:\n\n``` js\nvar sourceOfTruth = {}\n\nvar vmA = new Vue({\n  data: sourceOfTruth\n})\n\nvar vmB = new Vue({\n  data: sourceOfTruth\n})\n```\n\nNow whenever `sourceOfTruth` is mutated, both `vmA` and `vmB` will update their views automatically. Subcomponents within each of these instances would also have access via `this.$root.$data`. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.\n\nTo help solve this problem, we can adopt a **store pattern**:\n\n``` js\nvar store = {\n  debug: true,\n  state: {\n    message: 'Hello!'\n  },\n  setMessageAction (newValue) {\n    if (this.debug) console.log('setMessageAction triggered with', newValue)\n    this.state.message = newValue\n  },\n  clearMessageAction () {\n    if (this.debug) console.log('clearMessageAction triggered')\n    this.state.message = ''\n  }\n}\n```\n\nNotice all actions that mutate the store's state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we'll also have a log of what happened leading up to the bug.\n\nIn addition, each instance/component can still own and manage its own private state:\n\n``` js\nvar vmA = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n\nvar vmB = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n```\n\n![State Management](/images/state.png)\n\n<p class=\"tip\">It's important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</p>\n\nAs we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the [Flux](https://facebook.github.io/flux/) architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.\n\nThis brings us full circle back to [vuex](https://github.com/vuejs/vuex), so if you've read this far it's probably time to try it out!\n","source":"v2/guide/state-management.md","raw":"---\ntitle: State Management\ntype: guide\norder: 502\n---\n\n## Official Flux-Like Implementation\n\nLarge applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers [vuex](https://github.com/vuejs/vuex): our own Elm-inspired state management library. It even integrates into [vue-devtools](https://github.com/vuejs/vue-devtools), providing zero-setup access to [time travel debugging](https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif).\n\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/mastering-vuex/intro-to-vuex/\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vuex Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\n### Information for React Developers\n\nIf you're coming from React, you may be wondering how vuex compares to [redux](https://github.com/reactjs/redux), the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via [simple bindings](https://classic.yarnpkg.com/en/packages?q=redux%20vue&p=1). Vuex is different in that it _knows_ it's in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.\n\n## Simple State Management from Scratch\n\nIt is often overlooked that the source of truth in Vue applications is the raw `data` object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:\n\n``` js\nvar sourceOfTruth = {}\n\nvar vmA = new Vue({\n  data: sourceOfTruth\n})\n\nvar vmB = new Vue({\n  data: sourceOfTruth\n})\n```\n\nNow whenever `sourceOfTruth` is mutated, both `vmA` and `vmB` will update their views automatically. Subcomponents within each of these instances would also have access via `this.$root.$data`. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.\n\nTo help solve this problem, we can adopt a **store pattern**:\n\n``` js\nvar store = {\n  debug: true,\n  state: {\n    message: 'Hello!'\n  },\n  setMessageAction (newValue) {\n    if (this.debug) console.log('setMessageAction triggered with', newValue)\n    this.state.message = newValue\n  },\n  clearMessageAction () {\n    if (this.debug) console.log('clearMessageAction triggered')\n    this.state.message = ''\n  }\n}\n```\n\nNotice all actions that mutate the store's state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we'll also have a log of what happened leading up to the bug.\n\nIn addition, each instance/component can still own and manage its own private state:\n\n``` js\nvar vmA = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n\nvar vmB = new Vue({\n  data: {\n    privateState: {},\n    sharedState: store.state\n  }\n})\n```\n\n![State Management](/images/state.png)\n\n<p class=\"tip\">It's important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</p>\n\nAs we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the [Flux](https://facebook.github.io/flux/) architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.\n\nThis brings us full circle back to [vuex](https://github.com/vuejs/vuex), so if you've read this far it's probably time to try it out!\n","date":"2020-09-25T23:55:41.140Z","updated":"2020-09-25T23:55:41.140Z","path":"v2/guide/state-management.html","comments":1,"layout":"page","_id":"ckfl66gyo002ic2v5iviajzw6","content":"<h2 id=\"Official-Flux-Like-Implementation\"><a href=\"#Official-Flux-Like-Implementation\" class=\"headerlink\" title=\"Official Flux-Like Implementation\"></a>Official Flux-Like Implementation</h2><p>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">vuex</a>: our own Elm-inspired state management library. It even integrates into <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a>, providing zero-setup access to <a href=\"https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif\" target=\"_blank\" rel=\"noopener\">time travel debugging</a>.</p>\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/mastering-vuex/intro-to-vuex/\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vuex Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\n<h3 id=\"Information-for-React-Developers\"><a href=\"#Information-for-React-Developers\" class=\"headerlink\" title=\"Information for React Developers\"></a>Information for React Developers</h3><p>If you’re coming from React, you may be wondering how vuex compares to <a href=\"https://github.com/reactjs/redux\" target=\"_blank\" rel=\"noopener\">redux</a>, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via <a href=\"https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;p=1\" target=\"_blank\" rel=\"noopener\">simple bindings</a>. Vuex is different in that it <em>knows</em> it’s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</p>\n<h2 id=\"Simple-State-Management-from-Scratch\"><a href=\"#Simple-State-Management-from-Scratch\" class=\"headerlink\" title=\"Simple State Management from Scratch\"></a>Simple State Management from Scratch</h2><p>It is often overlooked that the source of truth in Vue applications is the raw <code>data</code> object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> sourceOfTruth = &#123;&#125;\n\n<span class=\"hljs-keyword\">var</span> vmA = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: sourceOfTruth\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vmB = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: sourceOfTruth\n&#125;)</code></pre>\n<p>Now whenever <code>sourceOfTruth</code> is mutated, both <code>vmA</code> and <code>vmB</code> will update their views automatically. Subcomponents within each of these instances would also have access via <code>this.$root.$data</code>. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</p>\n<p>To help solve this problem, we can adopt a <strong>store pattern</strong>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> store = &#123;\n  <span class=\"hljs-attr\">debug</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">state</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello!'</span>\n  &#125;,\n  setMessageAction (newValue) &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.debug) <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'setMessageAction triggered with'</span>, newValue)\n    <span class=\"hljs-keyword\">this</span>.state.message = newValue\n  &#125;,\n  clearMessageAction () &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.debug) <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'clearMessageAction triggered'</span>)\n    <span class=\"hljs-keyword\">this</span>.state.message = <span class=\"hljs-string\">''</span>\n  &#125;\n&#125;</code></pre>\n<p>Notice all actions that mutate the store’s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we’ll also have a log of what happened leading up to the bug.</p>\n<p>In addition, each instance/component can still own and manage its own private state:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vmA = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">privateState</span>: &#123;&#125;,\n    <span class=\"hljs-attr\">sharedState</span>: store.state\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vmB = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">privateState</span>: &#123;&#125;,\n    <span class=\"hljs-attr\">sharedState</span>: store.state\n  &#125;\n&#125;)</code></pre>\n<p><img src=\"/images/state.png\" alt=\"State Management\"></p>\n<p class=\"tip\">It’s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</p>\n\n<p>As we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the <a href=\"https://facebook.github.io/flux/\" target=\"_blank\" rel=\"noopener\">Flux</a> architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.</p>\n<p>This brings us full circle back to <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">vuex</a>, so if you’ve read this far it’s probably time to try it out!</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Official-Flux-Like-Implementation\"><a href=\"#Official-Flux-Like-Implementation\" class=\"headerlink\" title=\"Official Flux-Like Implementation\"></a>Official Flux-Like Implementation</h2><p>Large applications can often grow in complexity, due to multiple pieces of state scattered across many components and the interactions between them. To solve this problem, Vue offers <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">vuex</a>: our own Elm-inspired state management library. It even integrates into <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a>, providing zero-setup access to <a href=\"https://raw.githubusercontent.com/vuejs/vue-devtools/master/media/demo.gif\" target=\"_blank\" rel=\"noopener\">time travel debugging</a>.</p>\n<div class=\"vue-mastery\"><a href=\"https://www.vuemastery.com/courses/mastering-vuex/intro-to-vuex/\" target=\"_blank\" rel=\"sponsored noopener\" title=\"Vuex Tutorial\">Watch a video explanation on Vue Mastery</a></div>\n\n<h3 id=\"Information-for-React-Developers\"><a href=\"#Information-for-React-Developers\" class=\"headerlink\" title=\"Information for React Developers\"></a>Information for React Developers</h3><p>If you’re coming from React, you may be wondering how vuex compares to <a href=\"https://github.com/reactjs/redux\" target=\"_blank\" rel=\"noopener\">redux</a>, the most popular Flux implementation in that ecosystem. Redux is actually view-layer agnostic, so it can easily be used with Vue via <a href=\"https://classic.yarnpkg.com/en/packages?q=redux%20vue&amp;p=1\" target=\"_blank\" rel=\"noopener\">simple bindings</a>. Vuex is different in that it <em>knows</em> it’s in a Vue app. This allows it to better integrate with Vue, offering a more intuitive API and improved development experience.</p>\n<h2 id=\"Simple-State-Management-from-Scratch\"><a href=\"#Simple-State-Management-from-Scratch\" class=\"headerlink\" title=\"Simple State Management from Scratch\"></a>Simple State Management from Scratch</h2><p>It is often overlooked that the source of truth in Vue applications is the raw <code>data</code> object - a Vue instance only proxies access to it. Therefore, if you have a piece of state that should be shared by multiple instances, you can share it by identity:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> sourceOfTruth = &#123;&#125;\n\n<span class=\"hljs-keyword\">var</span> vmA = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: sourceOfTruth\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vmB = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: sourceOfTruth\n&#125;)</code></pre>\n<p>Now whenever <code>sourceOfTruth</code> is mutated, both <code>vmA</code> and <code>vmB</code> will update their views automatically. Subcomponents within each of these instances would also have access via <code>this.$root.$data</code>. We have a single source of truth now, but debugging would be a nightmare. Any piece of data could be changed by any part of our app at any time, without leaving a trace.</p>\n<p>To help solve this problem, we can adopt a <strong>store pattern</strong>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> store = &#123;\n  <span class=\"hljs-attr\">debug</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">state</span>: &#123;\n    <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">'Hello!'</span>\n  &#125;,\n  setMessageAction (newValue) &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.debug) <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'setMessageAction triggered with'</span>, newValue)\n    <span class=\"hljs-keyword\">this</span>.state.message = newValue\n  &#125;,\n  clearMessageAction () &#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.debug) <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'clearMessageAction triggered'</span>)\n    <span class=\"hljs-keyword\">this</span>.state.message = <span class=\"hljs-string\">''</span>\n  &#125;\n&#125;</code></pre>\n<p>Notice all actions that mutate the store’s state are put inside the store itself. This type of centralized state management makes it easier to understand what type of mutations could happen and how they are triggered. Now when something goes wrong, we’ll also have a log of what happened leading up to the bug.</p>\n<p>In addition, each instance/component can still own and manage its own private state:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vmA = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">privateState</span>: &#123;&#125;,\n    <span class=\"hljs-attr\">sharedState</span>: store.state\n  &#125;\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vmB = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">privateState</span>: &#123;&#125;,\n    <span class=\"hljs-attr\">sharedState</span>: store.state\n  &#125;\n&#125;)</code></pre>\n<p><img src=\"/images/state.png\" alt=\"State Management\"></p>\n<p class=\"tip\">It’s important to note that you should never replace the original state object in your actions - the components and the store need to share reference to the same object in order for mutations to be observed.</p>\n\n<p>As we continue developing the convention where components are never allowed to directly mutate state that belongs to a store, but should instead dispatch events that notify the store to perform actions, we eventually arrive at the <a href=\"https://facebook.github.io/flux/\" target=\"_blank\" rel=\"noopener\">Flux</a> architecture. The benefit of this convention is we can record all state mutations happening to the store and implement advanced debugging helpers such as mutation logs, snapshots, and history re-rolls / time travel.</p>\n<p>This brings us full circle back to <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">vuex</a>, so if you’ve read this far it’s probably time to try it out!</p>\n"},{"title":"Template Syntax","type":"guide","order":4,"_content":"\nVue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance's data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\n\nUnder the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\n\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also [directly write render functions](render-function.html) instead of templates, with optional JSX support.\n\n## Interpolations\n\n### Text\n\nThe most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):\n\n``` html\n<span>Message: {{ msg }}</span>\n```\n\nThe mustache tag will be replaced with the value of the `msg` property on the corresponding data object. It will also be updated whenever the data object's `msg` property changes.\n\nYou can also perform one-time interpolations that do not update on data change by using the [v-once directive](../api/#v-once), but keep in mind this will also affect any other bindings on the same node:\n\n``` html\n<span v-once>This will never change: {{ msg }}</span>\n```\n\n### Raw HTML\n\nThe double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the [`v-html` directive](../api/#v-html):\n\n``` html\n<p>Using mustaches: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n```\n\n{% raw %}\n<div id=\"example1\" class=\"demo\">\n  <p>Using mustaches: {{ rawHtml }}</p>\n  <p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n</div>\n<script>\nnew Vue({\n  el: '#example1',\n  data: function () {\n    return {\n      rawHtml: '<span style=\"color: red\">This should be red.</span>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nThe contents of the `span` will be replaced with the value of the `rawHtml` property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use `v-html` to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\n\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS vulnerabilities](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use HTML interpolation on trusted content and **never** on user-provided content.</p>\n\n### Attributes\n\nMustaches cannot be used inside HTML attributes. Instead, use a [`v-bind` directive](../api/#v-bind):\n\n``` html\n<div v-bind:id=\"dynamicId\"></div>\n```\n\nIn the case of boolean attributes, where their mere existence implies `true`, `v-bind` works a little differently. In this example:\n\n``` html\n<button v-bind:disabled=\"isButtonDisabled\">Button</button>\n```\n\nIf `isButtonDisabled` has the value of `null`, `undefined`, or `false`, the `disabled` attribute will not even be included in the rendered `<button>` element.\n\n### Using JavaScript Expressions\n\nSo far we've only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:\n\n``` html\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\nThese expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain **one single expression**, so the following will **NOT** work:\n\n``` html\n<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}\n```\n\n<p class=\"tip\">Template expressions are sandboxed and only have access to a [whitelist of globals](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9) such as `Math` and `Date`. You should not attempt to access user-defined globals in template expressions.</p>\n\n## Directives\n\nDirectives are special attributes with the `v-` prefix. Directive attribute values are expected to be **a single JavaScript expression** (with the exception of `v-for`, which will be discussed later). A directive's job is to reactively apply side effects to the DOM when the value of its expression changes. Let's review the example we saw in the introduction:\n\n``` html\n<p v-if=\"seen\">Now you see me</p>\n```\n\nHere, the `v-if` directive would remove/insert the `<p>` element based on the truthiness of the value of the expression `seen`.\n\n### Arguments\n\nSome directives can take an \"argument\", denoted by a colon after the directive name. For example, the `v-bind` directive is used to reactively update an HTML attribute:\n\n``` html\n<a v-bind:href=\"url\"> ... </a>\n```\n\nHere `href` is the argument, which tells the `v-bind` directive to bind the element's `href` attribute to the value of the expression `url`.\n\nAnother example is the `v-on` directive, which listens to DOM events:\n\n``` html\n<a v-on:click=\"doSomething\"> ... </a>\n```\n\nHere the argument is the event name to listen to. We will talk about event handling in more detail too.\n\n### Dynamic Arguments\n\n> New in 2.6.0+\n\nStarting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\n\n``` html\n<!--\nNote that there are some constraints to the argument expression, as explained\nin the \"Dynamic Argument Expression Constraints\" section below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n```\n\nHere `attributeName` will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, `attributeName`, whose value is `\"href\"`, then this binding will be equivalent to `v-bind:href`.\n\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\n\n``` html\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n```\n\nIn this example, when `eventName`'s value is `\"focus\"`, `v-on:[eventName]` will be equivalent to `v-on:focus`.\n\n#### Dynamic Argument Value Constraints\n\nDynamic arguments are expected to evaluate to a string, with the exception of `null`. The special value `null` can be used to explicitly remove the binding. Any other non-string value will trigger a warning.\n\n#### Dynamic Argument Expression Constraints\n\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\n\n``` html\n<!-- This will trigger a compiler warning. -->\n<a v-bind:['foo' + bar]=\"value\"> ... </a>\n```\n\nThe workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.\n\nWhen using in-DOM templates (i.e., templates written directly in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\n\n``` html\n<!--\nThis will be converted to v-bind:[someattr] in in-DOM templates.\nUnless you have a \"someattr\" property in your instance, your code won't work.\n-->\n<a v-bind:[someAttr]=\"value\"> ... </a>\n```\n\n### Modifiers\n\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the `.prevent` modifier tells the `v-on` directive to call `event.preventDefault()` on the triggered event:\n\n``` html\n<form v-on:submit.prevent=\"onSubmit\"> ... </form>\n```\n\nYou'll see other examples of modifiers later, [for `v-on`](events.html#Event-Modifiers) and [for `v-model`](forms.html#Modifiers), when we explore those features.\n\n## Shorthands\n\nThe `v-` prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the `v-` prefix becomes less important when you are building a [SPA](https://en.wikipedia.org/wiki/Single-page_application), where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, `v-bind` and `v-on`:\n\n### `v-bind` Shorthand\n\n``` html\n<!-- full syntax -->\n<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>\n\n<!-- shorthand with dynamic argument (2.6.0+) -->\n<a :[key]=\"url\"> ... </a>\n```\n\n### `v-on` Shorthand\n\n``` html\n<!-- full syntax -->\n<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>\n\n<!-- shorthand with dynamic argument (2.6.0+) -->\n<a @[event]=\"doSomething\"> ... </a>\n```\n\nThey may look a bit different from normal HTML, but `:` and `@` are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.\n","source":"v2/guide/syntax.md","raw":"---\ntitle: Template Syntax\ntype: guide\norder: 4\n---\n\nVue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance's data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.\n\nUnder the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.\n\nIf you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also [directly write render functions](render-function.html) instead of templates, with optional JSX support.\n\n## Interpolations\n\n### Text\n\nThe most basic form of data binding is text interpolation using the \"Mustache\" syntax (double curly braces):\n\n``` html\n<span>Message: {{ msg }}</span>\n```\n\nThe mustache tag will be replaced with the value of the `msg` property on the corresponding data object. It will also be updated whenever the data object's `msg` property changes.\n\nYou can also perform one-time interpolations that do not update on data change by using the [v-once directive](../api/#v-once), but keep in mind this will also affect any other bindings on the same node:\n\n``` html\n<span v-once>This will never change: {{ msg }}</span>\n```\n\n### Raw HTML\n\nThe double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the [`v-html` directive](../api/#v-html):\n\n``` html\n<p>Using mustaches: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n```\n\n{% raw %}\n<div id=\"example1\" class=\"demo\">\n  <p>Using mustaches: {{ rawHtml }}</p>\n  <p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n</div>\n<script>\nnew Vue({\n  el: '#example1',\n  data: function () {\n    return {\n      rawHtml: '<span style=\"color: red\">This should be red.</span>'\n    }\n  }\n})\n</script>\n{% endraw %}\n\nThe contents of the `span` will be replaced with the value of the `rawHtml` property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use `v-html` to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.\n\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS vulnerabilities](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use HTML interpolation on trusted content and **never** on user-provided content.</p>\n\n### Attributes\n\nMustaches cannot be used inside HTML attributes. Instead, use a [`v-bind` directive](../api/#v-bind):\n\n``` html\n<div v-bind:id=\"dynamicId\"></div>\n```\n\nIn the case of boolean attributes, where their mere existence implies `true`, `v-bind` works a little differently. In this example:\n\n``` html\n<button v-bind:disabled=\"isButtonDisabled\">Button</button>\n```\n\nIf `isButtonDisabled` has the value of `null`, `undefined`, or `false`, the `disabled` attribute will not even be included in the rendered `<button>` element.\n\n### Using JavaScript Expressions\n\nSo far we've only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:\n\n``` html\n{{ number + 1 }}\n\n{{ ok ? 'YES' : 'NO' }}\n\n{{ message.split('').reverse().join('') }}\n\n<div v-bind:id=\"'list-' + id\"></div>\n```\n\nThese expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain **one single expression**, so the following will **NOT** work:\n\n``` html\n<!-- this is a statement, not an expression: -->\n{{ var a = 1 }}\n\n<!-- flow control won't work either, use ternary expressions -->\n{{ if (ok) { return message } }}\n```\n\n<p class=\"tip\">Template expressions are sandboxed and only have access to a [whitelist of globals](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9) such as `Math` and `Date`. You should not attempt to access user-defined globals in template expressions.</p>\n\n## Directives\n\nDirectives are special attributes with the `v-` prefix. Directive attribute values are expected to be **a single JavaScript expression** (with the exception of `v-for`, which will be discussed later). A directive's job is to reactively apply side effects to the DOM when the value of its expression changes. Let's review the example we saw in the introduction:\n\n``` html\n<p v-if=\"seen\">Now you see me</p>\n```\n\nHere, the `v-if` directive would remove/insert the `<p>` element based on the truthiness of the value of the expression `seen`.\n\n### Arguments\n\nSome directives can take an \"argument\", denoted by a colon after the directive name. For example, the `v-bind` directive is used to reactively update an HTML attribute:\n\n``` html\n<a v-bind:href=\"url\"> ... </a>\n```\n\nHere `href` is the argument, which tells the `v-bind` directive to bind the element's `href` attribute to the value of the expression `url`.\n\nAnother example is the `v-on` directive, which listens to DOM events:\n\n``` html\n<a v-on:click=\"doSomething\"> ... </a>\n```\n\nHere the argument is the event name to listen to. We will talk about event handling in more detail too.\n\n### Dynamic Arguments\n\n> New in 2.6.0+\n\nStarting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:\n\n``` html\n<!--\nNote that there are some constraints to the argument expression, as explained\nin the \"Dynamic Argument Expression Constraints\" section below.\n-->\n<a v-bind:[attributeName]=\"url\"> ... </a>\n```\n\nHere `attributeName` will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, `attributeName`, whose value is `\"href\"`, then this binding will be equivalent to `v-bind:href`.\n\nSimilarly, you can use dynamic arguments to bind a handler to a dynamic event name:\n\n``` html\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n```\n\nIn this example, when `eventName`'s value is `\"focus\"`, `v-on:[eventName]` will be equivalent to `v-on:focus`.\n\n#### Dynamic Argument Value Constraints\n\nDynamic arguments are expected to evaluate to a string, with the exception of `null`. The special value `null` can be used to explicitly remove the binding. Any other non-string value will trigger a warning.\n\n#### Dynamic Argument Expression Constraints\n\nDynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:\n\n``` html\n<!-- This will trigger a compiler warning. -->\n<a v-bind:['foo' + bar]=\"value\"> ... </a>\n```\n\nThe workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.\n\nWhen using in-DOM templates (i.e., templates written directly in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:\n\n``` html\n<!--\nThis will be converted to v-bind:[someattr] in in-DOM templates.\nUnless you have a \"someattr\" property in your instance, your code won't work.\n-->\n<a v-bind:[someAttr]=\"value\"> ... </a>\n```\n\n### Modifiers\n\nModifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the `.prevent` modifier tells the `v-on` directive to call `event.preventDefault()` on the triggered event:\n\n``` html\n<form v-on:submit.prevent=\"onSubmit\"> ... </form>\n```\n\nYou'll see other examples of modifiers later, [for `v-on`](events.html#Event-Modifiers) and [for `v-model`](forms.html#Modifiers), when we explore those features.\n\n## Shorthands\n\nThe `v-` prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the `v-` prefix becomes less important when you are building a [SPA](https://en.wikipedia.org/wiki/Single-page_application), where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, `v-bind` and `v-on`:\n\n### `v-bind` Shorthand\n\n``` html\n<!-- full syntax -->\n<a v-bind:href=\"url\"> ... </a>\n\n<!-- shorthand -->\n<a :href=\"url\"> ... </a>\n\n<!-- shorthand with dynamic argument (2.6.0+) -->\n<a :[key]=\"url\"> ... </a>\n```\n\n### `v-on` Shorthand\n\n``` html\n<!-- full syntax -->\n<a v-on:click=\"doSomething\"> ... </a>\n\n<!-- shorthand -->\n<a @click=\"doSomething\"> ... </a>\n\n<!-- shorthand with dynamic argument (2.6.0+) -->\n<a @[event]=\"doSomething\"> ... </a>\n```\n\nThey may look a bit different from normal HTML, but `:` and `@` are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.\n","date":"2020-09-25T23:55:41.140Z","updated":"2020-09-25T23:55:41.140Z","path":"v2/guide/syntax.html","comments":1,"layout":"page","_id":"ckfl66gyo002jc2v5cxqgedb3","content":"<p>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance’s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</p>\n<p>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</p>\n<p>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also <a href=\"render-function.html\">directly write render functions</a> instead of templates, with optional JSX support.</p>\n<h2 id=\"Interpolations\"><a href=\"#Interpolations\" class=\"headerlink\" title=\"Interpolations\"></a>Interpolations</h2><h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>The most basic form of data binding is text interpolation using the “Mustache” syntax (double curly braces):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<p>The mustache tag will be replaced with the value of the <code>msg</code> property on the corresponding data object. It will also be updated whenever the data object’s <code>msg</code> property changes.</p>\n<p>You can also perform one-time interpolations that do not update on data change by using the <a href=\"../api/#v-once\">v-once directive</a>, but keep in mind this will also affect any other bindings on the same node:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>This will never change: &#123;&#123; msg &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<h3 id=\"Raw-HTML\"><a href=\"#Raw-HTML\" class=\"headerlink\" title=\"Raw HTML\"></a>Raw HTML</h3><p>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the <a href=\"../api/#v-html\"><code>v-html</code> directive</a>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Using v-html directive: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"rawHtml\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n\n<div id=\"example1\" class=\"demo\">\n  <p>Using mustaches: {{ rawHtml }}</p>\n  <p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n</div>\n<script>\nnew Vue({\n  el: '#example1',\n  data: function () {\n    return {\n      rawHtml: '<span style=\"color: red\">This should be red.</span>'\n    }\n  }\n})\n</script>\n\n<p>The contents of the <code>span</code> will be replaced with the value of the <code>rawHtml</code> property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use <code>v-html</code> to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</p>\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"noopener\">XSS vulnerabilities</a>. Only use HTML interpolation on trusted content and <strong>never</strong> on user-provided content.</p>\n\n<h3 id=\"Attributes\"><a href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"></a>Attributes</h3><p>Mustaches cannot be used inside HTML attributes. Instead, use a <a href=\"../api/#v-bind\"><code>v-bind</code> directive</a>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"dynamicId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>In the case of boolean attributes, where their mere existence implies <code>true</code>, <code>v-bind</code> works a little differently. In this example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-bind:disabled</span>=<span class=\"hljs-string\">\"isButtonDisabled\"</span>&gt;</span>Button<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>If <code>isButtonDisabled</code> has the value of <code>null</code>, <code>undefined</code>, or <code>false</code>, the <code>disabled</code> attribute will not even be included in the rendered <code>&lt;button&gt;</code> element.</p>\n<h3 id=\"Using-JavaScript-Expressions\"><a href=\"#Using-JavaScript-Expressions\" class=\"headerlink\" title=\"Using JavaScript Expressions\"></a>Using JavaScript Expressions</h3><p>So far we’ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</p>\n<pre><code class=\"hljs html\">&#123;&#123; number + 1 &#125;&#125;\n\n&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;\n\n&#123;&#123; message.split('').reverse().join('') &#125;&#125;\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"'list-' + id\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain <strong>one single expression</strong>, so the following will <strong>NOT</strong> work:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- this is a statement, not an expression: --&gt;</span>\n&#123;&#123; var a = 1 &#125;&#125;\n\n<span class=\"hljs-comment\">&lt;!-- flow control won't work either, use ternary expressions --&gt;</span>\n&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</code></pre>\n<p class=\"tip\">Template expressions are sandboxed and only have access to a <a href=\"https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9\" target=\"_blank\" rel=\"noopener\">whitelist of globals</a> such as <code>Math</code> and <code>Date</code>. You should not attempt to access user-defined globals in template expressions.</p>\n\n<h2 id=\"Directives\"><a href=\"#Directives\" class=\"headerlink\" title=\"Directives\"></a>Directives</h2><p>Directives are special attributes with the <code>v-</code> prefix. Directive attribute values are expected to be <strong>a single JavaScript expression</strong> (with the exception of <code>v-for</code>, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. Let’s review the example we saw in the introduction:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>Here, the <code>v-if</code> directive would remove/insert the <code>&lt;p&gt;</code> element based on the truthiness of the value of the expression <code>seen</code>.</p>\n<h3 id=\"Arguments\"><a href=\"#Arguments\" class=\"headerlink\" title=\"Arguments\"></a>Arguments</h3><p>Some directives can take an “argument”, denoted by a colon after the directive name. For example, the <code>v-bind</code> directive is used to reactively update an HTML attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Here <code>href</code> is the argument, which tells the <code>v-bind</code> directive to bind the element’s <code>href</code> attribute to the value of the expression <code>url</code>.</p>\n<p>Another example is the <code>v-on</code> directive, which listens to DOM events:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</p>\n<h3 id=\"Dynamic-Arguments\"><a href=\"#Dynamic-Arguments\" class=\"headerlink\" title=\"Dynamic Arguments\"></a>Dynamic Arguments</h3><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<p>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--\nNote that there are some constraints to the argument expression, as explained\nin the \"Dynamic Argument Expression Constraints\" section below.\n--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">attributeName</span>]=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Here <code>attributeName</code> will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, <code>attributeName</code>, whose value is <code>&quot;href&quot;</code>, then this binding will be equivalent to <code>v-bind:href</code>.</p>\n<p>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:</span>[<span class=\"hljs-attr\">eventName</span>]=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>In this example, when <code>eventName</code>‘s value is <code>&quot;focus&quot;</code>, <code>v-on:[eventName]</code> will be equivalent to <code>v-on:focus</code>.</p>\n<h4 id=\"Dynamic-Argument-Value-Constraints\"><a href=\"#Dynamic-Argument-Value-Constraints\" class=\"headerlink\" title=\"Dynamic Argument Value Constraints\"></a>Dynamic Argument Value Constraints</h4><p>Dynamic arguments are expected to evaluate to a string, with the exception of <code>null</code>. The special value <code>null</code> can be used to explicitly remove the binding. Any other non-string value will trigger a warning.</p>\n<h4 id=\"Dynamic-Argument-Expression-Constraints\"><a href=\"#Dynamic-Argument-Expression-Constraints\" class=\"headerlink\" title=\"Dynamic Argument Expression Constraints\"></a>Dynamic Argument Expression Constraints</h4><p>Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- This will trigger a compiler warning. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:</span>['<span class=\"hljs-attr\">foo</span>' + <span class=\"hljs-attr\">bar</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</p>\n<p>When using in-DOM templates (i.e., templates written directly in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--\nThis will be converted to v-bind:[someattr] in in-DOM templates.\nUnless you have a \"someattr\" property in your instance, your code won't work.\n--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">someAttr</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<h3 id=\"Modifiers\"><a href=\"#Modifiers\" class=\"headerlink\" title=\"Modifiers\"></a>Modifiers</h3><p>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the <code>.prevent</code> modifier tells the <code>v-on</code> directive to call <code>event.preventDefault()</code> on the triggered event:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>=<span class=\"hljs-string\">\"onSubmit\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>You’ll see other examples of modifiers later, <a href=\"events.html#Event-Modifiers\">for <code>v-on</code></a> and <a href=\"forms.html#Modifiers\">for <code>v-model</code></a>, when we explore those features.</p>\n<h2 id=\"Shorthands\"><a href=\"#Shorthands\" class=\"headerlink\" title=\"Shorthands\"></a>Shorthands</h2><p>The <code>v-</code> prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the <code>v-</code> prefix becomes less important when you are building a <a href=\"https://en.wikipedia.org/wiki/Single-page_application\" target=\"_blank\" rel=\"noopener\">SPA</a>, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, <code>v-bind</code> and <code>v-on</code>:</p>\n<h3 id=\"v-bind-Shorthand\"><a href=\"#v-bind-Shorthand\" class=\"headerlink\" title=\"v-bind Shorthand\"></a><code>v-bind</code> Shorthand</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- full syntax --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<h3 id=\"v-on-Shorthand\"><a href=\"#v-on-Shorthand\" class=\"headerlink\" title=\"v-on Shorthand\"></a><code>v-on</code> Shorthand</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- full syntax --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>They may look a bit different from normal HTML, but <code>:</code> and <code>@</code> are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance’s data. All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers.</p>\n<p>Under the hood, Vue compiles the templates into Virtual DOM render functions. Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes.</p>\n<p>If you are familiar with Virtual DOM concepts and prefer the raw power of JavaScript, you can also <a href=\"render-function.html\">directly write render functions</a> instead of templates, with optional JSX support.</p>\n<h2 id=\"Interpolations\"><a href=\"#Interpolations\" class=\"headerlink\" title=\"Interpolations\"></a>Interpolations</h2><h3 id=\"Text\"><a href=\"#Text\" class=\"headerlink\" title=\"Text\"></a>Text</h3><p>The most basic form of data binding is text interpolation using the “Mustache” syntax (double curly braces):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<p>The mustache tag will be replaced with the value of the <code>msg</code> property on the corresponding data object. It will also be updated whenever the data object’s <code>msg</code> property changes.</p>\n<p>You can also perform one-time interpolations that do not update on data change by using the <a href=\"../api/#v-once\">v-once directive</a>, but keep in mind this will also affect any other bindings on the same node:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>This will never change: &#123;&#123; msg &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n<h3 id=\"Raw-HTML\"><a href=\"#Raw-HTML\" class=\"headerlink\" title=\"Raw HTML\"></a>Raw HTML</h3><p>The double mustaches interprets the data as plain text, not HTML. In order to output real HTML, you will need to use the <a href=\"../api/#v-html\"><code>v-html</code> directive</a>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Using v-html directive: <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"rawHtml\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n\n<div id=\"example1\" class=\"demo\">\n  <p>Using mustaches: {{ rawHtml }}</p>\n  <p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n</div>\n<script>\nnew Vue({\n  el: '#example1',\n  data: function () {\n    return {\n      rawHtml: '<span style=\"color: red\">This should be red.</span>'\n    }\n  }\n})\n</script>\n\n<p>The contents of the <code>span</code> will be replaced with the value of the <code>rawHtml</code> property, interpreted as plain HTML - data bindings are ignored. Note that you cannot use <code>v-html</code> to compose template partials, because Vue is not a string-based templating engine. Instead, components are preferred as the fundamental unit for UI reuse and composition.</p>\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"noopener\">XSS vulnerabilities</a>. Only use HTML interpolation on trusted content and <strong>never</strong> on user-provided content.</p>\n\n<h3 id=\"Attributes\"><a href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"></a>Attributes</h3><p>Mustaches cannot be used inside HTML attributes. Instead, use a <a href=\"../api/#v-bind\"><code>v-bind</code> directive</a>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"dynamicId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>In the case of boolean attributes, where their mere existence implies <code>true</code>, <code>v-bind</code> works a little differently. In this example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-bind:disabled</span>=<span class=\"hljs-string\">\"isButtonDisabled\"</span>&gt;</span>Button<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>If <code>isButtonDisabled</code> has the value of <code>null</code>, <code>undefined</code>, or <code>false</code>, the <code>disabled</code> attribute will not even be included in the rendered <code>&lt;button&gt;</code> element.</p>\n<h3 id=\"Using-JavaScript-Expressions\"><a href=\"#Using-JavaScript-Expressions\" class=\"headerlink\" title=\"Using JavaScript Expressions\"></a>Using JavaScript Expressions</h3><p>So far we’ve only been binding to simple property keys in our templates. But Vue.js actually supports the full power of JavaScript expressions inside all data bindings:</p>\n<pre><code class=\"hljs html\">&#123;&#123; number + 1 &#125;&#125;\n\n&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;\n\n&#123;&#123; message.split('').reverse().join('') &#125;&#125;\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:id</span>=<span class=\"hljs-string\">\"'list-' + id\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance. One restriction is that each binding can only contain <strong>one single expression</strong>, so the following will <strong>NOT</strong> work:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- this is a statement, not an expression: --&gt;</span>\n&#123;&#123; var a = 1 &#125;&#125;\n\n<span class=\"hljs-comment\">&lt;!-- flow control won't work either, use ternary expressions --&gt;</span>\n&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</code></pre>\n<p class=\"tip\">Template expressions are sandboxed and only have access to a <a href=\"https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9\" target=\"_blank\" rel=\"noopener\">whitelist of globals</a> such as <code>Math</code> and <code>Date</code>. You should not attempt to access user-defined globals in template expressions.</p>\n\n<h2 id=\"Directives\"><a href=\"#Directives\" class=\"headerlink\" title=\"Directives\"></a>Directives</h2><p>Directives are special attributes with the <code>v-</code> prefix. Directive attribute values are expected to be <strong>a single JavaScript expression</strong> (with the exception of <code>v-for</code>, which will be discussed later). A directive’s job is to reactively apply side effects to the DOM when the value of its expression changes. Let’s review the example we saw in the introduction:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"seen\"</span>&gt;</span>Now you see me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n<p>Here, the <code>v-if</code> directive would remove/insert the <code>&lt;p&gt;</code> element based on the truthiness of the value of the expression <code>seen</code>.</p>\n<h3 id=\"Arguments\"><a href=\"#Arguments\" class=\"headerlink\" title=\"Arguments\"></a>Arguments</h3><p>Some directives can take an “argument”, denoted by a colon after the directive name. For example, the <code>v-bind</code> directive is used to reactively update an HTML attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Here <code>href</code> is the argument, which tells the <code>v-bind</code> directive to bind the element’s <code>href</code> attribute to the value of the expression <code>url</code>.</p>\n<p>Another example is the <code>v-on</code> directive, which listens to DOM events:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Here the argument is the event name to listen to. We will talk about event handling in more detail too.</p>\n<h3 id=\"Dynamic-Arguments\"><a href=\"#Dynamic-Arguments\" class=\"headerlink\" title=\"Dynamic Arguments\"></a>Dynamic Arguments</h3><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<p>Starting in version 2.6.0, it is also possible to use a JavaScript expression in a directive argument by wrapping it with square brackets:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--\nNote that there are some constraints to the argument expression, as explained\nin the \"Dynamic Argument Expression Constraints\" section below.\n--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">attributeName</span>]=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>Here <code>attributeName</code> will be dynamically evaluated as a JavaScript expression, and its evaluated value will be used as the final value for the argument. For example, if your Vue instance has a data property, <code>attributeName</code>, whose value is <code>&quot;href&quot;</code>, then this binding will be equivalent to <code>v-bind:href</code>.</p>\n<p>Similarly, you can use dynamic arguments to bind a handler to a dynamic event name:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:</span>[<span class=\"hljs-attr\">eventName</span>]=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>In this example, when <code>eventName</code>‘s value is <code>&quot;focus&quot;</code>, <code>v-on:[eventName]</code> will be equivalent to <code>v-on:focus</code>.</p>\n<h4 id=\"Dynamic-Argument-Value-Constraints\"><a href=\"#Dynamic-Argument-Value-Constraints\" class=\"headerlink\" title=\"Dynamic Argument Value Constraints\"></a>Dynamic Argument Value Constraints</h4><p>Dynamic arguments are expected to evaluate to a string, with the exception of <code>null</code>. The special value <code>null</code> can be used to explicitly remove the binding. Any other non-string value will trigger a warning.</p>\n<h4 id=\"Dynamic-Argument-Expression-Constraints\"><a href=\"#Dynamic-Argument-Expression-Constraints\" class=\"headerlink\" title=\"Dynamic Argument Expression Constraints\"></a>Dynamic Argument Expression Constraints</h4><p>Dynamic argument expressions have some syntax constraints because certain characters, such as spaces and quotes, are invalid inside HTML attribute names. For example, the following is invalid:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- This will trigger a compiler warning. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:</span>['<span class=\"hljs-attr\">foo</span>' + <span class=\"hljs-attr\">bar</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>The workaround is to either use expressions without spaces or quotes, or replace the complex expression with a computed property.</p>\n<p>When using in-DOM templates (i.e., templates written directly in an HTML file), you should also avoid naming keys with uppercase characters, as browsers will coerce attribute names into lowercase:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!--\nThis will be converted to v-bind:[someattr] in in-DOM templates.\nUnless you have a \"someattr\" property in your instance, your code won't work.\n--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">someAttr</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<h3 id=\"Modifiers\"><a href=\"#Modifiers\" class=\"headerlink\" title=\"Modifiers\"></a>Modifiers</h3><p>Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way. For example, the <code>.prevent</code> modifier tells the <code>v-on</code> directive to call <code>event.preventDefault()</code> on the triggered event:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">v-on:submit.prevent</span>=<span class=\"hljs-string\">\"onSubmit\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span></code></pre>\n<p>You’ll see other examples of modifiers later, <a href=\"events.html#Event-Modifiers\">for <code>v-on</code></a> and <a href=\"forms.html#Modifiers\">for <code>v-model</code></a>, when we explore those features.</p>\n<h2 id=\"Shorthands\"><a href=\"#Shorthands\" class=\"headerlink\" title=\"Shorthands\"></a>Shorthands</h2><p>The <code>v-</code> prefix serves as a visual cue for identifying Vue-specific attributes in your templates. This is useful when you are using Vue.js to apply dynamic behavior to some existing markup, but can feel verbose for some frequently used directives. At the same time, the need for the <code>v-</code> prefix becomes less important when you are building a <a href=\"https://en.wikipedia.org/wiki/Single-page_application\" target=\"_blank\" rel=\"noopener\">SPA</a>, where Vue manages every template. Therefore, Vue provides special shorthands for two of the most often used directives, <code>v-bind</code> and <code>v-on</code>:</p>\n<h3 id=\"v-bind-Shorthand\"><a href=\"#v-bind-Shorthand\" class=\"headerlink\" title=\"v-bind Shorthand\"></a><code>v-bind</code> Shorthand</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- full syntax --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-bind:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:href</span>=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"url\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<h3 id=\"v-on-Shorthand\"><a href=\"#v-on-Shorthand\" class=\"headerlink\" title=\"v-on Shorthand\"></a><code>v-on</code> Shorthand</h3><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- full syntax --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand with dynamic argument (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> @[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doSomething\"</span>&gt;</span> ... <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span></code></pre>\n<p>They may look a bit different from normal HTML, but <code>:</code> and <code>@</code> are valid characters for attribute names and all Vue-supported browsers can parse it correctly. In addition, they do not appear in the final rendered markup. The shorthand syntax is totally optional, but you will likely appreciate it when you learn more about its usage later.</p>\n"},{"title":"Testing","type":"guide","order":402,"_content":"\n# Testing\n\n## Introduction\n\nWhen it comes to building reliable applications, tests can play a critical role in an individual or team's ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:\n\n- Unit Testing\n- Component Testing\n- End-To-End (E2E) Testing\n\nThis section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.\n\n## Unit Testing\n\n### Introduction\n\nUnit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.\n\nUnit testing a Vue application does not significantly differ from testing other types of applications.\n\n### Choosing Your Framework\n\nSince unit testing advice is often framework-agnostic, here are some basic guidelines to keep in mind when evaluating which unit testing tool is best for your application.\n\n#### First-class error reporting\n\nWhen tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.\n\nSome unit testing frameworks, like Jest, include assertion libraries. Others, like Mocha, require you to install assertion libraries separately (usually Chai).\n\n#### Active community and team\n\nSince the majority of unit testing frameworks are open-source, having a community that is active can be critical to some teams that will be maintaining their tests for a long period of time and needs to ensure that a project will be actively maintained. In addition, having an active community has the benefit of providing more support whenever you run into issues.\n\n### Frameworks\n\nWhile there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.\n\n#### Jest\n\nJest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.\n\n**Resources:**\n\n- [Official Jest Website](https://jestjs.io)\n- [Official Vue 2 CLI Plugin - Jest](https://cli.vuejs.org/core-plugins/unit-jest.html)\n\n#### Mocha\n\nMocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.\n\n**Resources:**\n\n- [Official Mocha Website](https://mochajs.org)\n- [Official Vue CLI Plugin - Mocha](https://cli.vuejs.org/core-plugins/unit-mocha.html)\n\n## Component Testing\n\n### Introduction\n\nTo test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.\n\n### Choosing Your Framework\n\nThe following section provides guidelines on things to keep in mind when evaluating which component testing framework is best for your application.\n\n#### Optimal compatibility with the Vue ecosystem\n\nIt should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.\n\n#### First-class error reporting\n\nWhen tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.\n\n### Recommendations\n\n#### Vue Testing Library (@testing-library/vue)\n\nVue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.\n\nIts guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.\n\n**Resources:**\n\n- [Official Vue Testing Library Website](https://testing-library.com/docs/vue-testing-library/intro)\n\n#### Vue Test Utils\n\nVue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.\n\n**Resources**\n\n- [Official Vue Test Utils Documentation](https://vue-test-utils.vuejs.org)\n- [Vue Testing Handbook](https://lmiller1990.github.io/vue-testing-handbook/#what-is-this-guide) by Lachlan Miller\n- [Cookbook: Unit Testing Vue Components](https://vuejs.org/v2/cookbook/unit-testing-vue-components.html)\n\n## End-to-End (E2E) Testing\n\n### Introduction\n\nWhile unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.\n\nIn other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.\n\n### Choosing Your Framework\n\nWhile end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.\n\n#### Cross-browser testing\n\nOne of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.\n\n<p class=\"tip\">A recent development in for catching browser-specific issues is using application monitoring and error reporting tools (e.g., Sentry, LogRocket, etc.) for browsers that are not as commonly used (e.g., < IE11, older Safari versions, etc.).</p>\n\n#### Faster feedback loops\n\nOne of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer's workflow and productivity.\n\n#### First class debugging experience\n\nWhile developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.\n\n#### Visibility in headless mode\n\nWhen end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.\n\n### Recommendations\n\nWhile there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.\n\n#### Cypress.io\n\nCypress.io is a testing framework that aims to enhance developer productivity by enabling developers to reliably test their applications while providing a first class developer experience.\n\n**Resources**\n\n- [Cypress' Official Website](https://www.cypress.io)\n- [Official Vue CLI Cypress Plugin](https://cli.vuejs.org/core-plugins/e2e-cypress.html)\n- [Cypress Testing Library](https://github.com/testing-library/cypress-testing-library)\n\n#### Nightwatch.js\n\nNightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.\n\n**Resources:**\n\n- [Nightwatch's Official Website](https://nightwatchjs.org)\n- [Official Vue CLI Nightwatch Plugin](https://cli.vuejs.org/core-plugins/e2e-nightwatch.html)\n\n#### Puppeteer\n\nPuppeteer is a Node library that provides a high-level API to control the browser and can pair with other test runners (e.g., Jest) to test your application.\n\n**Resources:**\n\n- [Puppeteer's Official Website](https://pptr.dev)\n\n#### TestCafe\n\nTestCafe is a Node.js based end-to-end framework that aims to provide easy setup so that developers can focus on creating tests that are easy to write and reliable.\n\n**Resources:**\n\n- [TestCafe's Official Website](https://devexpress.github.io/testcafe/)\n","source":"v2/guide/testing.md","raw":"---\ntitle: Testing\ntype: guide\norder: 402\n---\n\n# Testing\n\n## Introduction\n\nWhen it comes to building reliable applications, tests can play a critical role in an individual or team's ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:\n\n- Unit Testing\n- Component Testing\n- End-To-End (E2E) Testing\n\nThis section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.\n\n## Unit Testing\n\n### Introduction\n\nUnit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.\n\nUnit testing a Vue application does not significantly differ from testing other types of applications.\n\n### Choosing Your Framework\n\nSince unit testing advice is often framework-agnostic, here are some basic guidelines to keep in mind when evaluating which unit testing tool is best for your application.\n\n#### First-class error reporting\n\nWhen tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.\n\nSome unit testing frameworks, like Jest, include assertion libraries. Others, like Mocha, require you to install assertion libraries separately (usually Chai).\n\n#### Active community and team\n\nSince the majority of unit testing frameworks are open-source, having a community that is active can be critical to some teams that will be maintaining their tests for a long period of time and needs to ensure that a project will be actively maintained. In addition, having an active community has the benefit of providing more support whenever you run into issues.\n\n### Frameworks\n\nWhile there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.\n\n#### Jest\n\nJest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.\n\n**Resources:**\n\n- [Official Jest Website](https://jestjs.io)\n- [Official Vue 2 CLI Plugin - Jest](https://cli.vuejs.org/core-plugins/unit-jest.html)\n\n#### Mocha\n\nMocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.\n\n**Resources:**\n\n- [Official Mocha Website](https://mochajs.org)\n- [Official Vue CLI Plugin - Mocha](https://cli.vuejs.org/core-plugins/unit-mocha.html)\n\n## Component Testing\n\n### Introduction\n\nTo test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.\n\n### Choosing Your Framework\n\nThe following section provides guidelines on things to keep in mind when evaluating which component testing framework is best for your application.\n\n#### Optimal compatibility with the Vue ecosystem\n\nIt should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.\n\n#### First-class error reporting\n\nWhen tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.\n\n### Recommendations\n\n#### Vue Testing Library (@testing-library/vue)\n\nVue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.\n\nIts guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.\n\n**Resources:**\n\n- [Official Vue Testing Library Website](https://testing-library.com/docs/vue-testing-library/intro)\n\n#### Vue Test Utils\n\nVue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.\n\n**Resources**\n\n- [Official Vue Test Utils Documentation](https://vue-test-utils.vuejs.org)\n- [Vue Testing Handbook](https://lmiller1990.github.io/vue-testing-handbook/#what-is-this-guide) by Lachlan Miller\n- [Cookbook: Unit Testing Vue Components](https://vuejs.org/v2/cookbook/unit-testing-vue-components.html)\n\n## End-to-End (E2E) Testing\n\n### Introduction\n\nWhile unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.\n\nIn other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.\n\n### Choosing Your Framework\n\nWhile end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.\n\n#### Cross-browser testing\n\nOne of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team's resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.\n\n<p class=\"tip\">A recent development in for catching browser-specific issues is using application monitoring and error reporting tools (e.g., Sentry, LogRocket, etc.) for browsers that are not as commonly used (e.g., < IE11, older Safari versions, etc.).</p>\n\n#### Faster feedback loops\n\nOne of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer's workflow and productivity.\n\n#### First class debugging experience\n\nWhile developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.\n\n#### Visibility in headless mode\n\nWhen end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.\n\n### Recommendations\n\nWhile there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.\n\n#### Cypress.io\n\nCypress.io is a testing framework that aims to enhance developer productivity by enabling developers to reliably test their applications while providing a first class developer experience.\n\n**Resources**\n\n- [Cypress' Official Website](https://www.cypress.io)\n- [Official Vue CLI Cypress Plugin](https://cli.vuejs.org/core-plugins/e2e-cypress.html)\n- [Cypress Testing Library](https://github.com/testing-library/cypress-testing-library)\n\n#### Nightwatch.js\n\nNightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.\n\n**Resources:**\n\n- [Nightwatch's Official Website](https://nightwatchjs.org)\n- [Official Vue CLI Nightwatch Plugin](https://cli.vuejs.org/core-plugins/e2e-nightwatch.html)\n\n#### Puppeteer\n\nPuppeteer is a Node library that provides a high-level API to control the browser and can pair with other test runners (e.g., Jest) to test your application.\n\n**Resources:**\n\n- [Puppeteer's Official Website](https://pptr.dev)\n\n#### TestCafe\n\nTestCafe is a Node.js based end-to-end framework that aims to provide easy setup so that developers can focus on creating tests that are easy to write and reliable.\n\n**Resources:**\n\n- [TestCafe's Official Website](https://devexpress.github.io/testcafe/)\n","date":"2020-09-25T23:55:41.140Z","updated":"2020-09-25T23:55:41.140Z","path":"v2/guide/testing.html","comments":1,"layout":"page","_id":"ckfl66gyp002kc2v519dyceaw","content":"<h1 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing\"></a>Testing</h1><h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>When it comes to building reliable applications, tests can play a critical role in an individual or team’s ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:</p>\n<ul>\n<li>Unit Testing</li>\n<li>Component Testing</li>\n<li>End-To-End (E2E) Testing</li>\n</ul>\n<p>This section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.</p>\n<h2 id=\"Unit-Testing\"><a href=\"#Unit-Testing\" class=\"headerlink\" title=\"Unit Testing\"></a>Unit Testing</h2><h3 id=\"Introduction-1\"><a href=\"#Introduction-1\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Unit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.</p>\n<p>Unit testing a Vue application does not significantly differ from testing other types of applications.</p>\n<h3 id=\"Choosing-Your-Framework\"><a href=\"#Choosing-Your-Framework\" class=\"headerlink\" title=\"Choosing Your Framework\"></a>Choosing Your Framework</h3><p>Since unit testing advice is often framework-agnostic, here are some basic guidelines to keep in mind when evaluating which unit testing tool is best for your application.</p>\n<h4 id=\"First-class-error-reporting\"><a href=\"#First-class-error-reporting\" class=\"headerlink\" title=\"First-class error reporting\"></a>First-class error reporting</h4><p>When tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.</p>\n<p>Some unit testing frameworks, like Jest, include assertion libraries. Others, like Mocha, require you to install assertion libraries separately (usually Chai).</p>\n<h4 id=\"Active-community-and-team\"><a href=\"#Active-community-and-team\" class=\"headerlink\" title=\"Active community and team\"></a>Active community and team</h4><p>Since the majority of unit testing frameworks are open-source, having a community that is active can be critical to some teams that will be maintaining their tests for a long period of time and needs to ensure that a project will be actively maintained. In addition, having an active community has the benefit of providing more support whenever you run into issues.</p>\n<h3 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h3><p>While there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.</p>\n<h4 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h4><p>Jest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://jestjs.io\" target=\"_blank\" rel=\"noopener\">Official Jest Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/unit-jest.html\" target=\"_blank\" rel=\"noopener\">Official Vue 2 CLI Plugin - Jest</a></li>\n</ul>\n<h4 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h4><p>Mocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://mochajs.org\" target=\"_blank\" rel=\"noopener\">Official Mocha Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/unit-mocha.html\" target=\"_blank\" rel=\"noopener\">Official Vue CLI Plugin - Mocha</a></li>\n</ul>\n<h2 id=\"Component-Testing\"><a href=\"#Component-Testing\" class=\"headerlink\" title=\"Component Testing\"></a>Component Testing</h2><h3 id=\"Introduction-2\"><a href=\"#Introduction-2\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>To test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.</p>\n<h3 id=\"Choosing-Your-Framework-1\"><a href=\"#Choosing-Your-Framework-1\" class=\"headerlink\" title=\"Choosing Your Framework\"></a>Choosing Your Framework</h3><p>The following section provides guidelines on things to keep in mind when evaluating which component testing framework is best for your application.</p>\n<h4 id=\"Optimal-compatibility-with-the-Vue-ecosystem\"><a href=\"#Optimal-compatibility-with-the-Vue-ecosystem\" class=\"headerlink\" title=\"Optimal compatibility with the Vue ecosystem\"></a>Optimal compatibility with the Vue ecosystem</h4><p>It should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.</p>\n<h4 id=\"First-class-error-reporting-1\"><a href=\"#First-class-error-reporting-1\" class=\"headerlink\" title=\"First-class error reporting\"></a>First-class error reporting</h4><p>When tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.</p>\n<h3 id=\"Recommendations\"><a href=\"#Recommendations\" class=\"headerlink\" title=\"Recommendations\"></a>Recommendations</h3><h4 id=\"Vue-Testing-Library-testing-library-vue\"><a href=\"#Vue-Testing-Library-testing-library-vue\" class=\"headerlink\" title=\"Vue Testing Library (@testing-library/vue)\"></a>Vue Testing Library (@testing-library/vue)</h4><p>Vue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.</p>\n<p>Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://testing-library.com/docs/vue-testing-library/intro\" target=\"_blank\" rel=\"noopener\">Official Vue Testing Library Website</a></li>\n</ul>\n<h4 id=\"Vue-Test-Utils\"><a href=\"#Vue-Test-Utils\" class=\"headerlink\" title=\"Vue Test Utils\"></a>Vue Test Utils</h4><p>Vue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.</p>\n<p><strong>Resources</strong></p>\n<ul>\n<li><a href=\"https://vue-test-utils.vuejs.org\" target=\"_blank\" rel=\"noopener\">Official Vue Test Utils Documentation</a></li>\n<li><a href=\"https://lmiller1990.github.io/vue-testing-handbook/#what-is-this-guide\" target=\"_blank\" rel=\"noopener\">Vue Testing Handbook</a> by Lachlan Miller</li>\n<li><a href=\"https://vuejs.org/v2/cookbook/unit-testing-vue-components.html\">Cookbook: Unit Testing Vue Components</a></li>\n</ul>\n<h2 id=\"End-to-End-E2E-Testing\"><a href=\"#End-to-End-E2E-Testing\" class=\"headerlink\" title=\"End-to-End (E2E) Testing\"></a>End-to-End (E2E) Testing</h2><h3 id=\"Introduction-3\"><a href=\"#Introduction-3\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>While unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.</p>\n<p>In other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.</p>\n<h3 id=\"Choosing-Your-Framework-2\"><a href=\"#Choosing-Your-Framework-2\" class=\"headerlink\" title=\"Choosing Your Framework\"></a>Choosing Your Framework</h3><p>While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.</p>\n<h4 id=\"Cross-browser-testing\"><a href=\"#Cross-browser-testing\" class=\"headerlink\" title=\"Cross-browser testing\"></a>Cross-browser testing</h4><p>One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team’s resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.</p>\n<p class=\"tip\">A recent development in for catching browser-specific issues is using application monitoring and error reporting tools (e.g., Sentry, LogRocket, etc.) for browsers that are not as commonly used (e.g., &lt; IE11, older Safari versions, etc.).</p>\n\n<h4 id=\"Faster-feedback-loops\"><a href=\"#Faster-feedback-loops\" class=\"headerlink\" title=\"Faster feedback loops\"></a>Faster feedback loops</h4><p>One of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer’s workflow and productivity.</p>\n<h4 id=\"First-class-debugging-experience\"><a href=\"#First-class-debugging-experience\" class=\"headerlink\" title=\"First class debugging experience\"></a>First class debugging experience</h4><p>While developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.</p>\n<h4 id=\"Visibility-in-headless-mode\"><a href=\"#Visibility-in-headless-mode\" class=\"headerlink\" title=\"Visibility in headless mode\"></a>Visibility in headless mode</h4><p>When end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.</p>\n<h3 id=\"Recommendations-1\"><a href=\"#Recommendations-1\" class=\"headerlink\" title=\"Recommendations\"></a>Recommendations</h3><p>While there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.</p>\n<h4 id=\"Cypress-io\"><a href=\"#Cypress-io\" class=\"headerlink\" title=\"Cypress.io\"></a>Cypress.io</h4><p>Cypress.io is a testing framework that aims to enhance developer productivity by enabling developers to reliably test their applications while providing a first class developer experience.</p>\n<p><strong>Resources</strong></p>\n<ul>\n<li><a href=\"https://www.cypress.io\" target=\"_blank\" rel=\"noopener\">Cypress’ Official Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/e2e-cypress.html\" target=\"_blank\" rel=\"noopener\">Official Vue CLI Cypress Plugin</a></li>\n<li><a href=\"https://github.com/testing-library/cypress-testing-library\" target=\"_blank\" rel=\"noopener\">Cypress Testing Library</a></li>\n</ul>\n<h4 id=\"Nightwatch-js\"><a href=\"#Nightwatch-js\" class=\"headerlink\" title=\"Nightwatch.js\"></a>Nightwatch.js</h4><p>Nightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://nightwatchjs.org\" target=\"_blank\" rel=\"noopener\">Nightwatch’s Official Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/e2e-nightwatch.html\" target=\"_blank\" rel=\"noopener\">Official Vue CLI Nightwatch Plugin</a></li>\n</ul>\n<h4 id=\"Puppeteer\"><a href=\"#Puppeteer\" class=\"headerlink\" title=\"Puppeteer\"></a>Puppeteer</h4><p>Puppeteer is a Node library that provides a high-level API to control the browser and can pair with other test runners (e.g., Jest) to test your application.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://pptr.dev\" target=\"_blank\" rel=\"noopener\">Puppeteer’s Official Website</a></li>\n</ul>\n<h4 id=\"TestCafe\"><a href=\"#TestCafe\" class=\"headerlink\" title=\"TestCafe\"></a>TestCafe</h4><p>TestCafe is a Node.js based end-to-end framework that aims to provide easy setup so that developers can focus on creating tests that are easy to write and reliable.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://devexpress.github.io/testcafe/\" target=\"_blank\" rel=\"noopener\">TestCafe’s Official Website</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Testing\"><a href=\"#Testing\" class=\"headerlink\" title=\"Testing\"></a>Testing</h1><h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>When it comes to building reliable applications, tests can play a critical role in an individual or team’s ability to build new features, refactor code, fix bugs, etc. While there are many schools of thought with testing, there are three categories often discussed in the context of web applications:</p>\n<ul>\n<li>Unit Testing</li>\n<li>Component Testing</li>\n<li>End-To-End (E2E) Testing</li>\n</ul>\n<p>This section aims to provide guidance to navigating the testing ecosystem and choosing the right tools for your Vue application or component library.</p>\n<h2 id=\"Unit-Testing\"><a href=\"#Unit-Testing\" class=\"headerlink\" title=\"Unit Testing\"></a>Unit Testing</h2><h3 id=\"Introduction-1\"><a href=\"#Introduction-1\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>Unit tests allow you to test individual units of code in isolation. The purpose of unit testing is to provide developers with confidence in their code. By writing thorough, meaningful tests, you achieve the confidence that as new features are built or your code is refactored your application will remain functional and stable.</p>\n<p>Unit testing a Vue application does not significantly differ from testing other types of applications.</p>\n<h3 id=\"Choosing-Your-Framework\"><a href=\"#Choosing-Your-Framework\" class=\"headerlink\" title=\"Choosing Your Framework\"></a>Choosing Your Framework</h3><p>Since unit testing advice is often framework-agnostic, here are some basic guidelines to keep in mind when evaluating which unit testing tool is best for your application.</p>\n<h4 id=\"First-class-error-reporting\"><a href=\"#First-class-error-reporting\" class=\"headerlink\" title=\"First-class error reporting\"></a>First-class error reporting</h4><p>When tests fail, it is critical that your unit testing framework provides useful errors. This is the job of the assertion library. An assertion with high-quality error messages helps minimize the amount of time it takes to debug the problem. In addition to simply telling you what test is failing, assertion libraries provide context for why a test fails, e.g., what is expected vs what was received.</p>\n<p>Some unit testing frameworks, like Jest, include assertion libraries. Others, like Mocha, require you to install assertion libraries separately (usually Chai).</p>\n<h4 id=\"Active-community-and-team\"><a href=\"#Active-community-and-team\" class=\"headerlink\" title=\"Active community and team\"></a>Active community and team</h4><p>Since the majority of unit testing frameworks are open-source, having a community that is active can be critical to some teams that will be maintaining their tests for a long period of time and needs to ensure that a project will be actively maintained. In addition, having an active community has the benefit of providing more support whenever you run into issues.</p>\n<h3 id=\"Frameworks\"><a href=\"#Frameworks\" class=\"headerlink\" title=\"Frameworks\"></a>Frameworks</h3><p>While there are many tools in the ecosystem, here are some common unit testing tools that are being used in the Vue.js ecosystem.</p>\n<h4 id=\"Jest\"><a href=\"#Jest\" class=\"headerlink\" title=\"Jest\"></a>Jest</h4><p>Jest is a JavaScript test framework that is focused on simplicity. One of its unique features is the ability to take snapshots of tests in order to provide an alternative means of verifying units of your application.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://jestjs.io\" target=\"_blank\" rel=\"noopener\">Official Jest Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/unit-jest.html\" target=\"_blank\" rel=\"noopener\">Official Vue 2 CLI Plugin - Jest</a></li>\n</ul>\n<h4 id=\"Mocha\"><a href=\"#Mocha\" class=\"headerlink\" title=\"Mocha\"></a>Mocha</h4><p>Mocha is a JavaScript test framework that is focused on being flexible. Because of this flexibility, it allows you to choose different libraries to fulfill other common features such as spying (e.g., Sinon) and assertions (e.g., Chai). Another unique feature of Mocha is that it can also execute tests in the browser in addition to Node.js.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://mochajs.org\" target=\"_blank\" rel=\"noopener\">Official Mocha Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/unit-mocha.html\" target=\"_blank\" rel=\"noopener\">Official Vue CLI Plugin - Mocha</a></li>\n</ul>\n<h2 id=\"Component-Testing\"><a href=\"#Component-Testing\" class=\"headerlink\" title=\"Component Testing\"></a>Component Testing</h2><h3 id=\"Introduction-2\"><a href=\"#Introduction-2\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>To test most Vue components, they must be mounted to the DOM (either virtual or real) in order to fully assert that they are working. This is another framework-agnostic concept. As a result, component testing frameworks were created to give users the ability to do this in a reliable way while also providing Vue-specific conveniences such as integrations for Vuex, Vue Router, and other Vue plugins.</p>\n<h3 id=\"Choosing-Your-Framework-1\"><a href=\"#Choosing-Your-Framework-1\" class=\"headerlink\" title=\"Choosing Your Framework\"></a>Choosing Your Framework</h3><p>The following section provides guidelines on things to keep in mind when evaluating which component testing framework is best for your application.</p>\n<h4 id=\"Optimal-compatibility-with-the-Vue-ecosystem\"><a href=\"#Optimal-compatibility-with-the-Vue-ecosystem\" class=\"headerlink\" title=\"Optimal compatibility with the Vue ecosystem\"></a>Optimal compatibility with the Vue ecosystem</h4><p>It should be no surprise that one of the first criteria is that a component testing library should have is being as compatible with the Vue ecosystem as possible. While this may seem comprehensive, some key integration areas to keep in mind include single file components (SFCs), Vuex, Vue Router, and any other Vue specific plugins that your application relies on.</p>\n<h4 id=\"First-class-error-reporting-1\"><a href=\"#First-class-error-reporting-1\" class=\"headerlink\" title=\"First-class error reporting\"></a>First-class error reporting</h4><p>When tests fail, it is critical that your component testing framework provides useful error logs that help to minimize the amount of time it takes to debug the problem. In addition to simply telling you what test fails, they should also provides context for why a test fails, e.g., what is expected vs what was received.</p>\n<h3 id=\"Recommendations\"><a href=\"#Recommendations\" class=\"headerlink\" title=\"Recommendations\"></a>Recommendations</h3><h4 id=\"Vue-Testing-Library-testing-library-vue\"><a href=\"#Vue-Testing-Library-testing-library-vue\" class=\"headerlink\" title=\"Vue Testing Library (@testing-library/vue)\"></a>Vue Testing Library (@testing-library/vue)</h4><p>Vue Testing Library is a set of tools focused on testing components without relying on implementation details. Built with accessibility in mind, its approach also makes refactoring a breeze.</p>\n<p>Its guiding principle is that the more tests resemble the way software is used, the more confidence they can provide.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://testing-library.com/docs/vue-testing-library/intro\" target=\"_blank\" rel=\"noopener\">Official Vue Testing Library Website</a></li>\n</ul>\n<h4 id=\"Vue-Test-Utils\"><a href=\"#Vue-Test-Utils\" class=\"headerlink\" title=\"Vue Test Utils\"></a>Vue Test Utils</h4><p>Vue Test Utils is the official low-level component testing library that was written to provide users access to Vue specific APIs. If you are new to testing Vue applications, we would recommend using Vue Testing Library, which is an abstraction over Vue Test Utils.</p>\n<p><strong>Resources</strong></p>\n<ul>\n<li><a href=\"https://vue-test-utils.vuejs.org\" target=\"_blank\" rel=\"noopener\">Official Vue Test Utils Documentation</a></li>\n<li><a href=\"https://lmiller1990.github.io/vue-testing-handbook/#what-is-this-guide\" target=\"_blank\" rel=\"noopener\">Vue Testing Handbook</a> by Lachlan Miller</li>\n<li><a href=\"https://vuejs.org/v2/cookbook/unit-testing-vue-components.html\">Cookbook: Unit Testing Vue Components</a></li>\n</ul>\n<h2 id=\"End-to-End-E2E-Testing\"><a href=\"#End-to-End-E2E-Testing\" class=\"headerlink\" title=\"End-to-End (E2E) Testing\"></a>End-to-End (E2E) Testing</h2><h3 id=\"Introduction-3\"><a href=\"#Introduction-3\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h3><p>While unit tests provide developers with some degree of confidence, unit and component tests are limited in their abilities to provide holistic coverage of an application when deployed to production. As a result, end-to-end (E2E) tests provide coverage on what is arguably the most important aspect of an application: what happens when users actually use your applications.</p>\n<p>In other words, E2E tests validate all of the layers in your application. This not only includes your frontend code, but all associated backend services and infrastructure that are more representative of the environment that your users will be in. By testing how user actions impact your application, E2E tests are often the key to higher confidence in whether an application is functioning properly or not.</p>\n<h3 id=\"Choosing-Your-Framework-2\"><a href=\"#Choosing-Your-Framework-2\" class=\"headerlink\" title=\"Choosing Your Framework\"></a>Choosing Your Framework</h3><p>While end-to-end (E2E) testing on the web has gained a negative reputation for unreliable (flaky) tests and slowing down development processes, modern E2E tools have made strides forward to create more reliable, interactive, and useful tests. When choosing an E2E testing framework, the following sections provide some guidance on things to keep in mind when choosing a testing framework for your application.</p>\n<h4 id=\"Cross-browser-testing\"><a href=\"#Cross-browser-testing\" class=\"headerlink\" title=\"Cross-browser testing\"></a>Cross-browser testing</h4><p>One of the primary benefits that end-to-end (E2E) testing is known for is its ability to test your application across multiple browsers. While it may seem desirable to have 100% cross-browser coverage, it is important to note that cross browser testing has diminishing returns on a team’s resources due the additional time and machine power required to run them consistently. As a result, it is important to be mindful of this trade-off when choosing the amount of cross-browser testing your application needs.</p>\n<p class=\"tip\">A recent development in for catching browser-specific issues is using application monitoring and error reporting tools (e.g., Sentry, LogRocket, etc.) for browsers that are not as commonly used (e.g., &lt; IE11, older Safari versions, etc.).</p>\n\n<h4 id=\"Faster-feedback-loops\"><a href=\"#Faster-feedback-loops\" class=\"headerlink\" title=\"Faster feedback loops\"></a>Faster feedback loops</h4><p>One of the primary problems with end-to-end (E2E) tests and development is that running the entire suite takes a long time. Typically, this is only done in continuous integration and deployment (CI/CD) pipelines. Modern E2E testing frameworks have helped to solve this by adding features like parallelization, which allows for CI/CD pipelines to often run magnitudes faster than before. In addition, when developing locally, the ability to selectively run a single test for the page you are working on while also providing hot reloading of tests can help to boost a developer’s workflow and productivity.</p>\n<h4 id=\"First-class-debugging-experience\"><a href=\"#First-class-debugging-experience\" class=\"headerlink\" title=\"First class debugging experience\"></a>First class debugging experience</h4><p>While developers have traditionally relied on scanning logs in a terminal window to help determine what went wrong in a test, modern end-to-end (E2E) test frameworks allow developers to leverage tools that they are already familiar with, e.g. browser developer tools.</p>\n<h4 id=\"Visibility-in-headless-mode\"><a href=\"#Visibility-in-headless-mode\" class=\"headerlink\" title=\"Visibility in headless mode\"></a>Visibility in headless mode</h4><p>When end-to-end (E2E) tests are run in continuous integration / deployment pipelines, they are often run in headless browsers (i.e., no visible browser is opened for the user to watch). As a result, when errors occur, a critical feature that modern E2E testing frameworks provide 1st class support for is the ability to see snapshots and/or videos of your applications during various testing stages in order to provide insight into why errors are happening. Historically, it was tedious to maintain these integrations.</p>\n<h3 id=\"Recommendations-1\"><a href=\"#Recommendations-1\" class=\"headerlink\" title=\"Recommendations\"></a>Recommendations</h3><p>While there are many tools in the ecosystem, here are some common end-to-end (E2E) testing frameworks that are being used in the Vue.js ecosystem.</p>\n<h4 id=\"Cypress-io\"><a href=\"#Cypress-io\" class=\"headerlink\" title=\"Cypress.io\"></a>Cypress.io</h4><p>Cypress.io is a testing framework that aims to enhance developer productivity by enabling developers to reliably test their applications while providing a first class developer experience.</p>\n<p><strong>Resources</strong></p>\n<ul>\n<li><a href=\"https://www.cypress.io\" target=\"_blank\" rel=\"noopener\">Cypress’ Official Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/e2e-cypress.html\" target=\"_blank\" rel=\"noopener\">Official Vue CLI Cypress Plugin</a></li>\n<li><a href=\"https://github.com/testing-library/cypress-testing-library\" target=\"_blank\" rel=\"noopener\">Cypress Testing Library</a></li>\n</ul>\n<h4 id=\"Nightwatch-js\"><a href=\"#Nightwatch-js\" class=\"headerlink\" title=\"Nightwatch.js\"></a>Nightwatch.js</h4><p>Nightwatch.js is an end-to-end testing framework that can be used to test web applications and websites, as well as Node.js unit and integration testing.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://nightwatchjs.org\" target=\"_blank\" rel=\"noopener\">Nightwatch’s Official Website</a></li>\n<li><a href=\"https://cli.vuejs.org/core-plugins/e2e-nightwatch.html\" target=\"_blank\" rel=\"noopener\">Official Vue CLI Nightwatch Plugin</a></li>\n</ul>\n<h4 id=\"Puppeteer\"><a href=\"#Puppeteer\" class=\"headerlink\" title=\"Puppeteer\"></a>Puppeteer</h4><p>Puppeteer is a Node library that provides a high-level API to control the browser and can pair with other test runners (e.g., Jest) to test your application.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://pptr.dev\" target=\"_blank\" rel=\"noopener\">Puppeteer’s Official Website</a></li>\n</ul>\n<h4 id=\"TestCafe\"><a href=\"#TestCafe\" class=\"headerlink\" title=\"TestCafe\"></a>TestCafe</h4><p>TestCafe is a Node.js based end-to-end framework that aims to provide easy setup so that developers can focus on creating tests that are easy to write and reliable.</p>\n<p><strong>Resources:</strong></p>\n<ul>\n<li><a href=\"https://devexpress.github.io/testcafe/\" target=\"_blank\" rel=\"noopener\">TestCafe’s Official Website</a></li>\n</ul>\n"},{"title":"TypeScript Support","type":"guide","order":403,"_content":"\n> [Vue CLI](https://cli.vuejs.org) provides built-in TypeScript tooling support. \n\n## Official Declaration in NPM Packages\n\nA static type system can help prevent many potential runtime errors, especially as applications grow. That's why Vue ships with [official type declarations](https://github.com/vuejs/vue/tree/dev/types) for [TypeScript](https://www.typescriptlang.org/) - not only in Vue core, but also for [vue-router](https://github.com/vuejs/vue-router/tree/dev/types) and [vuex](https://github.com/vuejs/vuex/tree/dev/types) as well.\n\nSince these are [published on NPM](https://cdn.jsdelivr.net/npm/vue/types/), and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don't need any additional tooling to use TypeScript with Vue.\n\n## Recommended Configuration\n\n``` js\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // this aligns with Vue's browser support\n    \"target\": \"es5\",\n    // this enables stricter inference for data properties on `this`\n    \"strict\": true,\n    // if using webpack 2+ or rollup, to leverage tree shaking:\n    \"module\": \"es2015\",\n    \"moduleResolution\": \"node\"\n  }\n}\n```\n\nNote that you have to include `strict: true` (or at least `noImplicitThis: true` which is a part of `strict` flag) to leverage type checking of `this` in component methods otherwise it is always treated as `any` type.\n\nSee [TypeScript compiler options docs](https://www.typescriptlang.org/docs/handbook/compiler-options.html) for more details.\n\n## Development Tooling\n\n### Project Creation\n\n[Vue CLI 3](https://github.com/vuejs/vue-cli) can generate new projects that use TypeScript. To get started:\n\n```bash\n# 1. Install Vue CLI, if it's not already installed\nnpm install --global @vue/cli\n\n# 2. Create a new project, then choose the \"Manually select features\" option\nvue create my-project-name\n```\n\n### Editor Support\n\nFor developing Vue applications with TypeScript, we strongly recommend using [Visual Studio Code](https://code.visualstudio.com/), which provides great out-of-the-box support for TypeScript. If you are using [single-file components](./single-file-components.html) (SFCs), get the awesome [Vetur extension](https://github.com/vuejs/vetur), which provides TypeScript inference inside SFCs and many other great features.\n\n[WebStorm](https://www.jetbrains.com/webstorm/) also provides out-of-the-box support for both TypeScript and Vue.\n\n## Basic Usage\n\nTo let TypeScript properly infer types inside Vue component options, you need to define components with `Vue.component` or `Vue.extend`:\n\n``` ts\nimport Vue from 'vue'\n\nconst Component = Vue.extend({\n  // type inference enabled\n})\n\nconst Component = {\n  // this will NOT have type inference,\n  // because TypeScript can't tell this is options for a Vue component.\n}\n```\n\n## Class-Style Vue Components\n\nIf you prefer a class-based API when declaring components, you can use the officially maintained [vue-class-component](https://github.com/vuejs/vue-class-component) decorator:\n\n``` ts\nimport Vue from 'vue'\nimport Component from 'vue-class-component'\n\n// The @Component decorator indicates the class is a Vue component\n@Component({\n  // All component options are allowed in here\n  template: '<button @click=\"onClick\">Click!</button>'\n})\nexport default class MyComponent extends Vue {\n  // Initial data can be declared as instance properties\n  message: string = 'Hello!'\n\n  // Component methods can be declared as instance methods\n  onClick (): void {\n    window.alert(this.message)\n  }\n}\n```\n\n## Augmenting Types for Use with Plugins\n\nPlugins may add to Vue's global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there's a TypeScript feature to augment existing types called [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nFor example, to declare an instance property `$myProperty` with type `string`:\n\n``` ts\n// 1. Make sure to import 'vue' before declaring augmented types\nimport Vue from 'vue'\n\n// 2. Specify a file with the types you want to augment\n//    Vue has the constructor type in types/vue.d.ts\ndeclare module 'vue/types/vue' {\n  // 3. Declare augmentation for Vue\n  interface Vue {\n    $myProperty: string\n  }\n}\n```\n\nAfter including the above code as a declaration file (like `my-property.d.ts`) in your project, you can use `$myProperty` on a Vue instance.\n\n```ts\nvar vm = new Vue()\nconsole.log(vm.$myProperty) // This should compile successfully\n```\n\nYou can also declare additional global properties and component options:\n\n```ts\nimport Vue from 'vue'\n\ndeclare module 'vue/types/vue' {\n  // Global properties can be declared\n  // on the `VueConstructor` interface\n  interface VueConstructor {\n    $myGlobal: string\n  }\n}\n\n// ComponentOptions is declared in types/options.d.ts\ndeclare module 'vue/types/options' {\n  interface ComponentOptions<V extends Vue> {\n    myOption?: string\n  }\n}\n```\n\nThe above declarations allow the following code to be compiled:\n\n```ts\n// Global property\nconsole.log(Vue.$myGlobal)\n\n// Additional component option\nvar vm = new Vue({\n  myOption: 'Hello'\n})\n```\n\n## Annotating Return Types\n\nBecause of the circular nature of Vue's declaration files, TypeScript may have difficulties inferring the types of certain methods. For this reason, you may need to annotate the return type on methods like `render` and those in `computed`.\n\n```ts\nimport Vue, { VNode } from 'vue'\n\nconst Component = Vue.extend({\n  data () {\n    return {\n      msg: 'Hello'\n    }\n  },\n  methods: {\n    // need annotation due to `this` in return type\n    greet (): string {\n      return this.msg + ' world'\n    }\n  },\n  computed: {\n    // need annotation\n    greeting(): string {\n      return this.greet() + '!'\n    }\n  },\n  // `createElement` is inferred, but `render` needs return type\n  render (createElement): VNode {\n    return createElement('div', this.greeting)\n  }\n})\n```\n\nIf you find type inference or member completion isn't working, annotating certain methods may help address these problems. Using the `--noImplicitAny` option will help find many of these unannotated methods.\n\n\n\n## Annotating Props\n\n```ts\nimport Vue, { PropType } from 'vue'\n\ninterface ComplexMessage { \n  title: string,\n  okMessage: string,\n  cancelMessage: string\n}\nconst Component = Vue.extend({\n  props: {\n    name: String,\n    success: { type: String },\n    callback: { \n      type: Function as PropType<() => void>\n    },\n    message: {\n      type: Object as PropType<ComplexMessage>,\n      required: true,\n      validator (message: ComplexMessage) {\n        return !!message.title;\n      }\n    }\n  }\n})\n```\nIf you find validator not getting type inference or member completion isn't working, annotating the argument with the expected type may help address these problems.\n","source":"v2/guide/typescript.md","raw":"---\ntitle: TypeScript Support\ntype: guide\norder: 403\n---\n\n> [Vue CLI](https://cli.vuejs.org) provides built-in TypeScript tooling support. \n\n## Official Declaration in NPM Packages\n\nA static type system can help prevent many potential runtime errors, especially as applications grow. That's why Vue ships with [official type declarations](https://github.com/vuejs/vue/tree/dev/types) for [TypeScript](https://www.typescriptlang.org/) - not only in Vue core, but also for [vue-router](https://github.com/vuejs/vue-router/tree/dev/types) and [vuex](https://github.com/vuejs/vuex/tree/dev/types) as well.\n\nSince these are [published on NPM](https://cdn.jsdelivr.net/npm/vue/types/), and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don't need any additional tooling to use TypeScript with Vue.\n\n## Recommended Configuration\n\n``` js\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // this aligns with Vue's browser support\n    \"target\": \"es5\",\n    // this enables stricter inference for data properties on `this`\n    \"strict\": true,\n    // if using webpack 2+ or rollup, to leverage tree shaking:\n    \"module\": \"es2015\",\n    \"moduleResolution\": \"node\"\n  }\n}\n```\n\nNote that you have to include `strict: true` (or at least `noImplicitThis: true` which is a part of `strict` flag) to leverage type checking of `this` in component methods otherwise it is always treated as `any` type.\n\nSee [TypeScript compiler options docs](https://www.typescriptlang.org/docs/handbook/compiler-options.html) for more details.\n\n## Development Tooling\n\n### Project Creation\n\n[Vue CLI 3](https://github.com/vuejs/vue-cli) can generate new projects that use TypeScript. To get started:\n\n```bash\n# 1. Install Vue CLI, if it's not already installed\nnpm install --global @vue/cli\n\n# 2. Create a new project, then choose the \"Manually select features\" option\nvue create my-project-name\n```\n\n### Editor Support\n\nFor developing Vue applications with TypeScript, we strongly recommend using [Visual Studio Code](https://code.visualstudio.com/), which provides great out-of-the-box support for TypeScript. If you are using [single-file components](./single-file-components.html) (SFCs), get the awesome [Vetur extension](https://github.com/vuejs/vetur), which provides TypeScript inference inside SFCs and many other great features.\n\n[WebStorm](https://www.jetbrains.com/webstorm/) also provides out-of-the-box support for both TypeScript and Vue.\n\n## Basic Usage\n\nTo let TypeScript properly infer types inside Vue component options, you need to define components with `Vue.component` or `Vue.extend`:\n\n``` ts\nimport Vue from 'vue'\n\nconst Component = Vue.extend({\n  // type inference enabled\n})\n\nconst Component = {\n  // this will NOT have type inference,\n  // because TypeScript can't tell this is options for a Vue component.\n}\n```\n\n## Class-Style Vue Components\n\nIf you prefer a class-based API when declaring components, you can use the officially maintained [vue-class-component](https://github.com/vuejs/vue-class-component) decorator:\n\n``` ts\nimport Vue from 'vue'\nimport Component from 'vue-class-component'\n\n// The @Component decorator indicates the class is a Vue component\n@Component({\n  // All component options are allowed in here\n  template: '<button @click=\"onClick\">Click!</button>'\n})\nexport default class MyComponent extends Vue {\n  // Initial data can be declared as instance properties\n  message: string = 'Hello!'\n\n  // Component methods can be declared as instance methods\n  onClick (): void {\n    window.alert(this.message)\n  }\n}\n```\n\n## Augmenting Types for Use with Plugins\n\nPlugins may add to Vue's global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there's a TypeScript feature to augment existing types called [module augmentation](https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation).\n\nFor example, to declare an instance property `$myProperty` with type `string`:\n\n``` ts\n// 1. Make sure to import 'vue' before declaring augmented types\nimport Vue from 'vue'\n\n// 2. Specify a file with the types you want to augment\n//    Vue has the constructor type in types/vue.d.ts\ndeclare module 'vue/types/vue' {\n  // 3. Declare augmentation for Vue\n  interface Vue {\n    $myProperty: string\n  }\n}\n```\n\nAfter including the above code as a declaration file (like `my-property.d.ts`) in your project, you can use `$myProperty` on a Vue instance.\n\n```ts\nvar vm = new Vue()\nconsole.log(vm.$myProperty) // This should compile successfully\n```\n\nYou can also declare additional global properties and component options:\n\n```ts\nimport Vue from 'vue'\n\ndeclare module 'vue/types/vue' {\n  // Global properties can be declared\n  // on the `VueConstructor` interface\n  interface VueConstructor {\n    $myGlobal: string\n  }\n}\n\n// ComponentOptions is declared in types/options.d.ts\ndeclare module 'vue/types/options' {\n  interface ComponentOptions<V extends Vue> {\n    myOption?: string\n  }\n}\n```\n\nThe above declarations allow the following code to be compiled:\n\n```ts\n// Global property\nconsole.log(Vue.$myGlobal)\n\n// Additional component option\nvar vm = new Vue({\n  myOption: 'Hello'\n})\n```\n\n## Annotating Return Types\n\nBecause of the circular nature of Vue's declaration files, TypeScript may have difficulties inferring the types of certain methods. For this reason, you may need to annotate the return type on methods like `render` and those in `computed`.\n\n```ts\nimport Vue, { VNode } from 'vue'\n\nconst Component = Vue.extend({\n  data () {\n    return {\n      msg: 'Hello'\n    }\n  },\n  methods: {\n    // need annotation due to `this` in return type\n    greet (): string {\n      return this.msg + ' world'\n    }\n  },\n  computed: {\n    // need annotation\n    greeting(): string {\n      return this.greet() + '!'\n    }\n  },\n  // `createElement` is inferred, but `render` needs return type\n  render (createElement): VNode {\n    return createElement('div', this.greeting)\n  }\n})\n```\n\nIf you find type inference or member completion isn't working, annotating certain methods may help address these problems. Using the `--noImplicitAny` option will help find many of these unannotated methods.\n\n\n\n## Annotating Props\n\n```ts\nimport Vue, { PropType } from 'vue'\n\ninterface ComplexMessage { \n  title: string,\n  okMessage: string,\n  cancelMessage: string\n}\nconst Component = Vue.extend({\n  props: {\n    name: String,\n    success: { type: String },\n    callback: { \n      type: Function as PropType<() => void>\n    },\n    message: {\n      type: Object as PropType<ComplexMessage>,\n      required: true,\n      validator (message: ComplexMessage) {\n        return !!message.title;\n      }\n    }\n  }\n})\n```\nIf you find validator not getting type inference or member completion isn't working, annotating the argument with the expected type may help address these problems.\n","date":"2020-09-25T23:55:41.141Z","updated":"2020-09-25T23:55:41.141Z","path":"v2/guide/typescript.html","comments":1,"layout":"page","_id":"ckfl66gyp002lc2v5wj2itl45","content":"<blockquote>\n<p><a href=\"https://cli.vuejs.org\" target=\"_blank\" rel=\"noopener\">Vue CLI</a> provides built-in TypeScript tooling support. </p>\n</blockquote>\n<h2 id=\"Official-Declaration-in-NPM-Packages\"><a href=\"#Official-Declaration-in-NPM-Packages\" class=\"headerlink\" title=\"Official Declaration in NPM Packages\"></a>Official Declaration in NPM Packages</h2><p>A static type system can help prevent many potential runtime errors, especially as applications grow. That’s why Vue ships with <a href=\"https://github.com/vuejs/vue/tree/dev/types\" target=\"_blank\" rel=\"noopener\">official type declarations</a> for <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript</a> - not only in Vue core, but also for <a href=\"https://github.com/vuejs/vue-router/tree/dev/types\" target=\"_blank\" rel=\"noopener\">vue-router</a> and <a href=\"https://github.com/vuejs/vuex/tree/dev/types\" target=\"_blank\" rel=\"noopener\">vuex</a> as well.</p>\n<p>Since these are <a href=\"https://cdn.jsdelivr.net/npm/vue/types/\" target=\"_blank\" rel=\"noopener\">published on NPM</a>, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don’t need any additional tooling to use TypeScript with Vue.</p>\n<h2 id=\"Recommended-Configuration\"><a href=\"#Recommended-Configuration\" class=\"headerlink\" title=\"Recommended Configuration\"></a>Recommended Configuration</h2><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// tsconfig.json</span>\n&#123;\n  <span class=\"hljs-string\">\"compilerOptions\"</span>: &#123;\n    <span class=\"hljs-comment\">// this aligns with Vue's browser support</span>\n    <span class=\"hljs-string\">\"target\"</span>: <span class=\"hljs-string\">\"es5\"</span>,\n    <span class=\"hljs-comment\">// this enables stricter inference for data properties on `this`</span>\n    <span class=\"hljs-string\">\"strict\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// if using webpack 2+ or rollup, to leverage tree shaking:</span>\n    <span class=\"hljs-string\">\"module\"</span>: <span class=\"hljs-string\">\"es2015\"</span>,\n    <span class=\"hljs-string\">\"moduleResolution\"</span>: <span class=\"hljs-string\">\"node\"</span>\n  &#125;\n&#125;</code></pre>\n<p>Note that you have to include <code>strict: true</code> (or at least <code>noImplicitThis: true</code> which is a part of <code>strict</code> flag) to leverage type checking of <code>this</code> in component methods otherwise it is always treated as <code>any</code> type.</p>\n<p>See <a href=\"https://www.typescriptlang.org/docs/handbook/compiler-options.html\" target=\"_blank\" rel=\"noopener\">TypeScript compiler options docs</a> for more details.</p>\n<h2 id=\"Development-Tooling\"><a href=\"#Development-Tooling\" class=\"headerlink\" title=\"Development Tooling\"></a>Development Tooling</h2><h3 id=\"Project-Creation\"><a href=\"#Project-Creation\" class=\"headerlink\" title=\"Project Creation\"></a>Project Creation</h3><p><a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">Vue CLI 3</a> can generate new projects that use TypeScript. To get started:</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 1. Install Vue CLI, if it's not already installed</span>\nnpm install --global @vue/cli\n\n<span class=\"hljs-comment\"># 2. Create a new project, then choose the \"Manually select features\" option</span>\nvue create my-project-name</code></pre>\n<h3 id=\"Editor-Support\"><a href=\"#Editor-Support\" class=\"headerlink\" title=\"Editor Support\"></a>Editor Support</h3><p>For developing Vue applications with TypeScript, we strongly recommend using <a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a>, which provides great out-of-the-box support for TypeScript. If you are using <a href=\"./single-file-components.html\">single-file components</a> (SFCs), get the awesome <a href=\"https://github.com/vuejs/vetur\" target=\"_blank\" rel=\"noopener\">Vetur extension</a>, which provides TypeScript inference inside SFCs and many other great features.</p>\n<p><a href=\"https://www.jetbrains.com/webstorm/\" target=\"_blank\" rel=\"noopener\">WebStorm</a> also provides out-of-the-box support for both TypeScript and Vue.</p>\n<h2 id=\"Basic-Usage\"><a href=\"#Basic-Usage\" class=\"headerlink\" title=\"Basic Usage\"></a>Basic Usage</h2><p>To let TypeScript properly infer types inside Vue component options, you need to define components with <code>Vue.component</code> or <code>Vue.extend</code>:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">const</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-comment\">// type inference enabled</span>\n&#125;)\n\n<span class=\"hljs-keyword\">const</span> Component = &#123;\n  <span class=\"hljs-comment\">// this will NOT have type inference,</span>\n  <span class=\"hljs-comment\">// because TypeScript can't tell this is options for a Vue component.</span>\n&#125;</code></pre>\n<h2 id=\"Class-Style-Vue-Components\"><a href=\"#Class-Style-Vue-Components\" class=\"headerlink\" title=\"Class-Style Vue Components\"></a>Class-Style Vue Components</h2><p>If you prefer a class-based API when declaring components, you can use the officially maintained <a href=\"https://github.com/vuejs/vue-class-component\" target=\"_blank\" rel=\"noopener\">vue-class-component</a> decorator:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> Component <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue-class-component'</span>\n\n<span class=\"hljs-comment\">// The @Component decorator indicates the class is a Vue component</span>\n<span class=\"hljs-meta\">@Component</span>(&#123;\n  <span class=\"hljs-comment\">// All component options are allowed in here</span>\n  template: <span class=\"hljs-string\">'&lt;button @click=\"onClick\"&gt;Click!&lt;/button&gt;'</span>\n&#125;)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> MyComponent <span class=\"hljs-keyword\">extends</span> Vue &#123;\n  <span class=\"hljs-comment\">// Initial data can be declared as instance properties</span>\n  message: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Hello!'</span>\n\n  <span class=\"hljs-comment\">// Component methods can be declared as instance methods</span>\n  onClick (): <span class=\"hljs-built_in\">void</span> &#123;\n    <span class=\"hljs-built_in\">window</span>.alert(<span class=\"hljs-keyword\">this</span>.message)\n  &#125;\n&#125;</code></pre>\n<h2 id=\"Augmenting-Types-for-Use-with-Plugins\"><a href=\"#Augmenting-Types-for-Use-with-Plugins\" class=\"headerlink\" title=\"Augmenting Types for Use with Plugins\"></a>Augmenting Types for Use with Plugins</h2><p>Plugins may add to Vue’s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there’s a TypeScript feature to augment existing types called <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\" target=\"_blank\" rel=\"noopener\">module augmentation</a>.</p>\n<p>For example, to declare an instance property <code>$myProperty</code> with type <code>string</code>:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 1. Make sure to import 'vue' before declaring augmented types</span>\n<span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-comment\">// 2. Specify a file with the types you want to augment</span>\n<span class=\"hljs-comment\">//    Vue has the constructor type in types/vue.d.ts</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'vue/types/vue' &#123;\n  <span class=\"hljs-comment\">// 3. Declare augmentation for Vue</span>\n  <span class=\"hljs-keyword\">interface</span> Vue &#123;\n    $myProperty: <span class=\"hljs-built_in\">string</span>\n  &#125;\n&#125;</code></pre>\n<p>After including the above code as a declaration file (like <code>my-property.d.ts</code>) in your project, you can use <code>$myProperty</code> on a Vue instance.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue()\n<span class=\"hljs-built_in\">console</span>.log(vm.$myProperty) <span class=\"hljs-comment\">// This should compile successfully</span></code></pre>\n<p>You can also declare additional global properties and component options:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'vue/types/vue' &#123;\n  <span class=\"hljs-comment\">// Global properties can be declared</span>\n  <span class=\"hljs-comment\">// on the `VueConstructor` interface</span>\n  <span class=\"hljs-keyword\">interface</span> VueConstructor &#123;\n    $myGlobal: <span class=\"hljs-built_in\">string</span>\n  &#125;\n&#125;\n\n<span class=\"hljs-comment\">// ComponentOptions is declared in types/options.d.ts</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'vue/types/options' &#123;\n  <span class=\"hljs-keyword\">interface</span> ComponentOptions&lt;V <span class=\"hljs-keyword\">extends</span> Vue&gt; &#123;\n    myOption?: <span class=\"hljs-built_in\">string</span>\n  &#125;\n&#125;</code></pre>\n<p>The above declarations allow the following code to be compiled:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Global property</span>\n<span class=\"hljs-built_in\">console</span>.log(Vue.$myGlobal)\n\n<span class=\"hljs-comment\">// Additional component option</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  myOption: <span class=\"hljs-string\">'Hello'</span>\n&#125;)</code></pre>\n<h2 id=\"Annotating-Return-Types\"><a href=\"#Annotating-Return-Types\" class=\"headerlink\" title=\"Annotating Return Types\"></a>Annotating Return Types</h2><p>Because of the circular nature of Vue’s declaration files, TypeScript may have difficulties inferring the types of certain methods. For this reason, you may need to annotate the return type on methods like <code>render</code> and those in <code>computed</code>.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue, &#123; VNode &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">const</span> Component = Vue.extend(&#123;\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      msg: <span class=\"hljs-string\">'Hello'</span>\n    &#125;\n  &#125;,\n  methods: &#123;\n    <span class=\"hljs-comment\">// need annotation due to `this` in return type</span>\n    greet (): <span class=\"hljs-built_in\">string</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.msg + <span class=\"hljs-string\">' world'</span>\n    &#125;\n  &#125;,\n  computed: &#123;\n    <span class=\"hljs-comment\">// need annotation</span>\n    greeting(): <span class=\"hljs-built_in\">string</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.greet() + <span class=\"hljs-string\">'!'</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-comment\">// `createElement` is inferred, but `render` needs return type</span>\n  render (createElement): VNode &#123;\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, <span class=\"hljs-keyword\">this</span>.greeting)\n  &#125;\n&#125;)</code></pre>\n<p>If you find type inference or member completion isn’t working, annotating certain methods may help address these problems. Using the <code>--noImplicitAny</code> option will help find many of these unannotated methods.</p>\n<h2 id=\"Annotating-Props\"><a href=\"#Annotating-Props\" class=\"headerlink\" title=\"Annotating Props\"></a>Annotating Props</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue, &#123; PropType &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">interface</span> ComplexMessage &#123; \n  title: <span class=\"hljs-built_in\">string</span>,\n  okMessage: <span class=\"hljs-built_in\">string</span>,\n  cancelMessage: <span class=\"hljs-built_in\">string</span>\n&#125;\n<span class=\"hljs-keyword\">const</span> Component = Vue.extend(&#123;\n  props: &#123;\n    name: <span class=\"hljs-built_in\">String</span>,\n    success: &#123; <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">String</span> &#125;,\n    callback: &#123; \n      <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">Function</span> <span class=\"hljs-keyword\">as</span> PropType&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>&gt;\n    &#125;,\n    message: &#123;\n      <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">Object</span> <span class=\"hljs-keyword\">as</span> PropType&lt;ComplexMessage&gt;,\n      required: <span class=\"hljs-literal\">true</span>,\n      validator (message: ComplexMessage) &#123;\n        <span class=\"hljs-keyword\">return</span> !!message.title;\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>If you find validator not getting type inference or member completion isn’t working, annotating the argument with the expected type may help address these problems.</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://cli.vuejs.org\" target=\"_blank\" rel=\"noopener\">Vue CLI</a> provides built-in TypeScript tooling support. </p>\n</blockquote>\n<h2 id=\"Official-Declaration-in-NPM-Packages\"><a href=\"#Official-Declaration-in-NPM-Packages\" class=\"headerlink\" title=\"Official Declaration in NPM Packages\"></a>Official Declaration in NPM Packages</h2><p>A static type system can help prevent many potential runtime errors, especially as applications grow. That’s why Vue ships with <a href=\"https://github.com/vuejs/vue/tree/dev/types\" target=\"_blank\" rel=\"noopener\">official type declarations</a> for <a href=\"https://www.typescriptlang.org/\" target=\"_blank\" rel=\"noopener\">TypeScript</a> - not only in Vue core, but also for <a href=\"https://github.com/vuejs/vue-router/tree/dev/types\" target=\"_blank\" rel=\"noopener\">vue-router</a> and <a href=\"https://github.com/vuejs/vuex/tree/dev/types\" target=\"_blank\" rel=\"noopener\">vuex</a> as well.</p>\n<p>Since these are <a href=\"https://cdn.jsdelivr.net/npm/vue/types/\" target=\"_blank\" rel=\"noopener\">published on NPM</a>, and the latest TypeScript knows how to resolve type declarations in NPM packages, this means when installed via NPM, you don’t need any additional tooling to use TypeScript with Vue.</p>\n<h2 id=\"Recommended-Configuration\"><a href=\"#Recommended-Configuration\" class=\"headerlink\" title=\"Recommended Configuration\"></a>Recommended Configuration</h2><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// tsconfig.json</span>\n&#123;\n  <span class=\"hljs-string\">\"compilerOptions\"</span>: &#123;\n    <span class=\"hljs-comment\">// this aligns with Vue's browser support</span>\n    <span class=\"hljs-string\">\"target\"</span>: <span class=\"hljs-string\">\"es5\"</span>,\n    <span class=\"hljs-comment\">// this enables stricter inference for data properties on `this`</span>\n    <span class=\"hljs-string\">\"strict\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-comment\">// if using webpack 2+ or rollup, to leverage tree shaking:</span>\n    <span class=\"hljs-string\">\"module\"</span>: <span class=\"hljs-string\">\"es2015\"</span>,\n    <span class=\"hljs-string\">\"moduleResolution\"</span>: <span class=\"hljs-string\">\"node\"</span>\n  &#125;\n&#125;</code></pre>\n<p>Note that you have to include <code>strict: true</code> (or at least <code>noImplicitThis: true</code> which is a part of <code>strict</code> flag) to leverage type checking of <code>this</code> in component methods otherwise it is always treated as <code>any</code> type.</p>\n<p>See <a href=\"https://www.typescriptlang.org/docs/handbook/compiler-options.html\" target=\"_blank\" rel=\"noopener\">TypeScript compiler options docs</a> for more details.</p>\n<h2 id=\"Development-Tooling\"><a href=\"#Development-Tooling\" class=\"headerlink\" title=\"Development Tooling\"></a>Development Tooling</h2><h3 id=\"Project-Creation\"><a href=\"#Project-Creation\" class=\"headerlink\" title=\"Project Creation\"></a>Project Creation</h3><p><a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">Vue CLI 3</a> can generate new projects that use TypeScript. To get started:</p>\n<pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 1. Install Vue CLI, if it's not already installed</span>\nnpm install --global @vue/cli\n\n<span class=\"hljs-comment\"># 2. Create a new project, then choose the \"Manually select features\" option</span>\nvue create my-project-name</code></pre>\n<h3 id=\"Editor-Support\"><a href=\"#Editor-Support\" class=\"headerlink\" title=\"Editor Support\"></a>Editor Support</h3><p>For developing Vue applications with TypeScript, we strongly recommend using <a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">Visual Studio Code</a>, which provides great out-of-the-box support for TypeScript. If you are using <a href=\"./single-file-components.html\">single-file components</a> (SFCs), get the awesome <a href=\"https://github.com/vuejs/vetur\" target=\"_blank\" rel=\"noopener\">Vetur extension</a>, which provides TypeScript inference inside SFCs and many other great features.</p>\n<p><a href=\"https://www.jetbrains.com/webstorm/\" target=\"_blank\" rel=\"noopener\">WebStorm</a> also provides out-of-the-box support for both TypeScript and Vue.</p>\n<h2 id=\"Basic-Usage\"><a href=\"#Basic-Usage\" class=\"headerlink\" title=\"Basic Usage\"></a>Basic Usage</h2><p>To let TypeScript properly infer types inside Vue component options, you need to define components with <code>Vue.component</code> or <code>Vue.extend</code>:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">const</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-comment\">// type inference enabled</span>\n&#125;)\n\n<span class=\"hljs-keyword\">const</span> Component = &#123;\n  <span class=\"hljs-comment\">// this will NOT have type inference,</span>\n  <span class=\"hljs-comment\">// because TypeScript can't tell this is options for a Vue component.</span>\n&#125;</code></pre>\n<h2 id=\"Class-Style-Vue-Components\"><a href=\"#Class-Style-Vue-Components\" class=\"headerlink\" title=\"Class-Style Vue Components\"></a>Class-Style Vue Components</h2><p>If you prefer a class-based API when declaring components, you can use the officially maintained <a href=\"https://github.com/vuejs/vue-class-component\" target=\"_blank\" rel=\"noopener\">vue-class-component</a> decorator:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n<span class=\"hljs-keyword\">import</span> Component <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue-class-component'</span>\n\n<span class=\"hljs-comment\">// The @Component decorator indicates the class is a Vue component</span>\n<span class=\"hljs-meta\">@Component</span>(&#123;\n  <span class=\"hljs-comment\">// All component options are allowed in here</span>\n  template: <span class=\"hljs-string\">'&lt;button @click=\"onClick\"&gt;Click!&lt;/button&gt;'</span>\n&#125;)\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> MyComponent <span class=\"hljs-keyword\">extends</span> Vue &#123;\n  <span class=\"hljs-comment\">// Initial data can be declared as instance properties</span>\n  message: <span class=\"hljs-built_in\">string</span> = <span class=\"hljs-string\">'Hello!'</span>\n\n  <span class=\"hljs-comment\">// Component methods can be declared as instance methods</span>\n  onClick (): <span class=\"hljs-built_in\">void</span> &#123;\n    <span class=\"hljs-built_in\">window</span>.alert(<span class=\"hljs-keyword\">this</span>.message)\n  &#125;\n&#125;</code></pre>\n<h2 id=\"Augmenting-Types-for-Use-with-Plugins\"><a href=\"#Augmenting-Types-for-Use-with-Plugins\" class=\"headerlink\" title=\"Augmenting Types for Use with Plugins\"></a>Augmenting Types for Use with Plugins</h2><p>Plugins may add to Vue’s global/instance properties and component options. In these cases, type declarations are needed to make plugins compile in TypeScript. Fortunately, there’s a TypeScript feature to augment existing types called <a href=\"https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation\" target=\"_blank\" rel=\"noopener\">module augmentation</a>.</p>\n<p>For example, to declare an instance property <code>$myProperty</code> with type <code>string</code>:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// 1. Make sure to import 'vue' before declaring augmented types</span>\n<span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-comment\">// 2. Specify a file with the types you want to augment</span>\n<span class=\"hljs-comment\">//    Vue has the constructor type in types/vue.d.ts</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'vue/types/vue' &#123;\n  <span class=\"hljs-comment\">// 3. Declare augmentation for Vue</span>\n  <span class=\"hljs-keyword\">interface</span> Vue &#123;\n    $myProperty: <span class=\"hljs-built_in\">string</span>\n  &#125;\n&#125;</code></pre>\n<p>After including the above code as a declaration file (like <code>my-property.d.ts</code>) in your project, you can use <code>$myProperty</code> on a Vue instance.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue()\n<span class=\"hljs-built_in\">console</span>.log(vm.$myProperty) <span class=\"hljs-comment\">// This should compile successfully</span></code></pre>\n<p>You can also declare additional global properties and component options:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'vue/types/vue' &#123;\n  <span class=\"hljs-comment\">// Global properties can be declared</span>\n  <span class=\"hljs-comment\">// on the `VueConstructor` interface</span>\n  <span class=\"hljs-keyword\">interface</span> VueConstructor &#123;\n    $myGlobal: <span class=\"hljs-built_in\">string</span>\n  &#125;\n&#125;\n\n<span class=\"hljs-comment\">// ComponentOptions is declared in types/options.d.ts</span>\n<span class=\"hljs-keyword\">declare</span> <span class=\"hljs-keyword\">module</span> 'vue/types/options' &#123;\n  <span class=\"hljs-keyword\">interface</span> ComponentOptions&lt;V <span class=\"hljs-keyword\">extends</span> Vue&gt; &#123;\n    myOption?: <span class=\"hljs-built_in\">string</span>\n  &#125;\n&#125;</code></pre>\n<p>The above declarations allow the following code to be compiled:</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-comment\">// Global property</span>\n<span class=\"hljs-built_in\">console</span>.log(Vue.$myGlobal)\n\n<span class=\"hljs-comment\">// Additional component option</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  myOption: <span class=\"hljs-string\">'Hello'</span>\n&#125;)</code></pre>\n<h2 id=\"Annotating-Return-Types\"><a href=\"#Annotating-Return-Types\" class=\"headerlink\" title=\"Annotating Return Types\"></a>Annotating Return Types</h2><p>Because of the circular nature of Vue’s declaration files, TypeScript may have difficulties inferring the types of certain methods. For this reason, you may need to annotate the return type on methods like <code>render</code> and those in <code>computed</code>.</p>\n<pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue, &#123; VNode &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">const</span> Component = Vue.extend(&#123;\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      msg: <span class=\"hljs-string\">'Hello'</span>\n    &#125;\n  &#125;,\n  methods: &#123;\n    <span class=\"hljs-comment\">// need annotation due to `this` in return type</span>\n    greet (): <span class=\"hljs-built_in\">string</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.msg + <span class=\"hljs-string\">' world'</span>\n    &#125;\n  &#125;,\n  computed: &#123;\n    <span class=\"hljs-comment\">// need annotation</span>\n    greeting(): <span class=\"hljs-built_in\">string</span> &#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.greet() + <span class=\"hljs-string\">'!'</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-comment\">// `createElement` is inferred, but `render` needs return type</span>\n  render (createElement): VNode &#123;\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, <span class=\"hljs-keyword\">this</span>.greeting)\n  &#125;\n&#125;)</code></pre>\n<p>If you find type inference or member completion isn’t working, annotating certain methods may help address these problems. Using the <code>--noImplicitAny</code> option will help find many of these unannotated methods.</p>\n<h2 id=\"Annotating-Props\"><a href=\"#Annotating-Props\" class=\"headerlink\" title=\"Annotating Props\"></a>Annotating Props</h2><pre><code class=\"hljs ts\"><span class=\"hljs-keyword\">import</span> Vue, &#123; PropType &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vue'</span>\n\n<span class=\"hljs-keyword\">interface</span> ComplexMessage &#123; \n  title: <span class=\"hljs-built_in\">string</span>,\n  okMessage: <span class=\"hljs-built_in\">string</span>,\n  cancelMessage: <span class=\"hljs-built_in\">string</span>\n&#125;\n<span class=\"hljs-keyword\">const</span> Component = Vue.extend(&#123;\n  props: &#123;\n    name: <span class=\"hljs-built_in\">String</span>,\n    success: &#123; <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">String</span> &#125;,\n    callback: &#123; \n      <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">Function</span> <span class=\"hljs-keyword\">as</span> PropType&lt;<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> <span class=\"hljs-built_in\">void</span>&gt;\n    &#125;,\n    message: &#123;\n      <span class=\"hljs-keyword\">type</span>: <span class=\"hljs-built_in\">Object</span> <span class=\"hljs-keyword\">as</span> PropType&lt;ComplexMessage&gt;,\n      required: <span class=\"hljs-literal\">true</span>,\n      validator (message: ComplexMessage) &#123;\n        <span class=\"hljs-keyword\">return</span> !!message.title;\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<p>If you find validator not getting type inference or member completion isn’t working, annotating the argument with the expected type may help address these problems.</p>\n"},{"title":"Style Guide","type":"style-guide","_content":"\nThis is the official style guide for Vue-specific code. If you use Vue in a project, it's a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don't believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.\n\nFor the most part, we also avoid suggestions about JavaScript or HTML in general. We don't mind whether you use semicolons or trailing commas. We don't mind whether your HTML uses single-quotes or double-quotes for attribute values. Some exceptions will exist however, where we've found that a particular pattern is helpful in the context of Vue.\n\n> **Soon, we'll also provide tips for enforcement.** Sometimes you'll simply have to be disciplined, but wherever possible, we'll try to show you how to use ESLint and other automated processes to make enforcement simpler.\n\nFinally, we've split rules into four categories:\n\n\n\n## Rule Categories\n\n### Priority A: Essential\n\nThese rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.\n\n### Priority B: Strongly Recommended\n\nThese rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.\n\n### Priority C: Recommended\n\nWhere multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you're consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:\n\n1. train your brain to more easily parse most of the community code you encounter\n2. be able to copy and paste most community code examples without modification\n3. often find new hires are already accustomed to your preferred coding style, at least in regards to Vue\n\n### Priority D: Use with Caution\n\nSome features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.\n\n\n\n## Priority A Rules: Essential (Error Prevention)\n\n\n\n### Multi-word component names <sup data-p=\"a\">essential</sup>\n\n**Component names should always be multi-word, except for root `App` components, and built-in components provided by Vue, such as `<transition>` or `<component>`.**\n\nThis [prevents conflicts](http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name) with existing and future HTML elements, since all HTML elements are a single word.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('todo', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'Todo',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nVue.component('todo-item', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'TodoItem',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component data <sup data-p=\"a\">essential</sup>\n\n**Component `data` must be a function.**\n\nWhen using the `data` property on a component (i.e. anywhere except on `new Vue`), the value must be a function that returns an object.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nWhen the value of `data` is an object, it's shared across all instances of a component. Imagine, for example, a `TodoList` component with this data:\n\n``` js\ndata: {\n  listTitle: '',\n  todos: []\n}\n```\n\nWe might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There's a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.\n\nInstead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:\n\n``` js\ndata: function () {\n  return {\n    listTitle: '',\n    todos: []\n  }\n}\n```\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('some-comp', {\n  data: {\n    foo: 'bar'\n  }\n})\n```\n\n``` js\nexport default {\n  data: {\n    foo: 'bar'\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n``` js\nVue.component('some-comp', {\n  data: function () {\n    return {\n      foo: 'bar'\n    }\n  }\n})\n```\n\n``` js\n// In a .vue file\nexport default {\n  data () {\n    return {\n      foo: 'bar'\n    }\n  }\n}\n```\n\n``` js\n// It's OK to use an object directly in a root\n// Vue instance, since only a single instance\n// will ever exist.\nnew Vue({\n  data: {\n    foo: 'bar'\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop definitions <sup data-p=\"a\">essential</sup>\n\n**Prop definitions should be as detailed as possible.**\n\nIn committed code, prop definitions should always be as detailed as possible, specifying at least type(s).\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nDetailed [prop definitions](https://vuejs.org/v2/guide/components.html#Prop-Validation) have two advantages:\n\n- They document the API of the component, so that it's easy to see how the component is meant to be used.\n- In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\n// This is only OK when prototyping\nprops: ['status']\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nprops: {\n  status: String\n}\n```\n\n``` js\n// Even better!\nprops: {\n  status: {\n    type: String,\n    required: true,\n    validator: function (value) {\n      return [\n        'syncing',\n        'synced',\n        'version-conflict',\n        'error'\n      ].indexOf(value) !== -1\n    }\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Keyed `v-for` <sup data-p=\"a\">essential</sup>\n\n**Always use `key` with `v-for`.**\n\n`key` with `v-for` is _always_ required on components, in order to maintain internal component state down the subtree. Even for elements though, it's a good practice to maintain predictable behavior, such as [object constancy](https://bost.ocks.org/mike/constancy/) in animations.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nLet's say you have a list of todos:\n\n``` js\ndata: function () {\n  return {\n    todos: [\n      {\n        id: 1,\n        text: 'Learn to use v-for'\n      },\n      {\n        id: 2,\n        text: 'Learn to use key'\n      }\n    ]\n  }\n}\n```\n\nThen you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.\n\nThe problem is, there are cases where it's important not to delete elements that will remain in the DOM. For example, you may want to use `<transition-group>` to animate list sorting, or maintain focus if the rendered element is an `<input>`. In these cases, adding a unique key for each item (e.g. `:key=\"todo.id\"`) will tell Vue how to behave more predictably.\n\nIn our experience, it's better to _always_ add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn't necessary, you can make a conscious exception.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<ul>\n  <li v-for=\"todo in todos\">\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Avoid `v-if` with `v-for` <sup data-p=\"a\">essential</sup>\n\n**Never use `v-if` on the same element as `v-for`.**\n\nThere are two common cases where this can be tempting:\n\n- To filter items in a list (e.g. `v-for=\"user in users\" v-if=\"user.isActive\"`). In these cases, replace `users` with a new computed property that returns your filtered list (e.g. `activeUsers`).\n\n- To avoid rendering a list if it should be hidden (e.g. `v-for=\"user in users\" v-if=\"shouldShowUsers\"`). In these cases, move the `v-if` to a container element (e.g. `ul`, `ol`).\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nWhen Vue processes directives, `v-for` has a higher priority than `v-if`, so that this template:\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nWill be evaluated similar to:\n\n``` js\nthis.users.map(function (user) {\n  if (user.isActive) {\n    return user.name\n  }\n})\n```\n\nSo even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.\n\nBy iterating over a computed property instead, like this:\n\n``` js\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n      return user.isActive\n    })\n  }\n}\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nWe get the following benefits:\n\n- The filtered list will _only_ be re-evaluated if there are relevant changes to the `users` array, making filtering much more efficient.\n- Using `v-for=\"user in activeUsers\"`, we _only_ iterate over active users during render, making rendering much more efficient.\n- Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.\n\nWe get similar benefits from updating:\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nto:\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nBy moving the `v-if` to a container element, we're no longer checking `shouldShowUsers` for _every_ user in the list. Instead, we check it once and don't even evaluate the `v-for` if `shouldShowUsers` is false.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component style scoping <sup data-p=\"a\">essential</sup>\n\n**For applications, styles in a top-level `App` component and in layout components may be global, but all other components should always be scoped.**\n\nThis is only relevant for [single-file components](../guide/single-file-components.html). It does _not_ require that the [`scoped` attribute](https://vue-loader.vuejs.org/en/features/scoped-css.html) be used. Scoping could be through [CSS modules](https://vue-loader.vuejs.org/en/features/css-modules.html), a class-based strategy such as [BEM](http://getbem.com/), or another library/convention.\n\n**Component libraries, however, should prefer a class-based strategy instead of using the `scoped` attribute.**\n\nThis makes overriding internal styles easier, with human-readable class names that don't have too high specificity, but are still very unlikely to result in a conflict.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nIf you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.\n\nBeyond the `scoped` attribute, using unique class names can help ensure that 3rd-party CSS does not apply to your own HTML. For example, many projects use the `button`, `btn`, or `icon` class names, so even if not using a strategy such as BEM, adding an app-specific and/or component-specific prefix (e.g. `ButtonClose-icon`) can provide some protection.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<template>\n  <button class=\"button button-close\">X</button>\n</template>\n\n<!-- Using the `scoped` attribute -->\n<style scoped>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.button-close {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button :class=\"[$style.button, $style.buttonClose]\">X</button>\n</template>\n\n<!-- Using CSS modules -->\n<style module>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.buttonClose {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button class=\"c-Button c-Button--close\">X</button>\n</template>\n\n<!-- Using the BEM convention -->\n<style>\n.c-Button {\n  border: none;\n  border-radius: 2px;\n}\n\n.c-Button--close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Private property names <sup data-p=\"a\">essential</sup>\n\n**Use module scoping to keep private functions inaccessible from the outside. If that's not possible, always use the `$_` prefix for custom private properties in a plugin, mixin, etc that should not be considered public API. Then to avoid conflicts with code by other authors, also include a named scope (e.g. `$_yourPluginName_`).**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nVue uses the `_` prefix to define its own private properties, so using the same prefix (e.g. `_update`) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won't arise in a later version.\n\nAs for the `$` prefix, its purpose within the Vue ecosystem is special instance properties that are exposed to the user, so using it for _private_ properties would not be appropriate.\n\nInstead, we recommend combining the two prefixes into `$_`, as a convention for user-defined private properties that guarantee no conflicts with Vue.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    _update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_myGreatMixin_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\n// Even better!\nvar myGreatMixin = {\n  // ...\n  methods: {\n    publicMethod() {\n      // ...\n      myPrivateFunction()\n    }\n  }\n}\n\nfunction myPrivateFunction() {\n  // ...\n}\n\nexport default myGreatMixin\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## Priority B Rules: Strongly Recommended (Improving Readability)\n\n\n\n### Component files <sup data-p=\"b\">strongly recommended</sup>\n\n**Whenever a build system is available to concatenate files, each component should be in its own file.**\n\nThis helps you to more quickly find a component when you need to edit it or review how to use it.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('TodoList', {\n  // ...\n})\n\nVue.component('TodoItem', {\n  // ...\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- TodoList.js\n|- TodoItem.js\n```\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Single-file component filename casing <sup data-p=\"b\">strongly recommended</sup>\n\n**Filenames of [single-file components](../guide/single-file-components.html) should either be always PascalCase or always kebab-case.**\n\nPascalCase works best with autocompletion in code editors, as it's consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- mycomponent.vue\n```\n\n```\ncomponents/\n|- myComponent.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- MyComponent.vue\n```\n\n```\ncomponents/\n|- my-component.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Base component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Base components (a.k.a. presentational, dumb, or pure components) that apply app-specific styling and conventions should all begin with a specific prefix, such as `Base`, `App`, or `V`.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nThese components lay the foundation for consistent styling and behavior in your application. They may **only** contain:\n\n- HTML elements,\n- other base components, and\n- 3rd-party UI components.\n\nBut they'll **never** contain global state (e.g. from a Vuex store).\n\nTheir names often include the name of an element they wrap (e.g. `BaseButton`, `BaseTable`), unless no element exists for their specific purpose (e.g. `BaseIcon`). If you build similar components for a more specific context, they will almost always consume these components (e.g. `BaseButton` may be used in `ButtonSubmit`).\n\nSome advantages of this convention:\n\n- When organized alphabetically in editors, your app's base components are all listed together, making them easier to identify.\n\n- Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. `MyButton`, `VueButton`).\n\n- Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:\n\n  ``` js\n  var requireComponent = require.context(\"./src\", true, /Base[A-Z]\\w+\\.(vue|js)$/)\n  requireComponent.keys().forEach(function (fileName) {\n    var baseComponentConfig = requireComponent(fileName)\n    baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n    var baseComponentName = baseComponentConfig.name || (\n      fileName\n        .replace(/^.+\\//, '')\n        .replace(/\\.\\w+$/, '')\n    )\n    Vue.component(baseComponentName, baseComponentConfig)\n  })\n  ```\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n```\n\n```\ncomponents/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue\n```\n\n```\ncomponents/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Single-instance component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Components that should only ever have a single active instance should begin with the `The` prefix, to denote that there can be only one.**\n\nThis does not mean the component is only used in a single page, but it will only be used once _per page_. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it's a good indication that this is actually a reusable component that is only used once per page _for now_.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- Heading.vue\n|- MySidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- TheHeading.vue\n|- TheSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Tightly coupled component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Child components that are tightly coupled with their parent should include the parent component name as a prefix.**\n\nIf a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nYou might be tempted to solve this problem by nesting child components in directories named after their parent. For example:\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue\n```\n\nor:\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue\n```\n\nThis isn't recommended, as it results in:\n\n- Many files with similar names, making rapid file switching in code editors more difficult.\n- Many nested sub-directories, which increases the time it takes to browse components in an editor's sidebar.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Order of words in component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Component names should start with the highest-level (often most general) words and end with descriptive modifying words.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nYou may be wondering:\n\n> \"Why would we force component names to use less natural language?\"\n\nIn natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:\n\n- Coffee _with_ milk\n- Soup _of the_ day\n- Visitor _to the_ museum\n\nYou can definitely include these connector words in component names if you'd like, but the order is still important.\n\nAlso note that **what's considered \"highest-level\" will be contextual to your app**. For example, imagine an app with a search form. It may include components like this one:\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n\nAs you might notice, it's quite difficult to see which components are specific to the search. Now let's rename the components according to the rule:\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue\n```\n\nSince editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.\n\nYou might be tempted to solve this problem differently, nesting all the search components under a \"search\" directory, then all the settings components under a \"settings\" directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:\n\n- It generally takes more time to navigate through nested sub-directories, than scrolling through a single `components` directory.\n- Name conflicts (e.g. multiple `ButtonDelete.vue` components) make it more difficult to quickly navigate to a specific component in a code editor.\n- Refactoring becomes more difficult, because find-and-replace often isn't sufficient to update relative references to a moved component.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Self-closing components <sup data-p=\"b\">strongly recommended</sup>\n\n**Components with no content should be self-closing in [single-file components](../guide/single-file-components.html), string templates, and [JSX](../guide/render-function.html#JSX) - but never in DOM templates.**\n\nComponents that self-close communicate that they not only have no content, but are **meant** to have no content. It's the difference between a blank page in a book and one labeled \"This page intentionally left blank.\" Your code is also cleaner without the unnecessary closing tag.\n\nUnfortunately, HTML doesn't allow custom elements to be self-closing - only [official \"void\" elements](https://www.w3.org/TR/html/syntax.html#void-elements). That's why the strategy is only possible when Vue's template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<!-- In single-file components, string templates, and JSX -->\n<MyComponent></MyComponent>\n```\n\n``` html\n<!-- In DOM templates -->\n<my-component/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- In single-file components, string templates, and JSX -->\n<MyComponent/>\n```\n\n``` html\n<!-- In DOM templates -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component name casing in templates <sup data-p=\"b\">strongly recommended</sup>\n\n**In most projects, component names should always be PascalCase in [single-file components](../guide/single-file-components.html) and string templates - but kebab-case in DOM templates.**\n\nPascalCase has a few advantages over kebab-case:\n\n- Editors can autocomplete component names in templates, because PascalCase is also used in JavaScript.\n- `<MyComponent>` is more visually distinct from a single-word HTML element than `<my-component>`, because there are two character differences (the two capitals), rather than just one (a hyphen).\n- If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.\n\nUnfortunately, due to HTML's case insensitivity, DOM templates must still use kebab-case.\n\nAlso note that if you've already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, **using kebab-case everywhere is also acceptable.**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<!-- In single-file components and string templates -->\n<mycomponent/>\n```\n\n``` html\n<!-- In single-file components and string templates -->\n<myComponent/>\n```\n\n``` html\n<!-- In DOM templates -->\n<MyComponent></MyComponent>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- In single-file components and string templates -->\n<MyComponent/>\n```\n\n``` html\n<!-- In DOM templates -->\n<my-component></my-component>\n```\n\nOR\n\n``` html\n<!-- Everywhere -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component name casing in JS/JSX <sup data-p=\"b\">strongly recommended</sup>\n\n**Component names in JS/[JSX](../guide/render-function.html#JSX) should always be PascalCase, though they may be kebab-case inside strings for simpler applications that only use global component registration through `Vue.component`.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nIn JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.\n\nHowever, for applications that use **only** global component definitions via `Vue.component`, we recommend kebab-case instead. The reasons are:\n\n- It's rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.\n- These applications always include many in-DOM templates, where [kebab-case **must** be used](#Component-name-casing-in-templates-strongly-recommended).\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('myComponent', {\n  // ...\n})\n```\n\n``` js\nimport myComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'myComponent',\n  // ...\n}\n```\n\n``` js\nexport default {\n  name: 'my-component',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nVue.component('MyComponent', {\n  // ...\n})\n```\n\n``` js\nVue.component('my-component', {\n  // ...\n})\n```\n\n``` js\nimport MyComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Full-word component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Component names should prefer full words over abbreviations.**\n\nThe autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- SdSettings.vue\n|- UProfOpts.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop name casing <sup data-p=\"b\">strongly recommended</sup>\n\n**Prop names should always use camelCase during declaration, but kebab-case in templates and [JSX](../guide/render-function.html#JSX).**\n\nWe're simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nprops: {\n  'greeting-text': String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greetingText=\"hi\"/>\n{% endcodeblock %}\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nprops: {\n  greetingText: String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greeting-text=\"hi\"/>\n{% endcodeblock %}\n{% raw %}</div>{% endraw %}\n\n\n\n### Multi-attribute elements <sup data-p=\"b\">strongly recommended</sup>\n\n**Elements with multiple attributes should span multiple lines, with one attribute per line.**\n\nIn JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it's much easier to read. Our templates and [JSX](../guide/render-function.html#JSX) deserve the same consideration.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<img src=\"https://vuejs.org/images/logo.png\" alt=\"Vue Logo\">\n```\n\n``` html\n<MyComponent foo=\"a\" bar=\"b\" baz=\"c\"/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<img\n  src=\"https://vuejs.org/images/logo.png\"\n  alt=\"Vue Logo\"\n>\n```\n\n``` html\n<MyComponent\n  foo=\"a\"\n  bar=\"b\"\n  baz=\"c\"\n/>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Simple expressions in templates <sup data-p=\"b\">strongly recommended</sup>\n\n**Component templates should only include simple expressions, with more complex expressions refactored into computed properties or methods.**\n\nComplex expressions in your templates make them less declarative. We should strive to describe _what_ should appear, not _how_ we're computing that value. Computed properties and methods also allow the code to be reused.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n{{\n  fullName.split(' ').map(function (word) {\n    return word[0].toUpperCase() + word.slice(1)\n  }).join(' ')\n}}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- In a template -->\n{{ normalizedFullName }}\n```\n\n``` js\n// The complex expression has been moved to a computed property\ncomputed: {\n  normalizedFullName: function () {\n    return this.fullName.split(' ').map(function (word) {\n      return word[0].toUpperCase() + word.slice(1)\n    }).join(' ')\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Simple computed properties <sup data-p=\"b\">strongly recommended</sup>\n\n**Complex computed properties should be split into as many simpler properties as possible.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nSimpler, well-named computed properties are:\n\n- __Easier to test__\n\n  When each computed property contains only a very simple expression, with very few dependencies, it's much easier to write tests confirming that it works correctly.\n\n- __Easier to read__\n\n  Simplifying computed properties forces you to give each value a descriptive name, even if it's not reused. This makes it much easier for other developers (and future you) to focus on the code they care about and figure out what's going on.\n\n- __More adaptable to changing requirements__\n\n  Any value that can be named might be useful to the view. For example, we might decide to display a message telling the user how much money they saved. We might also decide to calculate sales tax, but perhaps display it separately, rather than as part of the final price.\n\n  Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\ncomputed: {\n  price: function () {\n    var basePrice = this.manufactureCost / (1 - this.profitMargin)\n    return (\n      basePrice -\n      basePrice * (this.discountPercent || 0)\n    )\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\ncomputed: {\n  basePrice: function () {\n    return this.manufactureCost / (1 - this.profitMargin)\n  },\n  discount: function () {\n    return this.basePrice * (this.discountPercent || 0)\n  },\n  finalPrice: function () {\n    return this.basePrice - this.discount\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Quoted attribute values <sup data-p=\"b\">strongly recommended</sup>\n\n**Non-empty HTML attribute values should always be inside quotes (single or double, whichever is not used in JS).**\n\nWhile attribute values without any spaces are not required to have quotes in HTML, this practice often leads to _avoiding_ spaces, making attribute values less readable.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<input type=text>\n```\n\n``` html\n<AppSidebar :style={width:sidebarWidth+'px'}>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<input type=\"text\">\n```\n\n``` html\n<AppSidebar :style=\"{ width: sidebarWidth + 'px' }\">\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Directive shorthands <sup data-p=\"b\">strongly recommended</sup>\n\n**Directive shorthands (`:` for `v-bind:`, `@` for `v-on:` and `#` for `v-slot`) should be used always or never.**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<input\n  :value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  v-bind:placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  @input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  v-on:focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template v-slot:footer>\n  <p>Here's some contact info</p>\n</template>\n```\n\n``` html\n<template #header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n\n## Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)\n\n\n\n### Component/instance options order <sup data-p=\"c\">recommended</sup>\n\n**Component/instance options should be ordered consistently.**\n\nThis is the default order we recommend for component options. They're split into categories, so you'll know where to add new properties from plugins.\n\n1. **Side Effects** (triggers effects outside the component)\n  - `el`\n\n2. **Global Awareness** (requires knowledge beyond the component)\n  - `name`\n  - `parent`\n\n3. **Component Type** (changes the type of the component)\n  - `functional`\n\n4. **Template Modifiers** (changes the way templates are compiled)\n  - `delimiters`\n  - `comments`\n\n5. **Template Dependencies** (assets used in the template)\n  - `components`\n  - `directives`\n  - `filters`\n\n6. **Composition** (merges properties into the options)\n  - `extends`\n  - `mixins`\n\n7. **Interface** (the interface to the component)\n  - `inheritAttrs`\n  - `model`\n  - `props`/`propsData`\n\n8. **Local State** (local reactive properties)\n  - `data`\n  - `computed`\n\n9. **Events** (callbacks triggered by reactive events)\n  - `watch`\n  - Lifecycle Events (in the order they are called)\n    - `beforeCreate`\n    - `created`\n    - `beforeMount`\n    - `mounted`\n    - `beforeUpdate`\n    - `updated`\n    - `activated`\n    - `deactivated`\n    - `beforeDestroy`\n    - `destroyed`\n\n10. **Non-Reactive Properties** (instance properties independent of the reactivity system)\n  - `methods`\n\n11. **Rendering** (the declarative description of the component output)\n  - `template`/`render`\n  - `renderError`\n\n\n\n### Element attribute order <sup data-p=\"c\">recommended</sup>\n\n**The attributes of elements (including components) should be ordered consistently.**\n\nThis is the default order we recommend for component options. They're split into categories, so you'll know where to add custom attributes and directives.\n\n1. **Definition** (provides the component options)\n  - `is`\n\n2. **List Rendering** (creates multiple variations of the same element)\n  - `v-for`\n\n3. **Conditionals** (whether the element is rendered/shown)\n  - `v-if`\n  - `v-else-if`\n  - `v-else`\n  - `v-show`\n  - `v-cloak`\n\n4. **Render Modifiers** (changes the way the element renders)\n  - `v-pre`\n  - `v-once`\n\n5. **Global Awareness** (requires knowledge beyond the component)\n  - `id`\n\n6. **Unique Attributes** (attributes that require unique values)\n  - `ref`\n  - `key`\n\n7. **Two-Way Binding** (combining binding and events)\n  - `v-model`\n\n8. **Other Attributes** (all unspecified bound & unbound attributes)\n\n9. **Events** (component event listeners)\n  - `v-on`\n\n10. **Content** (overrides the content of the element)\n  - `v-html`\n  - `v-text`\n\n\n\n### Empty lines in component/instance options <sup data-p=\"c\">recommended</sup>\n\n**You may want to add one empty line between multi-line properties, particularly if the options can no longer fit on your screen without scrolling.**\n\nWhen components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n\n  focused: {\n    type: Boolean,\n    default: false\n  },\n\n  label: String,\n  icon: String\n},\n\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n\n``` js\n// No spaces are also fine, as long as the component\n// is still easy to read and navigate.\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n  focused: {\n    type: Boolean,\n    default: false\n  },\n  label: String,\n  icon: String\n},\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Single-file component top-level element order <sup data-p=\"c\">recommended</sup>\n\n**[Single-file components](../guide/single-file-components.html) should always order `<script>`, `<template>`, and `<style>` tags consistently, with `<style>` last, because at least one of the other two is always necessary.**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<style>/* ... */</style>\n<script>/* ... */</script>\n<template>...</template>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## Priority D Rules: Use with Caution (Potentially Dangerous Patterns)\n\n\n\n### `v-if`/`v-else-if`/`v-else` without `key` <sup data-p=\"d\">use with caution</sup>\n\n**It's usually best to use `key` with `v-if` + `v-else`, if they are the same element type (e.g. both `<div>` elements).**\n\nBy default, Vue updates the DOM as efficiently as possible. That means when switching between elements of the same type, it simply patches the existing element, rather than removing it and adding a new one in its place. This can have [unintended consequences](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences) if these elements should not actually be considered the same.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<div v-if=\"error\">\n  Error: {{ error }}\n</div>\n<div v-else>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<div\n  v-if=\"error\"\n  key=\"search-status\"\n>\n  Error: {{ error }}\n</div>\n<div\n  v-else\n  key=\"search-results\"\n>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Element selectors with `scoped` <sup data-p=\"d\">use with caution</sup>\n\n**Element selectors should be avoided with `scoped`.**\n\nPrefer class selectors over element selectors in `scoped` styles, because large numbers of element selectors are slow.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nTo scope styles, Vue adds a unique attribute to component elements, such as `data-v-f3f3eg9`. Then selectors are modified so that only matching elements with this attribute are selected (e.g. `button[data-v-f3f3eg9]`).\n\nThe problem is that large numbers of [element-attribute selectors](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=a%5Bhref%5D&body=background%3A+%23CFD&ne=1000) (e.g. `button[data-v-f3f3eg9]`) will be considerably slower than [class-attribute selectors](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=.class%5Bhref%5D&body=background%3A+%23CFD&ne=1000) (e.g. `.btn-close[data-v-f3f3eg9]`), so class selectors should be preferred whenever possible.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<template>\n  <button>X</button>\n</template>\n\n<style scoped>\nbutton {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style scoped>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Implicit parent-child communication <sup data-p=\"d\">use with caution</sup>\n\n**Props and events should be preferred for parent-child component communication, instead of `this.$parent` or mutating props.**\n\nAn ideal Vue application is props down, events up. Sticking to this convention makes your components much easier to understand. However, there are edge cases where prop mutation or `this.$parent` can simplify two components that are already deeply coupled.\n\nThe problem is, there are also many _simple_ cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: '<input v-model=\"todo.text\">'\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: {\n    removeTodo () {\n      var vm = this\n      vm.$parent.todos = vm.$parent.todos.filter(function (todo) {\n        return todo.id !== vm.todo.id\n      })\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"removeTodo\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"$emit('delete')\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Non-flux state management <sup data-p=\"d\">use with caution</sup>\n\n**[Vuex](https://github.com/vuejs/vuex) should be preferred for global state management, instead of `this.$root` or a global event bus.**\n\nManaging state on `this.$root` and/or using a [global event bus](https://vuejs.org/v2/guide/migration.html#dispatch-and-broadcast-replaced) can be convenient for very simple cases, but it is not appropriate for most applications.\n\nVuex is the [official flux-like implementation](https://vuejs.org/v2/guide/state-management.html#Official-Flux-Like-Implementation) for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full [Vue DevTools](https://vuejs.org/v2/guide/installation.html#Vue-Devtools) support).\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\n// main.js\nnew Vue({\n  data: {\n    todos: []\n  },\n  created: function () {\n    this.$on('remove-todo', this.removeTodo)\n  },\n  methods: {\n    removeTodo: function (todo) {\n      var todoIdToRemove = todo.id\n      this.todos = this.todos.filter(function (todo) {\n        return todo.id !== todoIdToRemove\n      })\n    }\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\n// store/modules/todos.js\nexport default {\n  state: {\n    list: []\n  },\n  mutations: {\n    REMOVE_TODO (state, todoId) {\n      state.list = state.list.filter(todo => todo.id !== todoId)\n    }\n  },\n  actions: {\n    removeTodo ({ commit, state }, todo) {\n      commit('REMOVE_TODO', todo.id)\n    }\n  }\n}\n```\n\n``` html\n<!-- TodoItem.vue -->\n<template>\n  <span>\n    {{ todo.text }}\n    <button @click=\"removeTodo(todo)\">\n      X\n    </button>\n  </span>\n</template>\n\n<script>\nimport { mapActions } from 'vuex'\n\nexport default {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: mapActions(['removeTodo'])\n}\n</script>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n{% raw %}\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"There is unfortunately no way to automatically enforce this rule.\">self-discipline</span>',\n    runtime: 'runtime error',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>Enforcement</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n{% endraw %}\n","source":"v2/style-guide/index.md","raw":"---\ntitle: Style Guide\ntype: style-guide\n---\n\nThis is the official style guide for Vue-specific code. If you use Vue in a project, it's a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don't believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.\n\nFor the most part, we also avoid suggestions about JavaScript or HTML in general. We don't mind whether you use semicolons or trailing commas. We don't mind whether your HTML uses single-quotes or double-quotes for attribute values. Some exceptions will exist however, where we've found that a particular pattern is helpful in the context of Vue.\n\n> **Soon, we'll also provide tips for enforcement.** Sometimes you'll simply have to be disciplined, but wherever possible, we'll try to show you how to use ESLint and other automated processes to make enforcement simpler.\n\nFinally, we've split rules into four categories:\n\n\n\n## Rule Categories\n\n### Priority A: Essential\n\nThese rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.\n\n### Priority B: Strongly Recommended\n\nThese rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.\n\n### Priority C: Recommended\n\nWhere multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you're consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:\n\n1. train your brain to more easily parse most of the community code you encounter\n2. be able to copy and paste most community code examples without modification\n3. often find new hires are already accustomed to your preferred coding style, at least in regards to Vue\n\n### Priority D: Use with Caution\n\nSome features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.\n\n\n\n## Priority A Rules: Essential (Error Prevention)\n\n\n\n### Multi-word component names <sup data-p=\"a\">essential</sup>\n\n**Component names should always be multi-word, except for root `App` components, and built-in components provided by Vue, such as `<transition>` or `<component>`.**\n\nThis [prevents conflicts](http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name) with existing and future HTML elements, since all HTML elements are a single word.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('todo', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'Todo',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nVue.component('todo-item', {\n  // ...\n})\n```\n\n``` js\nexport default {\n  name: 'TodoItem',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component data <sup data-p=\"a\">essential</sup>\n\n**Component `data` must be a function.**\n\nWhen using the `data` property on a component (i.e. anywhere except on `new Vue`), the value must be a function that returns an object.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nWhen the value of `data` is an object, it's shared across all instances of a component. Imagine, for example, a `TodoList` component with this data:\n\n``` js\ndata: {\n  listTitle: '',\n  todos: []\n}\n```\n\nWe might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There's a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.\n\nInstead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:\n\n``` js\ndata: function () {\n  return {\n    listTitle: '',\n    todos: []\n  }\n}\n```\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('some-comp', {\n  data: {\n    foo: 'bar'\n  }\n})\n```\n\n``` js\nexport default {\n  data: {\n    foo: 'bar'\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n``` js\nVue.component('some-comp', {\n  data: function () {\n    return {\n      foo: 'bar'\n    }\n  }\n})\n```\n\n``` js\n// In a .vue file\nexport default {\n  data () {\n    return {\n      foo: 'bar'\n    }\n  }\n}\n```\n\n``` js\n// It's OK to use an object directly in a root\n// Vue instance, since only a single instance\n// will ever exist.\nnew Vue({\n  data: {\n    foo: 'bar'\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop definitions <sup data-p=\"a\">essential</sup>\n\n**Prop definitions should be as detailed as possible.**\n\nIn committed code, prop definitions should always be as detailed as possible, specifying at least type(s).\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nDetailed [prop definitions](https://vuejs.org/v2/guide/components.html#Prop-Validation) have two advantages:\n\n- They document the API of the component, so that it's easy to see how the component is meant to be used.\n- In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\n// This is only OK when prototyping\nprops: ['status']\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nprops: {\n  status: String\n}\n```\n\n``` js\n// Even better!\nprops: {\n  status: {\n    type: String,\n    required: true,\n    validator: function (value) {\n      return [\n        'syncing',\n        'synced',\n        'version-conflict',\n        'error'\n      ].indexOf(value) !== -1\n    }\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Keyed `v-for` <sup data-p=\"a\">essential</sup>\n\n**Always use `key` with `v-for`.**\n\n`key` with `v-for` is _always_ required on components, in order to maintain internal component state down the subtree. Even for elements though, it's a good practice to maintain predictable behavior, such as [object constancy](https://bost.ocks.org/mike/constancy/) in animations.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nLet's say you have a list of todos:\n\n``` js\ndata: function () {\n  return {\n    todos: [\n      {\n        id: 1,\n        text: 'Learn to use v-for'\n      },\n      {\n        id: 2,\n        text: 'Learn to use key'\n      }\n    ]\n  }\n}\n```\n\nThen you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.\n\nThe problem is, there are cases where it's important not to delete elements that will remain in the DOM. For example, you may want to use `<transition-group>` to animate list sorting, or maintain focus if the rendered element is an `<input>`. In these cases, adding a unique key for each item (e.g. `:key=\"todo.id\"`) will tell Vue how to behave more predictably.\n\nIn our experience, it's better to _always_ add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn't necessary, you can make a conscious exception.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<ul>\n  <li v-for=\"todo in todos\">\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<ul>\n  <li\n    v-for=\"todo in todos\"\n    :key=\"todo.id\"\n  >\n    {{ todo.text }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Avoid `v-if` with `v-for` <sup data-p=\"a\">essential</sup>\n\n**Never use `v-if` on the same element as `v-for`.**\n\nThere are two common cases where this can be tempting:\n\n- To filter items in a list (e.g. `v-for=\"user in users\" v-if=\"user.isActive\"`). In these cases, replace `users` with a new computed property that returns your filtered list (e.g. `activeUsers`).\n\n- To avoid rendering a list if it should be hidden (e.g. `v-for=\"user in users\" v-if=\"shouldShowUsers\"`). In these cases, move the `v-if` to a container element (e.g. `ul`, `ol`).\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nWhen Vue processes directives, `v-for` has a higher priority than `v-if`, so that this template:\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nWill be evaluated similar to:\n\n``` js\nthis.users.map(function (user) {\n  if (user.isActive) {\n    return user.name\n  }\n})\n```\n\nSo even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.\n\nBy iterating over a computed property instead, like this:\n\n``` js\ncomputed: {\n  activeUsers: function () {\n    return this.users.filter(function (user) {\n      return user.isActive\n    })\n  }\n}\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nWe get the following benefits:\n\n- The filtered list will _only_ be re-evaluated if there are relevant changes to the `users` array, making filtering much more efficient.\n- Using `v-for=\"user in activeUsers\"`, we _only_ iterate over active users during render, making rendering much more efficient.\n- Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.\n\nWe get similar benefits from updating:\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nto:\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\nBy moving the `v-if` to a container element, we're no longer checking `shouldShowUsers` for _every_ user in the list. Instead, we check it once and don't even evaluate the `v-for` if `shouldShowUsers` is false.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"user.isActive\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul>\n  <li\n    v-for=\"user in users\"\n    v-if=\"shouldShowUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<ul>\n  <li\n    v-for=\"user in activeUsers\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n\n``` html\n<ul v-if=\"shouldShowUsers\">\n  <li\n    v-for=\"user in users\"\n    :key=\"user.id\"\n  >\n    {{ user.name }}\n  </li>\n</ul>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component style scoping <sup data-p=\"a\">essential</sup>\n\n**For applications, styles in a top-level `App` component and in layout components may be global, but all other components should always be scoped.**\n\nThis is only relevant for [single-file components](../guide/single-file-components.html). It does _not_ require that the [`scoped` attribute](https://vue-loader.vuejs.org/en/features/scoped-css.html) be used. Scoping could be through [CSS modules](https://vue-loader.vuejs.org/en/features/css-modules.html), a class-based strategy such as [BEM](http://getbem.com/), or another library/convention.\n\n**Component libraries, however, should prefer a class-based strategy instead of using the `scoped` attribute.**\n\nThis makes overriding internal styles easier, with human-readable class names that don't have too high specificity, but are still very unlikely to result in a conflict.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nIf you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.\n\nBeyond the `scoped` attribute, using unique class names can help ensure that 3rd-party CSS does not apply to your own HTML. For example, many projects use the `button`, `btn`, or `icon` class names, so even if not using a strategy such as BEM, adding an app-specific and/or component-specific prefix (e.g. `ButtonClose-icon`) can provide some protection.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<template>\n  <button class=\"button button-close\">X</button>\n</template>\n\n<!-- Using the `scoped` attribute -->\n<style scoped>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.button-close {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button :class=\"[$style.button, $style.buttonClose]\">X</button>\n</template>\n\n<!-- Using CSS modules -->\n<style module>\n.button {\n  border: none;\n  border-radius: 2px;\n}\n\n.buttonClose {\n  background-color: red;\n}\n</style>\n```\n\n``` html\n<template>\n  <button class=\"c-Button c-Button--close\">X</button>\n</template>\n\n<!-- Using the BEM convention -->\n<style>\n.c-Button {\n  border: none;\n  border-radius: 2px;\n}\n\n.c-Button--close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Private property names <sup data-p=\"a\">essential</sup>\n\n**Use module scoping to keep private functions inaccessible from the outside. If that's not possible, always use the `$_` prefix for custom private properties in a plugin, mixin, etc that should not be considered public API. Then to avoid conflicts with code by other authors, also include a named scope (e.g. `$_yourPluginName_`).**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nVue uses the `_` prefix to define its own private properties, so using the same prefix (e.g. `_update`) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won't arise in a later version.\n\nAs for the `$` prefix, its purpose within the Vue ecosystem is special instance properties that are exposed to the user, so using it for _private_ properties would not be appropriate.\n\nInstead, we recommend combining the two prefixes into `$_`, as a convention for user-defined private properties that guarantee no conflicts with Vue.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    _update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nvar myGreatMixin = {\n  // ...\n  methods: {\n    $_myGreatMixin_update: function () {\n      // ...\n    }\n  }\n}\n```\n\n``` js\n// Even better!\nvar myGreatMixin = {\n  // ...\n  methods: {\n    publicMethod() {\n      // ...\n      myPrivateFunction()\n    }\n  }\n}\n\nfunction myPrivateFunction() {\n  // ...\n}\n\nexport default myGreatMixin\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## Priority B Rules: Strongly Recommended (Improving Readability)\n\n\n\n### Component files <sup data-p=\"b\">strongly recommended</sup>\n\n**Whenever a build system is available to concatenate files, each component should be in its own file.**\n\nThis helps you to more quickly find a component when you need to edit it or review how to use it.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('TodoList', {\n  // ...\n})\n\nVue.component('TodoItem', {\n  // ...\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- TodoList.js\n|- TodoItem.js\n```\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Single-file component filename casing <sup data-p=\"b\">strongly recommended</sup>\n\n**Filenames of [single-file components](../guide/single-file-components.html) should either be always PascalCase or always kebab-case.**\n\nPascalCase works best with autocompletion in code editors, as it's consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- mycomponent.vue\n```\n\n```\ncomponents/\n|- myComponent.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- MyComponent.vue\n```\n\n```\ncomponents/\n|- my-component.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Base component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Base components (a.k.a. presentational, dumb, or pure components) that apply app-specific styling and conventions should all begin with a specific prefix, such as `Base`, `App`, or `V`.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nThese components lay the foundation for consistent styling and behavior in your application. They may **only** contain:\n\n- HTML elements,\n- other base components, and\n- 3rd-party UI components.\n\nBut they'll **never** contain global state (e.g. from a Vuex store).\n\nTheir names often include the name of an element they wrap (e.g. `BaseButton`, `BaseTable`), unless no element exists for their specific purpose (e.g. `BaseIcon`). If you build similar components for a more specific context, they will almost always consume these components (e.g. `BaseButton` may be used in `ButtonSubmit`).\n\nSome advantages of this convention:\n\n- When organized alphabetically in editors, your app's base components are all listed together, making them easier to identify.\n\n- Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. `MyButton`, `VueButton`).\n\n- Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:\n\n  ``` js\n  var requireComponent = require.context(\"./src\", true, /Base[A-Z]\\w+\\.(vue|js)$/)\n  requireComponent.keys().forEach(function (fileName) {\n    var baseComponentConfig = requireComponent(fileName)\n    baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n    var baseComponentName = baseComponentConfig.name || (\n      fileName\n        .replace(/^.+\\//, '')\n        .replace(/\\.\\w+$/, '')\n    )\n    Vue.component(baseComponentName, baseComponentConfig)\n  })\n  ```\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n```\n\n```\ncomponents/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue\n```\n\n```\ncomponents/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Single-instance component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Components that should only ever have a single active instance should begin with the `The` prefix, to denote that there can be only one.**\n\nThis does not mean the component is only used in a single page, but it will only be used once _per page_. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it's a good indication that this is actually a reusable component that is only used once per page _for now_.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- Heading.vue\n|- MySidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- TheHeading.vue\n|- TheSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Tightly coupled component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Child components that are tightly coupled with their parent should include the parent component name as a prefix.**\n\nIf a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nYou might be tempted to solve this problem by nesting child components in directories named after their parent. For example:\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue\n```\n\nor:\n\n```\ncomponents/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue\n```\n\nThis isn't recommended, as it results in:\n\n- Many files with similar names, making rapid file switching in code editors more difficult.\n- Many nested sub-directories, which increases the time it takes to browse components in an editor's sidebar.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue\n```\n\n```\ncomponents/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Order of words in component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Component names should start with the highest-level (often most general) words and end with descriptive modifying words.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nYou may be wondering:\n\n> \"Why would we force component names to use less natural language?\"\n\nIn natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:\n\n- Coffee _with_ milk\n- Soup _of the_ day\n- Visitor _to the_ museum\n\nYou can definitely include these connector words in component names if you'd like, but the order is still important.\n\nAlso note that **what's considered \"highest-level\" will be contextual to your app**. For example, imagine an app with a search form. It may include components like this one:\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n\nAs you might notice, it's quite difficult to see which components are specific to the search. Now let's rename the components according to the rule:\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue\n```\n\nSince editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.\n\nYou might be tempted to solve this problem differently, nesting all the search components under a \"search\" directory, then all the settings components under a \"settings\" directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:\n\n- It generally takes more time to navigate through nested sub-directories, than scrolling through a single `components` directory.\n- Name conflicts (e.g. multiple `ButtonDelete.vue` components) make it more difficult to quickly navigate to a specific component in a code editor.\n- Refactoring becomes more difficult, because find-and-replace often isn't sufficient to update relative references to a moved component.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Self-closing components <sup data-p=\"b\">strongly recommended</sup>\n\n**Components with no content should be self-closing in [single-file components](../guide/single-file-components.html), string templates, and [JSX](../guide/render-function.html#JSX) - but never in DOM templates.**\n\nComponents that self-close communicate that they not only have no content, but are **meant** to have no content. It's the difference between a blank page in a book and one labeled \"This page intentionally left blank.\" Your code is also cleaner without the unnecessary closing tag.\n\nUnfortunately, HTML doesn't allow custom elements to be self-closing - only [official \"void\" elements](https://www.w3.org/TR/html/syntax.html#void-elements). That's why the strategy is only possible when Vue's template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<!-- In single-file components, string templates, and JSX -->\n<MyComponent></MyComponent>\n```\n\n``` html\n<!-- In DOM templates -->\n<my-component/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- In single-file components, string templates, and JSX -->\n<MyComponent/>\n```\n\n``` html\n<!-- In DOM templates -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component name casing in templates <sup data-p=\"b\">strongly recommended</sup>\n\n**In most projects, component names should always be PascalCase in [single-file components](../guide/single-file-components.html) and string templates - but kebab-case in DOM templates.**\n\nPascalCase has a few advantages over kebab-case:\n\n- Editors can autocomplete component names in templates, because PascalCase is also used in JavaScript.\n- `<MyComponent>` is more visually distinct from a single-word HTML element than `<my-component>`, because there are two character differences (the two capitals), rather than just one (a hyphen).\n- If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.\n\nUnfortunately, due to HTML's case insensitivity, DOM templates must still use kebab-case.\n\nAlso note that if you've already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, **using kebab-case everywhere is also acceptable.**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<!-- In single-file components and string templates -->\n<mycomponent/>\n```\n\n``` html\n<!-- In single-file components and string templates -->\n<myComponent/>\n```\n\n``` html\n<!-- In DOM templates -->\n<MyComponent></MyComponent>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- In single-file components and string templates -->\n<MyComponent/>\n```\n\n``` html\n<!-- In DOM templates -->\n<my-component></my-component>\n```\n\nOR\n\n``` html\n<!-- Everywhere -->\n<my-component></my-component>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Component name casing in JS/JSX <sup data-p=\"b\">strongly recommended</sup>\n\n**Component names in JS/[JSX](../guide/render-function.html#JSX) should always be PascalCase, though they may be kebab-case inside strings for simpler applications that only use global component registration through `Vue.component`.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nIn JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.\n\nHowever, for applications that use **only** global component definitions via `Vue.component`, we recommend kebab-case instead. The reasons are:\n\n- It's rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.\n- These applications always include many in-DOM templates, where [kebab-case **must** be used](#Component-name-casing-in-templates-strongly-recommended).\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('myComponent', {\n  // ...\n})\n```\n\n``` js\nimport myComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'myComponent',\n  // ...\n}\n```\n\n``` js\nexport default {\n  name: 'my-component',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nVue.component('MyComponent', {\n  // ...\n})\n```\n\n``` js\nVue.component('my-component', {\n  // ...\n})\n```\n\n``` js\nimport MyComponent from './MyComponent.vue'\n```\n\n``` js\nexport default {\n  name: 'MyComponent',\n  // ...\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Full-word component names <sup data-p=\"b\">strongly recommended</sup>\n\n**Component names should prefer full words over abbreviations.**\n\nThe autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n```\ncomponents/\n|- SdSettings.vue\n|- UProfOpts.vue\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n```\ncomponents/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Prop name casing <sup data-p=\"b\">strongly recommended</sup>\n\n**Prop names should always use camelCase during declaration, but kebab-case in templates and [JSX](../guide/render-function.html#JSX).**\n\nWe're simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nprops: {\n  'greeting-text': String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greetingText=\"hi\"/>\n{% endcodeblock %}\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nprops: {\n  greetingText: String\n}\n```\n\n{% codeblock lang:html %}\n<WelcomeMessage greeting-text=\"hi\"/>\n{% endcodeblock %}\n{% raw %}</div>{% endraw %}\n\n\n\n### Multi-attribute elements <sup data-p=\"b\">strongly recommended</sup>\n\n**Elements with multiple attributes should span multiple lines, with one attribute per line.**\n\nIn JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it's much easier to read. Our templates and [JSX](../guide/render-function.html#JSX) deserve the same consideration.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<img src=\"https://vuejs.org/images/logo.png\" alt=\"Vue Logo\">\n```\n\n``` html\n<MyComponent foo=\"a\" bar=\"b\" baz=\"c\"/>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<img\n  src=\"https://vuejs.org/images/logo.png\"\n  alt=\"Vue Logo\"\n>\n```\n\n``` html\n<MyComponent\n  foo=\"a\"\n  bar=\"b\"\n  baz=\"c\"\n/>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Simple expressions in templates <sup data-p=\"b\">strongly recommended</sup>\n\n**Component templates should only include simple expressions, with more complex expressions refactored into computed properties or methods.**\n\nComplex expressions in your templates make them less declarative. We should strive to describe _what_ should appear, not _how_ we're computing that value. Computed properties and methods also allow the code to be reused.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n{{\n  fullName.split(' ').map(function (word) {\n    return word[0].toUpperCase() + word.slice(1)\n  }).join(' ')\n}}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- In a template -->\n{{ normalizedFullName }}\n```\n\n``` js\n// The complex expression has been moved to a computed property\ncomputed: {\n  normalizedFullName: function () {\n    return this.fullName.split(' ').map(function (word) {\n      return word[0].toUpperCase() + word.slice(1)\n    }).join(' ')\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Simple computed properties <sup data-p=\"b\">strongly recommended</sup>\n\n**Complex computed properties should be split into as many simpler properties as possible.**\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nSimpler, well-named computed properties are:\n\n- __Easier to test__\n\n  When each computed property contains only a very simple expression, with very few dependencies, it's much easier to write tests confirming that it works correctly.\n\n- __Easier to read__\n\n  Simplifying computed properties forces you to give each value a descriptive name, even if it's not reused. This makes it much easier for other developers (and future you) to focus on the code they care about and figure out what's going on.\n\n- __More adaptable to changing requirements__\n\n  Any value that can be named might be useful to the view. For example, we might decide to display a message telling the user how much money they saved. We might also decide to calculate sales tax, but perhaps display it separately, rather than as part of the final price.\n\n  Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\ncomputed: {\n  price: function () {\n    var basePrice = this.manufactureCost / (1 - this.profitMargin)\n    return (\n      basePrice -\n      basePrice * (this.discountPercent || 0)\n    )\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\ncomputed: {\n  basePrice: function () {\n    return this.manufactureCost / (1 - this.profitMargin)\n  },\n  discount: function () {\n    return this.basePrice * (this.discountPercent || 0)\n  },\n  finalPrice: function () {\n    return this.basePrice - this.discount\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Quoted attribute values <sup data-p=\"b\">strongly recommended</sup>\n\n**Non-empty HTML attribute values should always be inside quotes (single or double, whichever is not used in JS).**\n\nWhile attribute values without any spaces are not required to have quotes in HTML, this practice often leads to _avoiding_ spaces, making attribute values less readable.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<input type=text>\n```\n\n``` html\n<AppSidebar :style={width:sidebarWidth+'px'}>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<input type=\"text\">\n```\n\n``` html\n<AppSidebar :style=\"{ width: sidebarWidth + 'px' }\">\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Directive shorthands <sup data-p=\"b\">strongly recommended</sup>\n\n**Directive shorthands (`:` for `v-bind:`, `@` for `v-on:` and `#` for `v-slot`) should be used always or never.**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<input\n  :value=\"newTodoText\"\n  :placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  v-bind:value=\"newTodoText\"\n  v-bind:placeholder=\"newTodoInstructions\"\n>\n```\n\n``` html\n<input\n  @input=\"onInput\"\n  @focus=\"onFocus\"\n>\n```\n\n``` html\n<input\n  v-on:input=\"onInput\"\n  v-on:focus=\"onFocus\"\n>\n```\n\n``` html\n<template v-slot:header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template v-slot:footer>\n  <p>Here's some contact info</p>\n</template>\n```\n\n``` html\n<template #header>\n  <h1>Here might be a page title</h1>\n</template>\n\n<template #footer>\n  <p>Here's some contact info</p>\n</template>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n\n## Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)\n\n\n\n### Component/instance options order <sup data-p=\"c\">recommended</sup>\n\n**Component/instance options should be ordered consistently.**\n\nThis is the default order we recommend for component options. They're split into categories, so you'll know where to add new properties from plugins.\n\n1. **Side Effects** (triggers effects outside the component)\n  - `el`\n\n2. **Global Awareness** (requires knowledge beyond the component)\n  - `name`\n  - `parent`\n\n3. **Component Type** (changes the type of the component)\n  - `functional`\n\n4. **Template Modifiers** (changes the way templates are compiled)\n  - `delimiters`\n  - `comments`\n\n5. **Template Dependencies** (assets used in the template)\n  - `components`\n  - `directives`\n  - `filters`\n\n6. **Composition** (merges properties into the options)\n  - `extends`\n  - `mixins`\n\n7. **Interface** (the interface to the component)\n  - `inheritAttrs`\n  - `model`\n  - `props`/`propsData`\n\n8. **Local State** (local reactive properties)\n  - `data`\n  - `computed`\n\n9. **Events** (callbacks triggered by reactive events)\n  - `watch`\n  - Lifecycle Events (in the order they are called)\n    - `beforeCreate`\n    - `created`\n    - `beforeMount`\n    - `mounted`\n    - `beforeUpdate`\n    - `updated`\n    - `activated`\n    - `deactivated`\n    - `beforeDestroy`\n    - `destroyed`\n\n10. **Non-Reactive Properties** (instance properties independent of the reactivity system)\n  - `methods`\n\n11. **Rendering** (the declarative description of the component output)\n  - `template`/`render`\n  - `renderError`\n\n\n\n### Element attribute order <sup data-p=\"c\">recommended</sup>\n\n**The attributes of elements (including components) should be ordered consistently.**\n\nThis is the default order we recommend for component options. They're split into categories, so you'll know where to add custom attributes and directives.\n\n1. **Definition** (provides the component options)\n  - `is`\n\n2. **List Rendering** (creates multiple variations of the same element)\n  - `v-for`\n\n3. **Conditionals** (whether the element is rendered/shown)\n  - `v-if`\n  - `v-else-if`\n  - `v-else`\n  - `v-show`\n  - `v-cloak`\n\n4. **Render Modifiers** (changes the way the element renders)\n  - `v-pre`\n  - `v-once`\n\n5. **Global Awareness** (requires knowledge beyond the component)\n  - `id`\n\n6. **Unique Attributes** (attributes that require unique values)\n  - `ref`\n  - `key`\n\n7. **Two-Way Binding** (combining binding and events)\n  - `v-model`\n\n8. **Other Attributes** (all unspecified bound & unbound attributes)\n\n9. **Events** (component event listeners)\n  - `v-on`\n\n10. **Content** (overrides the content of the element)\n  - `v-html`\n  - `v-text`\n\n\n\n### Empty lines in component/instance options <sup data-p=\"c\">recommended</sup>\n\n**You may want to add one empty line between multi-line properties, particularly if the options can no longer fit on your screen without scrolling.**\n\nWhen components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n\n  focused: {\n    type: Boolean,\n    default: false\n  },\n\n  label: String,\n  icon: String\n},\n\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n\n``` js\n// No spaces are also fine, as long as the component\n// is still easy to read and navigate.\nprops: {\n  value: {\n    type: String,\n    required: true\n  },\n  focused: {\n    type: Boolean,\n    default: false\n  },\n  label: String,\n  icon: String\n},\ncomputed: {\n  formattedValue: function () {\n    // ...\n  },\n  inputClasses: function () {\n    // ...\n  }\n}\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Single-file component top-level element order <sup data-p=\"c\">recommended</sup>\n\n**[Single-file components](../guide/single-file-components.html) should always order `<script>`, `<template>`, and `<style>` tags consistently, with `<style>` last, because at least one of the other two is always necessary.**\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<style>/* ... */</style>\n<script>/* ... */</script>\n<template>...</template>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<!-- ComponentA.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<script>/* ... */</script>\n<template>...</template>\n<style>/* ... */</style>\n```\n\n``` html\n<!-- ComponentA.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n\n<!-- ComponentB.vue -->\n<template>...</template>\n<script>/* ... */</script>\n<style>/* ... */</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n## Priority D Rules: Use with Caution (Potentially Dangerous Patterns)\n\n\n\n### `v-if`/`v-else-if`/`v-else` without `key` <sup data-p=\"d\">use with caution</sup>\n\n**It's usually best to use `key` with `v-if` + `v-else`, if they are the same element type (e.g. both `<div>` elements).**\n\nBy default, Vue updates the DOM as efficiently as possible. That means when switching between elements of the same type, it simply patches the existing element, rather than removing it and adding a new one in its place. This can have [unintended consequences](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences) if these elements should not actually be considered the same.\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<div v-if=\"error\">\n  Error: {{ error }}\n</div>\n<div v-else>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<div\n  v-if=\"error\"\n  key=\"search-status\"\n>\n  Error: {{ error }}\n</div>\n<div\n  v-else\n  key=\"search-results\"\n>\n  {{ results }}\n</div>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Element selectors with `scoped` <sup data-p=\"d\">use with caution</sup>\n\n**Element selectors should be avoided with `scoped`.**\n\nPrefer class selectors over element selectors in `scoped` styles, because large numbers of element selectors are slow.\n\n{% raw %}\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n{% endraw %}\n\nTo scope styles, Vue adds a unique attribute to component elements, such as `data-v-f3f3eg9`. Then selectors are modified so that only matching elements with this attribute are selected (e.g. `button[data-v-f3f3eg9]`).\n\nThe problem is that large numbers of [element-attribute selectors](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=a%5Bhref%5D&body=background%3A+%23CFD&ne=1000) (e.g. `button[data-v-f3f3eg9]`) will be considerably slower than [class-attribute selectors](http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&sel=.class%5Bhref%5D&body=background%3A+%23CFD&ne=1000) (e.g. `.btn-close[data-v-f3f3eg9]`), so class selectors should be preferred whenever possible.\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` html\n<template>\n  <button>X</button>\n</template>\n\n<style scoped>\nbutton {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` html\n<template>\n  <button class=\"btn btn-close\">X</button>\n</template>\n\n<style scoped>\n.btn-close {\n  background-color: red;\n}\n</style>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Implicit parent-child communication <sup data-p=\"d\">use with caution</sup>\n\n**Props and events should be preferred for parent-child component communication, instead of `this.$parent` or mutating props.**\n\nAn ideal Vue application is props down, events up. Sticking to this convention makes your components much easier to understand. However, there are edge cases where prop mutation or `this.$parent` can simplify two components that are already deeply coupled.\n\nThe problem is, there are also many _simple_ cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: '<input v-model=\"todo.text\">'\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: {\n    removeTodo () {\n      var vm = this\n      vm.$parent.todos = vm.$parent.todos.filter(function (todo) {\n        return todo.id !== vm.todo.id\n      })\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"removeTodo\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    >\n  `\n})\n```\n\n``` js\nVue.component('TodoItem', {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  template: `\n    <span>\n      {{ todo.text }}\n      <button @click=\"$emit('delete')\">\n        X\n      </button>\n    </span>\n  `\n})\n```\n{% raw %}</div>{% endraw %}\n\n\n\n### Non-flux state management <sup data-p=\"d\">use with caution</sup>\n\n**[Vuex](https://github.com/vuejs/vuex) should be preferred for global state management, instead of `this.$root` or a global event bus.**\n\nManaging state on `this.$root` and/or using a [global event bus](https://vuejs.org/v2/guide/migration.html#dispatch-and-broadcast-replaced) can be convenient for very simple cases, but it is not appropriate for most applications.\n\nVuex is the [official flux-like implementation](https://vuejs.org/v2/guide/state-management.html#Official-Flux-Like-Implementation) for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full [Vue DevTools](https://vuejs.org/v2/guide/installation.html#Vue-Devtools) support).\n\n{% raw %}</details>{% endraw %}\n\n{% raw %}<div class=\"style-example example-bad\">{% endraw %}\n#### Bad\n\n``` js\n// main.js\nnew Vue({\n  data: {\n    todos: []\n  },\n  created: function () {\n    this.$on('remove-todo', this.removeTodo)\n  },\n  methods: {\n    removeTodo: function (todo) {\n      var todoIdToRemove = todo.id\n      this.todos = this.todos.filter(function (todo) {\n        return todo.id !== todoIdToRemove\n      })\n    }\n  }\n})\n```\n{% raw %}</div>{% endraw %}\n\n{% raw %}<div class=\"style-example example-good\">{% endraw %}\n#### Good\n\n``` js\n// store/modules/todos.js\nexport default {\n  state: {\n    list: []\n  },\n  mutations: {\n    REMOVE_TODO (state, todoId) {\n      state.list = state.list.filter(todo => todo.id !== todoId)\n    }\n  },\n  actions: {\n    removeTodo ({ commit, state }, todo) {\n      commit('REMOVE_TODO', todo.id)\n    }\n  }\n}\n```\n\n``` html\n<!-- TodoItem.vue -->\n<template>\n  <span>\n    {{ todo.text }}\n    <button @click=\"removeTodo(todo)\">\n      X\n    </button>\n  </span>\n</template>\n\n<script>\nimport { mapActions } from 'vuex'\n\nexport default {\n  props: {\n    todo: {\n      type: Object,\n      required: true\n    }\n  },\n  methods: mapActions(['removeTodo'])\n}\n</script>\n```\n{% raw %}</div>{% endraw %}\n\n\n\n{% raw %}\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"There is unfortunately no way to automatically enforce this rule.\">self-discipline</span>',\n    runtime: 'runtime error',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>Enforcement</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n{% endraw %}\n","date":"2020-09-25T23:55:41.141Z","updated":"2020-09-25T23:55:41.141Z","path":"v2/style-guide/index.html","comments":1,"layout":"page","_id":"ckfl66gyp002mc2v59tk5v2sn","content":"<p>This is the official style guide for Vue-specific code. If you use Vue in a project, it’s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don’t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</p>\n<p>For the most part, we also avoid suggestions about JavaScript or HTML in general. We don’t mind whether you use semicolons or trailing commas. We don’t mind whether your HTML uses single-quotes or double-quotes for attribute values. Some exceptions will exist however, where we’ve found that a particular pattern is helpful in the context of Vue.</p>\n<blockquote>\n<p><strong>Soon, we’ll also provide tips for enforcement.</strong> Sometimes you’ll simply have to be disciplined, but wherever possible, we’ll try to show you how to use ESLint and other automated processes to make enforcement simpler.</p>\n</blockquote>\n<p>Finally, we’ve split rules into four categories:</p>\n<h2 id=\"Rule-Categories\"><a href=\"#Rule-Categories\" class=\"headerlink\" title=\"Rule Categories\"></a>Rule Categories</h2><h3 id=\"Priority-A-Essential\"><a href=\"#Priority-A-Essential\" class=\"headerlink\" title=\"Priority A: Essential\"></a>Priority A: Essential</h3><p>These rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.</p>\n<h3 id=\"Priority-B-Strongly-Recommended\"><a href=\"#Priority-B-Strongly-Recommended\" class=\"headerlink\" title=\"Priority B: Strongly Recommended\"></a>Priority B: Strongly Recommended</h3><p>These rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.</p>\n<h3 id=\"Priority-C-Recommended\"><a href=\"#Priority-C-Recommended\" class=\"headerlink\" title=\"Priority C: Recommended\"></a>Priority C: Recommended</h3><p>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you’re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</p>\n<ol>\n<li>train your brain to more easily parse most of the community code you encounter</li>\n<li>be able to copy and paste most community code examples without modification</li>\n<li>often find new hires are already accustomed to your preferred coding style, at least in regards to Vue</li>\n</ol>\n<h3 id=\"Priority-D-Use-with-Caution\"><a href=\"#Priority-D-Use-with-Caution\" class=\"headerlink\" title=\"Priority D: Use with Caution\"></a>Priority D: Use with Caution</h3><p>Some features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.</p>\n<h2 id=\"Priority-A-Rules-Essential-Error-Prevention\"><a href=\"#Priority-A-Rules-Essential-Error-Prevention\" class=\"headerlink\" title=\"Priority A Rules: Essential (Error Prevention)\"></a>Priority A Rules: Essential (Error Prevention)</h2><h3 id=\"Multi-word-component-names-essential\"><a href=\"#Multi-word-component-names-essential\" class=\"headerlink\" title=\"Multi-word component names essential\"></a>Multi-word component names <sup data-p=\"a\">essential</sup></h3><p><strong>Component names should always be multi-word, except for root <code>App</code> components, and built-in components provided by Vue, such as <code>&lt;transition&gt;</code> or <code>&lt;component&gt;</code>.</strong></p>\n<p>This <a href=\"http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name\" target=\"_blank\" rel=\"noopener\">prevents conflicts</a> with existing and future HTML elements, since all HTML elements are a single word.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad\"><a href=\"#Bad\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Todo'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good\"><a href=\"#Good\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo-item'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'TodoItem'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"Component-data-essential\"><a href=\"#Component-data-essential\" class=\"headerlink\" title=\"Component data essential\"></a>Component data <sup data-p=\"a\">essential</sup></h3><p><strong>Component <code>data</code> must be a function.</strong></p>\n<p>When using the <code>data</code> property on a component (i.e. anywhere except on <code>new Vue</code>), the value must be a function that returns an object.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>When the value of <code>data</code> is an object, it’s shared across all instances of a component. Imagine, for example, a <code>TodoList</code> component with this data:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n  <span class=\"hljs-attr\">todos</span>: []\n&#125;</code></pre>\n<p>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There’s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</p>\n<p>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;\n&#125;</code></pre>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-1\"><a href=\"#Bad-1\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-1\"><a href=\"#Good-1\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// In a .vue file</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// It's OK to use an object directly in a root</span>\n<span class=\"hljs-comment\">// Vue instance, since only a single instance</span>\n<span class=\"hljs-comment\">// will ever exist.</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n</div>\n<h3 id=\"Prop-definitions-essential\"><a href=\"#Prop-definitions-essential\" class=\"headerlink\" title=\"Prop definitions essential\"></a>Prop definitions <sup data-p=\"a\">essential</sup></h3><p><strong>Prop definitions should be as detailed as possible.</strong></p>\n<p>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Detailed <a href=\"https://vuejs.org/v2/guide/components.html#Prop-Validation\">prop definitions</a> have two advantages:</p>\n<ul>\n<li>They document the API of the component, so that it’s easy to see how the component is meant to be used.</li>\n<li>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-2\"><a href=\"#Bad-2\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// This is only OK when prototyping</span>\n<span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'status'</span>]</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-2\"><a href=\"#Good-2\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Even better!</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">status</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> [\n        <span class=\"hljs-string\">'syncing'</span>,\n        <span class=\"hljs-string\">'synced'</span>,\n        <span class=\"hljs-string\">'version-conflict'</span>,\n        <span class=\"hljs-string\">'error'</span>\n      ].indexOf(value) !== <span class=\"hljs-number\">-1</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Keyed-v-for-essential\"><a href=\"#Keyed-v-for-essential\" class=\"headerlink\" title=\"Keyed v-for essential\"></a>Keyed <code>v-for</code> <sup data-p=\"a\">essential</sup></h3><p><strong>Always use <code>key</code> with <code>v-for</code>.</strong></p>\n<p><code>key</code> with <code>v-for</code> is <em>always</em> required on components, in order to maintain internal component state down the subtree. Even for elements though, it’s a good practice to maintain predictable behavior, such as <a href=\"https://bost.ocks.org/mike/constancy/\" target=\"_blank\" rel=\"noopener\">object constancy</a> in animations.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Let’s say you have a list of todos:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">todos</span>: [\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Learn to use v-for'</span>\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Learn to use key'</span>\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n<p>Then you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.</p>\n<p>The problem is, there are cases where it’s important not to delete elements that will remain in the DOM. For example, you may want to use <code>&lt;transition-group&gt;</code> to animate list sorting, or maintain focus if the rendered element is an <code>&lt;input&gt;</code>. In these cases, adding a unique key for each item (e.g. <code>:key=&quot;todo.id&quot;</code>) will tell Vue how to behave more predictably.</p>\n<p>In our experience, it’s better to <em>always</em> add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn’t necessary, you can make a conscious exception.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-3\"><a href=\"#Bad-3\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-3\"><a href=\"#Good-3\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Avoid-v-if-with-v-for-essential\"><a href=\"#Avoid-v-if-with-v-for-essential\" class=\"headerlink\" title=\"Avoid v-if with v-for essential\"></a>Avoid <code>v-if</code> with <code>v-for</code> <sup data-p=\"a\">essential</sup></h3><p><strong>Never use <code>v-if</code> on the same element as <code>v-for</code>.</strong></p>\n<p>There are two common cases where this can be tempting:</p>\n<ul>\n<li><p>To filter items in a list (e.g. <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>). In these cases, replace <code>users</code> with a new computed property that returns your filtered list (e.g. <code>activeUsers</code>).</p>\n</li>\n<li><p>To avoid rendering a list if it should be hidden (e.g. <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>). In these cases, move the <code>v-if</code> to a container element (e.g. <code>ul</code>, <code>ol</code>).</p>\n</li>\n</ul>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>When Vue processes directives, <code>v-for</code> has a higher priority than <code>v-if</code>, so that this template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>Will be evaluated similar to:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.users.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (user.isActive) &#123;\n    <span class=\"hljs-keyword\">return</span> user.name\n  &#125;\n&#125;)</code></pre>\n<p>So even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.</p>\n<p>By iterating over a computed property instead, like this:</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">activeUsers</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.users.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> user.isActive\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>We get the following benefits:</p>\n<ul>\n<li>The filtered list will <em>only</em> be re-evaluated if there are relevant changes to the <code>users</code> array, making filtering much more efficient.</li>\n<li>Using <code>v-for=&quot;user in activeUsers&quot;</code>, we <em>only</em> iterate over active users during render, making rendering much more efficient.</li>\n<li>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</li>\n</ul>\n<p>We get similar benefits from updating:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>to:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>By moving the <code>v-if</code> to a container element, we’re no longer checking <code>shouldShowUsers</code> for <em>every</em> user in the list. Instead, we check it once and don’t even evaluate the <code>v-for</code> if <code>shouldShowUsers</code> is false.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-4\"><a href=\"#Bad-4\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-4\"><a href=\"#Good-4\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Component-style-scoping-essential\"><a href=\"#Component-style-scoping-essential\" class=\"headerlink\" title=\"Component style scoping essential\"></a>Component style scoping <sup data-p=\"a\">essential</sup></h3><p><strong>For applications, styles in a top-level <code>App</code> component and in layout components may be global, but all other components should always be scoped.</strong></p>\n<p>This is only relevant for <a href=\"../guide/single-file-components.html\">single-file components</a>. It does <em>not</em> require that the <a href=\"https://vue-loader.vuejs.org/en/features/scoped-css.html\" target=\"_blank\" rel=\"noopener\"><code>scoped</code> attribute</a> be used. Scoping could be through <a href=\"https://vue-loader.vuejs.org/en/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS modules</a>, a class-based strategy such as <a href=\"http://getbem.com/\" target=\"_blank\" rel=\"noopener\">BEM</a>, or another library/convention.</p>\n<p><strong>Component libraries, however, should prefer a class-based strategy instead of using the <code>scoped</code> attribute.</strong></p>\n<p>This makes overriding internal styles easier, with human-readable class names that don’t have too high specificity, but are still very unlikely to result in a conflict.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</p>\n<p>Beyond the <code>scoped</code> attribute, using unique class names can help ensure that 3rd-party CSS does not apply to your own HTML. For example, many projects use the <code>button</code>, <code>btn</code>, or <code>icon</code> class names, so even if not using a strategy such as BEM, adding an app-specific and/or component-specific prefix (e.g. <code>ButtonClose-icon</code>) can provide some protection.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-5\"><a href=\"#Bad-5\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-5\"><a href=\"#Good-5\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button button-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Using the `scoped` attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.button-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[$style.button, $style.buttonClose]\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Using CSS modules --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">module</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.buttonClose</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"c-Button c-Button--close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Using the BEM convention --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.c-Button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.c-Button--close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Private-property-names-essential\"><a href=\"#Private-property-names-essential\" class=\"headerlink\" title=\"Private property names essential\"></a>Private property names <sup data-p=\"a\">essential</sup></h3><p><strong>Use module scoping to keep private functions inaccessible from the outside. If that’s not possible, always use the <code>$_</code> prefix for custom private properties in a plugin, mixin, etc that should not be considered public API. Then to avoid conflicts with code by other authors, also include a named scope (e.g. <code>$_yourPluginName_</code>).</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Vue uses the <code>_</code> prefix to define its own private properties, so using the same prefix (e.g. <code>_update</code>) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won’t arise in a later version.</p>\n<p>As for the <code>$</code> prefix, its purpose within the Vue ecosystem is special instance properties that are exposed to the user, so using it for <em>private</em> properties would not be appropriate.</p>\n<p>Instead, we recommend combining the two prefixes into <code>$_</code>, as a convention for user-defined private properties that guarantee no conflicts with Vue.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-6\"><a href=\"#Bad-6\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-6\"><a href=\"#Good-6\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_myGreatMixin_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Even better!</span>\n<span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    publicMethod() &#123;\n      <span class=\"hljs-comment\">// ...</span>\n      myPrivateFunction()\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myPrivateFunction</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> myGreatMixin</code></pre>\n</div>\n<h2 id=\"Priority-B-Rules-Strongly-Recommended-Improving-Readability\"><a href=\"#Priority-B-Rules-Strongly-Recommended-Improving-Readability\" class=\"headerlink\" title=\"Priority B Rules: Strongly Recommended (Improving Readability)\"></a>Priority B Rules: Strongly Recommended (Improving Readability)</h2><h3 id=\"Component-files-strongly-recommended\"><a href=\"#Component-files-strongly-recommended\" class=\"headerlink\" title=\"Component files strongly recommended\"></a>Component files <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Whenever a build system is available to concatenate files, each component should be in its own file.</strong></p>\n<p>This helps you to more quickly find a component when you need to edit it or review how to use it.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-7\"><a href=\"#Bad-7\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoList'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)\n\nVue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-7\"><a href=\"#Good-7\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.js\n|- TodoItem.js</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue</code></pre>\n</div>\n<h3 id=\"Single-file-component-filename-casing-strongly-recommended\"><a href=\"#Single-file-component-filename-casing-strongly-recommended\" class=\"headerlink\" title=\"Single-file component filename casing strongly recommended\"></a>Single-file component filename casing <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Filenames of <a href=\"../guide/single-file-components.html\">single-file components</a> should either be always PascalCase or always kebab-case.</strong></p>\n<p>PascalCase works best with autocompletion in code editors, as it’s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-8\"><a href=\"#Bad-8\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- mycomponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- myComponent.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-8\"><a href=\"#Good-8\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- MyComponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- my-component.vue</code></pre>\n</div>\n<h3 id=\"Base-component-names-strongly-recommended\"><a href=\"#Base-component-names-strongly-recommended\" class=\"headerlink\" title=\"Base component names strongly recommended\"></a>Base component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Base components (a.k.a. presentational, dumb, or pure components) that apply app-specific styling and conventions should all begin with a specific prefix, such as <code>Base</code>, <code>App</code>, or <code>V</code>.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>These components lay the foundation for consistent styling and behavior in your application. They may <strong>only</strong> contain:</p>\n<ul>\n<li>HTML elements,</li>\n<li>other base components, and</li>\n<li>3rd-party UI components.</li>\n</ul>\n<p>But they’ll <strong>never</strong> contain global state (e.g. from a Vuex store).</p>\n<p>Their names often include the name of an element they wrap (e.g. <code>BaseButton</code>, <code>BaseTable</code>), unless no element exists for their specific purpose (e.g. <code>BaseIcon</code>). If you build similar components for a more specific context, they will almost always consume these components (e.g. <code>BaseButton</code> may be used in <code>ButtonSubmit</code>).</p>\n<p>Some advantages of this convention:</p>\n<ul>\n<li><p>When organized alphabetically in editors, your app’s base components are all listed together, making them easier to identify.</p>\n</li>\n<li><p>Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. <code>MyButton</code>, <code>VueButton</code>).</p>\n</li>\n<li><p>Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> requireComponent = <span class=\"hljs-built_in\">require</span>.context(<span class=\"hljs-string\">\"./src\"</span>, <span class=\"hljs-literal\">true</span>, /Base[A-Z]\\w+\\.(vue|js)$/)\nrequireComponent.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fileName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> baseComponentConfig = requireComponent(fileName)\n  baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n  <span class=\"hljs-keyword\">var</span> baseComponentName = baseComponentConfig.name || (\n    fileName\n      .replace(<span class=\"hljs-regexp\">/^.+\\//</span>, <span class=\"hljs-string\">''</span>)\n      .replace(<span class=\"hljs-regexp\">/\\.\\w+$/</span>, <span class=\"hljs-string\">''</span>)\n  )\n  Vue.component(baseComponentName, baseComponentConfig)\n&#125;)</code></pre>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-9\"><a href=\"#Bad-9\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-9\"><a href=\"#Good-9\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue</code></pre>\n</div>\n<h3 id=\"Single-instance-component-names-strongly-recommended\"><a href=\"#Single-instance-component-names-strongly-recommended\" class=\"headerlink\" title=\"Single-instance component names strongly recommended\"></a>Single-instance component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Components that should only ever have a single active instance should begin with the <code>The</code> prefix, to denote that there can be only one.</strong></p>\n<p>This does not mean the component is only used in a single page, but it will only be used once <em>per page</em>. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it’s a good indication that this is actually a reusable component that is only used once per page <em>for now</em>.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-10\"><a href=\"#Bad-10\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- Heading.vue\n|- MySidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-10\"><a href=\"#Good-10\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- TheHeading.vue\n|- TheSidebar.vue</code></pre>\n</div>\n<h3 id=\"Tightly-coupled-component-names-strongly-recommended\"><a href=\"#Tightly-coupled-component-names-strongly-recommended\" class=\"headerlink\" title=\"Tightly coupled component names strongly recommended\"></a>Tightly coupled component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Child components that are tightly coupled with their parent should include the parent component name as a prefix.</strong></p>\n<p>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue</code></pre>\n<p>or:</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue</code></pre>\n<p>This isn’t recommended, as it results in:</p>\n<ul>\n<li>Many files with similar names, making rapid file switching in code editors more difficult.</li>\n<li>Many nested sub-directories, which increases the time it takes to browse components in an editor’s sidebar.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-11\"><a href=\"#Bad-11\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-11\"><a href=\"#Good-11\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue</code></pre>\n</div>\n<h3 id=\"Order-of-words-in-component-names-strongly-recommended\"><a href=\"#Order-of-words-in-component-names-strongly-recommended\" class=\"headerlink\" title=\"Order of words in component names strongly recommended\"></a>Order of words in component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component names should start with the highest-level (often most general) words and end with descriptive modifying words.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>You may be wondering:</p>\n<blockquote>\n<p>“Why would we force component names to use less natural language?”</p>\n</blockquote>\n<p>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</p>\n<ul>\n<li>Coffee <em>with</em> milk</li>\n<li>Soup <em>of the</em> day</li>\n<li>Visitor <em>to the</em> museum</li>\n</ul>\n<p>You can definitely include these connector words in component names if you’d like, but the order is still important.</p>\n<p>Also note that <strong>what’s considered “highest-level” will be contextual to your app</strong>. For example, imagine an app with a search form. It may include components like this one:</p>\n<pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n<p>As you might notice, it’s quite difficult to see which components are specific to the search. Now let’s rename the components according to the rule:</p>\n<pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue</code></pre>\n<p>Since editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.</p>\n<p>You might be tempted to solve this problem differently, nesting all the search components under a “search” directory, then all the settings components under a “settings” directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</p>\n<ul>\n<li>It generally takes more time to navigate through nested sub-directories, than scrolling through a single <code>components</code> directory.</li>\n<li>Name conflicts (e.g. multiple <code>ButtonDelete.vue</code> components) make it more difficult to quickly navigate to a specific component in a code editor.</li>\n<li>Refactoring becomes more difficult, because find-and-replace often isn’t sufficient to update relative references to a moved component.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-12\"><a href=\"#Bad-12\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-12\"><a href=\"#Good-12\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue</code></pre>\n</div>\n<h3 id=\"Self-closing-components-strongly-recommended\"><a href=\"#Self-closing-components-strongly-recommended\" class=\"headerlink\" title=\"Self-closing components strongly recommended\"></a>Self-closing components <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Components with no content should be self-closing in <a href=\"../guide/single-file-components.html\">single-file components</a>, string templates, and <a href=\"../guide/render-function.html#JSX\">JSX</a> - but never in DOM templates.</strong></p>\n<p>Components that self-close communicate that they not only have no content, but are <strong>meant</strong> to have no content. It’s the difference between a blank page in a book and one labeled “This page intentionally left blank.” Your code is also cleaner without the unnecessary closing tag.</p>\n<p>Unfortunately, HTML doesn’t allow custom elements to be self-closing - only <a href=\"https://www.w3.org/TR/html/syntax.html#void-elements\" target=\"_blank\" rel=\"noopener\">official “void” elements</a>. That’s why the strategy is only possible when Vue’s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-13\"><a href=\"#Bad-13\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components, string templates, and JSX --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-13\"><a href=\"#Good-13\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components, string templates, and JSX --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Component-name-casing-in-templates-strongly-recommended\"><a href=\"#Component-name-casing-in-templates-strongly-recommended\" class=\"headerlink\" title=\"Component name casing in templates strongly recommended\"></a>Component name casing in templates <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>In most projects, component names should always be PascalCase in <a href=\"../guide/single-file-components.html\">single-file components</a> and string templates - but kebab-case in DOM templates.</strong></p>\n<p>PascalCase has a few advantages over kebab-case:</p>\n<ul>\n<li>Editors can autocomplete component names in templates, because PascalCase is also used in JavaScript.</li>\n<li><code>&lt;MyComponent&gt;</code> is more visually distinct from a single-word HTML element than <code>&lt;my-component&gt;</code>, because there are two character differences (the two capitals), rather than just one (a hyphen).</li>\n<li>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</li>\n</ul>\n<p>Unfortunately, due to HTML’s case insensitivity, DOM templates must still use kebab-case.</p>\n<p>Also note that if you’ve already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, <strong>using kebab-case everywhere is also acceptable.</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-14\"><a href=\"#Bad-14\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components and string templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mycomponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components and string templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-14\"><a href=\"#Good-14\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components and string templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>OR</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Everywhere --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Component-name-casing-in-JS-JSX-strongly-recommended\"><a href=\"#Component-name-casing-in-JS-JSX-strongly-recommended\" class=\"headerlink\" title=\"Component name casing in JS/JSX strongly recommended\"></a>Component name casing in JS/JSX <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component names in JS/<a href=\"../guide/render-function.html#JSX\">JSX</a> should always be PascalCase, though they may be kebab-case inside strings for simpler applications that only use global component registration through <code>Vue.component</code>.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</p>\n<p>However, for applications that use <strong>only</strong> global component definitions via <code>Vue.component</code>, we recommend kebab-case instead. The reasons are:</p>\n<ul>\n<li>It’s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</li>\n<li>These applications always include many in-DOM templates, where <a href=\"#Component-name-casing-in-templates-strongly-recommended\">kebab-case <strong>must</strong> be used</a>.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-15\"><a href=\"#Bad-15\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'myComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> myComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'myComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'my-component'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-15\"><a href=\"#Good-15\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'MyComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'MyComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"Full-word-component-names-strongly-recommended\"><a href=\"#Full-word-component-names-strongly-recommended\" class=\"headerlink\" title=\"Full-word component names strongly recommended\"></a>Full-word component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component names should prefer full words over abbreviations.</strong></p>\n<p>The autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-16\"><a href=\"#Bad-16\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- SdSettings.vue\n|- UProfOpts.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-16\"><a href=\"#Good-16\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue</code></pre>\n</div>\n<h3 id=\"Prop-name-casing-strongly-recommended\"><a href=\"#Prop-name-casing-strongly-recommended\" class=\"headerlink\" title=\"Prop name casing strongly recommended\"></a>Prop name casing <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Prop names should always use camelCase during declaration, but kebab-case in templates and <a href=\"../guide/render-function.html#JSX\">JSX</a>.</strong></p>\n<p>We’re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-17\"><a href=\"#Bad-17\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-string\">'greeting-text'</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greetingText</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-17\"><a href=\"#Good-17\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">greetingText</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greeting-text</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<h3 id=\"Multi-attribute-elements-strongly-recommended\"><a href=\"#Multi-attribute-elements-strongly-recommended\" class=\"headerlink\" title=\"Multi-attribute elements strongly recommended\"></a>Multi-attribute elements <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Elements with multiple attributes should span multiple lines, with one attribute per line.</strong></p>\n<p>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it’s much easier to read. Our templates and <a href=\"../guide/render-function.html#JSX\">JSX</a> deserve the same consideration.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-18\"><a href=\"#Bad-18\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span> <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span> <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-18\"><a href=\"#Good-18\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span>\n  <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>\n  <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span>\n  <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span>\n  <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>\n/&gt;</span></code></pre>\n</div>\n<h3 id=\"Simple-expressions-in-templates-strongly-recommended\"><a href=\"#Simple-expressions-in-templates-strongly-recommended\" class=\"headerlink\" title=\"Simple expressions in templates strongly recommended\"></a>Simple expressions in templates <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component templates should only include simple expressions, with more complex expressions refactored into computed properties or methods.</strong></p>\n<p>Complex expressions in your templates make them less declarative. We should strive to describe <em>what</em> should appear, not <em>how</em> we’re computing that value. Computed properties and methods also allow the code to be reused.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-19\"><a href=\"#Bad-19\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\">&#123;&#123;\n  fullName.split(' ').map(function (word) &#123;\n    return word[0].toUpperCase() + word.slice(1)\n  &#125;).join(' ')\n&#125;&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-19\"><a href=\"#Good-19\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In a template --&gt;</span>\n&#123;&#123; normalizedFullName &#125;&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// The complex expression has been moved to a computed property</span>\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">normalizedFullName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.fullName.split(<span class=\"hljs-string\">' '</span>).map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">word</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> word[<span class=\"hljs-number\">0</span>].toUpperCase() + word.slice(<span class=\"hljs-number\">1</span>)\n    &#125;).join(<span class=\"hljs-string\">' '</span>)\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Simple-computed-properties-strongly-recommended\"><a href=\"#Simple-computed-properties-strongly-recommended\" class=\"headerlink\" title=\"Simple computed properties strongly recommended\"></a>Simple computed properties <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Complex computed properties should be split into as many simpler properties as possible.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Simpler, well-named computed properties are:</p>\n<ul>\n<li><p><strong>Easier to test</strong></p>\n<p>When each computed property contains only a very simple expression, with very few dependencies, it’s much easier to write tests confirming that it works correctly.</p>\n</li>\n<li><p><strong>Easier to read</strong></p>\n<p>Simplifying computed properties forces you to give each value a descriptive name, even if it’s not reused. This makes it much easier for other developers (and future you) to focus on the code they care about and figure out what’s going on.</p>\n</li>\n<li><p><strong>More adaptable to changing requirements</strong></p>\n<p>Any value that can be named might be useful to the view. For example, we might decide to display a message telling the user how much money they saved. We might also decide to calculate sales tax, but perhaps display it separately, rather than as part of the final price.</p>\n<p>Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.</p>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-20\"><a href=\"#Bad-20\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">price</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> basePrice = <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n    <span class=\"hljs-keyword\">return</span> (\n      basePrice -\n      basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n    )\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-20\"><a href=\"#Good-20\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">basePrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n  &#125;,\n  <span class=\"hljs-attr\">discount</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n  &#125;,\n  <span class=\"hljs-attr\">finalPrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice - <span class=\"hljs-keyword\">this</span>.discount\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Quoted-attribute-values-strongly-recommended\"><a href=\"#Quoted-attribute-values-strongly-recommended\" class=\"headerlink\" title=\"Quoted attribute values strongly recommended\"></a>Quoted attribute values <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Non-empty HTML attribute values should always be inside quotes (single or double, whichever is not used in JS).</strong></p>\n<p>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to <em>avoiding</em> spaces, making attribute values less readable.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-21\"><a href=\"#Bad-21\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">text</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">&#123;width:sidebarWidth+</span>'<span class=\"hljs-attr\">px</span>'&#125;&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-21\"><a href=\"#Good-21\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; width: sidebarWidth + 'px' &#125;\"</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Directive-shorthands-strongly-recommended\"><a href=\"#Directive-shorthands-strongly-recommended\" class=\"headerlink\" title=\"Directive shorthands strongly recommended\"></a>Directive shorthands <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Directive shorthands (<code>:</code> for <code>v-bind:</code>, <code>@</code> for <code>v-on:</code> and <code>#</code> for <code>v-slot</code>) should be used always or never.</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-22\"><a href=\"#Bad-22\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-22\"><a href=\"#Good-22\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">v-bind:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  @<span class=\"hljs-attr\">input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  <span class=\"hljs-attr\">v-on:focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"Priority-C-Rules-Recommended-Minimizing-Arbitrary-Choices-and-Cognitive-Overhead\"><a href=\"#Priority-C-Rules-Recommended-Minimizing-Arbitrary-Choices-and-Cognitive-Overhead\" class=\"headerlink\" title=\"Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)\"></a>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</h2><h3 id=\"Component-instance-options-order-recommended\"><a href=\"#Component-instance-options-order-recommended\" class=\"headerlink\" title=\"Component/instance options order recommended\"></a>Component/instance options order <sup data-p=\"c\">recommended</sup></h3><p><strong>Component/instance options should be ordered consistently.</strong></p>\n<p>This is the default order we recommend for component options. They’re split into categories, so you’ll know where to add new properties from plugins.</p>\n<ol>\n<li><p><strong>Side Effects</strong> (triggers effects outside the component)</p>\n<ul>\n<li><code>el</code></li>\n</ul>\n</li>\n<li><p><strong>Global Awareness</strong> (requires knowledge beyond the component)</p>\n<ul>\n<li><code>name</code></li>\n<li><code>parent</code></li>\n</ul>\n</li>\n<li><p><strong>Component Type</strong> (changes the type of the component)</p>\n<ul>\n<li><code>functional</code></li>\n</ul>\n</li>\n<li><p><strong>Template Modifiers</strong> (changes the way templates are compiled)</p>\n<ul>\n<li><code>delimiters</code></li>\n<li><code>comments</code></li>\n</ul>\n</li>\n<li><p><strong>Template Dependencies</strong> (assets used in the template)</p>\n<ul>\n<li><code>components</code></li>\n<li><code>directives</code></li>\n<li><code>filters</code></li>\n</ul>\n</li>\n<li><p><strong>Composition</strong> (merges properties into the options)</p>\n<ul>\n<li><code>extends</code></li>\n<li><code>mixins</code></li>\n</ul>\n</li>\n<li><p><strong>Interface</strong> (the interface to the component)</p>\n<ul>\n<li><code>inheritAttrs</code></li>\n<li><code>model</code></li>\n<li><code>props</code>/<code>propsData</code></li>\n</ul>\n</li>\n<li><p><strong>Local State</strong> (local reactive properties)</p>\n<ul>\n<li><code>data</code></li>\n<li><code>computed</code></li>\n</ul>\n</li>\n<li><p><strong>Events</strong> (callbacks triggered by reactive events)</p>\n<ul>\n<li><code>watch</code></li>\n<li>Lifecycle Events (in the order they are called)<ul>\n<li><code>beforeCreate</code></li>\n<li><code>created</code></li>\n<li><code>beforeMount</code></li>\n<li><code>mounted</code></li>\n<li><code>beforeUpdate</code></li>\n<li><code>updated</code></li>\n<li><code>activated</code></li>\n<li><code>deactivated</code></li>\n<li><code>beforeDestroy</code></li>\n<li><code>destroyed</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Non-Reactive Properties</strong> (instance properties independent of the reactivity system)</p>\n<ul>\n<li><code>methods</code></li>\n</ul>\n</li>\n<li><p><strong>Rendering</strong> (the declarative description of the component output)</p>\n<ul>\n<li><code>template</code>/<code>render</code></li>\n<li><code>renderError</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Element-attribute-order-recommended\"><a href=\"#Element-attribute-order-recommended\" class=\"headerlink\" title=\"Element attribute order recommended\"></a>Element attribute order <sup data-p=\"c\">recommended</sup></h3><p><strong>The attributes of elements (including components) should be ordered consistently.</strong></p>\n<p>This is the default order we recommend for component options. They’re split into categories, so you’ll know where to add custom attributes and directives.</p>\n<ol>\n<li><p><strong>Definition</strong> (provides the component options)</p>\n<ul>\n<li><code>is</code></li>\n</ul>\n</li>\n<li><p><strong>List Rendering</strong> (creates multiple variations of the same element)</p>\n<ul>\n<li><code>v-for</code></li>\n</ul>\n</li>\n<li><p><strong>Conditionals</strong> (whether the element is rendered/shown)</p>\n<ul>\n<li><code>v-if</code></li>\n<li><code>v-else-if</code></li>\n<li><code>v-else</code></li>\n<li><code>v-show</code></li>\n<li><code>v-cloak</code></li>\n</ul>\n</li>\n<li><p><strong>Render Modifiers</strong> (changes the way the element renders)</p>\n<ul>\n<li><code>v-pre</code></li>\n<li><code>v-once</code></li>\n</ul>\n</li>\n<li><p><strong>Global Awareness</strong> (requires knowledge beyond the component)</p>\n<ul>\n<li><code>id</code></li>\n</ul>\n</li>\n<li><p><strong>Unique Attributes</strong> (attributes that require unique values)</p>\n<ul>\n<li><code>ref</code></li>\n<li><code>key</code></li>\n</ul>\n</li>\n<li><p><strong>Two-Way Binding</strong> (combining binding and events)</p>\n<ul>\n<li><code>v-model</code></li>\n</ul>\n</li>\n<li><p><strong>Other Attributes</strong> (all unspecified bound &amp; unbound attributes)</p>\n</li>\n<li><p><strong>Events</strong> (component event listeners)</p>\n<ul>\n<li><code>v-on</code></li>\n</ul>\n</li>\n<li><p><strong>Content</strong> (overrides the content of the element)</p>\n<ul>\n<li><code>v-html</code></li>\n<li><code>v-text</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Empty-lines-in-component-instance-options-recommended\"><a href=\"#Empty-lines-in-component-instance-options-recommended\" class=\"headerlink\" title=\"Empty lines in component/instance options recommended\"></a>Empty lines in component/instance options <sup data-p=\"c\">recommended</sup></h3><p><strong>You may want to add one empty line between multi-line properties, particularly if the options can no longer fit on your screen without scrolling.</strong></p>\n<p>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</p>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-23\"><a href=\"#Good-23\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// No spaces are also fine, as long as the component</span>\n<span class=\"hljs-comment\">// is still easy to read and navigate.</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Single-file-component-top-level-element-order-recommended\"><a href=\"#Single-file-component-top-level-element-order-recommended\" class=\"headerlink\" title=\"Single-file component top-level element order recommended\"></a>Single-file component top-level element order <sup data-p=\"c\">recommended</sup></h3><p><strong><a href=\"../guide/single-file-components.html\">Single-file components</a> should always order <code>&lt;script&gt;</code>, <code>&lt;template&gt;</code>, and <code>&lt;style&gt;</code> tags consistently, with <code>&lt;style&gt;</code> last, because at least one of the other two is always necessary.</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-23\"><a href=\"#Bad-23\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-24\"><a href=\"#Good-24\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"Priority-D-Rules-Use-with-Caution-Potentially-Dangerous-Patterns\"><a href=\"#Priority-D-Rules-Use-with-Caution-Potentially-Dangerous-Patterns\" class=\"headerlink\" title=\"Priority D Rules: Use with Caution (Potentially Dangerous Patterns)\"></a>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</h2><h3 id=\"v-if-v-else-if-v-else-without-key-use-with-caution\"><a href=\"#v-if-v-else-if-v-else-without-key-use-with-caution\" class=\"headerlink\" title=\"v-if/v-else-if/v-else without key use with caution\"></a><code>v-if</code>/<code>v-else-if</code>/<code>v-else</code> without <code>key</code> <sup data-p=\"d\">use with caution</sup></h3><p><strong>It’s usually best to use <code>key</code> with <code>v-if</code> + <code>v-else</code>, if they are the same element type (e.g. both <code>&lt;div&gt;</code> elements).</strong></p>\n<p>By default, Vue updates the DOM as efficiently as possible. That means when switching between elements of the same type, it simply patches the existing element, rather than removing it and adding a new one in its place. This can have <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences\" target=\"_blank\" rel=\"noopener\">unintended consequences</a> if these elements should not actually be considered the same.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-24\"><a href=\"#Bad-24\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>&gt;</span>\n  Error: &#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-25\"><a href=\"#Good-25\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-status\"</span>\n&gt;</span>\n  Error: &#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-else</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-results\"</span>\n&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Element-selectors-with-scoped-use-with-caution\"><a href=\"#Element-selectors-with-scoped-use-with-caution\" class=\"headerlink\" title=\"Element selectors with scoped use with caution\"></a>Element selectors with <code>scoped</code> <sup data-p=\"d\">use with caution</sup></h3><p><strong>Element selectors should be avoided with <code>scoped</code>.</strong></p>\n<p>Prefer class selectors over element selectors in <code>scoped</code> styles, because large numbers of element selectors are slow.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>To scope styles, Vue adds a unique attribute to component elements, such as <code>data-v-f3f3eg9</code>. Then selectors are modified so that only matching elements with this attribute are selected (e.g. <code>button[data-v-f3f3eg9]</code>).</p>\n<p>The problem is that large numbers of <a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=a%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">element-attribute selectors</a> (e.g. <code>button[data-v-f3f3eg9]</code>) will be considerably slower than <a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=.class%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">class-attribute selectors</a> (e.g. <code>.btn-close[data-v-f3f3eg9]</code>), so class selectors should be preferred whenever possible.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-25\"><a href=\"#Bad-25\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-tag\">button</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-26\"><a href=\"#Good-26\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Implicit-parent-child-communication-use-with-caution\"><a href=\"#Implicit-parent-child-communication-use-with-caution\" class=\"headerlink\" title=\"Implicit parent-child communication use with caution\"></a>Implicit parent-child communication <sup data-p=\"d\">use with caution</sup></h3><p><strong>Props and events should be preferred for parent-child component communication, instead of <code>this.$parent</code> or mutating props.</strong></p>\n<p>An ideal Vue application is props down, events up. Sticking to this convention makes your components much easier to understand. However, there are edge cases where prop mutation or <code>this.$parent</code> can simplify two components that are already deeply coupled.</p>\n<p>The problem is, there are also many <em>simple</em> cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-26\"><a href=\"#Bad-26\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;input v-model=\"todo.text\"&gt;'</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    removeTodo () &#123;\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      vm.$parent.todos = vm.$parent.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== vm.todo.id\n      &#125;)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"removeTodo\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-27\"><a href=\"#Good-27\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"$emit('delete')\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<h3 id=\"Non-flux-state-management-use-with-caution\"><a href=\"#Non-flux-state-management-use-with-caution\" class=\"headerlink\" title=\"Non-flux state management use with caution\"></a>Non-flux state management <sup data-p=\"d\">use with caution</sup></h3><p><strong><a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> should be preferred for global state management, instead of <code>this.$root</code> or a global event bus.</strong></p>\n<p>Managing state on <code>this.$root</code> and/or using a <a href=\"https://vuejs.org/v2/guide/migration.html#dispatch-and-broadcast-replaced\">global event bus</a> can be convenient for very simple cases, but it is not appropriate for most applications.</p>\n<p>Vuex is the <a href=\"https://vuejs.org/v2/guide/state-management.html#Official-Flux-Like-Implementation\">official flux-like implementation</a> for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full <a href=\"https://vuejs.org/v2/guide/installation.html#Vue-Devtools\">Vue DevTools</a> support).</p>\n\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-27\"><a href=\"#Bad-27\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.$on(<span class=\"hljs-string\">'remove-todo'</span>, <span class=\"hljs-keyword\">this</span>.removeTodo)\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">removeTodo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> todoIdToRemove = todo.id\n      <span class=\"hljs-keyword\">this</span>.todos = <span class=\"hljs-keyword\">this</span>.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== todoIdToRemove\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-28\"><a href=\"#Good-28\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// store/modules/todos.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">state</span>: &#123;\n    <span class=\"hljs-attr\">list</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">mutations</span>: &#123;\n    REMOVE_TODO (state, todoId) &#123;\n      state.list = state.list.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">todo</span> =&gt;</span> todo.id !== todoId)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">actions</span>: &#123;\n    removeTodo (&#123; commit, state &#125;, todo) &#123;\n      commit(<span class=\"hljs-string\">'REMOVE_TODO'</span>, todo.id)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- TodoItem.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"removeTodo(todo)\"</span>&gt;</span>\n      X\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> &#123; mapActions &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vuex'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: mapActions([<span class=\"hljs-string\">'removeTodo'</span>])\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"There is unfortunately no way to automatically enforce this rule.\">self-discipline</span>',\n    runtime: 'runtime error',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>Enforcement</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n\n","site":{"data":{}},"excerpt":"","more":"<p>This is the official style guide for Vue-specific code. If you use Vue in a project, it’s a great reference to avoid errors, bikeshedding, and anti-patterns. However, we don’t believe that any style guide is ideal for all teams or projects, so mindful deviations are encouraged based on past experience, the surrounding tech stack, and personal values.</p>\n<p>For the most part, we also avoid suggestions about JavaScript or HTML in general. We don’t mind whether you use semicolons or trailing commas. We don’t mind whether your HTML uses single-quotes or double-quotes for attribute values. Some exceptions will exist however, where we’ve found that a particular pattern is helpful in the context of Vue.</p>\n<blockquote>\n<p><strong>Soon, we’ll also provide tips for enforcement.</strong> Sometimes you’ll simply have to be disciplined, but wherever possible, we’ll try to show you how to use ESLint and other automated processes to make enforcement simpler.</p>\n</blockquote>\n<p>Finally, we’ve split rules into four categories:</p>\n<h2 id=\"Rule-Categories\"><a href=\"#Rule-Categories\" class=\"headerlink\" title=\"Rule Categories\"></a>Rule Categories</h2><h3 id=\"Priority-A-Essential\"><a href=\"#Priority-A-Essential\" class=\"headerlink\" title=\"Priority A: Essential\"></a>Priority A: Essential</h3><p>These rules help prevent errors, so learn and abide by them at all costs. Exceptions may exist, but should be very rare and only be made by those with expert knowledge of both JavaScript and Vue.</p>\n<h3 id=\"Priority-B-Strongly-Recommended\"><a href=\"#Priority-B-Strongly-Recommended\" class=\"headerlink\" title=\"Priority B: Strongly Recommended\"></a>Priority B: Strongly Recommended</h3><p>These rules have been found to improve readability and/or developer experience in most projects. Your code will still run if you violate them, but violations should be rare and well-justified.</p>\n<h3 id=\"Priority-C-Recommended\"><a href=\"#Priority-C-Recommended\" class=\"headerlink\" title=\"Priority C: Recommended\"></a>Priority C: Recommended</h3><p>Where multiple, equally good options exist, an arbitrary choice can be made to ensure consistency. In these rules, we describe each acceptable option and suggest a default choice. That means you can feel free to make a different choice in your own codebase, as long as you’re consistent and have a good reason. Please do have a good reason though! By adapting to the community standard, you will:</p>\n<ol>\n<li>train your brain to more easily parse most of the community code you encounter</li>\n<li>be able to copy and paste most community code examples without modification</li>\n<li>often find new hires are already accustomed to your preferred coding style, at least in regards to Vue</li>\n</ol>\n<h3 id=\"Priority-D-Use-with-Caution\"><a href=\"#Priority-D-Use-with-Caution\" class=\"headerlink\" title=\"Priority D: Use with Caution\"></a>Priority D: Use with Caution</h3><p>Some features of Vue exist to accommodate rare edge cases or smoother migrations from a legacy code base. When overused however, they can make your code more difficult to maintain or even become a source of bugs. These rules shine a light on potentially risky features, describing when and why they should be avoided.</p>\n<h2 id=\"Priority-A-Rules-Essential-Error-Prevention\"><a href=\"#Priority-A-Rules-Essential-Error-Prevention\" class=\"headerlink\" title=\"Priority A Rules: Essential (Error Prevention)\"></a>Priority A Rules: Essential (Error Prevention)</h2><h3 id=\"Multi-word-component-names-essential\"><a href=\"#Multi-word-component-names-essential\" class=\"headerlink\" title=\"Multi-word component names essential\"></a>Multi-word component names <sup data-p=\"a\">essential</sup></h3><p><strong>Component names should always be multi-word, except for root <code>App</code> components, and built-in components provided by Vue, such as <code>&lt;transition&gt;</code> or <code>&lt;component&gt;</code>.</strong></p>\n<p>This <a href=\"http://w3c.github.io/webcomponents/spec/custom/#valid-custom-element-name\" target=\"_blank\" rel=\"noopener\">prevents conflicts</a> with existing and future HTML elements, since all HTML elements are a single word.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad\"><a href=\"#Bad\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'Todo'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good\"><a href=\"#Good\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'todo-item'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'TodoItem'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"Component-data-essential\"><a href=\"#Component-data-essential\" class=\"headerlink\" title=\"Component data essential\"></a>Component data <sup data-p=\"a\">essential</sup></h3><p><strong>Component <code>data</code> must be a function.</strong></p>\n<p>When using the <code>data</code> property on a component (i.e. anywhere except on <code>new Vue</code>), the value must be a function that returns an object.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>When the value of <code>data</code> is an object, it’s shared across all instances of a component. Imagine, for example, a <code>TodoList</code> component with this data:</p>\n<pre><code class=\"hljs js\">data: &#123;\n  <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n  <span class=\"hljs-attr\">todos</span>: []\n&#125;</code></pre>\n<p>We might want to reuse this component, allowing users to maintain multiple lists (e.g. for shopping, wishlists, daily chores, etc). There’s a problem though. Since every instance of the component references the same data object, changing the title of one list will also change the title of every other list. The same is true for adding/editing/deleting a todo.</p>\n<p>Instead, we want each component instance to only manage its own data. For that to happen, each instance must generate a unique data object. In JavaScript, this can be accomplished by returning the object in a function:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">listTitle</span>: <span class=\"hljs-string\">''</span>,\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;\n&#125;</code></pre>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-1\"><a href=\"#Bad-1\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-1\"><a href=\"#Good-1\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'some-comp'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// In a .vue file</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// It's OK to use an object directly in a root</span>\n<span class=\"hljs-comment\">// Vue instance, since only a single instance</span>\n<span class=\"hljs-comment\">// will ever exist.</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;\n&#125;)</code></pre>\n</div>\n<h3 id=\"Prop-definitions-essential\"><a href=\"#Prop-definitions-essential\" class=\"headerlink\" title=\"Prop definitions essential\"></a>Prop definitions <sup data-p=\"a\">essential</sup></h3><p><strong>Prop definitions should be as detailed as possible.</strong></p>\n<p>In committed code, prop definitions should always be as detailed as possible, specifying at least type(s).</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Detailed <a href=\"https://vuejs.org/v2/guide/components.html#Prop-Validation\">prop definitions</a> have two advantages:</p>\n<ul>\n<li>They document the API of the component, so that it’s easy to see how the component is meant to be used.</li>\n<li>In development, Vue will warn you if a component is ever provided incorrectly formatted props, helping you catch potential sources of error.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-2\"><a href=\"#Bad-2\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// This is only OK when prototyping</span>\n<span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'status'</span>]</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-2\"><a href=\"#Good-2\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">status</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Even better!</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">status</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> [\n        <span class=\"hljs-string\">'syncing'</span>,\n        <span class=\"hljs-string\">'synced'</span>,\n        <span class=\"hljs-string\">'version-conflict'</span>,\n        <span class=\"hljs-string\">'error'</span>\n      ].indexOf(value) !== <span class=\"hljs-number\">-1</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Keyed-v-for-essential\"><a href=\"#Keyed-v-for-essential\" class=\"headerlink\" title=\"Keyed v-for essential\"></a>Keyed <code>v-for</code> <sup data-p=\"a\">essential</sup></h3><p><strong>Always use <code>key</code> with <code>v-for</code>.</strong></p>\n<p><code>key</code> with <code>v-for</code> is <em>always</em> required on components, in order to maintain internal component state down the subtree. Even for elements though, it’s a good practice to maintain predictable behavior, such as <a href=\"https://bost.ocks.org/mike/constancy/\" target=\"_blank\" rel=\"noopener\">object constancy</a> in animations.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Let’s say you have a list of todos:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> &#123;\n    <span class=\"hljs-attr\">todos</span>: [\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Learn to use v-for'</span>\n      &#125;,\n      &#123;\n        <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>,\n        <span class=\"hljs-attr\">text</span>: <span class=\"hljs-string\">'Learn to use key'</span>\n      &#125;\n    ]\n  &#125;\n&#125;</code></pre>\n<p>Then you sort them alphabetically. When updating the DOM, Vue will optimize rendering to perform the cheapest DOM mutations possible. That might mean deleting the first todo element, then adding it again at the end of the list.</p>\n<p>The problem is, there are cases where it’s important not to delete elements that will remain in the DOM. For example, you may want to use <code>&lt;transition-group&gt;</code> to animate list sorting, or maintain focus if the rendered element is an <code>&lt;input&gt;</code>. In these cases, adding a unique key for each item (e.g. <code>:key=&quot;todo.id&quot;</code>) will tell Vue how to behave more predictably.</p>\n<p>In our experience, it’s better to <em>always</em> add a unique key, so that you and your team simply never have to worry about these edge cases. Then in the rare, performance-critical scenarios where object constancy isn’t necessary, you can make a conscious exception.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-3\"><a href=\"#Bad-3\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-3\"><a href=\"#Good-3\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"todo in todos\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"todo.id\"</span>\n  &gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Avoid-v-if-with-v-for-essential\"><a href=\"#Avoid-v-if-with-v-for-essential\" class=\"headerlink\" title=\"Avoid v-if with v-for essential\"></a>Avoid <code>v-if</code> with <code>v-for</code> <sup data-p=\"a\">essential</sup></h3><p><strong>Never use <code>v-if</code> on the same element as <code>v-for</code>.</strong></p>\n<p>There are two common cases where this can be tempting:</p>\n<ul>\n<li><p>To filter items in a list (e.g. <code>v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot;</code>). In these cases, replace <code>users</code> with a new computed property that returns your filtered list (e.g. <code>activeUsers</code>).</p>\n</li>\n<li><p>To avoid rendering a list if it should be hidden (e.g. <code>v-for=&quot;user in users&quot; v-if=&quot;shouldShowUsers&quot;</code>). In these cases, move the <code>v-if</code> to a container element (e.g. <code>ul</code>, <code>ol</code>).</p>\n</li>\n</ul>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>When Vue processes directives, <code>v-for</code> has a higher priority than <code>v-if</code>, so that this template:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>Will be evaluated similar to:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">this</span>.users.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n  <span class=\"hljs-keyword\">if</span> (user.isActive) &#123;\n    <span class=\"hljs-keyword\">return</span> user.name\n  &#125;\n&#125;)</code></pre>\n<p>So even if we only render elements for a small fraction of users, we have to iterate over the entire list every time we re-render, whether or not the set of active users has changed.</p>\n<p>By iterating over a computed property instead, like this:</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">activeUsers</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.users.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">user</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> user.isActive\n    &#125;)\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>We get the following benefits:</p>\n<ul>\n<li>The filtered list will <em>only</em> be re-evaluated if there are relevant changes to the <code>users</code> array, making filtering much more efficient.</li>\n<li>Using <code>v-for=&quot;user in activeUsers&quot;</code>, we <em>only</em> iterate over active users during render, making rendering much more efficient.</li>\n<li>Logic is now decoupled from the presentation layer, making maintenance (change/extension of logic) much easier.</li>\n</ul>\n<p>We get similar benefits from updating:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>to:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>By moving the <code>v-if</code> to a container element, we’re no longer checking <code>shouldShowUsers</code> for <em>every</em> user in the list. Instead, we check it once and don’t even evaluate the <code>v-for</code> if <code>shouldShowUsers</code> is false.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-4\"><a href=\"#Bad-4\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"user.isActive\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-4\"><a href=\"#Good-4\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in activeUsers\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"shouldShowUsers\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>\n    <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"user in users\"</span>\n    <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"user.id\"</span>\n  &gt;</span>\n    &#123;&#123; user.name &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Component-style-scoping-essential\"><a href=\"#Component-style-scoping-essential\" class=\"headerlink\" title=\"Component style scoping essential\"></a>Component style scoping <sup data-p=\"a\">essential</sup></h3><p><strong>For applications, styles in a top-level <code>App</code> component and in layout components may be global, but all other components should always be scoped.</strong></p>\n<p>This is only relevant for <a href=\"../guide/single-file-components.html\">single-file components</a>. It does <em>not</em> require that the <a href=\"https://vue-loader.vuejs.org/en/features/scoped-css.html\" target=\"_blank\" rel=\"noopener\"><code>scoped</code> attribute</a> be used. Scoping could be through <a href=\"https://vue-loader.vuejs.org/en/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS modules</a>, a class-based strategy such as <a href=\"http://getbem.com/\" target=\"_blank\" rel=\"noopener\">BEM</a>, or another library/convention.</p>\n<p><strong>Component libraries, however, should prefer a class-based strategy instead of using the <code>scoped</code> attribute.</strong></p>\n<p>This makes overriding internal styles easier, with human-readable class names that don’t have too high specificity, but are still very unlikely to result in a conflict.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>If you are developing a large project, working with other developers, or sometimes include 3rd-party HTML/CSS (e.g. from Auth0), consistent scoping will ensure that your styles only apply to the components they are meant for.</p>\n<p>Beyond the <code>scoped</code> attribute, using unique class names can help ensure that 3rd-party CSS does not apply to your own HTML. For example, many projects use the <code>button</code>, <code>btn</code>, or <code>icon</code> class names, so even if not using a strategy such as BEM, adding an app-specific and/or component-specific prefix (e.g. <code>ButtonClose-icon</code>) can provide some protection.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-5\"><a href=\"#Bad-5\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-5\"><a href=\"#Good-5\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"button button-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Using the `scoped` attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.button-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[$style.button, $style.buttonClose]\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Using CSS modules --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">module</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.buttonClose</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"c-Button c-Button--close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Using the BEM convention --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.c-Button</span> &#123;\n  <span class=\"hljs-attribute\">border</span>: none;\n  <span class=\"hljs-attribute\">border-radius</span>: <span class=\"hljs-number\">2px</span>;\n&#125;\n\n<span class=\"hljs-selector-class\">.c-Button--close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Private-property-names-essential\"><a href=\"#Private-property-names-essential\" class=\"headerlink\" title=\"Private property names essential\"></a>Private property names <sup data-p=\"a\">essential</sup></h3><p><strong>Use module scoping to keep private functions inaccessible from the outside. If that’s not possible, always use the <code>$_</code> prefix for custom private properties in a plugin, mixin, etc that should not be considered public API. Then to avoid conflicts with code by other authors, also include a named scope (e.g. <code>$_yourPluginName_</code>).</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Vue uses the <code>_</code> prefix to define its own private properties, so using the same prefix (e.g. <code>_update</code>) risks overwriting an instance property. Even if you check and Vue is not currently using a particular property name, there is no guarantee a conflict won’t arise in a later version.</p>\n<p>As for the <code>$</code> prefix, its purpose within the Vue ecosystem is special instance properties that are exposed to the user, so using it for <em>private</em> properties would not be appropriate.</p>\n<p>Instead, we recommend combining the two prefixes into <code>$_</code>, as a convention for user-defined private properties that guarantee no conflicts with Vue.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-6\"><a href=\"#Bad-6\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-6\"><a href=\"#Good-6\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">$_myGreatMixin_update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// ...</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// Even better!</span>\n<span class=\"hljs-keyword\">var</span> myGreatMixin = &#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    publicMethod() &#123;\n      <span class=\"hljs-comment\">// ...</span>\n      myPrivateFunction()\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">myPrivateFunction</span>(<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> myGreatMixin</code></pre>\n</div>\n<h2 id=\"Priority-B-Rules-Strongly-Recommended-Improving-Readability\"><a href=\"#Priority-B-Rules-Strongly-Recommended-Improving-Readability\" class=\"headerlink\" title=\"Priority B Rules: Strongly Recommended (Improving Readability)\"></a>Priority B Rules: Strongly Recommended (Improving Readability)</h2><h3 id=\"Component-files-strongly-recommended\"><a href=\"#Component-files-strongly-recommended\" class=\"headerlink\" title=\"Component files strongly recommended\"></a>Component files <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Whenever a build system is available to concatenate files, each component should be in its own file.</strong></p>\n<p>This helps you to more quickly find a component when you need to edit it or review how to use it.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-7\"><a href=\"#Bad-7\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoList'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)\n\nVue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-7\"><a href=\"#Good-7\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.js\n|- TodoItem.js</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue</code></pre>\n</div>\n<h3 id=\"Single-file-component-filename-casing-strongly-recommended\"><a href=\"#Single-file-component-filename-casing-strongly-recommended\" class=\"headerlink\" title=\"Single-file component filename casing strongly recommended\"></a>Single-file component filename casing <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Filenames of <a href=\"../guide/single-file-components.html\">single-file components</a> should either be always PascalCase or always kebab-case.</strong></p>\n<p>PascalCase works best with autocompletion in code editors, as it’s consistent with how we reference components in JS(X) and templates, wherever possible. However, mixed case filenames can sometimes create issues on case-insensitive file systems, which is why kebab-case is also perfectly acceptable.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-8\"><a href=\"#Bad-8\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- mycomponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- myComponent.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-8\"><a href=\"#Good-8\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- MyComponent.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- my-component.vue</code></pre>\n</div>\n<h3 id=\"Base-component-names-strongly-recommended\"><a href=\"#Base-component-names-strongly-recommended\" class=\"headerlink\" title=\"Base component names strongly recommended\"></a>Base component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Base components (a.k.a. presentational, dumb, or pure components) that apply app-specific styling and conventions should all begin with a specific prefix, such as <code>Base</code>, <code>App</code>, or <code>V</code>.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>These components lay the foundation for consistent styling and behavior in your application. They may <strong>only</strong> contain:</p>\n<ul>\n<li>HTML elements,</li>\n<li>other base components, and</li>\n<li>3rd-party UI components.</li>\n</ul>\n<p>But they’ll <strong>never</strong> contain global state (e.g. from a Vuex store).</p>\n<p>Their names often include the name of an element they wrap (e.g. <code>BaseButton</code>, <code>BaseTable</code>), unless no element exists for their specific purpose (e.g. <code>BaseIcon</code>). If you build similar components for a more specific context, they will almost always consume these components (e.g. <code>BaseButton</code> may be used in <code>ButtonSubmit</code>).</p>\n<p>Some advantages of this convention:</p>\n<ul>\n<li><p>When organized alphabetically in editors, your app’s base components are all listed together, making them easier to identify.</p>\n</li>\n<li><p>Since component names should always be multi-word, this convention prevents you from having to choose an arbitrary prefix for simple component wrappers (e.g. <code>MyButton</code>, <code>VueButton</code>).</p>\n</li>\n<li><p>Since these components are so frequently used, you may want to simply make them global instead of importing them everywhere. A prefix makes this possible with Webpack:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> requireComponent = <span class=\"hljs-built_in\">require</span>.context(<span class=\"hljs-string\">\"./src\"</span>, <span class=\"hljs-literal\">true</span>, /Base[A-Z]\\w+\\.(vue|js)$/)\nrequireComponent.keys().forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">fileName</span>) </span>&#123;\n  <span class=\"hljs-keyword\">var</span> baseComponentConfig = requireComponent(fileName)\n  baseComponentConfig = baseComponentConfig.default || baseComponentConfig\n  <span class=\"hljs-keyword\">var</span> baseComponentName = baseComponentConfig.name || (\n    fileName\n      .replace(<span class=\"hljs-regexp\">/^.+\\//</span>, <span class=\"hljs-string\">''</span>)\n      .replace(<span class=\"hljs-regexp\">/\\.\\w+$/</span>, <span class=\"hljs-string\">''</span>)\n  )\n  Vue.component(baseComponentName, baseComponentConfig)\n&#125;)</code></pre>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-9\"><a href=\"#Bad-9\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-9\"><a href=\"#Good-9\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- AppButton.vue\n|- AppTable.vue\n|- AppIcon.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- VButton.vue\n|- VTable.vue\n|- VIcon.vue</code></pre>\n</div>\n<h3 id=\"Single-instance-component-names-strongly-recommended\"><a href=\"#Single-instance-component-names-strongly-recommended\" class=\"headerlink\" title=\"Single-instance component names strongly recommended\"></a>Single-instance component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Components that should only ever have a single active instance should begin with the <code>The</code> prefix, to denote that there can be only one.</strong></p>\n<p>This does not mean the component is only used in a single page, but it will only be used once <em>per page</em>. These components never accept any props, since they are specific to your app, not their context within your app. If you find the need to add props, it’s a good indication that this is actually a reusable component that is only used once per page <em>for now</em>.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-10\"><a href=\"#Bad-10\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- Heading.vue\n|- MySidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-10\"><a href=\"#Good-10\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- TheHeading.vue\n|- TheSidebar.vue</code></pre>\n</div>\n<h3 id=\"Tightly-coupled-component-names-strongly-recommended\"><a href=\"#Tightly-coupled-component-names-strongly-recommended\" class=\"headerlink\" title=\"Tightly coupled component names strongly recommended\"></a>Tightly coupled component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Child components that are tightly coupled with their parent should include the parent component name as a prefix.</strong></p>\n<p>If a component only makes sense in the context of a single parent component, that relationship should be evident in its name. Since editors typically organize files alphabetically, this also keeps these related files next to each other.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>You might be tempted to solve this problem by nesting child components in directories named after their parent. For example:</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- index.vue\n      |- Button.vue\n   |- index.vue</code></pre>\n<p>or:</p>\n<pre><code class=\"hljs undefined\">components/\n|- TodoList/\n   |- Item/\n      |- Button.vue\n   |- Item.vue\n|- TodoList.vue</code></pre>\n<p>This isn’t recommended, as it results in:</p>\n<ul>\n<li>Many files with similar names, making rapid file switching in code editors more difficult.</li>\n<li>Many nested sub-directories, which increases the time it takes to browse components in an editor’s sidebar.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-11\"><a href=\"#Bad-11\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- NavigationForSearchSidebar.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-11\"><a href=\"#Good-11\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue</code></pre>\n<pre><code class=\"hljs undefined\">components/\n|- SearchSidebar.vue\n|- SearchSidebarNavigation.vue</code></pre>\n</div>\n<h3 id=\"Order-of-words-in-component-names-strongly-recommended\"><a href=\"#Order-of-words-in-component-names-strongly-recommended\" class=\"headerlink\" title=\"Order of words in component names strongly recommended\"></a>Order of words in component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component names should start with the highest-level (often most general) words and end with descriptive modifying words.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>You may be wondering:</p>\n<blockquote>\n<p>“Why would we force component names to use less natural language?”</p>\n</blockquote>\n<p>In natural English, adjectives and other descriptors do typically appear before the nouns, while exceptions require connector words. For example:</p>\n<ul>\n<li>Coffee <em>with</em> milk</li>\n<li>Soup <em>of the</em> day</li>\n<li>Visitor <em>to the</em> museum</li>\n</ul>\n<p>You can definitely include these connector words in component names if you’d like, but the order is still important.</p>\n<p>Also note that <strong>what’s considered “highest-level” will be contextual to your app</strong>. For example, imagine an app with a search form. It may include components like this one:</p>\n<pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n<p>As you might notice, it’s quite difficult to see which components are specific to the search. Now let’s rename the components according to the rule:</p>\n<pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputExcludeGlob.vue\n|- SearchInputQuery.vue\n|- SettingsCheckboxLaunchOnStartup.vue\n|- SettingsCheckboxTerms.vue</code></pre>\n<p>Since editors typically organize files alphabetically, all the important relationships between components are now evident at a glance.</p>\n<p>You might be tempted to solve this problem differently, nesting all the search components under a “search” directory, then all the settings components under a “settings” directory. We only recommend considering this approach in very large apps (e.g. 100+ components), for these reasons:</p>\n<ul>\n<li>It generally takes more time to navigate through nested sub-directories, than scrolling through a single <code>components</code> directory.</li>\n<li>Name conflicts (e.g. multiple <code>ButtonDelete.vue</code> components) make it more difficult to quickly navigate to a specific component in a code editor.</li>\n<li>Refactoring becomes more difficult, because find-and-replace often isn’t sufficient to update relative references to a moved component.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-12\"><a href=\"#Bad-12\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- ClearSearchButton.vue\n|- ExcludeFromSearchInput.vue\n|- LaunchOnStartupCheckbox.vue\n|- RunSearchButton.vue\n|- SearchInput.vue\n|- TermsCheckbox.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-12\"><a href=\"#Good-12\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- SearchButtonClear.vue\n|- SearchButtonRun.vue\n|- SearchInputQuery.vue\n|- SearchInputExcludeGlob.vue\n|- SettingsCheckboxTerms.vue\n|- SettingsCheckboxLaunchOnStartup.vue</code></pre>\n</div>\n<h3 id=\"Self-closing-components-strongly-recommended\"><a href=\"#Self-closing-components-strongly-recommended\" class=\"headerlink\" title=\"Self-closing components strongly recommended\"></a>Self-closing components <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Components with no content should be self-closing in <a href=\"../guide/single-file-components.html\">single-file components</a>, string templates, and <a href=\"../guide/render-function.html#JSX\">JSX</a> - but never in DOM templates.</strong></p>\n<p>Components that self-close communicate that they not only have no content, but are <strong>meant</strong> to have no content. It’s the difference between a blank page in a book and one labeled “This page intentionally left blank.” Your code is also cleaner without the unnecessary closing tag.</p>\n<p>Unfortunately, HTML doesn’t allow custom elements to be self-closing - only <a href=\"https://www.w3.org/TR/html/syntax.html#void-elements\" target=\"_blank\" rel=\"noopener\">official “void” elements</a>. That’s why the strategy is only possible when Vue’s template compiler can reach the template before the DOM, then serve the DOM spec-compliant HTML.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-13\"><a href=\"#Bad-13\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components, string templates, and JSX --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-13\"><a href=\"#Good-13\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components, string templates, and JSX --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Component-name-casing-in-templates-strongly-recommended\"><a href=\"#Component-name-casing-in-templates-strongly-recommended\" class=\"headerlink\" title=\"Component name casing in templates strongly recommended\"></a>Component name casing in templates <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>In most projects, component names should always be PascalCase in <a href=\"../guide/single-file-components.html\">single-file components</a> and string templates - but kebab-case in DOM templates.</strong></p>\n<p>PascalCase has a few advantages over kebab-case:</p>\n<ul>\n<li>Editors can autocomplete component names in templates, because PascalCase is also used in JavaScript.</li>\n<li><code>&lt;MyComponent&gt;</code> is more visually distinct from a single-word HTML element than <code>&lt;my-component&gt;</code>, because there are two character differences (the two capitals), rather than just one (a hyphen).</li>\n<li>If you use any non-Vue custom elements in your templates, such as a web component, PascalCase ensures that your Vue components remain distinctly visible.</li>\n</ul>\n<p>Unfortunately, due to HTML’s case insensitivity, DOM templates must still use kebab-case.</p>\n<p>Also note that if you’ve already invested heavily in kebab-case, consistency with HTML conventions and being able to use the same casing across all your projects may be more important than the advantages listed above. In those cases, <strong>using kebab-case everywhere is also acceptable.</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-14\"><a href=\"#Bad-14\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components and string templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mycomponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components and string templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">myComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">MyComponent</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-14\"><a href=\"#Good-14\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In single-file components and string templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>/&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In DOM templates --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>OR</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Everywhere --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Component-name-casing-in-JS-JSX-strongly-recommended\"><a href=\"#Component-name-casing-in-JS-JSX-strongly-recommended\" class=\"headerlink\" title=\"Component name casing in JS/JSX strongly recommended\"></a>Component name casing in JS/JSX <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component names in JS/<a href=\"../guide/render-function.html#JSX\">JSX</a> should always be PascalCase, though they may be kebab-case inside strings for simpler applications that only use global component registration through <code>Vue.component</code>.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>In JavaScript, PascalCase is the convention for classes and prototype constructors - essentially, anything that can have distinct instances. Vue components also have instances, so it makes sense to also use PascalCase. As an added benefit, using PascalCase within JSX (and templates) allows readers of the code to more easily distinguish between components and HTML elements.</p>\n<p>However, for applications that use <strong>only</strong> global component definitions via <code>Vue.component</code>, we recommend kebab-case instead. The reasons are:</p>\n<ul>\n<li>It’s rare that global components are ever referenced in JavaScript, so following a convention for JavaScript makes less sense.</li>\n<li>These applications always include many in-DOM templates, where <a href=\"#Component-name-casing-in-templates-strongly-recommended\">kebab-case <strong>must</strong> be used</a>.</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-15\"><a href=\"#Bad-15\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'myComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> myComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'myComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'my-component'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-15\"><a href=\"#Good-15\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'MyComponent'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> MyComponent <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./MyComponent.vue'</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'MyComponent'</span>,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n</div>\n<h3 id=\"Full-word-component-names-strongly-recommended\"><a href=\"#Full-word-component-names-strongly-recommended\" class=\"headerlink\" title=\"Full-word component names strongly recommended\"></a>Full-word component names <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component names should prefer full words over abbreviations.</strong></p>\n<p>The autocompletion in editors make the cost of writing longer names very low, while the clarity they provide is invaluable. Uncommon abbreviations, in particular, should always be avoided.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-16\"><a href=\"#Bad-16\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs undefined\">components/\n|- SdSettings.vue\n|- UProfOpts.vue</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-16\"><a href=\"#Good-16\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs undefined\">components/\n|- StudentDashboardSettings.vue\n|- UserProfileOptions.vue</code></pre>\n</div>\n<h3 id=\"Prop-name-casing-strongly-recommended\"><a href=\"#Prop-name-casing-strongly-recommended\" class=\"headerlink\" title=\"Prop name casing strongly recommended\"></a>Prop name casing <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Prop names should always use camelCase during declaration, but kebab-case in templates and <a href=\"../guide/render-function.html#JSX\">JSX</a>.</strong></p>\n<p>We’re simply following the conventions of each language. Within JavaScript, camelCase is more natural. Within HTML, kebab-case is.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-17\"><a href=\"#Bad-17\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-string\">'greeting-text'</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greetingText</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-17\"><a href=\"#Good-17\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">greetingText</span>: <span class=\"hljs-built_in\">String</span>\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">WelcomeMessage</span> <span class=\"hljs-attr\">greeting-text</span>=<span class=\"hljs-string\">\"hi\"</span>/&gt;</span></code></pre>\n</div>\n<h3 id=\"Multi-attribute-elements-strongly-recommended\"><a href=\"#Multi-attribute-elements-strongly-recommended\" class=\"headerlink\" title=\"Multi-attribute elements strongly recommended\"></a>Multi-attribute elements <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Elements with multiple attributes should span multiple lines, with one attribute per line.</strong></p>\n<p>In JavaScript, splitting objects with multiple properties over multiple lines is widely considered a good convention, because it’s much easier to read. Our templates and <a href=\"../guide/render-function.html#JSX\">JSX</a> deserve the same consideration.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-18\"><a href=\"#Bad-18\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span> <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span> <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>/&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-18\"><a href=\"#Good-18\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span>\n  <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"https://vuejs.org/images/logo.png\"</span>\n  <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">\"Vue Logo\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">MyComponent</span>\n  <span class=\"hljs-attr\">foo</span>=<span class=\"hljs-string\">\"a\"</span>\n  <span class=\"hljs-attr\">bar</span>=<span class=\"hljs-string\">\"b\"</span>\n  <span class=\"hljs-attr\">baz</span>=<span class=\"hljs-string\">\"c\"</span>\n/&gt;</span></code></pre>\n</div>\n<h3 id=\"Simple-expressions-in-templates-strongly-recommended\"><a href=\"#Simple-expressions-in-templates-strongly-recommended\" class=\"headerlink\" title=\"Simple expressions in templates strongly recommended\"></a>Simple expressions in templates <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Component templates should only include simple expressions, with more complex expressions refactored into computed properties or methods.</strong></p>\n<p>Complex expressions in your templates make them less declarative. We should strive to describe <em>what</em> should appear, not <em>how</em> we’re computing that value. Computed properties and methods also allow the code to be reused.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-19\"><a href=\"#Bad-19\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\">&#123;&#123;\n  fullName.split(' ').map(function (word) &#123;\n    return word[0].toUpperCase() + word.slice(1)\n  &#125;).join(' ')\n&#125;&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-19\"><a href=\"#Good-19\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- In a template --&gt;</span>\n&#123;&#123; normalizedFullName &#125;&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// The complex expression has been moved to a computed property</span>\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">normalizedFullName</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.fullName.split(<span class=\"hljs-string\">' '</span>).map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">word</span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> word[<span class=\"hljs-number\">0</span>].toUpperCase() + word.slice(<span class=\"hljs-number\">1</span>)\n    &#125;).join(<span class=\"hljs-string\">' '</span>)\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Simple-computed-properties-strongly-recommended\"><a href=\"#Simple-computed-properties-strongly-recommended\" class=\"headerlink\" title=\"Simple computed properties strongly recommended\"></a>Simple computed properties <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Complex computed properties should be split into as many simpler properties as possible.</strong></p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>Simpler, well-named computed properties are:</p>\n<ul>\n<li><p><strong>Easier to test</strong></p>\n<p>When each computed property contains only a very simple expression, with very few dependencies, it’s much easier to write tests confirming that it works correctly.</p>\n</li>\n<li><p><strong>Easier to read</strong></p>\n<p>Simplifying computed properties forces you to give each value a descriptive name, even if it’s not reused. This makes it much easier for other developers (and future you) to focus on the code they care about and figure out what’s going on.</p>\n</li>\n<li><p><strong>More adaptable to changing requirements</strong></p>\n<p>Any value that can be named might be useful to the view. For example, we might decide to display a message telling the user how much money they saved. We might also decide to calculate sales tax, but perhaps display it separately, rather than as part of the final price.</p>\n<p>Small, focused computed properties make fewer assumptions about how information will be used, so require less refactoring as requirements change.</p>\n</li>\n</ul>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-20\"><a href=\"#Bad-20\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">price</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> basePrice = <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n    <span class=\"hljs-keyword\">return</span> (\n      basePrice -\n      basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n    )\n  &#125;\n&#125;</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-20\"><a href=\"#Good-20\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">basePrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.manufactureCost / (<span class=\"hljs-number\">1</span> - <span class=\"hljs-keyword\">this</span>.profitMargin)\n  &#125;,\n  <span class=\"hljs-attr\">discount</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice * (<span class=\"hljs-keyword\">this</span>.discountPercent || <span class=\"hljs-number\">0</span>)\n  &#125;,\n  <span class=\"hljs-attr\">finalPrice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.basePrice - <span class=\"hljs-keyword\">this</span>.discount\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Quoted-attribute-values-strongly-recommended\"><a href=\"#Quoted-attribute-values-strongly-recommended\" class=\"headerlink\" title=\"Quoted attribute values strongly recommended\"></a>Quoted attribute values <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Non-empty HTML attribute values should always be inside quotes (single or double, whichever is not used in JS).</strong></p>\n<p>While attribute values without any spaces are not required to have quotes in HTML, this practice often leads to <em>avoiding</em> spaces, making attribute values less readable.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-21\"><a href=\"#Bad-21\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">text</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">&#123;width:sidebarWidth+</span>'<span class=\"hljs-attr\">px</span>'&#125;&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-21\"><a href=\"#Good-21\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">AppSidebar</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; width: sidebarWidth + 'px' &#125;\"</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Directive-shorthands-strongly-recommended\"><a href=\"#Directive-shorthands-strongly-recommended\" class=\"headerlink\" title=\"Directive shorthands strongly recommended\"></a>Directive shorthands <sup data-p=\"b\">strongly recommended</sup></h3><p><strong>Directive shorthands (<code>:</code> for <code>v-bind:</code>, <code>@</code> for <code>v-on:</code> and <code>#</code> for <code>v-slot</code>) should be used always or never.</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-22\"><a href=\"#Bad-22\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-22\"><a href=\"#Good-22\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-bind:value</span>=<span class=\"hljs-string\">\"newTodoText\"</span>\n  <span class=\"hljs-attr\">v-bind:placeholder</span>=<span class=\"hljs-string\">\"newTodoInstructions\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  @<span class=\"hljs-attr\">input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  @<span class=\"hljs-attr\">focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span>\n  <span class=\"hljs-attr\">v-on:input</span>=<span class=\"hljs-string\">\"onInput\"</span>\n  <span class=\"hljs-attr\">v-on:focus</span>=<span class=\"hljs-string\">\"onFocus\"</span>\n&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">header</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Here might be a page title<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> #<span class=\"hljs-attr\">footer</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some contact info<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"Priority-C-Rules-Recommended-Minimizing-Arbitrary-Choices-and-Cognitive-Overhead\"><a href=\"#Priority-C-Rules-Recommended-Minimizing-Arbitrary-Choices-and-Cognitive-Overhead\" class=\"headerlink\" title=\"Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)\"></a>Priority C Rules: Recommended (Minimizing Arbitrary Choices and Cognitive Overhead)</h2><h3 id=\"Component-instance-options-order-recommended\"><a href=\"#Component-instance-options-order-recommended\" class=\"headerlink\" title=\"Component/instance options order recommended\"></a>Component/instance options order <sup data-p=\"c\">recommended</sup></h3><p><strong>Component/instance options should be ordered consistently.</strong></p>\n<p>This is the default order we recommend for component options. They’re split into categories, so you’ll know where to add new properties from plugins.</p>\n<ol>\n<li><p><strong>Side Effects</strong> (triggers effects outside the component)</p>\n<ul>\n<li><code>el</code></li>\n</ul>\n</li>\n<li><p><strong>Global Awareness</strong> (requires knowledge beyond the component)</p>\n<ul>\n<li><code>name</code></li>\n<li><code>parent</code></li>\n</ul>\n</li>\n<li><p><strong>Component Type</strong> (changes the type of the component)</p>\n<ul>\n<li><code>functional</code></li>\n</ul>\n</li>\n<li><p><strong>Template Modifiers</strong> (changes the way templates are compiled)</p>\n<ul>\n<li><code>delimiters</code></li>\n<li><code>comments</code></li>\n</ul>\n</li>\n<li><p><strong>Template Dependencies</strong> (assets used in the template)</p>\n<ul>\n<li><code>components</code></li>\n<li><code>directives</code></li>\n<li><code>filters</code></li>\n</ul>\n</li>\n<li><p><strong>Composition</strong> (merges properties into the options)</p>\n<ul>\n<li><code>extends</code></li>\n<li><code>mixins</code></li>\n</ul>\n</li>\n<li><p><strong>Interface</strong> (the interface to the component)</p>\n<ul>\n<li><code>inheritAttrs</code></li>\n<li><code>model</code></li>\n<li><code>props</code>/<code>propsData</code></li>\n</ul>\n</li>\n<li><p><strong>Local State</strong> (local reactive properties)</p>\n<ul>\n<li><code>data</code></li>\n<li><code>computed</code></li>\n</ul>\n</li>\n<li><p><strong>Events</strong> (callbacks triggered by reactive events)</p>\n<ul>\n<li><code>watch</code></li>\n<li>Lifecycle Events (in the order they are called)<ul>\n<li><code>beforeCreate</code></li>\n<li><code>created</code></li>\n<li><code>beforeMount</code></li>\n<li><code>mounted</code></li>\n<li><code>beforeUpdate</code></li>\n<li><code>updated</code></li>\n<li><code>activated</code></li>\n<li><code>deactivated</code></li>\n<li><code>beforeDestroy</code></li>\n<li><code>destroyed</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Non-Reactive Properties</strong> (instance properties independent of the reactivity system)</p>\n<ul>\n<li><code>methods</code></li>\n</ul>\n</li>\n<li><p><strong>Rendering</strong> (the declarative description of the component output)</p>\n<ul>\n<li><code>template</code>/<code>render</code></li>\n<li><code>renderError</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Element-attribute-order-recommended\"><a href=\"#Element-attribute-order-recommended\" class=\"headerlink\" title=\"Element attribute order recommended\"></a>Element attribute order <sup data-p=\"c\">recommended</sup></h3><p><strong>The attributes of elements (including components) should be ordered consistently.</strong></p>\n<p>This is the default order we recommend for component options. They’re split into categories, so you’ll know where to add custom attributes and directives.</p>\n<ol>\n<li><p><strong>Definition</strong> (provides the component options)</p>\n<ul>\n<li><code>is</code></li>\n</ul>\n</li>\n<li><p><strong>List Rendering</strong> (creates multiple variations of the same element)</p>\n<ul>\n<li><code>v-for</code></li>\n</ul>\n</li>\n<li><p><strong>Conditionals</strong> (whether the element is rendered/shown)</p>\n<ul>\n<li><code>v-if</code></li>\n<li><code>v-else-if</code></li>\n<li><code>v-else</code></li>\n<li><code>v-show</code></li>\n<li><code>v-cloak</code></li>\n</ul>\n</li>\n<li><p><strong>Render Modifiers</strong> (changes the way the element renders)</p>\n<ul>\n<li><code>v-pre</code></li>\n<li><code>v-once</code></li>\n</ul>\n</li>\n<li><p><strong>Global Awareness</strong> (requires knowledge beyond the component)</p>\n<ul>\n<li><code>id</code></li>\n</ul>\n</li>\n<li><p><strong>Unique Attributes</strong> (attributes that require unique values)</p>\n<ul>\n<li><code>ref</code></li>\n<li><code>key</code></li>\n</ul>\n</li>\n<li><p><strong>Two-Way Binding</strong> (combining binding and events)</p>\n<ul>\n<li><code>v-model</code></li>\n</ul>\n</li>\n<li><p><strong>Other Attributes</strong> (all unspecified bound &amp; unbound attributes)</p>\n</li>\n<li><p><strong>Events</strong> (component event listeners)</p>\n<ul>\n<li><code>v-on</code></li>\n</ul>\n</li>\n<li><p><strong>Content</strong> (overrides the content of the element)</p>\n<ul>\n<li><code>v-html</code></li>\n<li><code>v-text</code></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"Empty-lines-in-component-instance-options-recommended\"><a href=\"#Empty-lines-in-component-instance-options-recommended\" class=\"headerlink\" title=\"Empty lines in component/instance options recommended\"></a>Empty lines in component/instance options <sup data-p=\"c\">recommended</sup></h3><p><strong>You may want to add one empty line between multi-line properties, particularly if the options can no longer fit on your screen without scrolling.</strong></p>\n<p>When components begin to feel cramped or difficult to read, adding spaces between multi-line properties can make them easier to skim again. In some editors, such as Vim, formatting options like this can also make them easier to navigate with the keyboard.</p>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-23\"><a href=\"#Good-23\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">props: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// No spaces are also fine, as long as the component</span>\n<span class=\"hljs-comment\">// is still easy to read and navigate.</span>\n<span class=\"hljs-attr\">props</span>: &#123;\n  <span class=\"hljs-attr\">value</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n  &#125;,\n  <span class=\"hljs-attr\">focused</span>: &#123;\n    <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Boolean</span>,\n    <span class=\"hljs-attr\">default</span>: <span class=\"hljs-literal\">false</span>\n  &#125;,\n  <span class=\"hljs-attr\">label</span>: <span class=\"hljs-built_in\">String</span>,\n  <span class=\"hljs-attr\">icon</span>: <span class=\"hljs-built_in\">String</span>\n&#125;,\n<span class=\"hljs-attr\">computed</span>: &#123;\n  <span class=\"hljs-attr\">formattedValue</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;,\n  <span class=\"hljs-attr\">inputClasses</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// ...</span>\n  &#125;\n&#125;</code></pre>\n</div>\n<h3 id=\"Single-file-component-top-level-element-order-recommended\"><a href=\"#Single-file-component-top-level-element-order-recommended\" class=\"headerlink\" title=\"Single-file component top-level element order recommended\"></a>Single-file component top-level element order <sup data-p=\"c\">recommended</sup></h3><p><strong><a href=\"../guide/single-file-components.html\">Single-file components</a> should always order <code>&lt;script&gt;</code>, <code>&lt;template&gt;</code>, and <code>&lt;style&gt;</code> tags consistently, with <code>&lt;style&gt;</code> last, because at least one of the other two is always necessary.</strong></p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-23\"><a href=\"#Bad-23\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-24\"><a href=\"#Good-24\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- ComponentA.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- ComponentB.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\"><span class=\"hljs-comment\">/* ... */</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h2 id=\"Priority-D-Rules-Use-with-Caution-Potentially-Dangerous-Patterns\"><a href=\"#Priority-D-Rules-Use-with-Caution-Potentially-Dangerous-Patterns\" class=\"headerlink\" title=\"Priority D Rules: Use with Caution (Potentially Dangerous Patterns)\"></a>Priority D Rules: Use with Caution (Potentially Dangerous Patterns)</h2><h3 id=\"v-if-v-else-if-v-else-without-key-use-with-caution\"><a href=\"#v-if-v-else-if-v-else-without-key-use-with-caution\" class=\"headerlink\" title=\"v-if/v-else-if/v-else without key use with caution\"></a><code>v-if</code>/<code>v-else-if</code>/<code>v-else</code> without <code>key</code> <sup data-p=\"d\">use with caution</sup></h3><p><strong>It’s usually best to use <code>key</code> with <code>v-if</code> + <code>v-else</code>, if they are the same element type (e.g. both <code>&lt;div&gt;</code> elements).</strong></p>\n<p>By default, Vue updates the DOM as efficiently as possible. That means when switching between elements of the same type, it simply patches the existing element, rather than removing it and adding a new one in its place. This can have <a href=\"https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-priority-d-rules-unintended-consequences\" target=\"_blank\" rel=\"noopener\">unintended consequences</a> if these elements should not actually be considered the same.</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-24\"><a href=\"#Bad-24\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>&gt;</span>\n  Error: &#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-25\"><a href=\"#Good-25\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"error\"</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-status\"</span>\n&gt;</span>\n  Error: &#123;&#123; error &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>\n  <span class=\"hljs-attr\">v-else</span>\n  <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">\"search-results\"</span>\n&gt;</span>\n  &#123;&#123; results &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Element-selectors-with-scoped-use-with-caution\"><a href=\"#Element-selectors-with-scoped-use-with-caution\" class=\"headerlink\" title=\"Element selectors with scoped use with caution\"></a>Element selectors with <code>scoped</code> <sup data-p=\"d\">use with caution</sup></h3><p><strong>Element selectors should be avoided with <code>scoped</code>.</strong></p>\n<p>Prefer class selectors over element selectors in <code>scoped</code> styles, because large numbers of element selectors are slow.</p>\n\n<details>\n<summary>\n  <h4>Detailed Explanation</h4>\n</summary>\n\n<p>To scope styles, Vue adds a unique attribute to component elements, such as <code>data-v-f3f3eg9</code>. Then selectors are modified so that only matching elements with this attribute are selected (e.g. <code>button[data-v-f3f3eg9]</code>).</p>\n<p>The problem is that large numbers of <a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=a%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">element-attribute selectors</a> (e.g. <code>button[data-v-f3f3eg9]</code>) will be considerably slower than <a href=\"http://stevesouders.com/efws/css-selectors/csscreate.php?n=1000&amp;sel=.class%5Bhref%5D&amp;body=background%3A+%23CFD&amp;ne=1000\" target=\"_blank\" rel=\"noopener\">class-attribute selectors</a> (e.g. <code>.btn-close[data-v-f3f3eg9]</code>), so class selectors should be preferred whenever possible.</p>\n</details>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-25\"><a href=\"#Bad-25\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-tag\">button</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-26\"><a href=\"#Good-26\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"btn btn-close\"</span>&gt;</span>X<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.btn-close</span> &#123;\n  <span class=\"hljs-attribute\">background-color</span>: red;\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span></code></pre>\n</div>\n<h3 id=\"Implicit-parent-child-communication-use-with-caution\"><a href=\"#Implicit-parent-child-communication-use-with-caution\" class=\"headerlink\" title=\"Implicit parent-child communication use with caution\"></a>Implicit parent-child communication <sup data-p=\"d\">use with caution</sup></h3><p><strong>Props and events should be preferred for parent-child component communication, instead of <code>this.$parent</code> or mutating props.</strong></p>\n<p>An ideal Vue application is props down, events up. Sticking to this convention makes your components much easier to understand. However, there are edge cases where prop mutation or <code>this.$parent</code> can simplify two components that are already deeply coupled.</p>\n<p>The problem is, there are also many <em>simple</em> cases where these patterns may offer convenience. Beware: do not be seduced into trading simplicity (being able to understand the flow of your state) for short-term convenience (writing less code).</p>\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-26\"><a href=\"#Bad-26\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;input v-model=\"todo.text\"&gt;'</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    removeTodo () &#123;\n      <span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">this</span>\n      vm.$parent.todos = vm.$parent.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== vm.todo.id\n      &#125;)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"removeTodo\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-27\"><a href=\"#Good-27\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;input\n      :value=\"todo.text\"\n      @input=\"$emit('input', $event.target.value)\"\n    &gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'TodoItem'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;span&gt;\n      &#123;&#123; todo.text &#125;&#125;\n      &lt;button @click=\"$emit('delete')\"&gt;\n        X\n      &lt;/button&gt;\n    &lt;/span&gt;\n  `</span>\n&#125;)</code></pre>\n</div>\n<h3 id=\"Non-flux-state-management-use-with-caution\"><a href=\"#Non-flux-state-management-use-with-caution\" class=\"headerlink\" title=\"Non-flux state management use with caution\"></a>Non-flux state management <sup data-p=\"d\">use with caution</sup></h3><p><strong><a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a> should be preferred for global state management, instead of <code>this.$root</code> or a global event bus.</strong></p>\n<p>Managing state on <code>this.$root</code> and/or using a <a href=\"https://vuejs.org/v2/guide/migration.html#dispatch-and-broadcast-replaced\">global event bus</a> can be convenient for very simple cases, but it is not appropriate for most applications.</p>\n<p>Vuex is the <a href=\"https://vuejs.org/v2/guide/state-management.html#Official-Flux-Like-Implementation\">official flux-like implementation</a> for Vue, and offers not only a central place to manage state, but also tools for organizing, tracking, and debugging state changes. It integrates well in the Vue ecosystem (including full <a href=\"https://vuejs.org/v2/guide/installation.html#Vue-Devtools\">Vue DevTools</a> support).</p>\n\n<div class=\"style-example example-bad\">\n<h4 id=\"Bad-27\"><a href=\"#Bad-27\" class=\"headerlink\" title=\"Bad\"></a>Bad</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// main.js</span>\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">todos</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">this</span>.$on(<span class=\"hljs-string\">'remove-todo'</span>, <span class=\"hljs-keyword\">this</span>.removeTodo)\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">removeTodo</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> todoIdToRemove = todo.id\n      <span class=\"hljs-keyword\">this</span>.todos = <span class=\"hljs-keyword\">this</span>.todos.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">todo</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> todo.id !== todoIdToRemove\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</div>\n<div class=\"style-example example-good\">\n<h4 id=\"Good-28\"><a href=\"#Good-28\" class=\"headerlink\" title=\"Good\"></a>Good</h4><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// store/modules/todos.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">state</span>: &#123;\n    <span class=\"hljs-attr\">list</span>: []\n  &#125;,\n  <span class=\"hljs-attr\">mutations</span>: &#123;\n    REMOVE_TODO (state, todoId) &#123;\n      state.list = state.list.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">todo</span> =&gt;</span> todo.id !== todoId)\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">actions</span>: &#123;\n    removeTodo (&#123; commit, state &#125;, todo) &#123;\n      commit(<span class=\"hljs-string\">'REMOVE_TODO'</span>, todo.id)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- TodoItem.vue --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>\n    &#123;&#123; todo.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"removeTodo(todo)\"</span>&gt;</span>\n      X\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> &#123; mapActions &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'vuex'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">todo</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Object</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: mapActions([<span class=\"hljs-string\">'removeTodo'</span>])\n&#125;\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n</div>\n\n<script>\n(function () {\n  var enforcementTypes = {\n    none: '<span title=\"There is unfortunately no way to automatically enforce this rule.\">self-discipline</span>',\n    runtime: 'runtime error',\n    linter: '<a href=\"https://github.com/vuejs/eslint-plugin-vue#eslint-plugin-vue\" target=\"_blank\" rel=\"noopener noreferrer\">plugin:vue/recommended</a>'\n  }\n  Vue.component('sg-enforcement', {\n    template: '\\\n      <span>\\\n        <strong>Enforcement</strong>:\\\n        <span class=\"style-rule-tag\" v-html=\"humanType\"/>\\\n      </span>\\\n    ',\n    props: {\n      type: {\n        type: String,\n        required: true,\n        validate: function (value) {\n          Object.keys(enforcementTypes).indexOf(value) !== -1\n        }\n      }\n    },\n    computed: {\n      humanType: function () {\n        return enforcementTypes[this.type]\n      }\n    }\n  })\n\n  // new Vue({\n  //  el: '#main'\n  // })\n})()\n</script>\n\n"},{"title":"API","type":"api","_content":"\n## Global Config\n\n`Vue.config` is an object containing Vue's global configurations. You can modify its properties listed below before bootstrapping your application:\n\n### silent\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  Suppress all Vue logs and warnings.\n\n### optionMergeStrategies\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  Define custom merging strategies for options.\n\n  The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.\n\n- **See also:** [Custom Option Merging Strategies](../guide/mixins.html#Custom-Option-Merge-Strategies)\n\n### devtools\n\n- **Type:** `boolean`\n\n- **Default:** `true` (`false` in production builds)\n\n- **Usage:**\n\n  ``` js\n  // make sure to set this synchronously immediately after loading Vue\n  Vue.config.devtools = true\n  ```\n\n  Configure whether to allow [vue-devtools](https://github.com/vuejs/vue-devtools) inspection. This option's default value is `true` in development builds and `false` in production builds. You can set it to `true` to enable inspection for production builds.\n\n### errorHandler\n\n- **Type:** `Function`\n\n- **Default:** `undefined`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm, info) {\n    // handle error\n    // `info` is a Vue-specific error info, e.g. which lifecycle hook\n    // the error was found in. Only available in 2.2.0+\n  }\n  ```\n\n  Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the Vue instance.\n\n  > In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is `undefined`, captured errors will be logged with `console.error` instead of crashing the app.\n\n  > In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.\n\n  > In 2.6.0+, this hook also captures errors thrown inside `v-on` DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.\n\n  > Error tracking services [Sentry](https://sentry.io/for/vue/) and [Bugsnag](https://docs.bugsnag.com/platforms/browsers/vue/) provide official integrations using this option.\n\n### warnHandler\n\n> New in 2.4.0+\n\n- **Type:** `Function`\n\n- **Default:** `undefined`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.warnHandler = function (msg, vm, trace) {\n    // `trace` is the component hierarchy trace\n  }\n  ```\n\n  Assign a custom handler for runtime Vue warnings. Note this only works during development and is ignored in production.\n\n### ignoredElements\n\n- **Type:** `Array<string | RegExp>`\n\n- **Default:** `[]`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component',\n    'another-web-component',\n    // Use a `RegExp` to ignore all elements that start with \"ion-\"\n    // 2.5+ only\n    /^ion-/\n  ]\n  ```\n\n  Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an `Unknown custom element`, assuming that you forgot to register a global component or misspelled a component name.\n\n### keyCodes\n\n- **Type:** `{ [key: string]: number | Array<number> }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    // camelCase won`t work\n    mediaPlayPause: 179,\n    // instead you can use kebab-case with double quotation marks\n    \"media-play-pause\": 179,\n    up: [38, 87]\n  }\n  ```\n\n  ```html\n  <input type=\"text\" @keyup.media-play-pause=\"method\">\n  ```\n\n  Define custom key alias(es) for `v-on`.\n\n### performance\n\n> New in 2.2.0+\n\n- **Type:** `boolean`\n\n- **Default:** `false (from 2.2.3+)`\n\n- **Usage**:\n\n  Set this to `true` to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the [performance.mark](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API.\n\n### productionTip\n\n> New in 2.2.0+\n\n- **Type:** `boolean`\n\n- **Default:** `true`\n\n- **Usage**:\n\n  Set this to `false` to prevent the production tip on Vue startup.\n\n## Global API\n\n### Vue.extend( options )\n\n- **Arguments:**\n  - `{Object} options`\n\n- **Usage:**\n\n  Create a \"subclass\" of the base Vue constructor. The argument should be an object containing component options.\n\n  The special case to note here is the `data` option - it must be a function when used with `Vue.extend()`.\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // create constructor\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // create an instance of Profile and mount it on an element\n  new Profile().$mount('#mount-point')\n  ```\n\n  Will result in:\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n### Vue.nextTick( [callback, context] )\n\n- **Arguments:**\n  - `{Function} [callback]`\n  - `{Object} [context]`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update.\n\n  ``` js\n  // modify data\n  vm.msg = 'Hello'\n  // DOM not updated yet\n  Vue.nextTick(function () {\n    // DOM updated\n  })\n\n  // usage as a promise (2.1.0+, see note below)\n  Vue.nextTick()\n    .then(function () {\n      // DOM updated\n    })\n  ```\n\n  > New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don't support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.\n\n- **See also:** [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n### Vue.set( target, propertyName/index, value )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates. This must be used to add new properties to reactive objects, as Vue cannot detect normal property additions (e.g. `this.myObject.newProperty = 'hi'`).\n\n  <p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### Vue.delete( target, propertyName/index )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n  > Only in 2.2.0+: Also works with Array + index.\n\n- **Usage:**\n\n  Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.\n\n  <p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### Vue.directive( id, [definition] )\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global directive.\n\n  ``` js\n  // register\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // register (function directive)\n  Vue.directive('my-directive', function () {\n    // this will be called as `bind` and `update`\n  })\n\n  // getter, return the directive definition if registered\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **See also:** [Custom Directives](../guide/custom-directive.html)\n\n### Vue.filter( id, [definition] )\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global filter.\n\n  ``` js\n  // register\n  Vue.filter('my-filter', function (value) {\n    // return processed value\n  })\n\n  // getter, return the filter if registered\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n- **See also:** [Filters](../guide/filters.html)\n\n### Vue.component( id, [definition] )\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global component. Registration also automatically sets the component's `name` with the given `id`.\n\n  ``` js\n  // register an extended constructor\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // register an options object (automatically call Vue.extend)\n  Vue.component('my-component', { /* ... */ })\n\n  // retrieve a registered component (always return constructor)\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n### Vue.use( plugin )\n\n- **Arguments:**\n  - `{Object | Function} plugin`\n\n- **Usage:**\n\n  Install a Vue.js plugin. If the plugin is an Object, it must expose an `install` method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.\n\n  This method has to be called before calling `new Vue()`\n\n  When this method is called on the same plugin multiple times, the plugin will be installed only once.\n\n- **See also:** [Plugins](../guide/plugins.html)\n\n### Vue.mixin( mixin )\n\n- **Arguments:**\n  - `{Object} mixin`\n\n- **Usage:**\n\n  Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. **Not recommended in application code**.\n\n- **See also:** [Global Mixin](../guide/mixins.html#Global-Mixin)\n\n### Vue.compile( template )\n\n- **Arguments:**\n  - `{string} template`\n\n- **Usage:**\n\n  Compiles a template string into a render function. **Only available in the full build.**\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **See also:** [Render Functions](../guide/render-function.html)\n\n### Vue.observable( object )\n\n> New in 2.6.0+\n\n- **Arguments:**\n  - `{Object} object`\n\n- **Usage:**\n\n  Make an object reactive. Internally, Vue uses this on the object returned by the `data` function.\n\n  The returned object can be used directly inside [render functions](../guide/render-function.html) and [computed properties](../guide/computed.html), and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:\n\n  ``` js\n  const state = Vue.observable({ count: 0 })\n\n  const Demo = {\n    render(h) {\n      return h('button', {\n        on: { click: () => { state.count++ }}\n      }, `count is: ${state.count}`)\n    }\n  }\n  ```\n\n  <p class=\"tip\">In Vue 2.x, `Vue.observable` directly mutates the object passed to it, so that it is equivalent to the object returned, as [demonstrated here](../guide/instance.html#Data-and-Methods). In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by `Vue.observable`, rather than the object originally passed to it.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### Vue.version\n\n- **Details**: Provides the installed version of Vue as a string. This is especially useful for community plugins and components, where you might use different strategies for different versions.\n\n- **Usage**:\n\n  ```js\n  var version = Number(Vue.version.split('.')[0])\n\n  if (version === 2) {\n    // Vue v2.x.x\n  } else if (version === 1) {\n    // Vue v1.x.x\n  } else {\n    // Unsupported versions of Vue\n  }\n  ```\n\n## Options / Data\n\n### data\n\n- **Type:** `Object | Function`\n\n- **Restriction:** Only accepts `Function` when used in a component definition.\n\n- **Details:**\n\n  The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it \"reactive\". **The object must be plain**: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.\n\n  Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.\n\n  After the instance is created, the original data object can be accessed as `vm.$data`. The Vue instance also proxies all the properties found on the data object, so `vm.a` will be equivalent to `vm.$data.a`.\n\n  Properties that start with `_` or `$` will **not** be proxied on the Vue instance because they may conflict with Vue's internal properties and API methods. You will have to access them as `vm.$data._property`.\n\n  When defining a **component**, `data` must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for `data`, that same object will be **shared by reference** across all instances created! By providing a `data` function, every time a new instance is created we can call it to return a fresh copy of the initial data.\n\n  If required, a deep clone of the original object can be obtained by passing `vm.$data` through `JSON.parse(JSON.stringify(...))`.\n\n- **Example:**\n\n  ``` js\n  var data = { a: 1 }\n\n  // direct instance creation\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // => 1\n  vm.$data === data // => true\n\n  // must use function when in Vue.extend()\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  Note that if you use an arrow function with the `data` property, `this` won't be the component's instance, but you can still access the instance as the function's first argument:\n\n  ```js\n  data: vm => ({ a: vm.myProp })\n  ```\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### props\n\n- **Type:** `Array<string> | Object`\n\n- **Details:**\n\n  A list/hash of attributes that are exposed to accept data from the parent component. It has an Array-based simple syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.\n\n  With Object-based syntax, you can use following options:\n    - `type`: can be one of the following native constructors: `String`, `Number`, `Boolean`, `Array`, `Object`, `Date`, `Function`, `Symbol`, any custom constructor function or an array of those. Will check if a prop has a given type, and will throw a warning if it doesn't. [More information](../guide/components-props.html#Prop-Types) on prop types.\n    - `default`: `any`\n    Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.\n    - `required`: `Boolean`\n    Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.\n    - `validator`: `Function`\n    Custom validator function that takes the prop value as the sole argument. In a non-production environment, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails). You can read more about prop validation [here](../guide/components-props.html#Prop-Validation).\n\n- **Example:**\n\n  ``` js\n  // simple syntax\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // object syntax with validation\n  Vue.component('props-demo-advanced', {\n    props: {\n      // type check\n      height: Number,\n      // type check plus other validations\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **See also:** [Props](../guide/components-props.html)\n\n### propsData\n\n- **Type:** `{ [key: string]: any }`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Pass props to an instance during its creation. This is primarily intended to make unit testing easier.\n\n- **Example:**\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n\n### computed\n\n- **Type:** `{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **Details:**\n\n  Computed properties to be mixed into the Vue instance. All getters and setters have their `this` context automatically bound to the Vue instance.\n\n  Note that if you use an arrow function with a computed property, `this` won't be the component's instance, but you can still access the instance as the function's first argument:\n\n  ```js\n  computed: {\n    aDouble: vm => vm.a * 2\n  }\n  ```\n\n  Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance's scope (i.e. not reactive), the computed property will __not__ be updated.\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // get only\n      aDouble: function () {\n        return this.a * 2\n      },\n      // both get and set\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // => 2\n  vm.aPlus = 3\n  vm.a       // => 2\n  vm.aDouble // => 4\n  ```\n\n- **See also:** [Computed Properties](../guide/computed.html)\n\n### methods\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Details:**\n\n  Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their `this` context automatically bound to the Vue instance.\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a method__ (e.g. `plus: () => this.a++`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.a` will be undefined.</p>\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **See also:** [Event Handling](../guide/events.html)\n\n### watch\n\n- **Type:** `{ [key: string]: string | Function | Object | Array}`\n\n- **Details:**\n\n  An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call `$watch()` for each entry in the object at instantiation.\n\n- **Example:**\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: {\n        f: {\n          g: 5\n        }\n      }\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // string method name\n      b: 'someMethod',\n      // the callback will be called whenever any of the watched object properties change regardless of their nested depth\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      },\n      // the callback will be called immediately after the start of the observation\n      d: {\n        handler: 'someMethod',\n        immediate: true\n      },\n      // you can pass array of callbacks, they will be called one-by-one\n      e: [\n        'handle1',\n        function handle2 (val, oldVal) { /* ... */ },\n        {\n          handler: function handle3 (val, oldVal) { /* ... */ },\n          /* ... */\n        }\n      ],\n      // watch vm.e.f's value: {g: 5}\n      'e.f': function (val, oldVal) { /* ... */ }\n    }\n  })\n  vm.a = 2 // => new: 2, old: 1\n  ```\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a watcher__ (e.g. `searchQuery: newValue => this.updateAutocomplete(newValue)`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.updateAutocomplete` will be undefined.</p>\n\n- **See also:** [Instance Methods / Data - vm.$watch](#vm-watch)\n\n## Options / DOM\n\n### el\n\n- **Type:** `string | Element`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.\n\n  After the instance is mounted, the resolved element will be accessible as `vm.$el`.\n\n  If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call `vm.$mount()` to manually start the compilation.\n\n  <p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to `<html>` or `<body>`.</p>\n\n  <p class=\"tip\">If neither `render` function nor `template` option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</p>\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Runtime + Compiler vs. Runtime-only](../guide/installation.html#Runtime-Compiler-vs-Runtime-only)\n\n### template\n\n- **Type:** `string`\n\n- **Details:**\n\n  A string template to be used as the markup for the Vue instance. The template will **replace** the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.\n\n  If the string starts with `#` it will be used as a querySelector and use the selected element's innerHTML as the template string. This allows the use of the common `<script type=\"x-template\">` trick to include templates.\n\n  <p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n\n  <p class=\"tip\">If render function is present in the Vue option, the template will be ignored.</p>\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n\n### render\n\n  - **Type:** `(createElement: () => VNode) => VNode`\n\n  - **Details:**\n\n    An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a `createElement` method as it's first argument used to create `VNode`s.\n\n    If the component is a functional component, the render function also receives an extra argument `context`, which provides access to contextual data since functional components are instance-less.\n\n    <p class=\"tip\">The `render` function has priority over the render function compiled from `template` option or in-DOM HTML template of the mounting element which is specified by the `el` option.</p>\n\n  - **See also:** [Render Functions](../guide/render-function.html)\n\n### renderError\n\n> New in 2.2.0+\n\n  - **Type:** `(createElement: () => VNode, error: Error) => VNode`\n\n  - **Details:**\n\n    **Only works in development mode.**\n\n    Provide an alternative render output when the default `render` function encounters an error. The error will be passed to `renderError` as the second argument. This is particularly useful when used together with hot-reload.\n\n  - **Example:**\n\n    ``` js\n    new Vue({\n      render (h) {\n        throw new Error('oops')\n      },\n      renderError (h, err) {\n        return h('pre', { style: { color: 'red' }}, err.stack)\n      }\n    }).$mount('#app')\n    ```\n\n  - **See also:** [Render Functions](../guide/render-function.html)\n\n## Options / Lifecycle Hooks\n\n<p class=\"tip\">All lifecycle hooks automatically have their `this` context bound to the instance, so that you can access data, computed properties, and methods. This means __you should not use an arrow function to define a lifecycle method__ (e.g. `created: () => this.fetchTodos()`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.fetchTodos` will be undefined.</p>\n\n### beforeCreate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously immediately after the instance has been initialized, before data observation and event/watcher setup.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### created\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the `$el` property will not be available yet.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeMount\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before the mounting begins: the `render` function is about to be called for the first time.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### mounted\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after the instance has been mounted, where `el` is replaced by the newly created `vm.$el`. If the root instance is mounted to an in-document element, `vm.$el` will also be in-document when `mounted` is called.\n\n  Note that `mounted` does **not** guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use [vm.$nextTick](#vm-nextTick) inside of `mounted`:\n\n  ``` js\n  mounted: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been rendered\n    })\n  }\n  ```\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeUpdate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when data changes, before the DOM is patched. This is a good place to access the existing DOM before an update, e.g. to remove manually added event listeners.\n\n  **This hook is not called during server-side rendering, because only the initial render is performed server-side.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### updated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a data change causes the virtual DOM to be re-rendered and patched.\n\n  The component's DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it's usually better to use a [computed property](#computed) or [watcher](#watch) instead.\n\n  Note that `updated` does **not** guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use [vm.$nextTick](#vm-nextTick) inside of `updated`:\n\n  ``` js\n  updated: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been re-rendered\n    })\n  }\n  ```\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### activated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is activated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### deactivated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is deactivated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### beforeDestroy\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### destroyed\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### errorCaptured\n\n> New in 2.5.0+\n\n- **Type:** `(err: Error, vm: Component, info: string) => ?boolean`\n\n- **Details:**\n\n  Called when an error from any descendent component is captured. The hook receives three arguments: the error, the component instance that triggered the error, and a string containing information on where the error was captured. The hook can return `false` to stop the error from propagating further.\n\n  <p class=\"tip\">You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</p>\n\n  **Error Propagation Rules**\n\n  - By default, all errors are still sent to the global `config.errorHandler` if it is defined, so that these errors can still be reported to an analytics service in a single place.\n\n  - If multiple `errorCaptured` hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error.\n\n  - If the `errorCaptured` hook itself throws an error, both this error and the original captured error are sent to the global `config.errorHandler`.\n\n  - An `errorCaptured` hook can return `false` to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional `errorCaptured` hooks or the global `config.errorHandler` from being invoked for this error.\n\n## Options / Assets\n\n### directives\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of directives to be made available to the Vue instance.\n\n- **See also:** [Custom Directives](../guide/custom-directive.html)\n\n### filters\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of filters to be made available to the Vue instance.\n\n- **See also:** [`Vue.filter`](#Vue-filter)\n\n### components\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of components to be made available to the Vue instance.\n\n- **See also:** [Components](../guide/components.html)\n\n## Options / Composition\n\n### parent\n\n- **Type:** `Vue instance`\n\n- **Details:**\n\n  Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as `this.$parent` for the child, and the child will be pushed into the parent's `$children` array.\n\n  <p class=\"tip\">Use `$parent` and `$children` sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n### mixins\n\n- **Type:** `Array<Object>`\n\n- **Details:**\n\n  The `mixins` option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in `Vue.extend()`. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.\n\n  Mixin hooks are called in the order they are provided, and called before the component's own hooks.\n\n- **Example:**\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // => 1\n  // => 2\n  ```\n\n- **See also:** [Mixins](../guide/mixins.html)\n\n### extends\n\n- **Type:** `Object | Function`\n\n- **Details:**\n\n  Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use `Vue.extend`. This is primarily intended to make it easier to extend between single file components.\n\n  This is similar to `mixins`.\n\n- **Example:**\n\n  ``` js\n  var CompA = { ... }\n\n  // extend CompA without having to call `Vue.extend` on either\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### provide / inject\n\n> New in 2.2.0+\n\n- **Type:**\n  - **provide:** `Object | () => Object`\n  - **inject:** `Array<string> | { [key: string]: string | Symbol | Object }`\n\n- **Details:**\n\n  <p class=\"tip\">`provide` and `inject` are primarily provided for advanced plugin / component library use cases. It is NOT recommended to use them in generic application code.</p>\n\n  This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React's context feature.\n\n  The `provide` option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support `Symbol` and `Reflect.ownKeys`.\n\n  The `inject` option should be either:\n  - an array of strings, or\n  - an object where the keys are the local binding name and the value is either:\n    - the key (string or Symbol) to search for in available injections, or\n    - an object where:\n      - the `from` property is the key (string or Symbol) to search for in available injections, and\n      - the `default` property is used as fallback value\n\n  > Note: the `provide` and `inject` bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.\n\n- **Example:**\n\n  ``` js\n  // parent component providing 'foo'\n  var Provider = {\n    provide: {\n      foo: 'bar'\n    },\n    // ...\n  }\n\n  // child component injecting 'foo'\n  var Child = {\n    inject: ['foo'],\n    created () {\n      console.log(this.foo) // => \"bar\"\n    }\n    // ...\n  }\n  ```\n\n  With ES2015 Symbols, function `provide` and object `inject`:\n  ``` js\n  const s = Symbol()\n\n  const Provider = {\n    provide () {\n      return {\n        [s]: 'foo'\n      }\n    }\n  }\n\n  const Child = {\n    inject: { s },\n    // ...\n  }\n  ```\n\n  > The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the `props` and the `data` initialization.\n\n  Using an injected value as the default for a prop:\n  ```js\n  const Child = {\n    inject: ['foo'],\n    props: {\n      bar: {\n        default () {\n          return this.foo\n        }\n      }\n    }\n  }\n  ```\n\n  Using an injected value as data entry:\n  ```js\n  const Child = {\n    inject: ['foo'],\n    data () {\n      return {\n        bar: this.foo\n      }\n    }\n  }\n  ```\n\n  > In 2.5.0+ injections can be optional with default value:\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: { default: 'foo' }\n    }\n  }\n  ```\n\n  If it needs to be injected from a property with a different name, use `from` to denote the source property:\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: 'foo'\n      }\n    }\n  }\n  ```\n\n  Similar to prop defaults, you need to use a factory function for non primitive values:\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: () => [1, 2, 3]\n      }\n    }\n  }\n  ```\n\n## Options / Misc\n\n### name\n\n- **Type:** `string`\n\n- **Restriction:** only respected when used as a component option.\n\n- **Details:**\n\n  Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with `Vue.component()`, the global ID is automatically set as its name.\n\n  Another benefit of specifying a `name` option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the [vue-devtools](https://github.com/vuejs/vue-devtools), unnamed components will show up as `<AnonymousComponent>`, which isn't very informative. By providing the `name` option, you will get a much more informative component tree.\n\n### delimiters\n\n- **Type:** `Array<string>`\n\n- **Default:** `{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **Restrictions:** This option is only available in the full build, with in-browser compilation.\n\n- **Details:**\n\n  Change the plain text interpolation delimiters.\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // Delimiters changed to ES6 template string style\n  ```\n\n### functional\n\n- **Type:** `boolean`\n\n- **Details:**\n\n  Causes a component to be stateless (no `data`) and instanceless (no `this` context). They are only a `render` function that returns virtual nodes making them much cheaper to render.\n\n- **See also:** [Functional Components](../guide/render-function.html#Functional-Components)\n\n### model\n\n> New in 2.2.0\n\n- **Type:** `{ prop?: string, event?: string }`\n\n- **Details:**\n\n  Allows a custom component to customize the prop and event used when it's used with `v-model`. By default, `v-model` on a component uses `value` as the prop and `input` as the event, but some input types such as checkboxes and radio buttons may want to use the `value` prop for a different purpose. Using the `model` option can avoid the conflict in such cases.\n\n- **Example:**\n\n  ``` js\n  Vue.component('my-checkbox', {\n    model: {\n      prop: 'checked',\n      event: 'change'\n    },\n    props: {\n      // this allows using the `value` prop for a different purpose\n      value: String,\n      // use `checked` as the prop which take the place of `value`\n      checked: {\n        type: Number,\n        default: 0\n      }\n    },\n    // ...\n  })\n  ```\n\n  ``` html\n  <my-checkbox v-model=\"foo\" value=\"some value\"></my-checkbox>\n  ```\n\n  The above will be equivalent to:\n\n  ``` html\n  <my-checkbox\n    :checked=\"foo\"\n    @change=\"val => { foo = val }\"\n    value=\"some value\">\n  </my-checkbox>\n  ```\n\n### inheritAttrs\n\n> New in 2.4.0+\n\n- **Type:** `boolean`\n\n- **Default:** `true`\n\n- **Details:**\n\n  By default, parent scope attribute bindings that are not recognized as props will \"fallthrough\" and be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting `inheritAttrs` to `false`, this default behavior can be disabled. The attributes are available via the `$attrs` instance property (also new in 2.4) and can be explicitly bound to a non-root element using `v-bind`.\n\n  Note: this option does **not** affect `class` and `style` bindings.\n\n### comments\n\n> New in 2.4.0+\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Restrictions:** This option is only available in the full build, with in-browser compilation.\n\n- **Details:**\n\n  When set to `true`, will preserve and render HTML comments found in templates. The default behavior is discarding them.\n\n## Instance Properties\n\n### vm.$data\n\n- **Type:** `Object`\n\n- **Details:**\n\n  The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.\n\n- **See also:** [Options / Data - data](#data)\n\n### vm.$props\n\n> New in 2.2.0+\n\n- **Type:** `Object`\n\n- **Details:**\n\n  An object representing the current props a component has received. The Vue instance proxies access to the properties on its props object.\n\n### vm.$el\n\n- **Type:** `Element`\n\n- **Read only**\n\n- **Details:**\n\n  The root DOM element that the Vue instance is managing.\n\n### vm.$options\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // => 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The parent instance, if the current instance has one.\n\n### vm.$root\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.\n\n### vm.$children\n\n- **Type:** `Array<Vue instance>`\n\n- **Read only**\n\n- **Details:**\n\n  The direct child components of the current instance. **Note there's no order guarantee for `$children`, and it is not reactive.** If you find yourself trying to use `$children` for data binding, consider using an Array and `v-for` to generate child components, and use the Array as the source of truth.\n\n### vm.$slots\n\n- **Type:** `{ [name: string]: ?Array<VNode> }`\n\n- **Read only**\n\n- **Reactive?** No\n\n- **Details:**\n\n  Used to programmatically access content [distributed by slots](../guide/components.html#Content-Distribution-with-Slots). Each [named slot](../guide/components.html#Named-Slots) has its own corresponding property (e.g. the contents of `v-slot:foo` will be found at `vm.$slots.foo`). The `default` property contains either nodes not included in a named slot or contents of `v-slot:default`.\n\n  Please note that slots are **not** reactive. If you need a component to re-render based on changes to data passed to a slot, we suggest considering a different strategy that relies on a reactive instance option, such as `props` or `data`.\n\n  **Note:** `v-slot:foo` is supported in v2.6+. For older versions, you can use the [deprecated syntax](../guide/components-slots.html#Deprecated-Syntax).\n\n  Accessing `vm.$slots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n- **Example:**\n\n  ```html\n  <blog-post>\n    <template v-slot:header>\n      <h1>About Me</h1>\n    </template>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <template v-slot:footer>\n      <p>Copyright 2016 Evan You</p>\n    </template>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header),\n        createElement('main', body),\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **See also:**\n  - [`<slot>` Component](#slot)\n  - [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n  - [Render Functions - Slots](../guide/render-function.html#Slots)\n\n### vm.$scopedSlots\n\n> New in 2.1.0+\n\n- **Type:** `{ [name: string]: props => Array<VNode> | undefined }`\n\n- **Read only**\n\n- **Details:**\n\n  Used to programmatically access [scoped slots](../guide/components.html#Scoped-Slots). For each slot, including the `default` one, the object contains a corresponding function that returns VNodes.\n\n  Accessing `vm.$scopedSlots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n  **Note:** since 2.6.0+, there are two notable changes to this property:\n\n  1. Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return `undefined`.\n\n  2. All `$slots` are now also exposed on `$scopedSlots` as functions. If you work with render functions, it is now recommended to always access slots via `$scopedSlots`, whether they currently use a scope or not. This will not only make future refactors to add a scope simpler, but also ease your eventual migration to Vue 3, where all slots will be functions.\n\n- **See also:**\n  - [`<slot>` Component](#slot)\n  - [Scoped Slots](../guide/components.html#Scoped-Slots)\n  - [Render Functions - Slots](../guide/render-function.html#Slots)\n\n### vm.$refs\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  An object of DOM elements and component instances, registered with [`ref` attributes](#ref).\n\n- **See also:**\n  - [Child Component Refs](../guide/components.html#Child-Component-Refs)\n  - [Special Attributes - ref](#ref)\n\n### vm.$isServer\n\n- **Type:** `boolean`\n\n- **Read only**\n\n- **Details:**\n\n  Whether the current Vue instance is running on the server.\n\n- **See also:** [Server-Side Rendering](../guide/ssr.html)\n\n### vm.$attrs\n\n> New in 2.4.0+\n\n- **Type:** `{ [key: string]: string }`\n\n- **Read only**\n\n- **Details:**\n\n  Contains parent-scope attribute bindings (except for `class` and `style`) that are not recognized (and extracted) as props. When a component doesn't have any declared props, this essentially contains all parent-scope bindings (except for `class` and `style`), and can be passed down to an inner component via `v-bind=\"$attrs\"` - useful when creating higher-order components.\n\n### vm.$listeners\n\n> New in 2.4.0+\n\n- **Type:** `{ [key: string]: Function | Array<Function> }`\n\n- **Read only**\n\n- **Details:**\n\n  Contains parent-scope `v-on` event listeners (without `.native` modifiers). This can be passed down to an inner component via `v-on=\"$listeners\"` - useful when creating transparent wrapper components.\n\n## Instance Methods / Data\n\n### vm.$watch( expOrFn, callback, [options] )\n\n- **Arguments:**\n  - `{string | Function} expOrFn`\n  - `{Function | Object} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **Returns:** `{Function} unwatch`\n\n- **Usage:**\n\n  Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.\n\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn't keep a copy of the pre-mutate value.</p>\n\n- **Example:**\n\n  ``` js\n  // keypath\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // do something\n  })\n\n  // function\n  vm.$watch(\n    function () {\n      // every time the expression `this.a + this.b` yields a different result,\n      // the handler will be called. It's as if we were watching a computed\n      // property without defining the computed property itself\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // do something\n    }\n  )\n  ```\n\n  `vm.$watch` returns an unwatch function that stops firing the callback:\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // later, teardown the watcher\n  unwatch()\n  ```\n\n- **Option: deep**\n\n  To also detect nested value changes inside Objects, you need to pass in `deep: true` in the options argument. Note that you don't need to do so to listen for Array mutations.\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **Option: immediate**\n\n  Passing in `immediate: true` in the option will trigger the callback immediately with the current value of the expression:\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // `callback` is fired immediately with current value of `a`\n  ```\n\n  Note that with `immediate` option you won't be able to unwatch the given property on the first callback call.\n\n  ``` js\n  // This will cause an error\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      unwatch()\n    },\n    { immediate: true }\n  )\n  ```\n\n  If you still want to call an unwatch function inside the callback, you should check its availability first:\n\n  ``` js\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      if (unwatch) {\n        unwatch()\n      }\n    },\n    { immediate: true }\n  )\n  ```\n\n### vm.$set( target, propertyName/index, value )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.set`.\n\n- **See also:** [Vue.set](#Vue-set)\n\n### vm.$delete( target, propertyName/index )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.delete`.\n\n- **See also:** [Vue.delete](#Vue-delete)\n\n## Instance Methods / Events\n\n### vm.$on( event, callback )\n\n- **Arguments:**\n  - `{string | Array<string>} event` (array only supported in 2.2.0+)\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event on the current vm. Events can be triggered by `vm.$emit`. The callback will receive all the additional arguments passed into these event-triggering methods.\n\n- **Example:**\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // => \"hi\"\n  ```\n\n### vm.$once( event, callback )\n\n- **Arguments:**\n  - `{string} event`\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.\n\n### vm.$off( [event, callback] )\n\n- **Arguments:**\n  - `{string | Array<string>} event` (array only supported in 2.2.2+)\n  - `{Function} [callback]`\n\n- **Usage:**\n\n  Remove custom event listener(s).\n\n  - If no arguments are provided, remove all event listeners;\n\n  - If only the event is provided, remove all listeners for that event;\n\n  - If both event and callback are given, remove the listener for that specific callback only.\n\n### vm.$emit( eventName, [...args] )\n\n- **Arguments:**\n  - `{string} eventName`\n  - `[...args]`\n\n  Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.\n\n- **Examples:**\n\n  Using `$emit` with only an event name:\n\n  ```js\n  Vue.component('welcome-button', {\n    template: `\n      <button v-on:click=\"$emit('welcome')\">\n        Click me to be welcomed\n      </button>\n    `\n  })\n  ```\n  ```html\n  <div id=\"emit-example-simple\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  ```\n  ```js\n  new Vue({\n    el: '#emit-example-simple',\n    methods: {\n      sayHi: function () {\n        alert('Hi!')\n      }\n    }\n  })\n  ```\n  {% raw %}\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n  Using `$emit` with additional arguments:\n\n  ```js\n  Vue.component('magic-eight-ball', {\n    data: function () {\n      return {\n        possibleAdvice: ['Yes', 'No', 'Maybe']\n      }\n    },\n    methods: {\n      giveAdvice: function () {\n        var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n        this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n      }\n    },\n    template: `\n      <button v-on:click=\"giveAdvice\">\n        Click me for advice\n      </button>\n    `\n  })\n  ```\n\n  ```html\n  <div id=\"emit-example-argument\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  ```\n\n  ```js\n  new Vue({\n    el: '#emit-example-argument',\n    methods: {\n      showAdvice: function (advice) {\n        alert(advice)\n      }\n    }\n  })\n  ```\n\n  {% raw %}\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n## Instance Methods / Lifecycle\n\n### vm.$mount( [elementOrSelector] )\n\n- **Arguments:**\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **Returns:** `vm` - the instance itself\n\n- **Usage:**\n\n  If a Vue instance didn't receive the `el` option at instantiation, it will be in \"unmounted\" state, without an associated DOM element. `vm.$mount()` can be used to manually start the mounting of an unmounted Vue instance.\n\n  If `elementOrSelector` argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.\n\n  The method returns the instance itself so you can chain other instance methods after it.\n\n- **Example:**\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // create and mount to #app (will replace #app)\n  new MyComponent().$mount('#app')\n\n  // the above is the same as:\n  new MyComponent({ el: '#app' })\n\n  // or, render off-document and append afterwards:\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Server-Side Rendering](../guide/ssr.html)\n\n### vm.$forceUpdate()\n\n- **Usage:**\n\n  Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.\n\n### vm.$nextTick( [callback] )\n\n- **Arguments:**\n  - `{Function} [callback]`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update. This is the same as the global `Vue.nextTick`, except that the callback's `this` context is automatically bound to the instance calling this method.\n\n  > New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don't support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // modify data\n        this.message = 'changed'\n        // DOM is not updated yet\n        this.$nextTick(function () {\n          // DOM is now updated\n          // `this` is bound to the current instance\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **See also:**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n### vm.$destroy()\n\n- **Usage:**\n\n  Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.\n\n  Triggers the `beforeDestroy` and `destroyed` hooks.\n\n  <p class=\"tip\">In normal use cases you shouldn't have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using `v-if` and `v-for`.</p>\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n## Directives\n\n### v-text\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `textContent`. If you need to update the part of `textContent`, you should use `{% raw %}{{ Mustache }}{% endraw %}` interpolations.\n\n- **Example:**\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- same as -->\n  <span>{{msg}}</span>\n  ```\n\n- **See also:** [Data Binding Syntax - Interpolations](../guide/syntax.html#Text)\n\n### v-html\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `innerHTML`. **Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates**. If you find yourself trying to compose templates using `v-html`, try to rethink the solution by using components instead.\n\n  <p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS attacks](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use `v-html` on trusted content and **never** on user-provided content.</p>\n\n  <p class=\"tip\">In [single-file components](../guide/single-file-components.html), `scoped` styles will not apply to content inside `v-html`, because that HTML is not processed by Vue's template compiler. If you want to target `v-html` content with scoped CSS, you can instead use [CSS modules](https://vue-loader.vuejs.org/en/features/css-modules.html) or an additional, global `<style>` element with a manual scoping strategy such as BEM.</p>\n\n- **Example:**\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n\n- **See also:** [Data Binding Syntax - Interpolations](../guide/syntax.html#Raw-HTML)\n\n### v-show\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Toggles the element's `display` CSS property based on the truthy-ness of the expression value.\n\n  This directive triggers transitions when its condition changes.\n\n- **See also:** [Conditional Rendering - v-show](../guide/conditional.html#v-show)\n\n### v-if\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a `<template>` element, its content will be extracted as the conditional block.\n\n  This directive triggers transitions when its condition changes.\n\n  <p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n\n- **See also:** [Conditional Rendering - v-if](../guide/conditional.html)\n\n### v-else\n\n- **Does not expect expression**\n\n- **Restriction:** previous sibling element must have `v-if` or `v-else-if`.\n\n- **Usage:**\n\n  Denote the \"else block\" for `v-if` or a `v-if`/`v-else-if` chain.\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **See also:** [Conditional Rendering - v-else](../guide/conditional.html#v-else)\n\n### v-else-if\n\n> New in 2.1.0+\n\n- **Expects:** `any`\n\n- **Restriction:** previous sibling element must have `v-if` or `v-else-if`.\n\n- **Usage:**\n\n  Denote the \"else if block\" for `v-if`. Can be chained.\n\n  ```html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **See also:** [Conditional Rendering - v-else-if](../guide/conditional.html#v-else-if)\n\n### v-for\n\n- **Expects:** `Array | Object | number | string | Iterable (since 2.6)`\n\n- **Usage:**\n\n  Render the element or template block multiple times based on the source data. The directive's value must use the special syntax `alias in expression` to provide an alias for the current element being iterated on:\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  Alternatively, you can also specify an alias for the index (or the key if used on an Object):\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, name, index) in object\"></div>\n  ```\n\n  The default behavior of `v-for` will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the `key` special attribute:\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  In 2.6+, `v-for` can also work on values that implement the [Iterable Protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol), including native `Map` and `Set`. However, it should be noted that Vue 2.x currently does not support reactivity on `Map` and `Set` values, so cannot automatically detect changes.\n\n  <p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n\n  The detailed usage for `v-for` is explained in the guide section linked below.\n\n- **See also:**\n  - [List Rendering](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **Shorthand:** `@`\n\n- **Expects:** `Function | Inline Statement | Object`\n\n- **Argument:** `event`\n\n- **Modifiers:**\n  - `.stop` - call `event.stopPropagation()`.\n  - `.prevent` - call `event.preventDefault()`.\n  - `.capture` - add event listener in capture mode.\n  - `.self` - only trigger handler if event was dispatched from this element.\n  - `.{keyCode | keyAlias}` - only trigger handler on certain keys.\n  - `.native` - listen for a native event on the root element of component.\n  - `.once` - trigger handler at most once.\n  - `.left` - (2.2.0+) only trigger handler for left button mouse events.\n  - `.right` - (2.2.0+) only trigger handler for right button mouse events.\n  - `.middle` - (2.2.0+) only trigger handler for middle button mouse events.\n  - `.passive` - (2.3.0+) attaches a DOM event with `{ passive: true }`.\n\n- **Usage:**\n\n  Attaches an event listener to the element. The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.\n\n  When used on a normal element, it listens to [**native DOM events**](https://developer.mozilla.org/en-US/docs/Web/Events) only. When used on a custom element component, it listens to **custom events** emitted on that child component.\n\n  When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special `$event` property: `v-on:click=\"handle('ok', $event)\"`.\n\n  Starting in 2.4.0+, `v-on` also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.\n\n- **Example:**\n\n  ```html\n  <!-- method handler -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- dynamic event (2.6.0+) -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- inline statement -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- shorthand -->\n  <button @click=\"doThis\"></button>\n\n  <!-- shorthand dynamic event (2.6.0+) -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- stop propagation -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- prevent default -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- prevent default without expression -->\n  <form @submit.prevent></form>\n\n  <!-- chain modifiers -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- key modifier using keyAlias -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- key modifier using keyCode -->\n  <input @keyup.13=\"onEnter\">\n\n  <!-- the click event will be triggered at most once -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- object syntax (2.4.0+) -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- inline statement -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- native event on component -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **See also:**\n  - [Event Handling](../guide/events.html)\n  - [Components - Custom Events](../guide/components.html#Custom-Events)\n\n### v-bind\n\n- **Shorthand:** `:`\n\n- **Expects:** `any (with argument) | Object (without argument)`\n\n- **Argument:** `attrOrProp (optional)`\n\n- **Modifiers:**\n  - `.prop` - Bind as a DOM property instead of an attribute ([what's the difference?](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028)). If the tag is a component then `.prop` will set the property on the component's `$el`.\n  - `.camel` - (2.1.0+) transform the kebab-case attribute name into camelCase.\n  - `.sync` - (2.3.0+) a syntax sugar that expands into a `v-on` handler for updating the bound value.\n\n- **Usage:**\n\n  Dynamically bind one or more attributes, or a component prop to an expression.\n\n  When used to bind the `class` or `style` attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.\n\n  When used for prop binding, the prop must be properly declared in the child component.\n\n  When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode `class` and `style` does not support Array or Objects.\n\n- **Example:**\n\n  ```html\n  <!-- bind an attribute -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- dynamic attribute name (2.6.0+) -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- shorthand -->\n  <img :src=\"imageSrc\">\n\n  <!-- shorthand dynamic attribute name (2.6.0+) -->\n  <button :[key]=\"value\"></button>\n\n  <!-- with inline string concatenation -->\n  <img :src=\"'/path/to/images/' + fileName\">\n\n  <!-- class binding -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style binding -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- binding an object of attributes -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- DOM attribute binding with prop modifier -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop binding. \"prop\" must be declared in my-component. -->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- pass down parent props in common with a child component -->\n  <child-component v-bind=\"$props\"></child-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  The `.camel` modifier allows camelizing a `v-bind` attribute name when using in-DOM templates, e.g. the SVG `viewBox` attribute:\n\n  ``` html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  `.camel` is not needed if you are using string templates, or compiling with `vue-loader`/`vueify`.\n\n- **See also:**\n  - [Class and Style Bindings](../guide/class-and-style.html)\n  - [Components - Props](../guide/components.html#Props)\n  - [Components - `.sync` Modifier](../guide/components.html#sync-Modifier)\n\n### v-model\n\n- **Expects:** varies based on value of form inputs element or output of components\n\n- **Limited to:**\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **Modifiers:**\n  - [`.lazy`](../guide/forms.html#lazy) - listen to `change` events instead of `input`\n  - [`.number`](../guide/forms.html#number) - cast valid input string to numbers\n  - [`.trim`](../guide/forms.html#trim) - trim input\n\n- **Usage:**\n\n  Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below.\n\n- **See also:**\n  - [Form Input Bindings](../guide/forms.html)\n  - [Components - Form Input Components using Custom Events](../guide/components.html#Form-Input-Components-using-Custom-Events)\n\n### v-slot\n\n- **Shorthand:** `#`\n\n- **Expects:** JavaScript expression that is valid in a function argument position (supports destructuring in [supported environments](../guide/components-slots.html#Slot-Props-Destructuring)). Optional - only needed if expecting props to be passed to the slot.\n\n- **Argument:** slot name (optional, defaults to `default`)\n\n- **Limited to:**\n  - `<template>`\n  - [components](../guide/components-slots.html#Abbreviated-Syntax-for-Lone-Default-Slots) (for a lone default slot with props)\n\n- **Usage:**\n\n  Denote named slots or slots that expect to receive props.\n\n- **Example:**\n\n  ```html\n  <!-- Named slots -->\n  <base-layout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    Default slot content\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </base-layout>\n\n  <!-- Named slot that receives props -->\n  <infinite-scroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </infinite-scroll>\n\n  <!-- Default slot that receive props, with destructuring -->\n  <mouse-position v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </mouse-position>\n  ```\n\n  For more details, see the links below.\n\n- **See also:**\n  - [Components - Slots](../guide/components-slots.html)\n  - [RFC-0001](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md)\n\n### v-pre\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.\n\n- **Example:**\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as `[v-cloak] { display: none }`, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.\n\n- **Example:**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  The `<div>` will not be visible until the compilation is done.\n\n### v-once\n\n- **Does not expect expression**\n\n- **Details:**\n\n  Render the element and component **once** only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.\n\n  ```html\n  <!-- single element -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- the element have children -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- component -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- `v-for` directive -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **See also:**\n  - [Data Binding Syntax - interpolations](../guide/syntax.html#Text)\n  - [Components - Cheap Static Components with `v-once`](../guide/components.html#Cheap-Static-Components-with-v-once)\n\n## Special Attributes\n\n### key\n\n- **Expects:** `number | string | boolean (since 2.4.2) | symbol (since 2.5.12)`\n\n  The `key` special attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.\n\n  Children of the same common parent must have **unique keys**. Duplicate keys will cause render errors.\n\n  The most common use case is combined with `v-for`:\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:\n\n  - Properly trigger lifecycle hooks of a component\n  - Trigger transitions\n\n  For example:\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  When `text` changes, the `<span>` will always be replaced instead of patched, so a transition will be triggered.\n\n### ref\n\n- **Expects:** `string`\n\n  `ref` is used to register a reference to an element or a child component. The reference will be registered under the parent component's `$refs` object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:\n\n  ``` html\n  <!-- vm.$refs.p will be the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- vm.$refs.child will be the child component instance -->\n  <child-component ref=\"child\"></child-component>\n  ```\n\n  When used on elements/components with `v-for`, the registered reference will be an Array containing DOM nodes or component instances.\n\n  An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don't exist yet! `$refs` is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\n- **See also:** [Child Component Refs](../guide/components.html#Child-Component-Refs)\n\n### is\n\n- **Expects:** `string | Object (component’s options object)`\n\n  Used for [dynamic components](../guide/components.html#Dynamic-Components) and to work around [limitations of in-DOM templates](../guide/components.html#DOM-Template-Parsing-Caveats).\n\n  For example:\n\n  ``` html\n  <!-- component changes when currentView changes -->\n  <component v-bind:is=\"currentView\"></component>\n\n  <!-- necessary because `<my-row>` would be invalid inside -->\n  <!-- a `<table>` element and so would be hoisted out      -->\n  <table>\n    <tr is=\"my-row\"></tr>\n  </table>\n  ```\n\n  For detailed usage, follow the links in the description above.\n\n- **See also:**\n  - [Dynamic Components](../guide/components.html#Dynamic-Components)\n  - [DOM Template Parsing Caveats](../guide/components.html#DOM-Template-Parsing-Caveats)\n\n### slot <sup style=\"color:#c92222\">deprecated</sup>\n\n**Prefer [v-slot](#v-slot) in 2.6.0+.**\n\n- **Expects:** `string`\n\n  Used on content inserted into child components to indicate which named slot the content belongs to.\n\n- **See also:** [Named Slots with `slot`](../guide/components.html#Named-Slots-with-slot)\n\n### slot-scope <sup style=\"color:#c92222\">deprecated</sup>\n\n**Prefer [v-slot](#v-slot) in 2.6.0+.**\n\n- **Expects:** `function argument expression`\n\n- **Usage:**\n\n  Used to denote an element or component as a scoped slot. The attribute's value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for [`scope`](#scope-replaced) in 2.5.0+.\n\n  This attribute does not support dynamic binding.\n\n- **See also:** [Scoped Slots with `slot-scope`](../guide/components.html#Scoped-Slots-with-slot-scope)\n\n### scope <sup style=\"color:#c92222\">removed</sup>\n\n**Replaced by [slot-scope](#slot-scope) in 2.5.0+. Prefer [v-slot](#v-slot) in 2.6.0+.**\n\nUsed to denote a `<template>` element as a scoped slot.\n\n- **Usage:**\n\n  Same as [`slot-scope`](#slot-scope) except that `scope` can only be used on `<template>` elements.\n\n## Built-In Components\n\n### component\n\n- **Props:**\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **Usage:**\n\n  A \"meta component\" for rendering dynamic components. The actual component to render is determined by the `is` prop:\n\n  ```html\n  <!-- a dynamic component controlled by -->\n  <!-- the `componentId` property on the vm -->\n  <component :is=\"componentId\"></component>\n\n  <!-- can also render registered component or component passed as prop -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **See also:** [Dynamic Components](../guide/components.html#Dynamic-Components)\n\n### transition\n\n- **Props:**\n  - `name` - string, Used to automatically generate transition CSS class names. e.g. `name: 'fade'` will auto expand to `.fade-enter`, `.fade-enter-active`, etc. Defaults to `\"v\"`.\n  - `appear` - boolean, Whether to apply transition on initial render. Defaults to `false`.\n  - `css` - boolean, Whether to apply CSS transition classes. Defaults to `true`. If set to `false`, will only trigger JavaScript hooks registered via component events.\n  - `type` - string, Specifies the type of transition events to wait for to determine transition end timing. Available values are `\"transition\"` and `\"animation\"`. By default, it will automatically detect the type that has a longer duration.\n  - `mode` - string, Controls the timing sequence of leaving/entering transitions. Available modes are `\"out-in\"` and `\"in-out\"`; defaults to simultaneous.\n  - `duration` - number | { `enter`: number, `leave`: number }, Specifies the duration of transition. By default, Vue waits for the first `transitionend` or `animationend` event on the root transition element.\n  - `enter-class` - string\n  - `leave-class` - string\n  - `appear-class` - string\n  - `enter-to-class` - string\n  - `leave-to-class` - string\n  - `appear-to-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-active-class` - string\n\n- **Events:**\n  - `before-enter`\n  - `before-leave`\n  - `before-appear`\n  - `enter`\n  - `leave`\n  - `appear`\n  - `after-enter`\n  - `after-leave`\n  - `after-appear`\n  - `enter-cancelled`\n  - `leave-cancelled` (`v-show` only)\n  - `appear-cancelled`\n\n- **Usage:**\n\n  `<transition>` serve as transition effects for **single** element/component. The `<transition>` only applies the transition behavior to the wrapped content inside; it doesn't render an extra DOM element, or show up in the inspected component hierarchy.\n\n  ```html\n  <!-- simple element -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- dynamic component -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- event hooking -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // for passed 'el' that DOM element as the argument, something ...\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### transition-group\n\n- **Props:**\n  - `tag` - string, defaults to `span`.\n  - `move-class` - overwrite CSS class applied during moving transition.\n  - exposes the same props as `<transition>` except `mode`.\n\n- **Events:**\n  - exposes the same events as `<transition>`.\n\n- **Usage:**\n\n  `<transition-group>` serve as transition effects for **multiple** elements/components. The `<transition-group>` renders a real DOM element. By default it renders a `<span>`, and you can configure what element it should render via the `tag` attribute.\n\n  Note that every child in a `<transition-group>` must be **uniquely keyed** for the animations to work properly.\n\n  `<transition-group>` supports moving transitions via CSS transform. When a child's position on screen has changed after an update, it will get applied a moving CSS class (auto generated from the `name` attribute or configured with the `move-class` attribute). If the CSS `transform` property is \"transition-able\" when the moving class is applied, the element will be smoothly animated to its destination using the [FLIP technique](https://aerotwist.com/blog/flip-your-animations/).\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### keep-alive\n\n- **Props:**\n  - `include` - string or RegExp or Array. Only components with matching names will be cached.\n  - `exclude` - string or RegExp or Array. Any component with a matching name will not be cached.\n  - `max` - number. The maximum number of component instances to cache.\n\n- **Usage:**\n\n  When wrapped around a dynamic component, `<keep-alive>` caches the inactive component instances without destroying them. Similar to `<transition>`, `<keep-alive>` is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.\n\n  When a component is toggled inside `<keep-alive>`, its `activated` and `deactivated` lifecycle hooks will be invoked accordingly.\n\n  > In 2.2.0+ and above, `activated` and `deactivated` will fire for all nested components inside a `<keep-alive>` tree.\n\n  Primarily used to preserve component state or avoid re-rendering.\n\n  ```html\n  <!-- basic -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- multiple conditional children -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- used together with `<transition>` -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n  Note, `<keep-alive>` is designed for the case where it has one direct child component that is being toggled. It does not work if you have `v-for` inside it. When there are multiple conditional children, as above, `<keep-alive>` requires that only one child is rendered at a time.\n\n- **`include` and `exclude`**\n\n  > New in 2.1.0+\n\n  The `include` and `exclude` props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:\n\n  ``` html\n  <!-- comma-delimited string -->\n  <keep-alive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- regex (use `v-bind`) -->\n  <keep-alive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- Array (use `v-bind`) -->\n  <keep-alive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  The match is first checked on the component's own `name` option, then its local registration name (the key in the parent's `components` option) if the `name` option is not available. Anonymous components cannot be matched against.\n\n- **`max`**\n\n  > New in 2.5.0+\n\n  The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.\n\n  ``` html\n  <keep-alive :max=\"10\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  <p class=\"tip\">`<keep-alive>` does not work with functional components because they do not have instances to be cached.</p>\n\n- **See also:** [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### slot\n\n- **Props:**\n  - `name` - string, Used for named slot.\n\n- **Usage:**\n\n  `<slot>` serve as content distribution outlets in component templates. `<slot>` itself will be replaced.\n\n  For detailed usage, see the guide section linked below.\n\n- **See also:** [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n\n## VNode Interface\n\n- Please refer to the [VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).\n\n## Server-Side Rendering\n\n- Please refer to the [vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).\n","source":"v2/api/index.md","raw":"---\ntitle: API\ntype: api\n---\n\n## Global Config\n\n`Vue.config` is an object containing Vue's global configurations. You can modify its properties listed below before bootstrapping your application:\n\n### silent\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.silent = true\n  ```\n\n  Suppress all Vue logs and warnings.\n\n### optionMergeStrategies\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {\n    return child + 1\n  }\n\n  const Profile = Vue.extend({\n    _my_option: 1\n  })\n\n  // Profile.options._my_option = 2\n  ```\n\n  Define custom merging strategies for options.\n\n  The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.\n\n- **See also:** [Custom Option Merging Strategies](../guide/mixins.html#Custom-Option-Merge-Strategies)\n\n### devtools\n\n- **Type:** `boolean`\n\n- **Default:** `true` (`false` in production builds)\n\n- **Usage:**\n\n  ``` js\n  // make sure to set this synchronously immediately after loading Vue\n  Vue.config.devtools = true\n  ```\n\n  Configure whether to allow [vue-devtools](https://github.com/vuejs/vue-devtools) inspection. This option's default value is `true` in development builds and `false` in production builds. You can set it to `true` to enable inspection for production builds.\n\n### errorHandler\n\n- **Type:** `Function`\n\n- **Default:** `undefined`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.errorHandler = function (err, vm, info) {\n    // handle error\n    // `info` is a Vue-specific error info, e.g. which lifecycle hook\n    // the error was found in. Only available in 2.2.0+\n  }\n  ```\n\n  Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the Vue instance.\n\n  > In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is `undefined`, captured errors will be logged with `console.error` instead of crashing the app.\n\n  > In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.\n\n  > In 2.6.0+, this hook also captures errors thrown inside `v-on` DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.\n\n  > Error tracking services [Sentry](https://sentry.io/for/vue/) and [Bugsnag](https://docs.bugsnag.com/platforms/browsers/vue/) provide official integrations using this option.\n\n### warnHandler\n\n> New in 2.4.0+\n\n- **Type:** `Function`\n\n- **Default:** `undefined`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.warnHandler = function (msg, vm, trace) {\n    // `trace` is the component hierarchy trace\n  }\n  ```\n\n  Assign a custom handler for runtime Vue warnings. Note this only works during development and is ignored in production.\n\n### ignoredElements\n\n- **Type:** `Array<string | RegExp>`\n\n- **Default:** `[]`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.ignoredElements = [\n    'my-custom-web-component',\n    'another-web-component',\n    // Use a `RegExp` to ignore all elements that start with \"ion-\"\n    // 2.5+ only\n    /^ion-/\n  ]\n  ```\n\n  Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an `Unknown custom element`, assuming that you forgot to register a global component or misspelled a component name.\n\n### keyCodes\n\n- **Type:** `{ [key: string]: number | Array<number> }`\n\n- **Default:** `{}`\n\n- **Usage:**\n\n  ``` js\n  Vue.config.keyCodes = {\n    v: 86,\n    f1: 112,\n    // camelCase won`t work\n    mediaPlayPause: 179,\n    // instead you can use kebab-case with double quotation marks\n    \"media-play-pause\": 179,\n    up: [38, 87]\n  }\n  ```\n\n  ```html\n  <input type=\"text\" @keyup.media-play-pause=\"method\">\n  ```\n\n  Define custom key alias(es) for `v-on`.\n\n### performance\n\n> New in 2.2.0+\n\n- **Type:** `boolean`\n\n- **Default:** `false (from 2.2.3+)`\n\n- **Usage**:\n\n  Set this to `true` to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the [performance.mark](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark) API.\n\n### productionTip\n\n> New in 2.2.0+\n\n- **Type:** `boolean`\n\n- **Default:** `true`\n\n- **Usage**:\n\n  Set this to `false` to prevent the production tip on Vue startup.\n\n## Global API\n\n### Vue.extend( options )\n\n- **Arguments:**\n  - `{Object} options`\n\n- **Usage:**\n\n  Create a \"subclass\" of the base Vue constructor. The argument should be an object containing component options.\n\n  The special case to note here is the `data` option - it must be a function when used with `Vue.extend()`.\n\n  ``` html\n  <div id=\"mount-point\"></div>\n  ```\n\n  ``` js\n  // create constructor\n  var Profile = Vue.extend({\n    template: '<p>{{firstName}} {{lastName}} aka {{alias}}</p>',\n    data: function () {\n      return {\n        firstName: 'Walter',\n        lastName: 'White',\n        alias: 'Heisenberg'\n      }\n    }\n  })\n  // create an instance of Profile and mount it on an element\n  new Profile().$mount('#mount-point')\n  ```\n\n  Will result in:\n\n  ``` html\n  <p>Walter White aka Heisenberg</p>\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n### Vue.nextTick( [callback, context] )\n\n- **Arguments:**\n  - `{Function} [callback]`\n  - `{Object} [context]`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update.\n\n  ``` js\n  // modify data\n  vm.msg = 'Hello'\n  // DOM not updated yet\n  Vue.nextTick(function () {\n    // DOM updated\n  })\n\n  // usage as a promise (2.1.0+, see note below)\n  Vue.nextTick()\n    .then(function () {\n      // DOM updated\n    })\n  ```\n\n  > New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don't support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.\n\n- **See also:** [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n### Vue.set( target, propertyName/index, value )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates. This must be used to add new properties to reactive objects, as Vue cannot detect normal property additions (e.g. `this.myObject.newProperty = 'hi'`).\n\n  <p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### Vue.delete( target, propertyName/index )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n  > Only in 2.2.0+: Also works with Array + index.\n\n- **Usage:**\n\n  Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.\n\n  <p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### Vue.directive( id, [definition] )\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global directive.\n\n  ``` js\n  // register\n  Vue.directive('my-directive', {\n    bind: function () {},\n    inserted: function () {},\n    update: function () {},\n    componentUpdated: function () {},\n    unbind: function () {}\n  })\n\n  // register (function directive)\n  Vue.directive('my-directive', function () {\n    // this will be called as `bind` and `update`\n  })\n\n  // getter, return the directive definition if registered\n  var myDirective = Vue.directive('my-directive')\n  ```\n\n- **See also:** [Custom Directives](../guide/custom-directive.html)\n\n### Vue.filter( id, [definition] )\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global filter.\n\n  ``` js\n  // register\n  Vue.filter('my-filter', function (value) {\n    // return processed value\n  })\n\n  // getter, return the filter if registered\n  var myFilter = Vue.filter('my-filter')\n  ```\n\n- **See also:** [Filters](../guide/filters.html)\n\n### Vue.component( id, [definition] )\n\n- **Arguments:**\n  - `{string} id`\n  - `{Function | Object} [definition]`\n\n- **Usage:**\n\n  Register or retrieve a global component. Registration also automatically sets the component's `name` with the given `id`.\n\n  ``` js\n  // register an extended constructor\n  Vue.component('my-component', Vue.extend({ /* ... */ }))\n\n  // register an options object (automatically call Vue.extend)\n  Vue.component('my-component', { /* ... */ })\n\n  // retrieve a registered component (always return constructor)\n  var MyComponent = Vue.component('my-component')\n  ```\n\n- **See also:** [Components](../guide/components.html)\n\n### Vue.use( plugin )\n\n- **Arguments:**\n  - `{Object | Function} plugin`\n\n- **Usage:**\n\n  Install a Vue.js plugin. If the plugin is an Object, it must expose an `install` method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.\n\n  This method has to be called before calling `new Vue()`\n\n  When this method is called on the same plugin multiple times, the plugin will be installed only once.\n\n- **See also:** [Plugins](../guide/plugins.html)\n\n### Vue.mixin( mixin )\n\n- **Arguments:**\n  - `{Object} mixin`\n\n- **Usage:**\n\n  Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. **Not recommended in application code**.\n\n- **See also:** [Global Mixin](../guide/mixins.html#Global-Mixin)\n\n### Vue.compile( template )\n\n- **Arguments:**\n  - `{string} template`\n\n- **Usage:**\n\n  Compiles a template string into a render function. **Only available in the full build.**\n\n  ``` js\n  var res = Vue.compile('<div><span>{{ msg }}</span></div>')\n\n  new Vue({\n    data: {\n      msg: 'hello'\n    },\n    render: res.render,\n    staticRenderFns: res.staticRenderFns\n  })\n  ```\n\n- **See also:** [Render Functions](../guide/render-function.html)\n\n### Vue.observable( object )\n\n> New in 2.6.0+\n\n- **Arguments:**\n  - `{Object} object`\n\n- **Usage:**\n\n  Make an object reactive. Internally, Vue uses this on the object returned by the `data` function.\n\n  The returned object can be used directly inside [render functions](../guide/render-function.html) and [computed properties](../guide/computed.html), and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:\n\n  ``` js\n  const state = Vue.observable({ count: 0 })\n\n  const Demo = {\n    render(h) {\n      return h('button', {\n        on: { click: () => { state.count++ }}\n      }, `count is: ${state.count}`)\n    }\n  }\n  ```\n\n  <p class=\"tip\">In Vue 2.x, `Vue.observable` directly mutates the object passed to it, so that it is equivalent to the object returned, as [demonstrated here](../guide/instance.html#Data-and-Methods). In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by `Vue.observable`, rather than the object originally passed to it.</p>\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### Vue.version\n\n- **Details**: Provides the installed version of Vue as a string. This is especially useful for community plugins and components, where you might use different strategies for different versions.\n\n- **Usage**:\n\n  ```js\n  var version = Number(Vue.version.split('.')[0])\n\n  if (version === 2) {\n    // Vue v2.x.x\n  } else if (version === 1) {\n    // Vue v1.x.x\n  } else {\n    // Unsupported versions of Vue\n  }\n  ```\n\n## Options / Data\n\n### data\n\n- **Type:** `Object | Function`\n\n- **Restriction:** Only accepts `Function` when used in a component definition.\n\n- **Details:**\n\n  The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it \"reactive\". **The object must be plain**: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.\n\n  Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.\n\n  After the instance is created, the original data object can be accessed as `vm.$data`. The Vue instance also proxies all the properties found on the data object, so `vm.a` will be equivalent to `vm.$data.a`.\n\n  Properties that start with `_` or `$` will **not** be proxied on the Vue instance because they may conflict with Vue's internal properties and API methods. You will have to access them as `vm.$data._property`.\n\n  When defining a **component**, `data` must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for `data`, that same object will be **shared by reference** across all instances created! By providing a `data` function, every time a new instance is created we can call it to return a fresh copy of the initial data.\n\n  If required, a deep clone of the original object can be obtained by passing `vm.$data` through `JSON.parse(JSON.stringify(...))`.\n\n- **Example:**\n\n  ``` js\n  var data = { a: 1 }\n\n  // direct instance creation\n  var vm = new Vue({\n    data: data\n  })\n  vm.a // => 1\n  vm.$data === data // => true\n\n  // must use function when in Vue.extend()\n  var Component = Vue.extend({\n    data: function () {\n      return { a: 1 }\n    }\n  })\n  ```\n\n  Note that if you use an arrow function with the `data` property, `this` won't be the component's instance, but you can still access the instance as the function's first argument:\n\n  ```js\n  data: vm => ({ a: vm.myProp })\n  ```\n\n- **See also:** [Reactivity in Depth](../guide/reactivity.html)\n\n### props\n\n- **Type:** `Array<string> | Object`\n\n- **Details:**\n\n  A list/hash of attributes that are exposed to accept data from the parent component. It has an Array-based simple syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.\n\n  With Object-based syntax, you can use following options:\n    - `type`: can be one of the following native constructors: `String`, `Number`, `Boolean`, `Array`, `Object`, `Date`, `Function`, `Symbol`, any custom constructor function or an array of those. Will check if a prop has a given type, and will throw a warning if it doesn't. [More information](../guide/components-props.html#Prop-Types) on prop types.\n    - `default`: `any`\n    Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.\n    - `required`: `Boolean`\n    Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.\n    - `validator`: `Function`\n    Custom validator function that takes the prop value as the sole argument. In a non-production environment, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails). You can read more about prop validation [here](../guide/components-props.html#Prop-Validation).\n\n- **Example:**\n\n  ``` js\n  // simple syntax\n  Vue.component('props-demo-simple', {\n    props: ['size', 'myMessage']\n  })\n\n  // object syntax with validation\n  Vue.component('props-demo-advanced', {\n    props: {\n      // type check\n      height: Number,\n      // type check plus other validations\n      age: {\n        type: Number,\n        default: 0,\n        required: true,\n        validator: function (value) {\n          return value >= 0\n        }\n      }\n    }\n  })\n  ```\n\n- **See also:** [Props](../guide/components-props.html)\n\n### propsData\n\n- **Type:** `{ [key: string]: any }`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Pass props to an instance during its creation. This is primarily intended to make unit testing easier.\n\n- **Example:**\n\n  ``` js\n  var Comp = Vue.extend({\n    props: ['msg'],\n    template: '<div>{{ msg }}</div>'\n  })\n\n  var vm = new Comp({\n    propsData: {\n      msg: 'hello'\n    }\n  })\n  ```\n\n### computed\n\n- **Type:** `{ [key: string]: Function | { get: Function, set: Function } }`\n\n- **Details:**\n\n  Computed properties to be mixed into the Vue instance. All getters and setters have their `this` context automatically bound to the Vue instance.\n\n  Note that if you use an arrow function with a computed property, `this` won't be the component's instance, but you can still access the instance as the function's first argument:\n\n  ```js\n  computed: {\n    aDouble: vm => vm.a * 2\n  }\n  ```\n\n  Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance's scope (i.e. not reactive), the computed property will __not__ be updated.\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    computed: {\n      // get only\n      aDouble: function () {\n        return this.a * 2\n      },\n      // both get and set\n      aPlus: {\n        get: function () {\n          return this.a + 1\n        },\n        set: function (v) {\n          this.a = v - 1\n        }\n      }\n    }\n  })\n  vm.aPlus   // => 2\n  vm.aPlus = 3\n  vm.a       // => 2\n  vm.aDouble // => 4\n  ```\n\n- **See also:** [Computed Properties](../guide/computed.html)\n\n### methods\n\n- **Type:** `{ [key: string]: Function }`\n\n- **Details:**\n\n  Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their `this` context automatically bound to the Vue instance.\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a method__ (e.g. `plus: () => this.a++`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.a` will be undefined.</p>\n\n- **Example:**\n\n  ```js\n  var vm = new Vue({\n    data: { a: 1 },\n    methods: {\n      plus: function () {\n        this.a++\n      }\n    }\n  })\n  vm.plus()\n  vm.a // 2\n  ```\n\n- **See also:** [Event Handling](../guide/events.html)\n\n### watch\n\n- **Type:** `{ [key: string]: string | Function | Object | Array}`\n\n- **Details:**\n\n  An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call `$watch()` for each entry in the object at instantiation.\n\n- **Example:**\n\n  ``` js\n  var vm = new Vue({\n    data: {\n      a: 1,\n      b: 2,\n      c: 3,\n      d: 4,\n      e: {\n        f: {\n          g: 5\n        }\n      }\n    },\n    watch: {\n      a: function (val, oldVal) {\n        console.log('new: %s, old: %s', val, oldVal)\n      },\n      // string method name\n      b: 'someMethod',\n      // the callback will be called whenever any of the watched object properties change regardless of their nested depth\n      c: {\n        handler: function (val, oldVal) { /* ... */ },\n        deep: true\n      },\n      // the callback will be called immediately after the start of the observation\n      d: {\n        handler: 'someMethod',\n        immediate: true\n      },\n      // you can pass array of callbacks, they will be called one-by-one\n      e: [\n        'handle1',\n        function handle2 (val, oldVal) { /* ... */ },\n        {\n          handler: function handle3 (val, oldVal) { /* ... */ },\n          /* ... */\n        }\n      ],\n      // watch vm.e.f's value: {g: 5}\n      'e.f': function (val, oldVal) { /* ... */ }\n    }\n  })\n  vm.a = 2 // => new: 2, old: 1\n  ```\n\n  <p class=\"tip\">Note that __you should not use an arrow function to define a watcher__ (e.g. `searchQuery: newValue => this.updateAutocomplete(newValue)`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.updateAutocomplete` will be undefined.</p>\n\n- **See also:** [Instance Methods / Data - vm.$watch](#vm-watch)\n\n## Options / DOM\n\n### el\n\n- **Type:** `string | Element`\n\n- **Restriction:** only respected in instance creation via `new`.\n\n- **Details:**\n\n  Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.\n\n  After the instance is mounted, the resolved element will be accessible as `vm.$el`.\n\n  If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call `vm.$mount()` to manually start the compilation.\n\n  <p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to `<html>` or `<body>`.</p>\n\n  <p class=\"tip\">If neither `render` function nor `template` option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</p>\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Runtime + Compiler vs. Runtime-only](../guide/installation.html#Runtime-Compiler-vs-Runtime-only)\n\n### template\n\n- **Type:** `string`\n\n- **Details:**\n\n  A string template to be used as the markup for the Vue instance. The template will **replace** the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.\n\n  If the string starts with `#` it will be used as a querySelector and use the selected element's innerHTML as the template string. This allows the use of the common `<script type=\"x-template\">` trick to include templates.\n\n  <p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n\n  <p class=\"tip\">If render function is present in the Vue option, the template will be ignored.</p>\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n\n### render\n\n  - **Type:** `(createElement: () => VNode) => VNode`\n\n  - **Details:**\n\n    An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a `createElement` method as it's first argument used to create `VNode`s.\n\n    If the component is a functional component, the render function also receives an extra argument `context`, which provides access to contextual data since functional components are instance-less.\n\n    <p class=\"tip\">The `render` function has priority over the render function compiled from `template` option or in-DOM HTML template of the mounting element which is specified by the `el` option.</p>\n\n  - **See also:** [Render Functions](../guide/render-function.html)\n\n### renderError\n\n> New in 2.2.0+\n\n  - **Type:** `(createElement: () => VNode, error: Error) => VNode`\n\n  - **Details:**\n\n    **Only works in development mode.**\n\n    Provide an alternative render output when the default `render` function encounters an error. The error will be passed to `renderError` as the second argument. This is particularly useful when used together with hot-reload.\n\n  - **Example:**\n\n    ``` js\n    new Vue({\n      render (h) {\n        throw new Error('oops')\n      },\n      renderError (h, err) {\n        return h('pre', { style: { color: 'red' }}, err.stack)\n      }\n    }).$mount('#app')\n    ```\n\n  - **See also:** [Render Functions](../guide/render-function.html)\n\n## Options / Lifecycle Hooks\n\n<p class=\"tip\">All lifecycle hooks automatically have their `this` context bound to the instance, so that you can access data, computed properties, and methods. This means __you should not use an arrow function to define a lifecycle method__ (e.g. `created: () => this.fetchTodos()`). The reason is arrow functions bind the parent context, so `this` will not be the Vue instance as you expect and `this.fetchTodos` will be undefined.</p>\n\n### beforeCreate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously immediately after the instance has been initialized, before data observation and event/watcher setup.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### created\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the `$el` property will not be available yet.\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeMount\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before the mounting begins: the `render` function is about to be called for the first time.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### mounted\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after the instance has been mounted, where `el` is replaced by the newly created `vm.$el`. If the root instance is mounted to an in-document element, `vm.$el` will also be in-document when `mounted` is called.\n\n  Note that `mounted` does **not** guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use [vm.$nextTick](#vm-nextTick) inside of `mounted`:\n\n  ``` js\n  mounted: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been rendered\n    })\n  }\n  ```\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### beforeUpdate\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when data changes, before the DOM is patched. This is a good place to access the existing DOM before an update, e.g. to remove manually added event listeners.\n\n  **This hook is not called during server-side rendering, because only the initial render is performed server-side.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### updated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a data change causes the virtual DOM to be re-rendered and patched.\n\n  The component's DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it's usually better to use a [computed property](#computed) or [watcher](#watch) instead.\n\n  Note that `updated` does **not** guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use [vm.$nextTick](#vm-nextTick) inside of `updated`:\n\n  ``` js\n  updated: function () {\n    this.$nextTick(function () {\n      // Code that will run only after the\n      // entire view has been re-rendered\n    })\n  }\n  ```\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### activated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is activated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### deactivated\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called when a kept-alive component is deactivated.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:**\n  - [Built-in Components - keep-alive](#keep-alive)\n  - [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### beforeDestroy\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### destroyed\n\n- **Type:** `Function`\n\n- **Details:**\n\n  Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.\n\n  **This hook is not called during server-side rendering.**\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n### errorCaptured\n\n> New in 2.5.0+\n\n- **Type:** `(err: Error, vm: Component, info: string) => ?boolean`\n\n- **Details:**\n\n  Called when an error from any descendent component is captured. The hook receives three arguments: the error, the component instance that triggered the error, and a string containing information on where the error was captured. The hook can return `false` to stop the error from propagating further.\n\n  <p class=\"tip\">You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</p>\n\n  **Error Propagation Rules**\n\n  - By default, all errors are still sent to the global `config.errorHandler` if it is defined, so that these errors can still be reported to an analytics service in a single place.\n\n  - If multiple `errorCaptured` hooks exist on a component's inheritance chain or parent chain, all of them will be invoked on the same error.\n\n  - If the `errorCaptured` hook itself throws an error, both this error and the original captured error are sent to the global `config.errorHandler`.\n\n  - An `errorCaptured` hook can return `false` to prevent the error from propagating further. This is essentially saying \"this error has been handled and should be ignored.\" It will prevent any additional `errorCaptured` hooks or the global `config.errorHandler` from being invoked for this error.\n\n## Options / Assets\n\n### directives\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of directives to be made available to the Vue instance.\n\n- **See also:** [Custom Directives](../guide/custom-directive.html)\n\n### filters\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of filters to be made available to the Vue instance.\n\n- **See also:** [`Vue.filter`](#Vue-filter)\n\n### components\n\n- **Type:** `Object`\n\n- **Details:**\n\n  A hash of components to be made available to the Vue instance.\n\n- **See also:** [Components](../guide/components.html)\n\n## Options / Composition\n\n### parent\n\n- **Type:** `Vue instance`\n\n- **Details:**\n\n  Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as `this.$parent` for the child, and the child will be pushed into the parent's `$children` array.\n\n  <p class=\"tip\">Use `$parent` and `$children` sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n### mixins\n\n- **Type:** `Array<Object>`\n\n- **Details:**\n\n  The `mixins` option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in `Vue.extend()`. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.\n\n  Mixin hooks are called in the order they are provided, and called before the component's own hooks.\n\n- **Example:**\n\n  ``` js\n  var mixin = {\n    created: function () { console.log(1) }\n  }\n  var vm = new Vue({\n    created: function () { console.log(2) },\n    mixins: [mixin]\n  })\n  // => 1\n  // => 2\n  ```\n\n- **See also:** [Mixins](../guide/mixins.html)\n\n### extends\n\n- **Type:** `Object | Function`\n\n- **Details:**\n\n  Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use `Vue.extend`. This is primarily intended to make it easier to extend between single file components.\n\n  This is similar to `mixins`.\n\n- **Example:**\n\n  ``` js\n  var CompA = { ... }\n\n  // extend CompA without having to call `Vue.extend` on either\n  var CompB = {\n    extends: CompA,\n    ...\n  }\n  ```\n\n### provide / inject\n\n> New in 2.2.0+\n\n- **Type:**\n  - **provide:** `Object | () => Object`\n  - **inject:** `Array<string> | { [key: string]: string | Symbol | Object }`\n\n- **Details:**\n\n  <p class=\"tip\">`provide` and `inject` are primarily provided for advanced plugin / component library use cases. It is NOT recommended to use them in generic application code.</p>\n\n  This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React's context feature.\n\n  The `provide` option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support `Symbol` and `Reflect.ownKeys`.\n\n  The `inject` option should be either:\n  - an array of strings, or\n  - an object where the keys are the local binding name and the value is either:\n    - the key (string or Symbol) to search for in available injections, or\n    - an object where:\n      - the `from` property is the key (string or Symbol) to search for in available injections, and\n      - the `default` property is used as fallback value\n\n  > Note: the `provide` and `inject` bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.\n\n- **Example:**\n\n  ``` js\n  // parent component providing 'foo'\n  var Provider = {\n    provide: {\n      foo: 'bar'\n    },\n    // ...\n  }\n\n  // child component injecting 'foo'\n  var Child = {\n    inject: ['foo'],\n    created () {\n      console.log(this.foo) // => \"bar\"\n    }\n    // ...\n  }\n  ```\n\n  With ES2015 Symbols, function `provide` and object `inject`:\n  ``` js\n  const s = Symbol()\n\n  const Provider = {\n    provide () {\n      return {\n        [s]: 'foo'\n      }\n    }\n  }\n\n  const Child = {\n    inject: { s },\n    // ...\n  }\n  ```\n\n  > The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the `props` and the `data` initialization.\n\n  Using an injected value as the default for a prop:\n  ```js\n  const Child = {\n    inject: ['foo'],\n    props: {\n      bar: {\n        default () {\n          return this.foo\n        }\n      }\n    }\n  }\n  ```\n\n  Using an injected value as data entry:\n  ```js\n  const Child = {\n    inject: ['foo'],\n    data () {\n      return {\n        bar: this.foo\n      }\n    }\n  }\n  ```\n\n  > In 2.5.0+ injections can be optional with default value:\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: { default: 'foo' }\n    }\n  }\n  ```\n\n  If it needs to be injected from a property with a different name, use `from` to denote the source property:\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: 'foo'\n      }\n    }\n  }\n  ```\n\n  Similar to prop defaults, you need to use a factory function for non primitive values:\n\n  ``` js\n  const Child = {\n    inject: {\n      foo: {\n        from: 'bar',\n        default: () => [1, 2, 3]\n      }\n    }\n  }\n  ```\n\n## Options / Misc\n\n### name\n\n- **Type:** `string`\n\n- **Restriction:** only respected when used as a component option.\n\n- **Details:**\n\n  Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with `Vue.component()`, the global ID is automatically set as its name.\n\n  Another benefit of specifying a `name` option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the [vue-devtools](https://github.com/vuejs/vue-devtools), unnamed components will show up as `<AnonymousComponent>`, which isn't very informative. By providing the `name` option, you will get a much more informative component tree.\n\n### delimiters\n\n- **Type:** `Array<string>`\n\n- **Default:** `{% raw %}[\"{{\", \"}}\"]{% endraw %}`\n\n- **Restrictions:** This option is only available in the full build, with in-browser compilation.\n\n- **Details:**\n\n  Change the plain text interpolation delimiters.\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    delimiters: ['${', '}']\n  })\n\n  // Delimiters changed to ES6 template string style\n  ```\n\n### functional\n\n- **Type:** `boolean`\n\n- **Details:**\n\n  Causes a component to be stateless (no `data`) and instanceless (no `this` context). They are only a `render` function that returns virtual nodes making them much cheaper to render.\n\n- **See also:** [Functional Components](../guide/render-function.html#Functional-Components)\n\n### model\n\n> New in 2.2.0\n\n- **Type:** `{ prop?: string, event?: string }`\n\n- **Details:**\n\n  Allows a custom component to customize the prop and event used when it's used with `v-model`. By default, `v-model` on a component uses `value` as the prop and `input` as the event, but some input types such as checkboxes and radio buttons may want to use the `value` prop for a different purpose. Using the `model` option can avoid the conflict in such cases.\n\n- **Example:**\n\n  ``` js\n  Vue.component('my-checkbox', {\n    model: {\n      prop: 'checked',\n      event: 'change'\n    },\n    props: {\n      // this allows using the `value` prop for a different purpose\n      value: String,\n      // use `checked` as the prop which take the place of `value`\n      checked: {\n        type: Number,\n        default: 0\n      }\n    },\n    // ...\n  })\n  ```\n\n  ``` html\n  <my-checkbox v-model=\"foo\" value=\"some value\"></my-checkbox>\n  ```\n\n  The above will be equivalent to:\n\n  ``` html\n  <my-checkbox\n    :checked=\"foo\"\n    @change=\"val => { foo = val }\"\n    value=\"some value\">\n  </my-checkbox>\n  ```\n\n### inheritAttrs\n\n> New in 2.4.0+\n\n- **Type:** `boolean`\n\n- **Default:** `true`\n\n- **Details:**\n\n  By default, parent scope attribute bindings that are not recognized as props will \"fallthrough\" and be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting `inheritAttrs` to `false`, this default behavior can be disabled. The attributes are available via the `$attrs` instance property (also new in 2.4) and can be explicitly bound to a non-root element using `v-bind`.\n\n  Note: this option does **not** affect `class` and `style` bindings.\n\n### comments\n\n> New in 2.4.0+\n\n- **Type:** `boolean`\n\n- **Default:** `false`\n\n- **Restrictions:** This option is only available in the full build, with in-browser compilation.\n\n- **Details:**\n\n  When set to `true`, will preserve and render HTML comments found in templates. The default behavior is discarding them.\n\n## Instance Properties\n\n### vm.$data\n\n- **Type:** `Object`\n\n- **Details:**\n\n  The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.\n\n- **See also:** [Options / Data - data](#data)\n\n### vm.$props\n\n> New in 2.2.0+\n\n- **Type:** `Object`\n\n- **Details:**\n\n  An object representing the current props a component has received. The Vue instance proxies access to the properties on its props object.\n\n### vm.$el\n\n- **Type:** `Element`\n\n- **Read only**\n\n- **Details:**\n\n  The root DOM element that the Vue instance is managing.\n\n### vm.$options\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:\n\n  ``` js\n  new Vue({\n    customOption: 'foo',\n    created: function () {\n      console.log(this.$options.customOption) // => 'foo'\n    }\n  })\n  ```\n\n### vm.$parent\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The parent instance, if the current instance has one.\n\n### vm.$root\n\n- **Type:** `Vue instance`\n\n- **Read only**\n\n- **Details:**\n\n  The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.\n\n### vm.$children\n\n- **Type:** `Array<Vue instance>`\n\n- **Read only**\n\n- **Details:**\n\n  The direct child components of the current instance. **Note there's no order guarantee for `$children`, and it is not reactive.** If you find yourself trying to use `$children` for data binding, consider using an Array and `v-for` to generate child components, and use the Array as the source of truth.\n\n### vm.$slots\n\n- **Type:** `{ [name: string]: ?Array<VNode> }`\n\n- **Read only**\n\n- **Reactive?** No\n\n- **Details:**\n\n  Used to programmatically access content [distributed by slots](../guide/components.html#Content-Distribution-with-Slots). Each [named slot](../guide/components.html#Named-Slots) has its own corresponding property (e.g. the contents of `v-slot:foo` will be found at `vm.$slots.foo`). The `default` property contains either nodes not included in a named slot or contents of `v-slot:default`.\n\n  Please note that slots are **not** reactive. If you need a component to re-render based on changes to data passed to a slot, we suggest considering a different strategy that relies on a reactive instance option, such as `props` or `data`.\n\n  **Note:** `v-slot:foo` is supported in v2.6+. For older versions, you can use the [deprecated syntax](../guide/components-slots.html#Deprecated-Syntax).\n\n  Accessing `vm.$slots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n- **Example:**\n\n  ```html\n  <blog-post>\n    <template v-slot:header>\n      <h1>About Me</h1>\n    </template>\n\n    <p>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.</p>\n\n    <template v-slot:footer>\n      <p>Copyright 2016 Evan You</p>\n    </template>\n\n    <p>If I have some content down here, it will also be included in vm.$slots.default.</p>.\n  </blog-post>\n  ```\n\n  ```js\n  Vue.component('blog-post', {\n    render: function (createElement) {\n      var header = this.$slots.header\n      var body   = this.$slots.default\n      var footer = this.$slots.footer\n      return createElement('div', [\n        createElement('header', header),\n        createElement('main', body),\n        createElement('footer', footer)\n      ])\n    }\n  })\n  ```\n\n- **See also:**\n  - [`<slot>` Component](#slot)\n  - [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n  - [Render Functions - Slots](../guide/render-function.html#Slots)\n\n### vm.$scopedSlots\n\n> New in 2.1.0+\n\n- **Type:** `{ [name: string]: props => Array<VNode> | undefined }`\n\n- **Read only**\n\n- **Details:**\n\n  Used to programmatically access [scoped slots](../guide/components.html#Scoped-Slots). For each slot, including the `default` one, the object contains a corresponding function that returns VNodes.\n\n  Accessing `vm.$scopedSlots` is most useful when writing a component with a [render function](../guide/render-function.html).\n\n  **Note:** since 2.6.0+, there are two notable changes to this property:\n\n  1. Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return `undefined`.\n\n  2. All `$slots` are now also exposed on `$scopedSlots` as functions. If you work with render functions, it is now recommended to always access slots via `$scopedSlots`, whether they currently use a scope or not. This will not only make future refactors to add a scope simpler, but also ease your eventual migration to Vue 3, where all slots will be functions.\n\n- **See also:**\n  - [`<slot>` Component](#slot)\n  - [Scoped Slots](../guide/components.html#Scoped-Slots)\n  - [Render Functions - Slots](../guide/render-function.html#Slots)\n\n### vm.$refs\n\n- **Type:** `Object`\n\n- **Read only**\n\n- **Details:**\n\n  An object of DOM elements and component instances, registered with [`ref` attributes](#ref).\n\n- **See also:**\n  - [Child Component Refs](../guide/components.html#Child-Component-Refs)\n  - [Special Attributes - ref](#ref)\n\n### vm.$isServer\n\n- **Type:** `boolean`\n\n- **Read only**\n\n- **Details:**\n\n  Whether the current Vue instance is running on the server.\n\n- **See also:** [Server-Side Rendering](../guide/ssr.html)\n\n### vm.$attrs\n\n> New in 2.4.0+\n\n- **Type:** `{ [key: string]: string }`\n\n- **Read only**\n\n- **Details:**\n\n  Contains parent-scope attribute bindings (except for `class` and `style`) that are not recognized (and extracted) as props. When a component doesn't have any declared props, this essentially contains all parent-scope bindings (except for `class` and `style`), and can be passed down to an inner component via `v-bind=\"$attrs\"` - useful when creating higher-order components.\n\n### vm.$listeners\n\n> New in 2.4.0+\n\n- **Type:** `{ [key: string]: Function | Array<Function> }`\n\n- **Read only**\n\n- **Details:**\n\n  Contains parent-scope `v-on` event listeners (without `.native` modifiers). This can be passed down to an inner component via `v-on=\"$listeners\"` - useful when creating transparent wrapper components.\n\n## Instance Methods / Data\n\n### vm.$watch( expOrFn, callback, [options] )\n\n- **Arguments:**\n  - `{string | Function} expOrFn`\n  - `{Function | Object} callback`\n  - `{Object} [options]`\n    - `{boolean} deep`\n    - `{boolean} immediate`\n\n- **Returns:** `{Function} unwatch`\n\n- **Usage:**\n\n  Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.\n\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn't keep a copy of the pre-mutate value.</p>\n\n- **Example:**\n\n  ``` js\n  // keypath\n  vm.$watch('a.b.c', function (newVal, oldVal) {\n    // do something\n  })\n\n  // function\n  vm.$watch(\n    function () {\n      // every time the expression `this.a + this.b` yields a different result,\n      // the handler will be called. It's as if we were watching a computed\n      // property without defining the computed property itself\n      return this.a + this.b\n    },\n    function (newVal, oldVal) {\n      // do something\n    }\n  )\n  ```\n\n  `vm.$watch` returns an unwatch function that stops firing the callback:\n\n  ``` js\n  var unwatch = vm.$watch('a', cb)\n  // later, teardown the watcher\n  unwatch()\n  ```\n\n- **Option: deep**\n\n  To also detect nested value changes inside Objects, you need to pass in `deep: true` in the options argument. Note that you don't need to do so to listen for Array mutations.\n\n  ``` js\n  vm.$watch('someObject', callback, {\n    deep: true\n  })\n  vm.someObject.nestedValue = 123\n  // callback is fired\n  ```\n\n- **Option: immediate**\n\n  Passing in `immediate: true` in the option will trigger the callback immediately with the current value of the expression:\n\n  ``` js\n  vm.$watch('a', callback, {\n    immediate: true\n  })\n  // `callback` is fired immediately with current value of `a`\n  ```\n\n  Note that with `immediate` option you won't be able to unwatch the given property on the first callback call.\n\n  ``` js\n  // This will cause an error\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      unwatch()\n    },\n    { immediate: true }\n  )\n  ```\n\n  If you still want to call an unwatch function inside the callback, you should check its availability first:\n\n  ``` js\n  var unwatch = vm.$watch(\n    'value',\n    function () {\n      doSomething()\n      if (unwatch) {\n        unwatch()\n      }\n    },\n    { immediate: true }\n  )\n  ```\n\n### vm.$set( target, propertyName/index, value )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n  - `{any} value`\n\n- **Returns:** the set value.\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.set`.\n\n- **See also:** [Vue.set](#Vue-set)\n\n### vm.$delete( target, propertyName/index )\n\n- **Arguments:**\n  - `{Object | Array} target`\n  - `{string | number} propertyName/index`\n\n- **Usage:**\n\n  This is the **alias** of the global `Vue.delete`.\n\n- **See also:** [Vue.delete](#Vue-delete)\n\n## Instance Methods / Events\n\n### vm.$on( event, callback )\n\n- **Arguments:**\n  - `{string | Array<string>} event` (array only supported in 2.2.0+)\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event on the current vm. Events can be triggered by `vm.$emit`. The callback will receive all the additional arguments passed into these event-triggering methods.\n\n- **Example:**\n\n  ``` js\n  vm.$on('test', function (msg) {\n    console.log(msg)\n  })\n  vm.$emit('test', 'hi')\n  // => \"hi\"\n  ```\n\n### vm.$once( event, callback )\n\n- **Arguments:**\n  - `{string} event`\n  - `{Function} callback`\n\n- **Usage:**\n\n  Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.\n\n### vm.$off( [event, callback] )\n\n- **Arguments:**\n  - `{string | Array<string>} event` (array only supported in 2.2.2+)\n  - `{Function} [callback]`\n\n- **Usage:**\n\n  Remove custom event listener(s).\n\n  - If no arguments are provided, remove all event listeners;\n\n  - If only the event is provided, remove all listeners for that event;\n\n  - If both event and callback are given, remove the listener for that specific callback only.\n\n### vm.$emit( eventName, [...args] )\n\n- **Arguments:**\n  - `{string} eventName`\n  - `[...args]`\n\n  Trigger an event on the current instance. Any additional arguments will be passed into the listener's callback function.\n\n- **Examples:**\n\n  Using `$emit` with only an event name:\n\n  ```js\n  Vue.component('welcome-button', {\n    template: `\n      <button v-on:click=\"$emit('welcome')\">\n        Click me to be welcomed\n      </button>\n    `\n  })\n  ```\n  ```html\n  <div id=\"emit-example-simple\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  ```\n  ```js\n  new Vue({\n    el: '#emit-example-simple',\n    methods: {\n      sayHi: function () {\n        alert('Hi!')\n      }\n    }\n  })\n  ```\n  {% raw %}\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n  Using `$emit` with additional arguments:\n\n  ```js\n  Vue.component('magic-eight-ball', {\n    data: function () {\n      return {\n        possibleAdvice: ['Yes', 'No', 'Maybe']\n      }\n    },\n    methods: {\n      giveAdvice: function () {\n        var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n        this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n      }\n    },\n    template: `\n      <button v-on:click=\"giveAdvice\">\n        Click me for advice\n      </button>\n    `\n  })\n  ```\n\n  ```html\n  <div id=\"emit-example-argument\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  ```\n\n  ```js\n  new Vue({\n    el: '#emit-example-argument',\n    methods: {\n      showAdvice: function (advice) {\n        alert(advice)\n      }\n    }\n  })\n  ```\n\n  {% raw %}\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  {% endraw %}\n\n## Instance Methods / Lifecycle\n\n### vm.$mount( [elementOrSelector] )\n\n- **Arguments:**\n  - `{Element | string} [elementOrSelector]`\n  - `{boolean} [hydrating]`\n\n- **Returns:** `vm` - the instance itself\n\n- **Usage:**\n\n  If a Vue instance didn't receive the `el` option at instantiation, it will be in \"unmounted\" state, without an associated DOM element. `vm.$mount()` can be used to manually start the mounting of an unmounted Vue instance.\n\n  If `elementOrSelector` argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.\n\n  The method returns the instance itself so you can chain other instance methods after it.\n\n- **Example:**\n\n  ``` js\n  var MyComponent = Vue.extend({\n    template: '<div>Hello!</div>'\n  })\n\n  // create and mount to #app (will replace #app)\n  new MyComponent().$mount('#app')\n\n  // the above is the same as:\n  new MyComponent({ el: '#app' })\n\n  // or, render off-document and append afterwards:\n  var component = new MyComponent().$mount()\n  document.getElementById('app').appendChild(component.$el)\n  ```\n\n- **See also:**\n  - [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n  - [Server-Side Rendering](../guide/ssr.html)\n\n### vm.$forceUpdate()\n\n- **Usage:**\n\n  Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.\n\n### vm.$nextTick( [callback] )\n\n- **Arguments:**\n  - `{Function} [callback]`\n\n- **Usage:**\n\n  Defer the callback to be executed after the next DOM update cycle. Use it immediately after you've changed some data to wait for the DOM update. This is the same as the global `Vue.nextTick`, except that the callback's `this` context is automatically bound to the instance calling this method.\n\n  > New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don't support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.\n\n- **Example:**\n\n  ``` js\n  new Vue({\n    // ...\n    methods: {\n      // ...\n      example: function () {\n        // modify data\n        this.message = 'changed'\n        // DOM is not updated yet\n        this.$nextTick(function () {\n          // DOM is now updated\n          // `this` is bound to the current instance\n          this.doSomethingElse()\n        })\n      }\n    }\n  })\n  ```\n\n- **See also:**\n  - [Vue.nextTick](#Vue-nextTick)\n  - [Async Update Queue](../guide/reactivity.html#Async-Update-Queue)\n\n### vm.$destroy()\n\n- **Usage:**\n\n  Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.\n\n  Triggers the `beforeDestroy` and `destroyed` hooks.\n\n  <p class=\"tip\">In normal use cases you shouldn't have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using `v-if` and `v-for`.</p>\n\n- **See also:** [Lifecycle Diagram](../guide/instance.html#Lifecycle-Diagram)\n\n## Directives\n\n### v-text\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `textContent`. If you need to update the part of `textContent`, you should use `{% raw %}{{ Mustache }}{% endraw %}` interpolations.\n\n- **Example:**\n\n  ```html\n  <span v-text=\"msg\"></span>\n  <!-- same as -->\n  <span>{{msg}}</span>\n  ```\n\n- **See also:** [Data Binding Syntax - Interpolations](../guide/syntax.html#Text)\n\n### v-html\n\n- **Expects:** `string`\n\n- **Details:**\n\n  Updates the element's `innerHTML`. **Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates**. If you find yourself trying to compose templates using `v-html`, try to rethink the solution by using components instead.\n\n  <p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to [XSS attacks](https://en.wikipedia.org/wiki/Cross-site_scripting). Only use `v-html` on trusted content and **never** on user-provided content.</p>\n\n  <p class=\"tip\">In [single-file components](../guide/single-file-components.html), `scoped` styles will not apply to content inside `v-html`, because that HTML is not processed by Vue's template compiler. If you want to target `v-html` content with scoped CSS, you can instead use [CSS modules](https://vue-loader.vuejs.org/en/features/css-modules.html) or an additional, global `<style>` element with a manual scoping strategy such as BEM.</p>\n\n- **Example:**\n\n  ```html\n  <div v-html=\"html\"></div>\n  ```\n\n- **See also:** [Data Binding Syntax - Interpolations](../guide/syntax.html#Raw-HTML)\n\n### v-show\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Toggles the element's `display` CSS property based on the truthy-ness of the expression value.\n\n  This directive triggers transitions when its condition changes.\n\n- **See also:** [Conditional Rendering - v-show](../guide/conditional.html#v-show)\n\n### v-if\n\n- **Expects:** `any`\n\n- **Usage:**\n\n  Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a `<template>` element, its content will be extracted as the conditional block.\n\n  This directive triggers transitions when its condition changes.\n\n  <p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n\n- **See also:** [Conditional Rendering - v-if](../guide/conditional.html)\n\n### v-else\n\n- **Does not expect expression**\n\n- **Restriction:** previous sibling element must have `v-if` or `v-else-if`.\n\n- **Usage:**\n\n  Denote the \"else block\" for `v-if` or a `v-if`/`v-else-if` chain.\n\n  ```html\n  <div v-if=\"Math.random() > 0.5\">\n    Now you see me\n  </div>\n  <div v-else>\n    Now you don't\n  </div>\n  ```\n\n- **See also:** [Conditional Rendering - v-else](../guide/conditional.html#v-else)\n\n### v-else-if\n\n> New in 2.1.0+\n\n- **Expects:** `any`\n\n- **Restriction:** previous sibling element must have `v-if` or `v-else-if`.\n\n- **Usage:**\n\n  Denote the \"else if block\" for `v-if`. Can be chained.\n\n  ```html\n  <div v-if=\"type === 'A'\">\n    A\n  </div>\n  <div v-else-if=\"type === 'B'\">\n    B\n  </div>\n  <div v-else-if=\"type === 'C'\">\n    C\n  </div>\n  <div v-else>\n    Not A/B/C\n  </div>\n  ```\n\n- **See also:** [Conditional Rendering - v-else-if](../guide/conditional.html#v-else-if)\n\n### v-for\n\n- **Expects:** `Array | Object | number | string | Iterable (since 2.6)`\n\n- **Usage:**\n\n  Render the element or template block multiple times based on the source data. The directive's value must use the special syntax `alias in expression` to provide an alias for the current element being iterated on:\n\n  ``` html\n  <div v-for=\"item in items\">\n    {{ item.text }}\n  </div>\n  ```\n\n  Alternatively, you can also specify an alias for the index (or the key if used on an Object):\n\n  ``` html\n  <div v-for=\"(item, index) in items\"></div>\n  <div v-for=\"(val, key) in object\"></div>\n  <div v-for=\"(val, name, index) in object\"></div>\n  ```\n\n  The default behavior of `v-for` will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the `key` special attribute:\n\n  ``` html\n  <div v-for=\"item in items\" :key=\"item.id\">\n    {{ item.text }}\n  </div>\n  ```\n\n  In 2.6+, `v-for` can also work on values that implement the [Iterable Protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol), including native `Map` and `Set`. However, it should be noted that Vue 2.x currently does not support reactivity on `Map` and `Set` values, so cannot automatically detect changes.\n\n  <p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n\n  The detailed usage for `v-for` is explained in the guide section linked below.\n\n- **See also:**\n  - [List Rendering](../guide/list.html)\n  - [key](../guide/list.html#key)\n\n### v-on\n\n- **Shorthand:** `@`\n\n- **Expects:** `Function | Inline Statement | Object`\n\n- **Argument:** `event`\n\n- **Modifiers:**\n  - `.stop` - call `event.stopPropagation()`.\n  - `.prevent` - call `event.preventDefault()`.\n  - `.capture` - add event listener in capture mode.\n  - `.self` - only trigger handler if event was dispatched from this element.\n  - `.{keyCode | keyAlias}` - only trigger handler on certain keys.\n  - `.native` - listen for a native event on the root element of component.\n  - `.once` - trigger handler at most once.\n  - `.left` - (2.2.0+) only trigger handler for left button mouse events.\n  - `.right` - (2.2.0+) only trigger handler for right button mouse events.\n  - `.middle` - (2.2.0+) only trigger handler for middle button mouse events.\n  - `.passive` - (2.3.0+) attaches a DOM event with `{ passive: true }`.\n\n- **Usage:**\n\n  Attaches an event listener to the element. The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.\n\n  When used on a normal element, it listens to [**native DOM events**](https://developer.mozilla.org/en-US/docs/Web/Events) only. When used on a custom element component, it listens to **custom events** emitted on that child component.\n\n  When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special `$event` property: `v-on:click=\"handle('ok', $event)\"`.\n\n  Starting in 2.4.0+, `v-on` also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.\n\n- **Example:**\n\n  ```html\n  <!-- method handler -->\n  <button v-on:click=\"doThis\"></button>\n\n  <!-- dynamic event (2.6.0+) -->\n  <button v-on:[event]=\"doThis\"></button>\n\n  <!-- inline statement -->\n  <button v-on:click=\"doThat('hello', $event)\"></button>\n\n  <!-- shorthand -->\n  <button @click=\"doThis\"></button>\n\n  <!-- shorthand dynamic event (2.6.0+) -->\n  <button @[event]=\"doThis\"></button>\n\n  <!-- stop propagation -->\n  <button @click.stop=\"doThis\"></button>\n\n  <!-- prevent default -->\n  <button @click.prevent=\"doThis\"></button>\n\n  <!-- prevent default without expression -->\n  <form @submit.prevent></form>\n\n  <!-- chain modifiers -->\n  <button @click.stop.prevent=\"doThis\"></button>\n\n  <!-- key modifier using keyAlias -->\n  <input @keyup.enter=\"onEnter\">\n\n  <!-- key modifier using keyCode -->\n  <input @keyup.13=\"onEnter\">\n\n  <!-- the click event will be triggered at most once -->\n  <button v-on:click.once=\"doThis\"></button>\n\n  <!-- object syntax (2.4.0+) -->\n  <button v-on=\"{ mousedown: doThis, mouseup: doThat }\"></button>\n  ```\n\n  Listening to custom events on a child component (the handler is called when \"my-event\" is emitted on the child):\n\n  ```html\n  <my-component @my-event=\"handleThis\"></my-component>\n\n  <!-- inline statement -->\n  <my-component @my-event=\"handleThis(123, $event)\"></my-component>\n\n  <!-- native event on component -->\n  <my-component @click.native=\"onClick\"></my-component>\n  ```\n\n- **See also:**\n  - [Event Handling](../guide/events.html)\n  - [Components - Custom Events](../guide/components.html#Custom-Events)\n\n### v-bind\n\n- **Shorthand:** `:`\n\n- **Expects:** `any (with argument) | Object (without argument)`\n\n- **Argument:** `attrOrProp (optional)`\n\n- **Modifiers:**\n  - `.prop` - Bind as a DOM property instead of an attribute ([what's the difference?](https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028)). If the tag is a component then `.prop` will set the property on the component's `$el`.\n  - `.camel` - (2.1.0+) transform the kebab-case attribute name into camelCase.\n  - `.sync` - (2.3.0+) a syntax sugar that expands into a `v-on` handler for updating the bound value.\n\n- **Usage:**\n\n  Dynamically bind one or more attributes, or a component prop to an expression.\n\n  When used to bind the `class` or `style` attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.\n\n  When used for prop binding, the prop must be properly declared in the child component.\n\n  When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode `class` and `style` does not support Array or Objects.\n\n- **Example:**\n\n  ```html\n  <!-- bind an attribute -->\n  <img v-bind:src=\"imageSrc\">\n\n  <!-- dynamic attribute name (2.6.0+) -->\n  <button v-bind:[key]=\"value\"></button>\n\n  <!-- shorthand -->\n  <img :src=\"imageSrc\">\n\n  <!-- shorthand dynamic attribute name (2.6.0+) -->\n  <button :[key]=\"value\"></button>\n\n  <!-- with inline string concatenation -->\n  <img :src=\"'/path/to/images/' + fileName\">\n\n  <!-- class binding -->\n  <div :class=\"{ red: isRed }\"></div>\n  <div :class=\"[classA, classB]\"></div>\n  <div :class=\"[classA, { classB: isB, classC: isC }]\">\n\n  <!-- style binding -->\n  <div :style=\"{ fontSize: size + 'px' }\"></div>\n  <div :style=\"[styleObjectA, styleObjectB]\"></div>\n\n  <!-- binding an object of attributes -->\n  <div v-bind=\"{ id: someProp, 'other-attr': otherProp }\"></div>\n\n  <!-- DOM attribute binding with prop modifier -->\n  <div v-bind:text-content.prop=\"text\"></div>\n\n  <!-- prop binding. \"prop\" must be declared in my-component. -->\n  <my-component :prop=\"someThing\"></my-component>\n\n  <!-- pass down parent props in common with a child component -->\n  <child-component v-bind=\"$props\"></child-component>\n\n  <!-- XLink -->\n  <svg><a :xlink:special=\"foo\"></a></svg>\n  ```\n\n  The `.camel` modifier allows camelizing a `v-bind` attribute name when using in-DOM templates, e.g. the SVG `viewBox` attribute:\n\n  ``` html\n  <svg :view-box.camel=\"viewBox\"></svg>\n  ```\n\n  `.camel` is not needed if you are using string templates, or compiling with `vue-loader`/`vueify`.\n\n- **See also:**\n  - [Class and Style Bindings](../guide/class-and-style.html)\n  - [Components - Props](../guide/components.html#Props)\n  - [Components - `.sync` Modifier](../guide/components.html#sync-Modifier)\n\n### v-model\n\n- **Expects:** varies based on value of form inputs element or output of components\n\n- **Limited to:**\n  - `<input>`\n  - `<select>`\n  - `<textarea>`\n  - components\n\n- **Modifiers:**\n  - [`.lazy`](../guide/forms.html#lazy) - listen to `change` events instead of `input`\n  - [`.number`](../guide/forms.html#number) - cast valid input string to numbers\n  - [`.trim`](../guide/forms.html#trim) - trim input\n\n- **Usage:**\n\n  Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below.\n\n- **See also:**\n  - [Form Input Bindings](../guide/forms.html)\n  - [Components - Form Input Components using Custom Events](../guide/components.html#Form-Input-Components-using-Custom-Events)\n\n### v-slot\n\n- **Shorthand:** `#`\n\n- **Expects:** JavaScript expression that is valid in a function argument position (supports destructuring in [supported environments](../guide/components-slots.html#Slot-Props-Destructuring)). Optional - only needed if expecting props to be passed to the slot.\n\n- **Argument:** slot name (optional, defaults to `default`)\n\n- **Limited to:**\n  - `<template>`\n  - [components](../guide/components-slots.html#Abbreviated-Syntax-for-Lone-Default-Slots) (for a lone default slot with props)\n\n- **Usage:**\n\n  Denote named slots or slots that expect to receive props.\n\n- **Example:**\n\n  ```html\n  <!-- Named slots -->\n  <base-layout>\n    <template v-slot:header>\n      Header content\n    </template>\n\n    Default slot content\n\n    <template v-slot:footer>\n      Footer content\n    </template>\n  </base-layout>\n\n  <!-- Named slot that receives props -->\n  <infinite-scroll>\n    <template v-slot:item=\"slotProps\">\n      <div class=\"item\">\n        {{ slotProps.item.text }}\n      </div>\n    </template>\n  </infinite-scroll>\n\n  <!-- Default slot that receive props, with destructuring -->\n  <mouse-position v-slot=\"{ x, y }\">\n    Mouse position: {{ x }}, {{ y }}\n  </mouse-position>\n  ```\n\n  For more details, see the links below.\n\n- **See also:**\n  - [Components - Slots](../guide/components-slots.html)\n  - [RFC-0001](https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md)\n\n### v-pre\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.\n\n- **Example:**\n\n  ```html\n  <span v-pre>{{ this will not be compiled }}</span>\n   ```\n\n### v-cloak\n\n- **Does not expect expression**\n\n- **Usage:**\n\n  This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as `[v-cloak] { display: none }`, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.\n\n- **Example:**\n\n  ```css\n  [v-cloak] {\n    display: none;\n  }\n  ```\n\n  ```html\n  <div v-cloak>\n    {{ message }}\n  </div>\n  ```\n\n  The `<div>` will not be visible until the compilation is done.\n\n### v-once\n\n- **Does not expect expression**\n\n- **Details:**\n\n  Render the element and component **once** only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.\n\n  ```html\n  <!-- single element -->\n  <span v-once>This will never change: {{msg}}</span>\n  <!-- the element have children -->\n  <div v-once>\n    <h1>comment</h1>\n    <p>{{msg}}</p>\n  </div>\n  <!-- component -->\n  <my-component v-once :comment=\"msg\"></my-component>\n  <!-- `v-for` directive -->\n  <ul>\n    <li v-for=\"i in list\" v-once>{{i}}</li>\n  </ul>\n  ```\n\n- **See also:**\n  - [Data Binding Syntax - interpolations](../guide/syntax.html#Text)\n  - [Components - Cheap Static Components with `v-once`](../guide/components.html#Cheap-Static-Components-with-v-once)\n\n## Special Attributes\n\n### key\n\n- **Expects:** `number | string | boolean (since 2.4.2) | symbol (since 2.5.12)`\n\n  The `key` special attribute is primarily used as a hint for Vue's virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.\n\n  Children of the same common parent must have **unique keys**. Duplicate keys will cause render errors.\n\n  The most common use case is combined with `v-for`:\n\n  ``` html\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">...</li>\n  </ul>\n  ```\n\n  It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:\n\n  - Properly trigger lifecycle hooks of a component\n  - Trigger transitions\n\n  For example:\n\n  ``` html\n  <transition>\n    <span :key=\"text\">{{ text }}</span>\n  </transition>\n  ```\n\n  When `text` changes, the `<span>` will always be replaced instead of patched, so a transition will be triggered.\n\n### ref\n\n- **Expects:** `string`\n\n  `ref` is used to register a reference to an element or a child component. The reference will be registered under the parent component's `$refs` object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:\n\n  ``` html\n  <!-- vm.$refs.p will be the DOM node -->\n  <p ref=\"p\">hello</p>\n\n  <!-- vm.$refs.child will be the child component instance -->\n  <child-component ref=\"child\"></child-component>\n  ```\n\n  When used on elements/components with `v-for`, the registered reference will be an Array containing DOM nodes or component instances.\n\n  An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don't exist yet! `$refs` is also non-reactive, therefore you should not attempt to use it in templates for data-binding.\n\n- **See also:** [Child Component Refs](../guide/components.html#Child-Component-Refs)\n\n### is\n\n- **Expects:** `string | Object (component’s options object)`\n\n  Used for [dynamic components](../guide/components.html#Dynamic-Components) and to work around [limitations of in-DOM templates](../guide/components.html#DOM-Template-Parsing-Caveats).\n\n  For example:\n\n  ``` html\n  <!-- component changes when currentView changes -->\n  <component v-bind:is=\"currentView\"></component>\n\n  <!-- necessary because `<my-row>` would be invalid inside -->\n  <!-- a `<table>` element and so would be hoisted out      -->\n  <table>\n    <tr is=\"my-row\"></tr>\n  </table>\n  ```\n\n  For detailed usage, follow the links in the description above.\n\n- **See also:**\n  - [Dynamic Components](../guide/components.html#Dynamic-Components)\n  - [DOM Template Parsing Caveats](../guide/components.html#DOM-Template-Parsing-Caveats)\n\n### slot <sup style=\"color:#c92222\">deprecated</sup>\n\n**Prefer [v-slot](#v-slot) in 2.6.0+.**\n\n- **Expects:** `string`\n\n  Used on content inserted into child components to indicate which named slot the content belongs to.\n\n- **See also:** [Named Slots with `slot`](../guide/components.html#Named-Slots-with-slot)\n\n### slot-scope <sup style=\"color:#c92222\">deprecated</sup>\n\n**Prefer [v-slot](#v-slot) in 2.6.0+.**\n\n- **Expects:** `function argument expression`\n\n- **Usage:**\n\n  Used to denote an element or component as a scoped slot. The attribute's value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for [`scope`](#scope-replaced) in 2.5.0+.\n\n  This attribute does not support dynamic binding.\n\n- **See also:** [Scoped Slots with `slot-scope`](../guide/components.html#Scoped-Slots-with-slot-scope)\n\n### scope <sup style=\"color:#c92222\">removed</sup>\n\n**Replaced by [slot-scope](#slot-scope) in 2.5.0+. Prefer [v-slot](#v-slot) in 2.6.0+.**\n\nUsed to denote a `<template>` element as a scoped slot.\n\n- **Usage:**\n\n  Same as [`slot-scope`](#slot-scope) except that `scope` can only be used on `<template>` elements.\n\n## Built-In Components\n\n### component\n\n- **Props:**\n  - `is` - string | ComponentDefinition | ComponentConstructor\n  - `inline-template` - boolean\n\n- **Usage:**\n\n  A \"meta component\" for rendering dynamic components. The actual component to render is determined by the `is` prop:\n\n  ```html\n  <!-- a dynamic component controlled by -->\n  <!-- the `componentId` property on the vm -->\n  <component :is=\"componentId\"></component>\n\n  <!-- can also render registered component or component passed as prop -->\n  <component :is=\"$options.components.child\"></component>\n  ```\n\n- **See also:** [Dynamic Components](../guide/components.html#Dynamic-Components)\n\n### transition\n\n- **Props:**\n  - `name` - string, Used to automatically generate transition CSS class names. e.g. `name: 'fade'` will auto expand to `.fade-enter`, `.fade-enter-active`, etc. Defaults to `\"v\"`.\n  - `appear` - boolean, Whether to apply transition on initial render. Defaults to `false`.\n  - `css` - boolean, Whether to apply CSS transition classes. Defaults to `true`. If set to `false`, will only trigger JavaScript hooks registered via component events.\n  - `type` - string, Specifies the type of transition events to wait for to determine transition end timing. Available values are `\"transition\"` and `\"animation\"`. By default, it will automatically detect the type that has a longer duration.\n  - `mode` - string, Controls the timing sequence of leaving/entering transitions. Available modes are `\"out-in\"` and `\"in-out\"`; defaults to simultaneous.\n  - `duration` - number | { `enter`: number, `leave`: number }, Specifies the duration of transition. By default, Vue waits for the first `transitionend` or `animationend` event on the root transition element.\n  - `enter-class` - string\n  - `leave-class` - string\n  - `appear-class` - string\n  - `enter-to-class` - string\n  - `leave-to-class` - string\n  - `appear-to-class` - string\n  - `enter-active-class` - string\n  - `leave-active-class` - string\n  - `appear-active-class` - string\n\n- **Events:**\n  - `before-enter`\n  - `before-leave`\n  - `before-appear`\n  - `enter`\n  - `leave`\n  - `appear`\n  - `after-enter`\n  - `after-leave`\n  - `after-appear`\n  - `enter-cancelled`\n  - `leave-cancelled` (`v-show` only)\n  - `appear-cancelled`\n\n- **Usage:**\n\n  `<transition>` serve as transition effects for **single** element/component. The `<transition>` only applies the transition behavior to the wrapped content inside; it doesn't render an extra DOM element, or show up in the inspected component hierarchy.\n\n  ```html\n  <!-- simple element -->\n  <transition>\n    <div v-if=\"ok\">toggled content</div>\n  </transition>\n\n  <!-- dynamic component -->\n  <transition name=\"fade\" mode=\"out-in\" appear>\n    <component :is=\"view\"></component>\n  </transition>\n\n  <!-- event hooking -->\n  <div id=\"transition-demo\">\n    <transition @after-enter=\"transitionComplete\">\n      <div v-show=\"ok\">toggled content</div>\n    </transition>\n  </div>\n  ```\n\n  ``` js\n  new Vue({\n    ...\n    methods: {\n      transitionComplete: function (el) {\n        // for passed 'el' that DOM element as the argument, something ...\n      }\n    }\n    ...\n  }).$mount('#transition-demo')\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### transition-group\n\n- **Props:**\n  - `tag` - string, defaults to `span`.\n  - `move-class` - overwrite CSS class applied during moving transition.\n  - exposes the same props as `<transition>` except `mode`.\n\n- **Events:**\n  - exposes the same events as `<transition>`.\n\n- **Usage:**\n\n  `<transition-group>` serve as transition effects for **multiple** elements/components. The `<transition-group>` renders a real DOM element. By default it renders a `<span>`, and you can configure what element it should render via the `tag` attribute.\n\n  Note that every child in a `<transition-group>` must be **uniquely keyed** for the animations to work properly.\n\n  `<transition-group>` supports moving transitions via CSS transform. When a child's position on screen has changed after an update, it will get applied a moving CSS class (auto generated from the `name` attribute or configured with the `move-class` attribute). If the CSS `transform` property is \"transition-able\" when the moving class is applied, the element will be smoothly animated to its destination using the [FLIP technique](https://aerotwist.com/blog/flip-your-animations/).\n\n  ```html\n  <transition-group tag=\"ul\" name=\"slide\">\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </transition-group>\n  ```\n\n- **See also:** [Transitions: Entering, Leaving, and Lists](../guide/transitions.html)\n\n### keep-alive\n\n- **Props:**\n  - `include` - string or RegExp or Array. Only components with matching names will be cached.\n  - `exclude` - string or RegExp or Array. Any component with a matching name will not be cached.\n  - `max` - number. The maximum number of component instances to cache.\n\n- **Usage:**\n\n  When wrapped around a dynamic component, `<keep-alive>` caches the inactive component instances without destroying them. Similar to `<transition>`, `<keep-alive>` is an abstract component: it doesn't render a DOM element itself, and doesn't show up in the component parent chain.\n\n  When a component is toggled inside `<keep-alive>`, its `activated` and `deactivated` lifecycle hooks will be invoked accordingly.\n\n  > In 2.2.0+ and above, `activated` and `deactivated` will fire for all nested components inside a `<keep-alive>` tree.\n\n  Primarily used to preserve component state or avoid re-rendering.\n\n  ```html\n  <!-- basic -->\n  <keep-alive>\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- multiple conditional children -->\n  <keep-alive>\n    <comp-a v-if=\"a > 1\"></comp-a>\n    <comp-b v-else></comp-b>\n  </keep-alive>\n\n  <!-- used together with `<transition>` -->\n  <transition>\n    <keep-alive>\n      <component :is=\"view\"></component>\n    </keep-alive>\n  </transition>\n  ```\n\n  Note, `<keep-alive>` is designed for the case where it has one direct child component that is being toggled. It does not work if you have `v-for` inside it. When there are multiple conditional children, as above, `<keep-alive>` requires that only one child is rendered at a time.\n\n- **`include` and `exclude`**\n\n  > New in 2.1.0+\n\n  The `include` and `exclude` props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:\n\n  ``` html\n  <!-- comma-delimited string -->\n  <keep-alive include=\"a,b\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- regex (use `v-bind`) -->\n  <keep-alive :include=\"/a|b/\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n\n  <!-- Array (use `v-bind`) -->\n  <keep-alive :include=\"['a', 'b']\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  The match is first checked on the component's own `name` option, then its local registration name (the key in the parent's `components` option) if the `name` option is not available. Anonymous components cannot be matched against.\n\n- **`max`**\n\n  > New in 2.5.0+\n\n  The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.\n\n  ``` html\n  <keep-alive :max=\"10\">\n    <component :is=\"view\"></component>\n  </keep-alive>\n  ```\n\n  <p class=\"tip\">`<keep-alive>` does not work with functional components because they do not have instances to be cached.</p>\n\n- **See also:** [Dynamic Components - keep-alive](../guide/components.html#keep-alive)\n\n### slot\n\n- **Props:**\n  - `name` - string, Used for named slot.\n\n- **Usage:**\n\n  `<slot>` serve as content distribution outlets in component templates. `<slot>` itself will be replaced.\n\n  For detailed usage, see the guide section linked below.\n\n- **See also:** [Content Distribution with Slots](../guide/components.html#Content-Distribution-with-Slots)\n\n## VNode Interface\n\n- Please refer to the [VNode class declaration](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).\n\n## Server-Side Rendering\n\n- Please refer to the [vue-server-renderer package documentation](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).\n","date":"2020-09-25T23:55:41.097Z","updated":"2020-09-25T23:55:41.097Z","path":"v2/api/index.html","comments":1,"layout":"page","_id":"ckfl66gyq002nc2v5f7n7h0z0","content":"<h2 id=\"Global-Config\"><a href=\"#Global-Config\" class=\"headerlink\" title=\"Global Config\"></a>Global Config</h2><p><code>Vue.config</code> is an object containing Vue’s global configurations. You can modify its properties listed below before bootstrapping your application:</p>\n<h3 id=\"silent\"><a href=\"#silent\" class=\"headerlink\" title=\"silent\"></a>silent</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>false</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.silent = <span class=\"hljs-literal\">true</span></code></pre>\n<p>Suppress all Vue logs and warnings.</p>\n</li>\n</ul>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.optionMergeStrategies._my_option = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">parent, child, vm</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> child + <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">_my_option</span>: <span class=\"hljs-number\">1</span>\n&#125;)\n\n<span class=\"hljs-comment\">// Profile.options._my_option = 2</span></code></pre>\n<p>Define custom merging strategies for options.</p>\n<p>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Custom-Option-Merge-Strategies\">Custom Option Merging Strategies</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code> (<code>false</code> in production builds)</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// make sure to set this synchronously immediately after loading Vue</span>\nVue.config.devtools = <span class=\"hljs-literal\">true</span></code></pre>\n<p>Configure whether to allow <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> inspection. This option’s default value is <code>true</code> in development builds and <code>false</code> in production builds. You can set it to <code>true</code> to enable inspection for production builds.</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>undefined</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.errorHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, vm, info</span>) </span>&#123;\n  <span class=\"hljs-comment\">// handle error</span>\n  <span class=\"hljs-comment\">// `info` is a Vue-specific error info, e.g. which lifecycle hook</span>\n  <span class=\"hljs-comment\">// the error was found in. Only available in 2.2.0+</span>\n&#125;</code></pre>\n<p>Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the Vue instance.</p>\n<blockquote>\n<p>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is <code>undefined</code>, captured errors will be logged with <code>console.error</code> instead of crashing the app.</p>\n</blockquote>\n<blockquote>\n<p>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</p>\n</blockquote>\n<blockquote>\n<p>In 2.6.0+, this hook also captures errors thrown inside <code>v-on</code> DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</p>\n</blockquote>\n<blockquote>\n<p>Error tracking services <a href=\"https://sentry.io/for/vue/\" target=\"_blank\" rel=\"noopener\">Sentry</a> and <a href=\"https://docs.bugsnag.com/platforms/browsers/vue/\" target=\"_blank\" rel=\"noopener\">Bugsnag</a> provide official integrations using this option.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"warnHandler\"><a href=\"#warnHandler\" class=\"headerlink\" title=\"warnHandler\"></a>warnHandler</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>undefined</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.warnHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg, vm, trace</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `trace` is the component hierarchy trace</span>\n&#125;</code></pre>\n<p>Assign a custom handler for runtime Vue warnings. Note this only works during development and is ignored in production.</p>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string | RegExp&gt;</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>[]</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.ignoredElements = [\n  'my-custom-web-component',\n  'another-web-component',\n  // Use a `RegExp` to ignore all elements that start with \"ion-\"\n  // 2.5+ only\n  /^ion-/\n]</code></pre>\n<p>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an <code>Unknown custom element</code>, assuming that you forgot to register a global component or misspelled a component name.</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.keyCodes = &#123;\n  <span class=\"hljs-attr\">v</span>: <span class=\"hljs-number\">86</span>,\n  <span class=\"hljs-attr\">f1</span>: <span class=\"hljs-number\">112</span>,\n  <span class=\"hljs-comment\">// camelCase won`t work</span>\n  <span class=\"hljs-attr\">mediaPlayPause</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-comment\">// instead you can use kebab-case with double quotation marks</span>\n  <span class=\"hljs-string\">\"media-play-pause\"</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-attr\">up</span>: [<span class=\"hljs-number\">38</span>, <span class=\"hljs-number\">87</span>]\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> @<span class=\"hljs-attr\">keyup.media-play-pause</span>=<span class=\"hljs-string\">\"method\"</span>&gt;</span></code></pre>\n<p>Define custom key alias(es) for <code>v-on</code>.</p>\n</li>\n</ul>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>false (from 2.2.3+)</code></p>\n</li>\n<li><p><strong>Usage</strong>:</p>\n<p>Set this to <code>true</code> to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\" target=\"_blank\" rel=\"noopener\">performance.mark</a> API.</p>\n</li>\n</ul>\n<h3 id=\"productionTip\"><a href=\"#productionTip\" class=\"headerlink\" title=\"productionTip\"></a>productionTip</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code></p>\n</li>\n<li><p><strong>Usage</strong>:</p>\n<p>Set this to <code>false</code> to prevent the production tip on Vue startup.</p>\n</li>\n</ul>\n<h2 id=\"Global-API\"><a href=\"#Global-API\" class=\"headerlink\" title=\"Global API\"></a>Global API</h2><h3 id=\"Vue-extend-options\"><a href=\"#Vue-extend-options\" class=\"headerlink\" title=\"Vue.extend( options )\"></a>Vue.extend( options )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a “subclass” of the base Vue constructor. The argument should be an object containing component options.</p>\n<p>The special case to note here is the <code>data</code> option - it must be a function when used with <code>Vue.extend()</code>.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"mount-point\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// create constructor</span>\n<span class=\"hljs-keyword\">var</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Walter'</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'White'</span>,\n      <span class=\"hljs-attr\">alias</span>: <span class=\"hljs-string\">'Heisenberg'</span>\n    &#125;\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// create an instance of Profile and mount it on an element</span>\n<span class=\"hljs-keyword\">new</span> Profile().$mount(<span class=\"hljs-string\">'#mount-point'</span>)</code></pre>\n<p>Will result in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick-callback-context\"><a href=\"#Vue-nextTick-callback-context\" class=\"headerlink\" title=\"Vue.nextTick( [callback, context] )\"></a>Vue.nextTick( [callback, context] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// modify data</span>\nvm.msg = <span class=\"hljs-string\">'Hello'</span>\n<span class=\"hljs-comment\">// DOM not updated yet</span>\nVue.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// DOM updated</span>\n&#125;)\n\n<span class=\"hljs-comment\">// usage as a promise (2.1.0+, see note below)</span>\nVue.nextTick()\n  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// DOM updated</span>\n  &#125;)</code></pre>\n<blockquote>\n<p>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don’t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</p>\n</blockquote>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set-target-propertyName-index-value\"><a href=\"#Vue-set-target-propertyName-index-value\" class=\"headerlink\" title=\"Vue.set( target, propertyName/index, value )\"></a>Vue.set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates. This must be used to add new properties to reactive objects, as Vue cannot detect normal property additions (e.g. <code>this.myObject.newProperty = &#39;hi&#39;</code>).</p>\n<p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-delete-target-propertyName-index\"><a href=\"#Vue-delete-target-propertyName-index\" class=\"headerlink\" title=\"Vue.delete( target, propertyName/index )\"></a>Vue.delete( target, propertyName/index )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n<blockquote>\n<p>Only in 2.2.0+: Also works with Array + index.</p>\n</blockquote>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</p>\n<p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive-id-definition\"><a href=\"#Vue-directive-id-definition\" class=\"headerlink\" title=\"Vue.directive( id, [definition] )\"></a>Vue.directive( id, [definition] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global directive.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// register</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">componentUpdated</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">unbind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n&#125;)\n\n<span class=\"hljs-comment\">// register (function directive)</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// this will be called as `bind` and `update`</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter, return the directive definition if registered</span>\n<span class=\"hljs-keyword\">var</span> myDirective = Vue.directive(<span class=\"hljs-string\">'my-directive'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/custom-directive.html\">Custom Directives</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter-id-definition\"><a href=\"#Vue-filter-id-definition\" class=\"headerlink\" title=\"Vue.filter( id, [definition] )\"></a>Vue.filter( id, [definition] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global filter.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// register</span>\nVue.filter(<span class=\"hljs-string\">'my-filter'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-comment\">// return processed value</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter, return the filter if registered</span>\n<span class=\"hljs-keyword\">var</span> myFilter = Vue.filter(<span class=\"hljs-string\">'my-filter'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/filters.html\">Filters</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-component-id-definition\"><a href=\"#Vue-component-id-definition\" class=\"headerlink\" title=\"Vue.component( id, [definition] )\"></a>Vue.component( id, [definition] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global component. Registration also automatically sets the component’s <code>name</code> with the given <code>id</code>.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// register an extended constructor</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, Vue.extend(&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;))\n\n<span class=\"hljs-comment\">// register an options object (automatically call Vue.extend)</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\n\n<span class=\"hljs-comment\">// retrieve a registered component (always return constructor)</span>\n<span class=\"hljs-keyword\">var</span> MyComponent = Vue.component(<span class=\"hljs-string\">'my-component'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use-plugin\"><a href=\"#Vue-use-plugin\" class=\"headerlink\" title=\"Vue.use( plugin )\"></a>Vue.use( plugin )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</p>\n<p>This method has to be called before calling <code>new Vue()</code></p>\n<p>When this method is called on the same plugin multiple times, the plugin will be installed only once.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/plugins.html\">Plugins</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin-mixin\"><a href=\"#Vue-mixin-mixin\" class=\"headerlink\" title=\"Vue.mixin( mixin )\"></a>Vue.mixin( mixin )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. <strong>Not recommended in application code</strong>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Global-Mixin\">Global Mixin</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile-template\"><a href=\"#Vue-compile-template\" class=\"headerlink\" title=\"Vue.compile( template )\"></a>Vue.compile( template )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Compiles a template string into a render function. <strong>Only available in the full build.</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> res = Vue.compile(<span class=\"hljs-string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">render</span>: res.render,\n  <span class=\"hljs-attr\">staticRenderFns</span>: res.staticRenderFns\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-observable-object\"><a href=\"#Vue-observable-object\" class=\"headerlink\" title=\"Vue.observable( object )\"></a>Vue.observable( object )</h3><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Make an object reactive. Internally, Vue uses this on the object returned by the <code>data</code> function.</p>\n<p>The returned object can be used directly inside <a href=\"../guide/render-function.html\">render functions</a> and <a href=\"../guide/computed.html\">computed properties</a>, and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> state = Vue.observable(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> &#125;)\n\n<span class=\"hljs-keyword\">const</span> Demo = &#123;\n  render(h) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'button'</span>, &#123;\n      <span class=\"hljs-attr\">on</span>: &#123; <span class=\"hljs-attr\">click</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123; state.count++ &#125;&#125;\n    &#125;, <span class=\"hljs-string\">`count is: <span class=\"hljs-subst\">$&#123;state.count&#125;</span>`</span>)\n  &#125;\n&#125;</code></pre>\n<p class=\"tip\">In Vue 2.x, <code>Vue.observable</code> directly mutates the object passed to it, so that it is equivalent to the object returned, as <a href=\"../guide/instance.html#Data-and-Methods\">demonstrated here</a>. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by <code>Vue.observable</code>, rather than the object originally passed to it.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-version\"><a href=\"#Vue-version\" class=\"headerlink\" title=\"Vue.version\"></a>Vue.version</h3><ul>\n<li><p><strong>Details</strong>: Provides the installed version of Vue as a string. This is especially useful for community plugins and components, where you might use different strategies for different versions.</p>\n</li>\n<li><p><strong>Usage</strong>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> version = <span class=\"hljs-built_in\">Number</span>(Vue.version.split(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>])\n\n<span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">2</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v2.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">1</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v1.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> &#123;\n  <span class=\"hljs-comment\">// Unsupported versions of Vue</span>\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"Options-Data\"><a href=\"#Options-Data\" class=\"headerlink\" title=\"Options / Data\"></a>Options / Data</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.</p>\n<p>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</p>\n<p>After the instance is created, the original data object can be accessed as <code>vm.$data</code>. The Vue instance also proxies all the properties found on the data object, so <code>vm.a</code> will be equivalent to <code>vm.$data.a</code>.</p>\n<p>Properties that start with <code>_</code> or <code>$</code> will <strong>not</strong> be proxied on the Vue instance because they may conflict with Vue’s internal properties and API methods. You will have to access them as <code>vm.$data._property</code>.</p>\n<p>When defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instances created! By providing a <code>data</code> function, every time a new instance is created we can call it to return a fresh copy of the initial data.</p>\n<p>If required, a deep clone of the original object can be obtained by passing <code>vm.$data</code> through <code>JSON.parse(JSON.stringify(...))</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n\n<span class=\"hljs-comment\">// direct instance creation</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\nvm.a <span class=\"hljs-comment\">// =&gt; 1</span>\nvm.$data === data <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// must use function when in Vue.extend()</span>\n<span class=\"hljs-keyword\">var</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Note that if you use an arrow function with the <code>data</code> property, <code>this</code> won’t be the component’s instance, but you can still access the instance as the function’s first argument:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> (&#123; <span class=\"hljs-attr\">a</span>: vm.myProp &#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A list/hash of attributes that are exposed to accept data from the parent component. It has an Array-based simple syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</p>\n<p>With Object-based syntax, you can use following options:</p>\n<ul>\n<li><code>type</code>: can be one of the following native constructors: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Array</code>, <code>Object</code>, <code>Date</code>, <code>Function</code>, <code>Symbol</code>, any custom constructor function or an array of those. Will check if a prop has a given type, and will throw a warning if it doesn’t. <a href=\"../guide/components-props.html#Prop-Types\">More information</a> on prop types.</li>\n<li><code>default</code>: <code>any</code><br>Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.</li>\n<li><code>required</code>: <code>Boolean</code><br>Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.</li>\n<li><code>validator</code>: <code>Function</code><br>Custom validator function that takes the prop value as the sole argument. In a non-production environment, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails). You can read more about prop validation <a href=\"../guide/components-props.html#Prop-Validation\">here</a>.</li>\n</ul>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// simple syntax</span>\nVue.component(<span class=\"hljs-string\">'props-demo-simple'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'size'</span>, <span class=\"hljs-string\">'myMessage'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// object syntax with validation</span>\nVue.component(<span class=\"hljs-string\">'props-demo-advanced'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// type check</span>\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-comment\">// type check plus other validations</span>\n    <span class=\"hljs-attr\">age</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> value &gt;= <span class=\"hljs-number\">0</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components-props.html\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> Comp = Vue.extend(&#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'msg'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Comp(&#123;\n  <span class=\"hljs-attr\">propsData</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Computed properties to be mixed into the Vue instance. All getters and setters have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p>Note that if you use an arrow function with a computed property, <code>this</code> won’t be the component’s instance, but you can still access the instance as the function’s first argument:</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> vm.a * <span class=\"hljs-number\">2</span>\n&#125;</code></pre>\n<p>Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance’s scope (i.e. not reactive), the computed property will <strong>not</strong> be updated.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-comment\">// get only</span>\n    <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a * <span class=\"hljs-number\">2</span>\n    &#125;,\n    <span class=\"hljs-comment\">// both get and set</span>\n    <span class=\"hljs-attr\">aPlus</span>: &#123;\n      <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-number\">1</span>\n      &#125;,\n      <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">v</span>) </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.a = v - <span class=\"hljs-number\">1</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)\nvm.aPlus   <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aPlus = <span class=\"hljs-number\">3</span>\nvm.a       <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aDouble <span class=\"hljs-comment\">// =&gt; 4</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/computed.html\">Computed Properties</a></p>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a method</strong> (e.g. <code>plus: () =&gt; this.a++</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">plus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.a++\n    &#125;\n  &#125;\n&#125;)\nvm.plus()\nvm.a <span class=\"hljs-comment\">// 2</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/events.html\">Event Handling</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: string | Function | Object | Array}</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call <code>$watch()</code> for each entry in the object at instantiation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>,\n    <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">4</span>,\n    <span class=\"hljs-attr\">e</span>: &#123;\n      <span class=\"hljs-attr\">f</span>: &#123;\n        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-number\">5</span>\n      &#125;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'new: %s, old: %s'</span>, val, oldVal)\n    &#125;,\n    <span class=\"hljs-comment\">// string method name</span>\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">'someMethod'</span>,\n    <span class=\"hljs-comment\">// the callback will be called whenever any of the watched object properties change regardless of their nested depth</span>\n    <span class=\"hljs-attr\">c</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// the callback will be called immediately after the start of the observation</span>\n    <span class=\"hljs-attr\">d</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-string\">'someMethod'</span>,\n      <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// you can pass array of callbacks, they will be called one-by-one</span>\n    <span class=\"hljs-attr\">e</span>: [\n      <span class=\"hljs-string\">'handle1'</span>,\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle2</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      &#123;\n        <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle3</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n        <span class=\"hljs-comment\">/* ... */</span>\n      &#125;\n    ],\n    <span class=\"hljs-comment\">// watch vm.e.f's value: &#123;g: 5&#125;</span>\n    <span class=\"hljs-string\">'e.f'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;\n&#125;)\nvm.a = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// =&gt; new: 2, old: 1</span></code></pre>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a watcher</strong> (e.g. <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.updateAutocomplete</code> will be undefined.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#vm-watch\">Instance Methods / Data - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"Options-DOM\"><a href=\"#Options-DOM\" class=\"headerlink\" title=\"Options / DOM\"></a>Options / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>Type:</strong> <code>string | Element</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p>\n<p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p>\n<p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p>\n<p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p>\n\n<p class=\"tip\">If neither <code>render</code> function nor <code>template</code> option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/installation.html#Runtime-Compiler-vs-Runtime-only\">Runtime + Compiler vs. Runtime-only</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A string template to be used as the markup for the Vue instance. The template will <strong>replace</strong> the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p>\n<p>If the string starts with <code>#</code> it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common <code>&lt;script type=&quot;x-template&quot;&gt;</code> trick to include templates.</p>\n<p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n\n<p class=\"tip\">If render function is present in the Vue option, the template will be ignored.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>Type:</strong> <code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a <code>createElement</code> method as it’s first argument used to create <code>VNode</code>s.</p>\n<p>If the component is a functional component, the render function also receives an extra argument <code>context</code>, which provides access to contextual data since functional components are instance-less.</p>\n<p class=\"tip\">The <code>render</code> function has priority over the render function compiled from <code>template</code> option or in-DOM HTML template of the mounting element which is specified by the <code>el</code> option.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h3 id=\"renderError\"><a href=\"#renderError\" class=\"headerlink\" title=\"renderError\"></a>renderError</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p><strong>Only works in development mode.</strong></p>\n<p>Provide an alternative render output when the default <code>render</code> function encounters an error. The error will be passed to <code>renderError</code> as the second argument. This is particularly useful when used together with hot-reload.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  render (h) &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'oops'</span>)\n  &#125;,\n  renderError (h, err) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'pre'</span>, &#123; <span class=\"hljs-attr\">style</span>: &#123; <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span> &#125;&#125;, err.stack)\n  &#125;\n&#125;).$mount(<span class=\"hljs-string\">'#app'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Lifecycle-Hooks\"><a href=\"#Options-Lifecycle-Hooks\" class=\"headerlink\" title=\"Options / Lifecycle Hooks\"></a>Options / Lifecycle Hooks</h2><p class=\"tip\">All lifecycle hooks automatically have their <code>this</code> context bound to the instance, so that you can access data, computed properties, and methods. This means <strong>you should not use an arrow function to define a lifecycle method</strong> (e.g. <code>created: () =&gt; this.fetchTodos()</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.fetchTodos</code> will be undefined.</p>\n\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously immediately after the instance has been initialized, before data observation and event/watcher setup.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the <code>$el</code> property will not be available yet.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before the mounting begins: the <code>render</code> function is about to be called for the first time.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after the instance has been mounted, where <code>el</code> is replaced by the newly created <code>vm.$el</code>. If the root instance is mounted to an in-document element, <code>vm.$el</code> will also be in-document when <code>mounted</code> is called.</p>\n<p>Note that <code>mounted</code> does <strong>not</strong> guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use <a href=\"#vm-nextTick\">vm.$nextTick</a> inside of <code>mounted</code>:</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when data changes, before the DOM is patched. This is a good place to access the existing DOM before an update, e.g. to remove manually added event listeners.</p>\n<p><strong>This hook is not called during server-side rendering, because only the initial render is performed server-side.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a data change causes the virtual DOM to be re-rendered and patched.</p>\n<p>The component’s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it’s usually better to use a <a href=\"#computed\">computed property</a> or <a href=\"#watch\">watcher</a> instead.</p>\n<p>Note that <code>updated</code> does <strong>not</strong> guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use <a href=\"#vm-nextTick\">vm.$nextTick</a> inside of <code>updated</code>:</p>\n<pre><code class=\"hljs js\">updated: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been re-rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is activated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is deactivated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"errorCaptured\"><a href=\"#errorCaptured\" class=\"headerlink\" title=\"errorCaptured\"></a>errorCaptured</h3><blockquote>\n<p>New in 2.5.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when an error from any descendent component is captured. The hook receives three arguments: the error, the component instance that triggered the error, and a string containing information on where the error was captured. The hook can return <code>false</code> to stop the error from propagating further.</p>\n<p class=\"tip\">You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</p>\n\n<p><strong>Error Propagation Rules</strong></p>\n<ul>\n<li><p>By default, all errors are still sent to the global <code>config.errorHandler</code> if it is defined, so that these errors can still be reported to an analytics service in a single place.</p>\n</li>\n<li><p>If multiple <code>errorCaptured</code> hooks exist on a component’s inheritance chain or parent chain, all of them will be invoked on the same error.</p>\n</li>\n<li><p>If the <code>errorCaptured</code> hook itself throws an error, both this error and the original captured error are sent to the global <code>config.errorHandler</code>.</p>\n</li>\n<li><p>An <code>errorCaptured</code> hook can return <code>false</code> to prevent the error from propagating further. This is essentially saying “this error has been handled and should be ignored.” It will prevent any additional <code>errorCaptured</code> hooks or the global <code>config.errorHandler</code> from being invoked for this error.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Options-Assets\"><a href=\"#Options-Assets\" class=\"headerlink\" title=\"Options / Assets\"></a>Options / Assets</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of directives to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/custom-directive.html\">Custom Directives</a></p>\n</li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of filters to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-filter\"><code>Vue.filter</code></a></p>\n</li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of components to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Composition\"><a href=\"#Options-Composition\" class=\"headerlink\" title=\"Options / Composition\"></a>Options / Composition</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as <code>this.$parent</code> for the child, and the child will be pushed into the parent’s <code>$children</code> array.</p>\n<p class=\"tip\">Use <code>$parent</code> and <code>$children</code> sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in <code>Vue.extend()</code>. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</p>\n<p>Mixin hooks are called in the order they are provided, and called before the component’s own hooks.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>) &#125;\n&#125;\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) &#125;,\n  <span class=\"hljs-attr\">mixins</span>: [mixin]\n&#125;)\n<span class=\"hljs-comment\">// =&gt; 1</span>\n<span class=\"hljs-comment\">// =&gt; 2</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html\">Mixins</a></p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use <code>Vue.extend</code>. This is primarily intended to make it easier to extend between single file components.</p>\n<p>This is similar to <code>mixins</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> CompA = &#123; ... &#125;\n\n<span class=\"hljs-comment\">// extend CompA without having to call `Vue.extend` on either</span>\n<span class=\"hljs-keyword\">var</span> CompB = &#123;\n  <span class=\"hljs-attr\">extends</span>: CompA,\n  ...\n&#125;</code></pre>\n</li>\n</ul>\n<h3 id=\"provide-inject\"><a href=\"#provide-inject\" class=\"headerlink\" title=\"provide / inject\"></a>provide / inject</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong></p>\n<ul>\n<li><strong>provide:</strong> <code>Object | () =&gt; Object</code></li>\n<li><strong>inject:</strong> <code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li>\n</ul>\n</li>\n<li><p><strong>Details:</strong></p>\n<p class=\"tip\"><code>provide</code> and <code>inject</code> are primarily provided for advanced plugin / component library use cases. It is NOT recommended to use them in generic application code.</p>\n\n<p>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React’s context feature.</p>\n<p>The <code>provide</code> option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support <code>Symbol</code> and <code>Reflect.ownKeys</code>.</p>\n<p>The <code>inject</code> option should be either:</p>\n<ul>\n<li>an array of strings, or</li>\n<li>an object where the keys are the local binding name and the value is either:<ul>\n<li>the key (string or Symbol) to search for in available injections, or</li>\n<li>an object where:<ul>\n<li>the <code>from</code> property is the key (string or Symbol) to search for in available injections, and</li>\n<li>the <code>default</code> property is used as fallback value</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Note: the <code>provide</code> and <code>inject</code> bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</p>\n</blockquote>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// parent component providing 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Provider = &#123;\n  <span class=\"hljs-attr\">provide</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// child component injecting 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  created () &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.foo) <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  &#125;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>With ES2015 Symbols, function <code>provide</code> and object <code>inject</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-built_in\">Symbol</span>()\n\n<span class=\"hljs-keyword\">const</span> Provider = &#123;\n  provide () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      [s]: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123; s &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<blockquote>\n<p>The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the <code>props</code> and the <code>data</code> initialization.</p>\n</blockquote>\n<p>Using an injected value as the default for a prop:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: &#123;\n      <span class=\"hljs-keyword\">default</span> () &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.foo\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>Using an injected value as data entry:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-keyword\">this</span>.foo\n    &#125;\n  &#125;\n&#125;</code></pre>\n<blockquote>\n<p>In 2.5.0+ injections can be optional with default value:</p>\n</blockquote>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span> &#125;\n  &#125;\n&#125;</code></pre>\n<p>If it needs to be injected from a property with a different name, use <code>from</code> to denote the source property:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>Similar to prop defaults, you need to use a factory function for non primitive values:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n    &#125;\n  &#125;\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"Options-Misc\"><a href=\"#Options-Misc\" class=\"headerlink\" title=\"Options / Misc\"></a>Options / Misc</h2><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected when used as a component option.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with <code>Vue.component()</code>, the global ID is automatically set as its name.</p>\n<p>Another benefit of specifying a <code>name</code> option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a>, unnamed components will show up as <code>&lt;AnonymousComponent&gt;</code>, which isn’t very informative. By providing the <code>name</code> option, you will get a much more informative component tree.</p>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>Restrictions:</strong> This option is only available in the full build, with in-browser compilation.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Change the plain text interpolation delimiters.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">delimiters</span>: [<span class=\"hljs-string\">'$&#123;'</span>, <span class=\"hljs-string\">'&#125;'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// Delimiters changed to ES6 template string style</span></code></pre>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Causes a component to be stateless (no <code>data</code>) and instanceless (no <code>this</code> context). They are only a <code>render</code> function that returns virtual nodes making them much cheaper to render.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html#Functional-Components\">Functional Components</a></p>\n</li>\n</ul>\n<h3 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h3><blockquote>\n<p>New in 2.2.0</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ prop?: string, event?: string }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allows a custom component to customize the prop and event used when it’s used with <code>v-model</code>. By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> prop for a different purpose. Using the <code>model</code> option can avoid the conflict in such cases.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-checkbox'</span>, &#123;\n  <span class=\"hljs-attr\">model</span>: &#123;\n    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">'checked'</span>,\n    <span class=\"hljs-attr\">event</span>: <span class=\"hljs-string\">'change'</span>\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// this allows using the `value` prop for a different purpose</span>\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-comment\">// use `checked` as the prop which take the place of `value`</span>\n    <span class=\"hljs-attr\">checked</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"foo\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n<p>The above will be equivalent to:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span>\n  <span class=\"hljs-attr\">:checked</span>=<span class=\"hljs-string\">\"foo\"</span>\n  @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">\"val =&gt; &#123; foo = val &#125;\"</span>\n  <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"inheritAttrs\"><a href=\"#inheritAttrs\" class=\"headerlink\" title=\"inheritAttrs\"></a>inheritAttrs</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>By default, parent scope attribute bindings that are not recognized as props will “fallthrough” and be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting <code>inheritAttrs</code> to <code>false</code>, this default behavior can be disabled. The attributes are available via the <code>$attrs</code> instance property (also new in 2.4) and can be explicitly bound to a non-root element using <code>v-bind</code>.</p>\n<p>Note: this option does <strong>not</strong> affect <code>class</code> and <code>style</code> bindings.</p>\n</li>\n</ul>\n<h3 id=\"comments\"><a href=\"#comments\" class=\"headerlink\" title=\"comments\"></a>comments</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>false</code></p>\n</li>\n<li><p><strong>Restrictions:</strong> This option is only available in the full build, with in-browser compilation.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>When set to <code>true</code>, will preserve and render HTML comments found in templates. The default behavior is discarding them.</p>\n</li>\n</ul>\n<h2 id=\"Instance-Properties\"><a href=\"#Instance-Properties\" class=\"headerlink\" title=\"Instance Properties\"></a>Instance Properties</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#data\">Options / Data - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-props\"><a href=\"#vm-props\" class=\"headerlink\" title=\"vm.$props\"></a>vm.$props</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object representing the current props a component has received. The Vue instance proxies access to the properties on its props object.</p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>Type:</strong> <code>Element</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root DOM element that the Vue instance is managing.</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">customOption</span>: <span class=\"hljs-string\">'foo'</span>,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$options.customOption) <span class=\"hljs-comment\">// =&gt; 'foo'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The parent instance, if the current instance has one.</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The direct child components of the current instance. <strong>Note there’s no order guarantee for <code>$children</code>, and it is not reactive.</strong> If you find yourself trying to use <code>$children</code> for data binding, consider using an Array and <code>v-for</code> to generate child components, and use the Array as the source of truth.</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Reactive?</strong> No</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Used to programmatically access content <a href=\"../guide/components.html#Content-Distribution-with-Slots\">distributed by slots</a>. Each <a href=\"../guide/components.html#Named-Slots\">named slot</a> has its own corresponding property (e.g. the contents of <code>v-slot:foo</code> will be found at <code>vm.$slots.foo</code>). The <code>default</code> property contains either nodes not included in a named slot or contents of <code>v-slot:default</code>.</p>\n<p>Please note that slots are <strong>not</strong> reactive. If you need a component to re-render based on changes to data passed to a slot, we suggest considering a different strategy that relies on a reactive instance option, such as <code>props</code> or <code>data</code>.</p>\n<p><strong>Note:</strong> <code>v-slot:foo</code> is supported in v2.6+. For older versions, you can use the <a href=\"../guide/components-slots.html#Deprecated-Syntax\">deprecated syntax</a>.</p>\n<p>Accessing <code>vm.$slots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>About Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Copyright 2016 Evan You<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>.\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> header = <span class=\"hljs-keyword\">this</span>.$slots.header\n    <span class=\"hljs-keyword\">var</span> body   = <span class=\"hljs-keyword\">this</span>.$slots.default\n    <span class=\"hljs-keyword\">var</span> footer = <span class=\"hljs-keyword\">this</span>.$slots.footer\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n      createElement(<span class=\"hljs-string\">'header'</span>, header),\n      createElement(<span class=\"hljs-string\">'main'</span>, body),\n      createElement(<span class=\"hljs-string\">'footer'</span>, footer)\n    ])\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> Component</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render Functions - Slots</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-scopedSlots\"><a href=\"#vm-scopedSlots\" class=\"headerlink\" title=\"vm.$scopedSlots\"></a>vm.$scopedSlots</h3><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ [name: string]: props =&gt; Array&lt;VNode&gt; | undefined }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Used to programmatically access <a href=\"../guide/components.html#Scoped-Slots\">scoped slots</a>. For each slot, including the <code>default</code> one, the object contains a corresponding function that returns VNodes.</p>\n<p>Accessing <code>vm.$scopedSlots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n<p><strong>Note:</strong> since 2.6.0+, there are two notable changes to this property:</p>\n<ol>\n<li><p>Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return <code>undefined</code>.</p>\n</li>\n<li><p>All <code>$slots</code> are now also exposed on <code>$scopedSlots</code> as functions. If you work with render functions, it is now recommended to always access slots via <code>$scopedSlots</code>, whether they currently use a scope or not. This will not only make future refactors to add a scope simpler, but also ease your eventual migration to Vue 3, where all slots will be functions.</p>\n</li>\n</ol>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> Component</a></li>\n<li><a href=\"../guide/components.html#Scoped-Slots\">Scoped Slots</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render Functions - Slots</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object of DOM elements and component instances, registered with <a href=\"#ref\"><code>ref</code> attributes</a>.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></li>\n<li><a href=\"#ref\">Special Attributes - ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Whether the current Vue instance is running on the server.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/ssr.html\">Server-Side Rendering</a></p>\n</li>\n</ul>\n<h3 id=\"vm-attrs\"><a href=\"#vm-attrs\" class=\"headerlink\" title=\"vm.$attrs\"></a>vm.$attrs</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: string }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Contains parent-scope attribute bindings (except for <code>class</code> and <code>style</code>) that are not recognized (and extracted) as props. When a component doesn’t have any declared props, this essentially contains all parent-scope bindings (except for <code>class</code> and <code>style</code>), and can be passed down to an inner component via <code>v-bind=&quot;$attrs&quot;</code> - useful when creating higher-order components.</p>\n</li>\n</ul>\n<h3 id=\"vm-listeners\"><a href=\"#vm-listeners\" class=\"headerlink\" title=\"vm.$listeners\"></a>vm.$listeners</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Contains parent-scope <code>v-on</code> event listeners (without <code>.native</code> modifiers). This can be passed down to an inner component via <code>v-on=&quot;$listeners&quot;</code> - useful when creating transparent wrapper components.</p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Data\"><a href=\"#Instance-Methods-Data\" class=\"headerlink\" title=\"Instance Methods / Data\"></a>Instance Methods / Data</h2><h3 id=\"vm-watch-expOrFn-callback-options\"><a href=\"#vm-watch-expOrFn-callback-options\" class=\"headerlink\" title=\"vm.$watch( expOrFn, callback, [options] )\"></a>vm.$watch( expOrFn, callback, [options] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function | Object} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</p>\n</li>\n</ul>\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn’t keep a copy of the pre-mutate value.</p>\n\n<ul>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// keypath</span>\nvm.$watch(<span class=\"hljs-string\">'a.b.c'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n  <span class=\"hljs-comment\">// do something</span>\n&#125;)\n\n<span class=\"hljs-comment\">// function</span>\nvm.$watch(\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// every time the expression `this.a + this.b` yields a different result,</span>\n    <span class=\"hljs-comment\">// the handler will be called. It's as if we were watching a computed</span>\n    <span class=\"hljs-comment\">// property without defining the computed property itself</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-keyword\">this</span>.b\n  &#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n    <span class=\"hljs-comment\">// do something</span>\n  &#125;\n)</code></pre>\n<p><code>vm.$watch</code> returns an unwatch function that stops firing the callback:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(<span class=\"hljs-string\">'a'</span>, cb)\n<span class=\"hljs-comment\">// later, teardown the watcher</span>\nunwatch()</code></pre>\n</li>\n<li><p><strong>Option: deep</strong></p>\n<p>To also detect nested value changes inside Objects, you need to pass in <code>deep: true</code> in the options argument. Note that you don’t need to do so to listen for Array mutations.</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'someObject'</span>, callback, &#123;\n  <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\nvm.someObject.nestedValue = <span class=\"hljs-number\">123</span>\n<span class=\"hljs-comment\">// callback is fired</span></code></pre>\n</li>\n<li><p><strong>Option: immediate</strong></p>\n<p>Passing in <code>immediate: true</code> in the option will trigger the callback immediately with the current value of the expression:</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'a'</span>, callback, &#123;\n  <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\n<span class=\"hljs-comment\">// `callback` is fired immediately with current value of `a`</span></code></pre>\n<p>Note that with <code>immediate</code> option you won’t be able to unwatch the given property on the first callback call.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// This will cause an error</span>\n<span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    unwatch()\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n<p>If you still want to call an unwatch function inside the callback, you should check its availability first:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    <span class=\"hljs-keyword\">if</span> (unwatch) &#123;\n      unwatch()\n    &#125;\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-set-target-propertyName-index-value\"><a href=\"#vm-set-target-propertyName-index-value\" class=\"headerlink\" title=\"vm.$set( target, propertyName/index, value )\"></a>vm.$set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.set</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete-target-propertyName-index\"><a href=\"#vm-delete-target-propertyName-index\" class=\"headerlink\" title=\"vm.$delete( target, propertyName/index )\"></a>vm.$delete( target, propertyName/index )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.delete</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Events\"><a href=\"#Instance-Methods-Events\" class=\"headerlink\" title=\"Instance Methods / Events\"></a>Instance Methods / Events</h2><h3 id=\"vm-on-event-callback\"><a href=\"#vm-on-event-callback\" class=\"headerlink\" title=\"vm.$on( event, callback )\"></a>vm.$on( event, callback )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (array only supported in 2.2.0+)</li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event on the current vm. Events can be triggered by <code>vm.$emit</code>. The callback will receive all the additional arguments passed into these event-triggering methods.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\">vm.$on(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(msg)\n&#125;)\nvm.$emit(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-string\">'hi'</span>)\n<span class=\"hljs-comment\">// =&gt; \"hi\"</span></code></pre>\n</li>\n</ul>\n<h3 id=\"vm-once-event-callback\"><a href=\"#vm-once-event-callback\" class=\"headerlink\" title=\"vm.$once( event, callback )\"></a>vm.$once( event, callback )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</p>\n</li>\n</ul>\n<h3 id=\"vm-off-event-callback\"><a href=\"#vm-off-event-callback\" class=\"headerlink\" title=\"vm.$off( [event, callback] )\"></a>vm.$off( [event, callback] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (array only supported in 2.2.2+)</li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Remove custom event listener(s).</p>\n<ul>\n<li><p>If no arguments are provided, remove all event listeners;</p>\n</li>\n<li><p>If only the event is provided, remove all listeners for that event;</p>\n</li>\n<li><p>If both event and callback are given, remove the listener for that specific callback only.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit-eventName-…args\"><a href=\"#vm-emit-eventName-…args\" class=\"headerlink\" title=\"vm.$emit( eventName, […args] )\"></a>vm.$emit( eventName, […args] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} eventName</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function.</p>\n</li>\n<li><p><strong>Examples:</strong></p>\n<p>Using <code>$emit</code> with only an event name:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'welcome-button'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"$emit('welcome')\"&gt;\n      Click me to be welcomed\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-simple\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">welcome-button</span> <span class=\"hljs-attr\">v-on:welcome</span>=<span class=\"hljs-string\">\"sayHi\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">welcome-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-simple'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">sayHi</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      alert(<span class=\"hljs-string\">'Hi!'</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  \n<p>Using <code>$emit</code> with additional arguments:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'magic-eight-ball'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">possibleAdvice</span>: [<span class=\"hljs-string\">'Yes'</span>, <span class=\"hljs-string\">'No'</span>, <span class=\"hljs-string\">'Maybe'</span>]\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">giveAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> randomAdviceIndex = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-keyword\">this</span>.possibleAdvice.length)\n      <span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'give-advice'</span>, <span class=\"hljs-keyword\">this</span>.possibleAdvice[randomAdviceIndex])\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"giveAdvice\"&gt;\n      Click me for advice\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-argument\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">magic-eight-ball</span> <span class=\"hljs-attr\">v-on:give-advice</span>=<span class=\"hljs-string\">\"showAdvice\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">magic-eight-ball</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-argument'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">showAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">advice</span>) </span>&#123;\n      alert(advice)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  \n</li>\n</ul>\n<h2 id=\"Instance-Methods-Lifecycle\"><a href=\"#Instance-Methods-Lifecycle\" class=\"headerlink\" title=\"Instance Methods / Lifecycle\"></a>Instance Methods / Lifecycle</h2><h3 id=\"vm-mount-elementOrSelector\"><a href=\"#vm-mount-elementOrSelector\" class=\"headerlink\" title=\"vm.$mount( [elementOrSelector] )\"></a>vm.$mount( [elementOrSelector] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>vm</code> - the instance itself</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>If a Vue instance didn’t receive the <code>el</code> option at instantiation, it will be in “unmounted” state, without an associated DOM element. <code>vm.$mount()</code> can be used to manually start the mounting of an unmounted Vue instance.</p>\n<p>If <code>elementOrSelector</code> argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</p>\n<p>The method returns the instance itself so you can chain other instance methods after it.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> MyComponent = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-comment\">// create and mount to #app (will replace #app)</span>\n<span class=\"hljs-keyword\">new</span> MyComponent().$mount(<span class=\"hljs-string\">'#app'</span>)\n\n<span class=\"hljs-comment\">// the above is the same as:</span>\n<span class=\"hljs-keyword\">new</span> MyComponent(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span> &#125;)\n\n<span class=\"hljs-comment\">// or, render off-document and append afterwards:</span>\n<span class=\"hljs-keyword\">var</span> component = <span class=\"hljs-keyword\">new</span> MyComponent().$mount()\n<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'app'</span>).appendChild(component.$el)</code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/ssr.html\">Server-Side Rendering</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\"><a href=\"#vm-forceUpdate\" class=\"headerlink\" title=\"vm.$forceUpdate()\"></a>vm.$forceUpdate()</h3><ul>\n<li><p><strong>Usage:</strong></p>\n<p>Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick-callback\"><a href=\"#vm-nextTick-callback\" class=\"headerlink\" title=\"vm.$nextTick( [callback] )\"></a>vm.$nextTick( [callback] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. This is the same as the global <code>Vue.nextTick</code>, except that the callback’s <code>this</code> context is automatically bound to the instance calling this method.</p>\n<blockquote>\n<p>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don’t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</p>\n</blockquote>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-attr\">example</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// modify data</span>\n      <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'changed'</span>\n      <span class=\"hljs-comment\">// DOM is not updated yet</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-comment\">// DOM is now updated</span>\n        <span class=\"hljs-comment\">// `this` is bound to the current instance</span>\n        <span class=\"hljs-keyword\">this</span>.doSomethingElse()\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\"><a href=\"#vm-destroy\" class=\"headerlink\" title=\"vm.$destroy()\"></a>vm.$destroy()</h3><ul>\n<li><p><strong>Usage:</strong></p>\n<p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.</p>\n<p>Triggers the <code>beforeDestroy</code> and <code>destroyed</code> hooks.</p>\n<p class=\"tip\">In normal use cases you shouldn’t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using <code>v-if</code> and <code>v-for</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h2 id=\"Directives\"><a href=\"#Directives\" class=\"headerlink\" title=\"Directives\"></a>Directives</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>textContent</code>. If you need to update the part of <code>textContent</code>, you should use <code>{{ Mustache }}</code> interpolations.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-text</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- same as --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Text\">Data Binding Syntax - Interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>innerHTML</code>. <strong>Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates</strong>. If you find yourself trying to compose templates using <code>v-html</code>, try to rethink the solution by using components instead.</p>\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"noopener\">XSS attacks</a>. Only use <code>v-html</code> on trusted content and <strong>never</strong> on user-provided content.</p>\n\n<p class=\"tip\">In <a href=\"../guide/single-file-components.html\">single-file components</a>, <code>scoped</code> styles will not apply to content inside <code>v-html</code>, because that HTML is not processed by Vue’s template compiler. If you want to target <code>v-html</code> content with scoped CSS, you can instead use <a href=\"https://vue-loader.vuejs.org/en/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS modules</a> or an additional, global <code>&lt;style&gt;</code> element with a manual scoping strategy such as BEM.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"html\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Raw-HTML\">Data Binding Syntax - Interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Toggles the element’s <code>display</code> CSS property based on the truthy-ness of the expression value.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-show\">Conditional Rendering - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a <code>&lt;template&gt;</code> element, its content will be extracted as the conditional block.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n<p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html\">Conditional Rendering - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else block” for <code>v-if</code> or a <code>v-if</code>/<code>v-else-if</code> chain.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Now you see me\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Now you don't\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-else\">Conditional Rendering - v-else</a></p>\n</li>\n</ul>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a>v-else-if</h3><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else if block” for <code>v-if</code>. Can be chained.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Not A/B/C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-else-if\">Conditional Rendering - v-else-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>Expects:</strong> <code>Array | Object | number | string | Iterable (since 2.6)</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Render the element or template block multiple times based on the source data. The directive’s value must use the special syntax <code>alias in expression</code> to provide an alias for the current element being iterated on:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, key) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, name, index) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The default behavior of <code>v-for</code> will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the <code>key</code> special attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>In 2.6+, <code>v-for</code> can also work on values that implement the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol\" target=\"_blank\" rel=\"noopener\">Iterable Protocol</a>, including native <code>Map</code> and <code>Set</code>. However, it should be noted that Vue 2.x currently does not support reactivity on <code>Map</code> and <code>Set</code> values, so cannot automatically detect changes.</p>\n<p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n\n<p>The detailed usage for <code>v-for</code> is explained in the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/list.html\">List Rendering</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>@</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>Function | Inline Statement | Object</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>event</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.stop</code> - call <code>event.stopPropagation()</code>.</li>\n<li><code>.prevent</code> - call <code>event.preventDefault()</code>.</li>\n<li><code>.capture</code> - add event listener in capture mode.</li>\n<li><code>.self</code> - only trigger handler if event was dispatched from this element.</li>\n<li><code>.{keyCode | keyAlias}</code> - only trigger handler on certain keys.</li>\n<li><code>.native</code> - listen for a native event on the root element of component.</li>\n<li><code>.once</code> - trigger handler at most once.</li>\n<li><code>.left</code> - (2.2.0+) only trigger handler for left button mouse events.</li>\n<li><code>.right</code> - (2.2.0+) only trigger handler for right button mouse events.</li>\n<li><code>.middle</code> - (2.2.0+) only trigger handler for middle button mouse events.</li>\n<li><code>.passive</code> - (2.3.0+) attaches a DOM event with <code>{ passive: true }</code>.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Attaches an event listener to the element. The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.</p>\n<p>When used on a normal element, it listens to <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\" target=\"_blank\" rel=\"noopener\"><strong>native DOM events</strong></a> only. When used on a custom element component, it listens to <strong>custom events</strong> emitted on that child component.</p>\n<p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>.</p>\n<p>Starting in 2.4.0+, <code>v-on</code> also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- method handler --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- dynamic event (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:</span>[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- inline statement --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand dynamic event (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- stop propagation --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prevent default --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prevent default without expression --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> @<span class=\"hljs-attr\">submit.prevent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- chain modifiers --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- key modifier using keyAlias --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.enter</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- key modifier using keyCode --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.13</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- the click event will be triggered at most once --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.once</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- object syntax (2.4.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"&#123; mousedown: doThis, mouseup: doThat &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Listening to custom events on a child component (the handler is called when “my-event” is emitted on the child):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- inline statement --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- native event on component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">click.native</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/events.html\">Event Handling</a></li>\n<li><a href=\"../guide/components.html#Custom-Events\">Components - Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>:</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.prop</code> - Bind as a DOM property instead of an attribute (<a href=\"https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\" target=\"_blank\" rel=\"noopener\">what’s the difference?</a>). If the tag is a component then <code>.prop</code> will set the property on the component’s <code>$el</code>.</li>\n<li><code>.camel</code> - (2.1.0+) transform the kebab-case attribute name into camelCase.</li>\n<li><code>.sync</code> - (2.3.0+) a syntax sugar that expands into a <code>v-on</code> handler for updating the bound value.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Dynamically bind one or more attributes, or a component prop to an expression.</p>\n<p>When used to bind the <code>class</code> or <code>style</code> attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</p>\n<p>When used for prop binding, the prop must be properly declared in the child component.</p>\n<p>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode <code>class</code> and <code>style</code> does not support Array or Objects.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- bind an attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">v-bind:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- dynamic attribute name (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand dynamic attribute name (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- with inline string concatenation --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"'/path/to/images/' + fileName\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- class binding --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, classB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- style binding --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- binding an object of attributes --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- DOM attribute binding with prop modifier --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:text-content.prop</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prop binding. \"prop\" must be declared in my-component. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">:prop</span>=<span class=\"hljs-string\">\"someThing\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- pass down parent props in common with a child component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"$props\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- XLink --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:xlink:special</span>=<span class=\"hljs-string\">\"foo\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">:view-box.camel</span>=<span class=\"hljs-string\">\"viewBox\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p><code>.camel</code> is not needed if you are using string templates, or compiling with <code>vue-loader</code>/<code>vueify</code>.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class and Style Bindings</a></li>\n<li><a href=\"../guide/components.html#Props\">Components - Props</a></li>\n<li><a href=\"../guide/components.html#sync-Modifier\">Components - <code>.sync</code> Modifier</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>Expects:</strong> varies based on value of form inputs element or output of components</p>\n</li>\n<li><p><strong>Limited to:</strong></p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - listen to <code>change</code> events instead of <code>input</code></li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - cast valid input string to numbers</li>\n<li><a href=\"../guide/forms.html#trim\"><code>.trim</code></a> - trim input</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html\">Form Input Bindings</a></li>\n<li><a href=\"../guide/components.html#Form-Input-Components-using-Custom-Events\">Components - Form Input Components using Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-slot\"><a href=\"#v-slot\" class=\"headerlink\" title=\"v-slot\"></a>v-slot</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>#</code></p>\n</li>\n<li><p><strong>Expects:</strong> JavaScript expression that is valid in a function argument position (supports destructuring in <a href=\"../guide/components-slots.html#Slot-Props-Destructuring\">supported environments</a>). Optional - only needed if expecting props to be passed to the slot.</p>\n</li>\n<li><p><strong>Argument:</strong> slot name (optional, defaults to <code>default</code>)</p>\n</li>\n<li><p><strong>Limited to:</strong></p>\n<ul>\n<li><code>&lt;template&gt;</code></li>\n<li><a href=\"../guide/components-slots.html#Abbreviated-Syntax-for-Lone-Default-Slots\">components</a> (for a lone default slot with props)</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote named slots or slots that expect to receive props.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Named slots --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    Header content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  Default slot content\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    Footer content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Named slot that receives props --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span>&gt;</span>\n      &#123;&#123; slotProps.item.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Default slot that receive props, with destructuring --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mouse-position</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; x, y &#125;\"</span>&gt;</span>\n  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mouse-position</span>&gt;</span></code></pre>\n<p>For more details, see the links below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components-slots.html\">Components - Slots</a></li>\n<li><a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC-0001</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[v-cloak]</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: none;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-cloak</span>&gt;</span>\n  &#123;&#123; message &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Render the element and component <strong>once</strong> only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- single element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- the element have children --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>comment<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-once</span> <span class=\"hljs-attr\">:comment</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- `v-for` directive --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in list\"</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/syntax.html#Text\">Data Binding Syntax - interpolations</a></li>\n<li><a href=\"../guide/components.html#Cheap-Static-Components-with-v-once\">Components - Cheap Static Components with <code>v-once</code></a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Special-Attributes\"><a href=\"#Special-Attributes\" class=\"headerlink\" title=\"Special Attributes\"></a>Special Attributes</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>Expects:</strong> <code>number | string | boolean (since 2.4.2) | symbol (since 2.5.12)</code></p>\n<p>The <code>key</code> special attribute is primarily used as a hint for Vue’s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</p>\n<p>Children of the same common parent must have <strong>unique keys</strong>. Duplicate keys will cause render errors.</p>\n<p>The most common use case is combined with <code>v-for</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</p>\n<ul>\n<li>Properly trigger lifecycle hooks of a component</li>\n<li>Trigger transitions</li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>When <code>text</code> changes, the <code>&lt;span&gt;</code> will always be replaced instead of patched, so a transition will be triggered.</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p><code>ref</code> is used to register a reference to an element or a child component. The reference will be registered under the parent component’s <code>$refs</code> object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- vm.$refs.p will be the DOM node --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"p\"</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- vm.$refs.child will be the child component instance --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span></code></pre>\n<p>When used on elements/components with <code>v-for</code>, the registered reference will be an Array containing DOM nodes or component instances.</p>\n<p>An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don’t exist yet! <code>$refs</code> is also non-reactive, therefore you should not attempt to use it in templates for data-binding.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></p>\n</li>\n</ul>\n<h3 id=\"is\"><a href=\"#is\" class=\"headerlink\" title=\"is\"></a>is</h3><ul>\n<li><p><strong>Expects:</strong> <code>string | Object (component’s options object)</code></p>\n<p>Used for <a href=\"../guide/components.html#Dynamic-Components\">dynamic components</a> and to work around <a href=\"../guide/components.html#DOM-Template-Parsing-Caveats\">limitations of in-DOM templates</a>.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- component changes when currentView changes --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentView\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- necessary because `&lt;my-row&gt;` would be invalid inside --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- a `&lt;table&gt;` element and so would be hoisted out      --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"my-row\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>For detailed usage, follow the links in the description above.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Dynamic-Components\">Dynamic Components</a></li>\n<li><a href=\"../guide/components.html#DOM-Template-Parsing-Caveats\">DOM Template Parsing Caveats</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"slot-deprecated\"><a href=\"#slot-deprecated\" class=\"headerlink\" title=\"slot deprecated\"></a>slot <sup style=\"color:#c92222\">deprecated</sup></h3><p><strong>Prefer <a href=\"#v-slot\">v-slot</a> in 2.6.0+.</strong></p>\n<ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p>Used on content inserted into child components to indicate which named slot the content belongs to.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Named-Slots-with-slot\">Named Slots with <code>slot</code></a></p>\n</li>\n</ul>\n<h3 id=\"slot-scope-deprecated\"><a href=\"#slot-scope-deprecated\" class=\"headerlink\" title=\"slot-scope deprecated\"></a>slot-scope <sup style=\"color:#c92222\">deprecated</sup></h3><p><strong>Prefer <a href=\"#v-slot\">v-slot</a> in 2.6.0+.</strong></p>\n<ul>\n<li><p><strong>Expects:</strong> <code>function argument expression</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Used to denote an element or component as a scoped slot. The attribute’s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for <a href=\"#scope-replaced\"><code>scope</code></a> in 2.5.0+.</p>\n<p>This attribute does not support dynamic binding.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Scoped-Slots-with-slot-scope\">Scoped Slots with <code>slot-scope</code></a></p>\n</li>\n</ul>\n<h3 id=\"scope-removed\"><a href=\"#scope-removed\" class=\"headerlink\" title=\"scope removed\"></a>scope <sup style=\"color:#c92222\">removed</sup></h3><p><strong>Replaced by <a href=\"#slot-scope\">slot-scope</a> in 2.5.0+. Prefer <a href=\"#v-slot\">v-slot</a> in 2.6.0+.</strong></p>\n<p>Used to denote a <code>&lt;template&gt;</code> element as a scoped slot.</p>\n<ul>\n<li><p><strong>Usage:</strong></p>\n<p>Same as <a href=\"#slot-scope\"><code>slot-scope</code></a> except that <code>scope</code> can only be used on <code>&lt;template&gt;</code> elements.</p>\n</li>\n</ul>\n<h2 id=\"Built-In-Components\"><a href=\"#Built-In-Components\" class=\"headerlink\" title=\"Built-In Components\"></a>Built-In Components</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>A “meta component” for rendering dynamic components. The actual component to render is determined by the <code>is</code> prop:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- a dynamic component controlled by --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- the `componentId` property on the vm --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"componentId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- can also render registered component or component passed as prop --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"$options.components.child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Dynamic-Components\">Dynamic Components</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used to automatically generate transition CSS class names. e.g. <code>name: &#39;fade&#39;</code> will auto expand to <code>.fade-enter</code>, <code>.fade-enter-active</code>, etc. Defaults to <code>&quot;v&quot;</code>.</li>\n<li><code>appear</code> - boolean, Whether to apply transition on initial render. Defaults to <code>false</code>.</li>\n<li><code>css</code> - boolean, Whether to apply CSS transition classes. Defaults to <code>true</code>. If set to <code>false</code>, will only trigger JavaScript hooks registered via component events.</li>\n<li><code>type</code> - string, Specifies the type of transition events to wait for to determine transition end timing. Available values are <code>&quot;transition&quot;</code> and <code>&quot;animation&quot;</code>. By default, it will automatically detect the type that has a longer duration.</li>\n<li><code>mode</code> - string, Controls the timing sequence of leaving/entering transitions. Available modes are <code>&quot;out-in&quot;</code> and <code>&quot;in-out&quot;</code>; defaults to simultaneous.</li>\n<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number }, Specifies the duration of transition. By default, Vue waits for the first <code>transitionend</code> or <code>animationend</code> event on the root transition element.</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>enter-to-class</code> - string</li>\n<li><code>leave-to-class</code> - string</li>\n<li><code>appear-to-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>enter</code></li>\n<li><code>leave</code></li>\n<li><code>appear</code></li>\n<li><code>after-enter</code></li>\n<li><code>after-leave</code></li>\n<li><code>after-appear</code></li>\n<li><code>enter-cancelled</code></li>\n<li><code>leave-cancelled</code> (<code>v-show</code> only)</li>\n<li><code>appear-cancelled</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition&gt;</code> serve as transition effects for <strong>single</strong> element/component. The <code>&lt;transition&gt;</code> only applies the transition behavior to the wrapped content inside; it doesn’t render an extra DOM element, or show up in the inspected component hierarchy.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- simple element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- dynamic component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"fade\"</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">\"out-in\"</span> <span class=\"hljs-attr\">appear</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- event hooking --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transition-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> @<span class=\"hljs-attr\">after-enter</span>=<span class=\"hljs-string\">\"transitionComplete\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  ...\n  methods: &#123;\n    <span class=\"hljs-attr\">transitionComplete</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n      <span class=\"hljs-comment\">// for passed 'el' that DOM element as the argument, something ...</span>\n    &#125;\n  &#125;\n  ...\n&#125;).$mount(<span class=\"hljs-string\">'#transition-demo'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>tag</code> - string, defaults to <code>span</code>.</li>\n<li><code>move-class</code> - overwrite CSS class applied during moving transition.</li>\n<li>exposes the same props as <code>&lt;transition&gt;</code> except <code>mode</code>.</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li>exposes the same events as <code>&lt;transition&gt;</code>.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition-group&gt;</code> serve as transition effects for <strong>multiple</strong> elements/components. The <code>&lt;transition-group&gt;</code> renders a real DOM element. By default it renders a <code>&lt;span&gt;</code>, and you can configure what element it should render via the <code>tag</code> attribute.</p>\n<p>Note that every child in a <code>&lt;transition-group&gt;</code> must be <strong>uniquely keyed</strong> for the animations to work properly.</p>\n<p><code>&lt;transition-group&gt;</code> supports moving transitions via CSS transform. When a child’s position on screen has changed after an update, it will get applied a moving CSS class (auto generated from the <code>name</code> attribute or configured with the <code>move-class</code> attribute). If the CSS <code>transform</code> property is “transition-able” when the moving class is applied, the element will be smoothly animated to its destination using the <a href=\"https://aerotwist.com/blog/flip-your-animations/\" target=\"_blank\" rel=\"noopener\">FLIP technique</a>.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition-group</span> <span class=\"hljs-attr\">tag</span>=<span class=\"hljs-string\">\"ul\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"slide\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n    &#123;&#123; item.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition-group</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>include</code> - string or RegExp or Array. Only components with matching names will be cached.</li>\n<li><code>exclude</code> - string or RegExp or Array. Any component with a matching name will not be cached.</li>\n<li><code>max</code> - number. The maximum number of component instances to cache.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>When wrapped around a dynamic component, <code>&lt;keep-alive&gt;</code> caches the inactive component instances without destroying them. Similar to <code>&lt;transition&gt;</code>, <code>&lt;keep-alive&gt;</code> is an abstract component: it doesn’t render a DOM element itself, and doesn’t show up in the component parent chain.</p>\n<p>When a component is toggled inside <code>&lt;keep-alive&gt;</code>, its <code>activated</code> and <code>deactivated</code> lifecycle hooks will be invoked accordingly.</p>\n<blockquote>\n<p>In 2.2.0+ and above, <code>activated</code> and <code>deactivated</code> will fire for all nested components inside a <code>&lt;keep-alive&gt;</code> tree.</p>\n</blockquote>\n<p>Primarily used to preserve component state or avoid re-rendering.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- basic --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- multiple conditional children --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-a</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"a &gt; 1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-a</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-b</span> <span class=\"hljs-attr\">v-else</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-b</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- used together with `&lt;transition&gt;` --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>Note, <code>&lt;keep-alive&gt;</code> is designed for the case where it has one direct child component that is being toggled. It does not work if you have <code>v-for</code> inside it. When there are multiple conditional children, as above, <code>&lt;keep-alive&gt;</code> requires that only one child is rendered at a time.</p>\n</li>\n<li><p><strong><code>include</code> and <code>exclude</code></strong></p>\n<blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<p>The <code>include</code> and <code>exclude</code> props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- comma-delimited string --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">include</span>=<span class=\"hljs-string\">\"a,b\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- regex (use `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"/a|b/\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Array (use `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"['a', 'b']\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>The match is first checked on the component’s own <code>name</code> option, then its local registration name (the key in the parent’s <code>components</code> option) if the <code>name</code> option is not available. Anonymous components cannot be matched against.</p>\n</li>\n<li><p><strong><code>max</code></strong></p>\n<blockquote>\n<p>New in 2.5.0+</p>\n</blockquote>\n<p>The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:max</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> does not work with functional components because they do not have instances to be cached.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used for named slot.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;slot&gt;</code> serve as content distribution outlets in component templates. <code>&lt;slot&gt;</code> itself will be replaced.</p>\n<p>For detailed usage, see the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></p>\n</li>\n</ul>\n<h2 id=\"VNode-Interface\"><a href=\"#VNode-Interface\" class=\"headerlink\" title=\"VNode Interface\"></a>VNode Interface</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"noopener\">VNode class declaration</a>.</li>\n</ul>\n<h2 id=\"Server-Side-Rendering\"><a href=\"#Server-Side-Rendering\" class=\"headerlink\" title=\"Server-Side Rendering\"></a>Server-Side Rendering</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\" target=\"_blank\" rel=\"noopener\">vue-server-renderer package documentation</a>.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Global-Config\"><a href=\"#Global-Config\" class=\"headerlink\" title=\"Global Config\"></a>Global Config</h2><p><code>Vue.config</code> is an object containing Vue’s global configurations. You can modify its properties listed below before bootstrapping your application:</p>\n<h3 id=\"silent\"><a href=\"#silent\" class=\"headerlink\" title=\"silent\"></a>silent</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>false</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.silent = <span class=\"hljs-literal\">true</span></code></pre>\n<p>Suppress all Vue logs and warnings.</p>\n</li>\n</ul>\n<h3 id=\"optionMergeStrategies\"><a href=\"#optionMergeStrategies\" class=\"headerlink\" title=\"optionMergeStrategies\"></a>optionMergeStrategies</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.optionMergeStrategies._my_option = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">parent, child, vm</span>) </span>&#123;\n  <span class=\"hljs-keyword\">return</span> child + <span class=\"hljs-number\">1</span>\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">_my_option</span>: <span class=\"hljs-number\">1</span>\n&#125;)\n\n<span class=\"hljs-comment\">// Profile.options._my_option = 2</span></code></pre>\n<p>Define custom merging strategies for options.</p>\n<p>The merge strategy receives the value of that option defined on the parent and child instances as the first and second arguments, respectively. The context Vue instance is passed as the third argument.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Custom-Option-Merge-Strategies\">Custom Option Merging Strategies</a></p>\n</li>\n</ul>\n<h3 id=\"devtools\"><a href=\"#devtools\" class=\"headerlink\" title=\"devtools\"></a>devtools</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code> (<code>false</code> in production builds)</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// make sure to set this synchronously immediately after loading Vue</span>\nVue.config.devtools = <span class=\"hljs-literal\">true</span></code></pre>\n<p>Configure whether to allow <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> inspection. This option’s default value is <code>true</code> in development builds and <code>false</code> in production builds. You can set it to <code>true</code> to enable inspection for production builds.</p>\n</li>\n</ul>\n<h3 id=\"errorHandler\"><a href=\"#errorHandler\" class=\"headerlink\" title=\"errorHandler\"></a>errorHandler</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>undefined</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.errorHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">err, vm, info</span>) </span>&#123;\n  <span class=\"hljs-comment\">// handle error</span>\n  <span class=\"hljs-comment\">// `info` is a Vue-specific error info, e.g. which lifecycle hook</span>\n  <span class=\"hljs-comment\">// the error was found in. Only available in 2.2.0+</span>\n&#125;</code></pre>\n<p>Assign a handler for uncaught errors during component render function and watchers. The handler gets called with the error and the Vue instance.</p>\n<blockquote>\n<p>In 2.2.0+, this hook also captures errors in component lifecycle hooks. Also, when this hook is <code>undefined</code>, captured errors will be logged with <code>console.error</code> instead of crashing the app.</p>\n</blockquote>\n<blockquote>\n<p>In 2.4.0+, this hook also captures errors thrown inside Vue custom event handlers.</p>\n</blockquote>\n<blockquote>\n<p>In 2.6.0+, this hook also captures errors thrown inside <code>v-on</code> DOM listeners. In addition, if any of the covered hooks or handlers returns a Promise chain (e.g. async functions), the error from that Promise chain will also be handled.</p>\n</blockquote>\n<blockquote>\n<p>Error tracking services <a href=\"https://sentry.io/for/vue/\" target=\"_blank\" rel=\"noopener\">Sentry</a> and <a href=\"https://docs.bugsnag.com/platforms/browsers/vue/\" target=\"_blank\" rel=\"noopener\">Bugsnag</a> provide official integrations using this option.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"warnHandler\"><a href=\"#warnHandler\" class=\"headerlink\" title=\"warnHandler\"></a>warnHandler</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>undefined</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.warnHandler = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg, vm, trace</span>) </span>&#123;\n  <span class=\"hljs-comment\">// `trace` is the component hierarchy trace</span>\n&#125;</code></pre>\n<p>Assign a custom handler for runtime Vue warnings. Note this only works during development and is ignored in production.</p>\n</li>\n</ul>\n<h3 id=\"ignoredElements\"><a href=\"#ignoredElements\" class=\"headerlink\" title=\"ignoredElements\"></a>ignoredElements</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string | RegExp&gt;</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>[]</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.ignoredElements = [\n  'my-custom-web-component',\n  'another-web-component',\n  // Use a `RegExp` to ignore all elements that start with \"ion-\"\n  // 2.5+ only\n  /^ion-/\n]</code></pre>\n<p>Make Vue ignore custom elements defined outside of Vue (e.g., using the Web Components APIs). Otherwise, it will throw a warning about an <code>Unknown custom element</code>, assuming that you forgot to register a global component or misspelled a component name.</p>\n</li>\n</ul>\n<h3 id=\"keyCodes\"><a href=\"#keyCodes\" class=\"headerlink\" title=\"keyCodes\"></a>keyCodes</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>{}</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<pre><code class=\"hljs js\">Vue.config.keyCodes = &#123;\n  <span class=\"hljs-attr\">v</span>: <span class=\"hljs-number\">86</span>,\n  <span class=\"hljs-attr\">f1</span>: <span class=\"hljs-number\">112</span>,\n  <span class=\"hljs-comment\">// camelCase won`t work</span>\n  <span class=\"hljs-attr\">mediaPlayPause</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-comment\">// instead you can use kebab-case with double quotation marks</span>\n  <span class=\"hljs-string\">\"media-play-pause\"</span>: <span class=\"hljs-number\">179</span>,\n  <span class=\"hljs-attr\">up</span>: [<span class=\"hljs-number\">38</span>, <span class=\"hljs-number\">87</span>]\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"text\"</span> @<span class=\"hljs-attr\">keyup.media-play-pause</span>=<span class=\"hljs-string\">\"method\"</span>&gt;</span></code></pre>\n<p>Define custom key alias(es) for <code>v-on</code>.</p>\n</li>\n</ul>\n<h3 id=\"performance\"><a href=\"#performance\" class=\"headerlink\" title=\"performance\"></a>performance</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>false (from 2.2.3+)</code></p>\n</li>\n<li><p><strong>Usage</strong>:</p>\n<p>Set this to <code>true</code> to enable component init, compile, render and patch performance tracing in the browser devtool performance/timeline panel. Only works in development mode and in browsers that support the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark\" target=\"_blank\" rel=\"noopener\">performance.mark</a> API.</p>\n</li>\n</ul>\n<h3 id=\"productionTip\"><a href=\"#productionTip\" class=\"headerlink\" title=\"productionTip\"></a>productionTip</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code></p>\n</li>\n<li><p><strong>Usage</strong>:</p>\n<p>Set this to <code>false</code> to prevent the production tip on Vue startup.</p>\n</li>\n</ul>\n<h2 id=\"Global-API\"><a href=\"#Global-API\" class=\"headerlink\" title=\"Global API\"></a>Global API</h2><h3 id=\"Vue-extend-options\"><a href=\"#Vue-extend-options\" class=\"headerlink\" title=\"Vue.extend( options )\"></a>Vue.extend( options )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} options</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a “subclass” of the base Vue constructor. The argument should be an object containing component options.</p>\n<p>The special case to note here is the <code>data</code> option - it must be a function when used with <code>Vue.extend()</code>.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"mount-point\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// create constructor</span>\n<span class=\"hljs-keyword\">var</span> Profile = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">'Walter'</span>,\n      <span class=\"hljs-attr\">lastName</span>: <span class=\"hljs-string\">'White'</span>,\n      <span class=\"hljs-attr\">alias</span>: <span class=\"hljs-string\">'Heisenberg'</span>\n    &#125;\n  &#125;\n&#125;)\n<span class=\"hljs-comment\">// create an instance of Profile and mount it on an element</span>\n<span class=\"hljs-keyword\">new</span> Profile().$mount(<span class=\"hljs-string\">'#mount-point'</span>)</code></pre>\n<p>Will result in:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Walter White aka Heisenberg<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-nextTick-callback-context\"><a href=\"#Vue-nextTick-callback-context\" class=\"headerlink\" title=\"Vue.nextTick( [callback, context] )\"></a>Vue.nextTick( [callback, context] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n<li><code>{Object} [context]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// modify data</span>\nvm.msg = <span class=\"hljs-string\">'Hello'</span>\n<span class=\"hljs-comment\">// DOM not updated yet</span>\nVue.nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// DOM updated</span>\n&#125;)\n\n<span class=\"hljs-comment\">// usage as a promise (2.1.0+, see note below)</span>\nVue.nextTick()\n  .then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// DOM updated</span>\n  &#125;)</code></pre>\n<blockquote>\n<p>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don’t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</p>\n</blockquote>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-set-target-propertyName-index-value\"><a href=\"#Vue-set-target-propertyName-index-value\" class=\"headerlink\" title=\"Vue.set( target, propertyName/index, value )\"></a>Vue.set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Adds a property to a reactive object, ensuring the new property is also reactive, so triggers view updates. This must be used to add new properties to reactive objects, as Vue cannot detect normal property additions (e.g. <code>this.myObject.newProperty = &#39;hi&#39;</code>).</p>\n<p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-delete-target-propertyName-index\"><a href=\"#Vue-delete-target-propertyName-index\" class=\"headerlink\" title=\"Vue.delete( target, propertyName/index )\"></a>Vue.delete( target, propertyName/index )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n<blockquote>\n<p>Only in 2.2.0+: Also works with Array + index.</p>\n</blockquote>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Delete a property on an object. If the object is reactive, ensure the deletion triggers view updates. This is primarily used to get around the limitation that Vue cannot detect property deletions, but you should rarely need to use it.</p>\n<p class=\"tip\">The target object cannot be a Vue instance, or the root data object of a Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-directive-id-definition\"><a href=\"#Vue-directive-id-definition\" class=\"headerlink\" title=\"Vue.directive( id, [definition] )\"></a>Vue.directive( id, [definition] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global directive.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// register</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, &#123;\n  <span class=\"hljs-attr\">bind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">inserted</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">update</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">componentUpdated</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;,\n  <span class=\"hljs-attr\">unbind</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;&#125;\n&#125;)\n\n<span class=\"hljs-comment\">// register (function directive)</span>\nVue.directive(<span class=\"hljs-string\">'my-directive'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-comment\">// this will be called as `bind` and `update`</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter, return the directive definition if registered</span>\n<span class=\"hljs-keyword\">var</span> myDirective = Vue.directive(<span class=\"hljs-string\">'my-directive'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/custom-directive.html\">Custom Directives</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-filter-id-definition\"><a href=\"#Vue-filter-id-definition\" class=\"headerlink\" title=\"Vue.filter( id, [definition] )\"></a>Vue.filter( id, [definition] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global filter.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// register</span>\nVue.filter(<span class=\"hljs-string\">'my-filter'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n  <span class=\"hljs-comment\">// return processed value</span>\n&#125;)\n\n<span class=\"hljs-comment\">// getter, return the filter if registered</span>\n<span class=\"hljs-keyword\">var</span> myFilter = Vue.filter(<span class=\"hljs-string\">'my-filter'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/filters.html\">Filters</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-component-id-definition\"><a href=\"#Vue-component-id-definition\" class=\"headerlink\" title=\"Vue.component( id, [definition] )\"></a>Vue.component( id, [definition] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} id</code></li>\n<li><code>{Function | Object} [definition]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Register or retrieve a global component. Registration also automatically sets the component’s <code>name</code> with the given <code>id</code>.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// register an extended constructor</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, Vue.extend(&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;))\n\n<span class=\"hljs-comment\">// register an options object (automatically call Vue.extend)</span>\nVue.component(<span class=\"hljs-string\">'my-component'</span>, &#123; <span class=\"hljs-comment\">/* ... */</span> &#125;)\n\n<span class=\"hljs-comment\">// retrieve a registered component (always return constructor)</span>\n<span class=\"hljs-keyword\">var</span> MyComponent = Vue.component(<span class=\"hljs-string\">'my-component'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-use-plugin\"><a href=\"#Vue-use-plugin\" class=\"headerlink\" title=\"Vue.use( plugin )\"></a>Vue.use( plugin )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Function} plugin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Install a Vue.js plugin. If the plugin is an Object, it must expose an <code>install</code> method. If it is a function itself, it will be treated as the install method. The install method will be called with Vue as the argument.</p>\n<p>This method has to be called before calling <code>new Vue()</code></p>\n<p>When this method is called on the same plugin multiple times, the plugin will be installed only once.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/plugins.html\">Plugins</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-mixin-mixin\"><a href=\"#Vue-mixin-mixin\" class=\"headerlink\" title=\"Vue.mixin( mixin )\"></a>Vue.mixin( mixin )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} mixin</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Apply a mixin globally, which affects every Vue instance created afterwards. This can be used by plugin authors to inject custom behavior into components. <strong>Not recommended in application code</strong>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html#Global-Mixin\">Global Mixin</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-compile-template\"><a href=\"#Vue-compile-template\" class=\"headerlink\" title=\"Vue.compile( template )\"></a>Vue.compile( template )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} template</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Compiles a template string into a render function. <strong>Only available in the full build.</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> res = Vue.compile(<span class=\"hljs-string\">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)\n\n<span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;,\n  <span class=\"hljs-attr\">render</span>: res.render,\n  <span class=\"hljs-attr\">staticRenderFns</span>: res.staticRenderFns\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-observable-object\"><a href=\"#Vue-observable-object\" class=\"headerlink\" title=\"Vue.observable( object )\"></a>Vue.observable( object )</h3><blockquote>\n<p>New in 2.6.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object} object</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Make an object reactive. Internally, Vue uses this on the object returned by the <code>data</code> function.</p>\n<p>The returned object can be used directly inside <a href=\"../guide/render-function.html\">render functions</a> and <a href=\"../guide/computed.html\">computed properties</a>, and will trigger appropriate updates when mutated. It can also be used as a minimal, cross-component state store for simple scenarios:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> state = Vue.observable(&#123; <span class=\"hljs-attr\">count</span>: <span class=\"hljs-number\">0</span> &#125;)\n\n<span class=\"hljs-keyword\">const</span> Demo = &#123;\n  render(h) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'button'</span>, &#123;\n      <span class=\"hljs-attr\">on</span>: &#123; <span class=\"hljs-attr\">click</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123; state.count++ &#125;&#125;\n    &#125;, <span class=\"hljs-string\">`count is: <span class=\"hljs-subst\">$&#123;state.count&#125;</span>`</span>)\n  &#125;\n&#125;</code></pre>\n<p class=\"tip\">In Vue 2.x, <code>Vue.observable</code> directly mutates the object passed to it, so that it is equivalent to the object returned, as <a href=\"../guide/instance.html#Data-and-Methods\">demonstrated here</a>. In Vue 3.x, a reactive proxy will be returned instead, leaving the original object non-reactive if mutated directly. Therefore, for future compatibility, we recommend always working with the object returned by <code>Vue.observable</code>, rather than the object originally passed to it.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"Vue-version\"><a href=\"#Vue-version\" class=\"headerlink\" title=\"Vue.version\"></a>Vue.version</h3><ul>\n<li><p><strong>Details</strong>: Provides the installed version of Vue as a string. This is especially useful for community plugins and components, where you might use different strategies for different versions.</p>\n</li>\n<li><p><strong>Usage</strong>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> version = <span class=\"hljs-built_in\">Number</span>(Vue.version.split(<span class=\"hljs-string\">'.'</span>)[<span class=\"hljs-number\">0</span>])\n\n<span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">2</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v2.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (version === <span class=\"hljs-number\">1</span>) &#123;\n  <span class=\"hljs-comment\">// Vue v1.x.x</span>\n&#125; <span class=\"hljs-keyword\">else</span> &#123;\n  <span class=\"hljs-comment\">// Unsupported versions of Vue</span>\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"Options-Data\"><a href=\"#Options-Data\" class=\"headerlink\" title=\"Options / Data\"></a>Options / Data</h2><h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with their own stateful behavior.</p>\n<p>Once observed, you can no longer add reactive properties to the root data object. It is therefore recommended to declare all root-level reactive properties upfront, before creating the instance.</p>\n<p>After the instance is created, the original data object can be accessed as <code>vm.$data</code>. The Vue instance also proxies all the properties found on the data object, so <code>vm.a</code> will be equivalent to <code>vm.$data.a</code>.</p>\n<p>Properties that start with <code>_</code> or <code>$</code> will <strong>not</strong> be proxied on the Vue instance because they may conflict with Vue’s internal properties and API methods. You will have to access them as <code>vm.$data._property</code>.</p>\n<p>When defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object, because there will be many instances created using the same definition. If we use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instances created! By providing a <code>data</code> function, every time a new instance is created we can call it to return a fresh copy of the initial data.</p>\n<p>If required, a deep clone of the original object can be obtained by passing <code>vm.$data</code> through <code>JSON.parse(JSON.stringify(...))</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> data = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n\n<span class=\"hljs-comment\">// direct instance creation</span>\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: data\n&#125;)\nvm.a <span class=\"hljs-comment\">// =&gt; 1</span>\nvm.$data === data <span class=\"hljs-comment\">// =&gt; true</span>\n\n<span class=\"hljs-comment\">// must use function when in Vue.extend()</span>\n<span class=\"hljs-keyword\">var</span> Component = Vue.extend(&#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;\n  &#125;\n&#125;)</code></pre>\n<p>Note that if you use an arrow function with the <code>data</code> property, <code>this</code> won’t be the component’s instance, but you can still access the instance as the function’s first argument:</p>\n<pre><code class=\"hljs js\">data: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> (&#123; <span class=\"hljs-attr\">a</span>: vm.myProp &#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/reactivity.html\">Reactivity in Depth</a></p>\n</li>\n</ul>\n<h3 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt; | Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A list/hash of attributes that are exposed to accept data from the parent component. It has an Array-based simple syntax and an alternative Object-based syntax that allows advanced configurations such as type checking, custom validation and default values.</p>\n<p>With Object-based syntax, you can use following options:</p>\n<ul>\n<li><code>type</code>: can be one of the following native constructors: <code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Array</code>, <code>Object</code>, <code>Date</code>, <code>Function</code>, <code>Symbol</code>, any custom constructor function or an array of those. Will check if a prop has a given type, and will throw a warning if it doesn’t. <a href=\"../guide/components-props.html#Prop-Types\">More information</a> on prop types.</li>\n<li><code>default</code>: <code>any</code><br>Specifies a default value for the prop. If the prop is not passed, this value will be used instead. Object or array defaults must be returned from a factory function.</li>\n<li><code>required</code>: <code>Boolean</code><br>Defines if the prop is required. In a non-production environment, a console warning will be thrown if this value is truthy and the prop is not passed.</li>\n<li><code>validator</code>: <code>Function</code><br>Custom validator function that takes the prop value as the sole argument. In a non-production environment, a console warning will be thrown if this function returns a falsy value (i.e. the validation fails). You can read more about prop validation <a href=\"../guide/components-props.html#Prop-Validation\">here</a>.</li>\n</ul>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// simple syntax</span>\nVue.component(<span class=\"hljs-string\">'props-demo-simple'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'size'</span>, <span class=\"hljs-string\">'myMessage'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// object syntax with validation</span>\nVue.component(<span class=\"hljs-string\">'props-demo-advanced'</span>, &#123;\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// type check</span>\n    <span class=\"hljs-attr\">height</span>: <span class=\"hljs-built_in\">Number</span>,\n    <span class=\"hljs-comment\">// type check plus other validations</span>\n    <span class=\"hljs-attr\">age</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>,\n      <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-attr\">validator</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> value &gt;= <span class=\"hljs-number\">0</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components-props.html\">Props</a></p>\n</li>\n</ul>\n<h3 id=\"propsData\"><a href=\"#propsData\" class=\"headerlink\" title=\"propsData\"></a>propsData</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: any }</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Pass props to an instance during its creation. This is primarily intended to make unit testing easier.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> Comp = Vue.extend(&#123;\n  <span class=\"hljs-attr\">props</span>: [<span class=\"hljs-string\">'msg'</span>],\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Comp(&#123;\n  <span class=\"hljs-attr\">propsData</span>: &#123;\n    <span class=\"hljs-attr\">msg</span>: <span class=\"hljs-string\">'hello'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"computed\"><a href=\"#computed\" class=\"headerlink\" title=\"computed\"></a>computed</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Computed properties to be mixed into the Vue instance. All getters and setters have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p>Note that if you use an arrow function with a computed property, <code>this</code> won’t be the component’s instance, but you can still access the instance as the function’s first argument:</p>\n<pre><code class=\"hljs js\">computed: &#123;\n  <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> vm.a * <span class=\"hljs-number\">2</span>\n&#125;</code></pre>\n<p>Computed properties are cached, and only re-computed on reactive dependency changes. Note that if a certain dependency is out of the instance’s scope (i.e. not reactive), the computed property will <strong>not</strong> be updated.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">computed</span>: &#123;\n    <span class=\"hljs-comment\">// get only</span>\n    <span class=\"hljs-attr\">aDouble</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a * <span class=\"hljs-number\">2</span>\n    &#125;,\n    <span class=\"hljs-comment\">// both get and set</span>\n    <span class=\"hljs-attr\">aPlus</span>: &#123;\n      <span class=\"hljs-attr\">get</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-number\">1</span>\n      &#125;,\n      <span class=\"hljs-attr\">set</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">v</span>) </span>&#123;\n        <span class=\"hljs-keyword\">this</span>.a = v - <span class=\"hljs-number\">1</span>\n      &#125;\n    &#125;\n  &#125;\n&#125;)\nvm.aPlus   <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aPlus = <span class=\"hljs-number\">3</span>\nvm.a       <span class=\"hljs-comment\">// =&gt; 2</span>\nvm.aDouble <span class=\"hljs-comment\">// =&gt; 4</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/computed.html\">Computed Properties</a></p>\n</li>\n</ul>\n<h3 id=\"methods\"><a href=\"#methods\" class=\"headerlink\" title=\"methods\"></a>methods</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Methods to be mixed into the Vue instance. You can access these methods directly on the VM instance, or use them in directive expressions. All methods will have their <code>this</code> context automatically bound to the Vue instance.</p>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a method</strong> (e.g. <code>plus: () =&gt; this.a++</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.a</code> will be undefined.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">plus</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">this</span>.a++\n    &#125;\n  &#125;\n&#125;)\nvm.plus()\nvm.a <span class=\"hljs-comment\">// 2</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/events.html\">Event Handling</a></p>\n</li>\n</ul>\n<h3 id=\"watch\"><a href=\"#watch\" class=\"headerlink\" title=\"watch\"></a>watch</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: string | Function | Object | Array}</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object where keys are expressions to watch and values are the corresponding callbacks. The value can also be a string of a method name, or an Object that contains additional options. The Vue instance will call <code>$watch()</code> for each entry in the object at instantiation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">data</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>,\n    <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>,\n    <span class=\"hljs-attr\">d</span>: <span class=\"hljs-number\">4</span>,\n    <span class=\"hljs-attr\">e</span>: &#123;\n      <span class=\"hljs-attr\">f</span>: &#123;\n        <span class=\"hljs-attr\">g</span>: <span class=\"hljs-number\">5</span>\n      &#125;\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">watch</span>: &#123;\n    <span class=\"hljs-attr\">a</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123;\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'new: %s, old: %s'</span>, val, oldVal)\n    &#125;,\n    <span class=\"hljs-comment\">// string method name</span>\n    <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">'someMethod'</span>,\n    <span class=\"hljs-comment\">// the callback will be called whenever any of the watched object properties change regardless of their nested depth</span>\n    <span class=\"hljs-attr\">c</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// the callback will be called immediately after the start of the observation</span>\n    <span class=\"hljs-attr\">d</span>: &#123;\n      <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-string\">'someMethod'</span>,\n      <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n    &#125;,\n    <span class=\"hljs-comment\">// you can pass array of callbacks, they will be called one-by-one</span>\n    <span class=\"hljs-attr\">e</span>: [\n      <span class=\"hljs-string\">'handle1'</span>,\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle2</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n      &#123;\n        <span class=\"hljs-attr\">handler</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handle3</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;,\n        <span class=\"hljs-comment\">/* ... */</span>\n      &#125;\n    ],\n    <span class=\"hljs-comment\">// watch vm.e.f's value: &#123;g: 5&#125;</span>\n    <span class=\"hljs-string\">'e.f'</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">val, oldVal</span>) </span>&#123; <span class=\"hljs-comment\">/* ... */</span> &#125;\n  &#125;\n&#125;)\nvm.a = <span class=\"hljs-number\">2</span> <span class=\"hljs-comment\">// =&gt; new: 2, old: 1</span></code></pre>\n<p class=\"tip\">Note that <strong>you should not use an arrow function to define a watcher</strong> (e.g. <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.updateAutocomplete</code> will be undefined.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#vm-watch\">Instance Methods / Data - vm.$watch</a></p>\n</li>\n</ul>\n<h2 id=\"Options-DOM\"><a href=\"#Options-DOM\" class=\"headerlink\" title=\"Options / DOM\"></a>Options / DOM</h2><h3 id=\"el\"><a href=\"#el\" class=\"headerlink\" title=\"el\"></a>el</h3><ul>\n<li><p><strong>Type:</strong> <code>string | Element</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p>\n<p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p>\n<p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p>\n<p class=\"tip\">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p>\n\n<p class=\"tip\">If neither <code>render</code> function nor <code>template</code> option is present, the in-DOM HTML of the mounting DOM element will be extracted as the template. In this case, Runtime + Compiler build of Vue should be used.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/installation.html#Runtime-Compiler-vs-Runtime-only\">Runtime + Compiler vs. Runtime-only</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"template\"><a href=\"#template\" class=\"headerlink\" title=\"template\"></a>template</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A string template to be used as the markup for the Vue instance. The template will <strong>replace</strong> the mounted element. Any existing markup inside the mounted element will be ignored, unless content distribution slots are present in the template.</p>\n<p>If the string starts with <code>#</code> it will be used as a querySelector and use the selected element’s innerHTML as the template string. This allows the use of the common <code>&lt;script type=&quot;x-template&quot;&gt;</code> trick to include templates.</p>\n<p class=\"tip\">From a security perspective, you should only use Vue templates that you can trust. Never use user-generated content as your template.</p>\n\n<p class=\"tip\">If render function is present in the Vue option, the template will be ignored.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><ul>\n<li><p><strong>Type:</strong> <code>(createElement: () =&gt; VNode) =&gt; VNode</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An alternative to string templates allowing you to leverage the full programmatic power of JavaScript. The render function receives a <code>createElement</code> method as it’s first argument used to create <code>VNode</code>s.</p>\n<p>If the component is a functional component, the render function also receives an extra argument <code>context</code>, which provides access to contextual data since functional components are instance-less.</p>\n<p class=\"tip\">The <code>render</code> function has priority over the render function compiled from <code>template</code> option or in-DOM HTML template of the mounting element which is specified by the <code>el</code> option.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h3 id=\"renderError\"><a href=\"#renderError\" class=\"headerlink\" title=\"renderError\"></a>renderError</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>(createElement: () =&gt; VNode, error: Error) =&gt; VNode</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p><strong>Only works in development mode.</strong></p>\n<p>Provide an alternative render output when the default <code>render</code> function encounters an error. The error will be passed to <code>renderError</code> as the second argument. This is particularly useful when used together with hot-reload.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  render (h) &#123;\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'oops'</span>)\n  &#125;,\n  renderError (h, err) &#123;\n    <span class=\"hljs-keyword\">return</span> h(<span class=\"hljs-string\">'pre'</span>, &#123; <span class=\"hljs-attr\">style</span>: &#123; <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">'red'</span> &#125;&#125;, err.stack)\n  &#125;\n&#125;).$mount(<span class=\"hljs-string\">'#app'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html\">Render Functions</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Lifecycle-Hooks\"><a href=\"#Options-Lifecycle-Hooks\" class=\"headerlink\" title=\"Options / Lifecycle Hooks\"></a>Options / Lifecycle Hooks</h2><p class=\"tip\">All lifecycle hooks automatically have their <code>this</code> context bound to the instance, so that you can access data, computed properties, and methods. This means <strong>you should not use an arrow function to define a lifecycle method</strong> (e.g. <code>created: () =&gt; this.fetchTodos()</code>). The reason is arrow functions bind the parent context, so <code>this</code> will not be the Vue instance as you expect and <code>this.fetchTodos</code> will be undefined.</p>\n\n<h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously immediately after the instance has been initialized, before data observation and event/watcher setup.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called synchronously after the instance is created. At this stage, the instance has finished processing the options which means the following have been set up: data observation, computed properties, methods, watch/event callbacks. However, the mounting phase has not been started, and the <code>$el</code> property will not be available yet.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before the mounting begins: the <code>render</code> function is about to be called for the first time.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after the instance has been mounted, where <code>el</code> is replaced by the newly created <code>vm.$el</code>. If the root instance is mounted to an in-document element, <code>vm.$el</code> will also be in-document when <code>mounted</code> is called.</p>\n<p>Note that <code>mounted</code> does <strong>not</strong> guarantee that all child components have also been mounted. If you want to wait until the entire view has been rendered, you can use <a href=\"#vm-nextTick\">vm.$nextTick</a> inside of <code>mounted</code>:</p>\n<pre><code class=\"hljs js\">mounted: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when data changes, before the DOM is patched. This is a good place to access the existing DOM before an update, e.g. to remove manually added event listeners.</p>\n<p><strong>This hook is not called during server-side rendering, because only the initial render is performed server-side.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a data change causes the virtual DOM to be re-rendered and patched.</p>\n<p>The component’s DOM will have been updated when this hook is called, so you can perform DOM-dependent operations here. However, in most cases you should avoid changing state inside the hook. To react to state changes, it’s usually better to use a <a href=\"#computed\">computed property</a> or <a href=\"#watch\">watcher</a> instead.</p>\n<p>Note that <code>updated</code> does <strong>not</strong> guarantee that all child components have also been re-rendered. If you want to wait until the entire view has been re-rendered, you can use <a href=\"#vm-nextTick\">vm.$nextTick</a> inside of <code>updated</code>:</p>\n<pre><code class=\"hljs js\">updated: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n  <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// Code that will run only after the</span>\n    <span class=\"hljs-comment\">// entire view has been re-rendered</span>\n  &#125;)\n&#125;</code></pre>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is activated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when a kept-alive component is deactivated.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#keep-alive\">Built-in Components - keep-alive</a></li>\n<li><a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called right before a Vue instance is destroyed. At this stage the instance is still fully functional.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li><p><strong>Type:</strong> <code>Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called after a Vue instance has been destroyed. When this hook is called, all directives of the Vue instance have been unbound, all event listeners have been removed, and all child Vue instances have also been destroyed.</p>\n<p><strong>This hook is not called during server-side rendering.</strong></p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h3 id=\"errorCaptured\"><a href=\"#errorCaptured\" class=\"headerlink\" title=\"errorCaptured\"></a>errorCaptured</h3><blockquote>\n<p>New in 2.5.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>(err: Error, vm: Component, info: string) =&gt; ?boolean</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Called when an error from any descendent component is captured. The hook receives three arguments: the error, the component instance that triggered the error, and a string containing information on where the error was captured. The hook can return <code>false</code> to stop the error from propagating further.</p>\n<p class=\"tip\">You can modify component state in this hook. However, it is important to have conditionals in your template or render function that short circuits other content when an error has been captured; otherwise the component will be thrown into an infinite render loop.</p>\n\n<p><strong>Error Propagation Rules</strong></p>\n<ul>\n<li><p>By default, all errors are still sent to the global <code>config.errorHandler</code> if it is defined, so that these errors can still be reported to an analytics service in a single place.</p>\n</li>\n<li><p>If multiple <code>errorCaptured</code> hooks exist on a component’s inheritance chain or parent chain, all of them will be invoked on the same error.</p>\n</li>\n<li><p>If the <code>errorCaptured</code> hook itself throws an error, both this error and the original captured error are sent to the global <code>config.errorHandler</code>.</p>\n</li>\n<li><p>An <code>errorCaptured</code> hook can return <code>false</code> to prevent the error from propagating further. This is essentially saying “this error has been handled and should be ignored.” It will prevent any additional <code>errorCaptured</code> hooks or the global <code>config.errorHandler</code> from being invoked for this error.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Options-Assets\"><a href=\"#Options-Assets\" class=\"headerlink\" title=\"Options / Assets\"></a>Options / Assets</h2><h3 id=\"directives\"><a href=\"#directives\" class=\"headerlink\" title=\"directives\"></a>directives</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of directives to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/custom-directive.html\">Custom Directives</a></p>\n</li>\n</ul>\n<h3 id=\"filters\"><a href=\"#filters\" class=\"headerlink\" title=\"filters\"></a>filters</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of filters to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-filter\"><code>Vue.filter</code></a></p>\n</li>\n</ul>\n<h3 id=\"components\"><a href=\"#components\" class=\"headerlink\" title=\"components\"></a>components</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>A hash of components to be made available to the Vue instance.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html\">Components</a></p>\n</li>\n</ul>\n<h2 id=\"Options-Composition\"><a href=\"#Options-Composition\" class=\"headerlink\" title=\"Options / Composition\"></a>Options / Composition</h2><h3 id=\"parent\"><a href=\"#parent\" class=\"headerlink\" title=\"parent\"></a>parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Specify the parent instance for the instance to be created. Establishes a parent-child relationship between the two. The parent will be accessible as <code>this.$parent</code> for the child, and the child will be pushed into the parent’s <code>$children</code> array.</p>\n<p class=\"tip\">Use <code>$parent</code> and <code>$children</code> sparingly - they mostly serve as an escape-hatch. Prefer using props and events for parent-child communication.</p>\n\n</li>\n</ul>\n<h3 id=\"mixins\"><a href=\"#mixins\" class=\"headerlink\" title=\"mixins\"></a>mixins</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Object&gt;</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The <code>mixins</code> option accepts an array of mixin objects. These mixin objects can contain instance options like normal instance objects, and they will be merged against the eventual options using the same option merging logic in <code>Vue.extend()</code>. e.g. If your mixin contains a created hook and the component itself also has one, both functions will be called.</p>\n<p>Mixin hooks are called in the order they are provided, and called before the component’s own hooks.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> mixin = &#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>) &#125;\n&#125;\n<span class=\"hljs-keyword\">var</span> vm = <span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123; <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>) &#125;,\n  <span class=\"hljs-attr\">mixins</span>: [mixin]\n&#125;)\n<span class=\"hljs-comment\">// =&gt; 1</span>\n<span class=\"hljs-comment\">// =&gt; 2</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/mixins.html\">Mixins</a></p>\n</li>\n</ul>\n<h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><strong>Type:</strong> <code>Object | Function</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allows declaratively extending another component (could be either a plain options object or a constructor) without having to use <code>Vue.extend</code>. This is primarily intended to make it easier to extend between single file components.</p>\n<p>This is similar to <code>mixins</code>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> CompA = &#123; ... &#125;\n\n<span class=\"hljs-comment\">// extend CompA without having to call `Vue.extend` on either</span>\n<span class=\"hljs-keyword\">var</span> CompB = &#123;\n  <span class=\"hljs-attr\">extends</span>: CompA,\n  ...\n&#125;</code></pre>\n</li>\n</ul>\n<h3 id=\"provide-inject\"><a href=\"#provide-inject\" class=\"headerlink\" title=\"provide / inject\"></a>provide / inject</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong></p>\n<ul>\n<li><strong>provide:</strong> <code>Object | () =&gt; Object</code></li>\n<li><strong>inject:</strong> <code>Array&lt;string&gt; | { [key: string]: string | Symbol | Object }</code></li>\n</ul>\n</li>\n<li><p><strong>Details:</strong></p>\n<p class=\"tip\"><code>provide</code> and <code>inject</code> are primarily provided for advanced plugin / component library use cases. It is NOT recommended to use them in generic application code.</p>\n\n<p>This pair of options are used together to allow an ancestor component to serve as a dependency injector for all its descendants, regardless of how deep the component hierarchy is, as long as they are in the same parent chain. If you are familiar with React, this is very similar to React’s context feature.</p>\n<p>The <code>provide</code> option should be an object or a function that returns an object. This object contains the properties that are available for injection into its descendants. You can use ES2015 Symbols as keys in this object, but only in environments that natively support <code>Symbol</code> and <code>Reflect.ownKeys</code>.</p>\n<p>The <code>inject</code> option should be either:</p>\n<ul>\n<li>an array of strings, or</li>\n<li>an object where the keys are the local binding name and the value is either:<ul>\n<li>the key (string or Symbol) to search for in available injections, or</li>\n<li>an object where:<ul>\n<li>the <code>from</code> property is the key (string or Symbol) to search for in available injections, and</li>\n<li>the <code>default</code> property is used as fallback value</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>Note: the <code>provide</code> and <code>inject</code> bindings are NOT reactive. This is intentional. However, if you pass down an observed object, properties on that object do remain reactive.</p>\n</blockquote>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// parent component providing 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Provider = &#123;\n  <span class=\"hljs-attr\">provide</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: <span class=\"hljs-string\">'bar'</span>\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;\n\n<span class=\"hljs-comment\">// child component injecting 'foo'</span>\n<span class=\"hljs-keyword\">var</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  created () &#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.foo) <span class=\"hljs-comment\">// =&gt; \"bar\"</span>\n  &#125;\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<p>With ES2015 Symbols, function <code>provide</code> and object <code>inject</code>:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> s = <span class=\"hljs-built_in\">Symbol</span>()\n\n<span class=\"hljs-keyword\">const</span> Provider = &#123;\n  provide () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      [s]: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;\n\n<span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123; s &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;</code></pre>\n<blockquote>\n<p>The next 2 examples work with Vue 2.2.1+. Below that version, injected values were resolved after the <code>props</code> and the <code>data</code> initialization.</p>\n</blockquote>\n<p>Using an injected value as the default for a prop:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-attr\">bar</span>: &#123;\n      <span class=\"hljs-keyword\">default</span> () &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.foo\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>Using an injected value as data entry:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: [<span class=\"hljs-string\">'foo'</span>],\n  data () &#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-keyword\">this</span>.foo\n    &#125;\n  &#125;\n&#125;</code></pre>\n<blockquote>\n<p>In 2.5.0+ injections can be optional with default value:</p>\n</blockquote>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123; <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span> &#125;\n  &#125;\n&#125;</code></pre>\n<p>If it needs to be injected from a property with a different name, use <code>from</code> to denote the source property:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">'foo'</span>\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>Similar to prop defaults, you need to use a factory function for non primitive values:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> Child = &#123;\n  <span class=\"hljs-attr\">inject</span>: &#123;\n    <span class=\"hljs-attr\">foo</span>: &#123;\n      <span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">'bar'</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n    &#125;\n  &#125;\n&#125;</code></pre>\n</li>\n</ul>\n<h2 id=\"Options-Misc\"><a href=\"#Options-Misc\" class=\"headerlink\" title=\"Options / Misc\"></a>Options / Misc</h2><h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name\"></a>name</h3><ul>\n<li><p><strong>Type:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Restriction:</strong> only respected when used as a component option.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allow the component to recursively invoke itself in its template. Note that when a component is registered globally with <code>Vue.component()</code>, the global ID is automatically set as its name.</p>\n<p>Another benefit of specifying a <code>name</code> option is debugging. Named components result in more helpful warning messages. Also, when inspecting an app in the <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a>, unnamed components will show up as <code>&lt;AnonymousComponent&gt;</code>, which isn’t very informative. By providing the <code>name</code> option, you will get a much more informative component tree.</p>\n</li>\n</ul>\n<h3 id=\"delimiters\"><a href=\"#delimiters\" class=\"headerlink\" title=\"delimiters\"></a>delimiters</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;string&gt;</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>[\"{{\", \"}}\"]</code></p>\n</li>\n<li><p><strong>Restrictions:</strong> This option is only available in the full build, with in-browser compilation.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Change the plain text interpolation delimiters.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">delimiters</span>: [<span class=\"hljs-string\">'$&#123;'</span>, <span class=\"hljs-string\">'&#125;'</span>]\n&#125;)\n\n<span class=\"hljs-comment\">// Delimiters changed to ES6 template string style</span></code></pre>\n</li>\n</ul>\n<h3 id=\"functional\"><a href=\"#functional\" class=\"headerlink\" title=\"functional\"></a>functional</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Causes a component to be stateless (no <code>data</code>) and instanceless (no <code>this</code> context). They are only a <code>render</code> function that returns virtual nodes making them much cheaper to render.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/render-function.html#Functional-Components\">Functional Components</a></p>\n</li>\n</ul>\n<h3 id=\"model\"><a href=\"#model\" class=\"headerlink\" title=\"model\"></a>model</h3><blockquote>\n<p>New in 2.2.0</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ prop?: string, event?: string }</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Allows a custom component to customize the prop and event used when it’s used with <code>v-model</code>. By default, <code>v-model</code> on a component uses <code>value</code> as the prop and <code>input</code> as the event, but some input types such as checkboxes and radio buttons may want to use the <code>value</code> prop for a different purpose. Using the <code>model</code> option can avoid the conflict in such cases.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-checkbox'</span>, &#123;\n  <span class=\"hljs-attr\">model</span>: &#123;\n    <span class=\"hljs-attr\">prop</span>: <span class=\"hljs-string\">'checked'</span>,\n    <span class=\"hljs-attr\">event</span>: <span class=\"hljs-string\">'change'</span>\n  &#125;,\n  <span class=\"hljs-attr\">props</span>: &#123;\n    <span class=\"hljs-comment\">// this allows using the `value` prop for a different purpose</span>\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-built_in\">String</span>,\n    <span class=\"hljs-comment\">// use `checked` as the prop which take the place of `value`</span>\n    <span class=\"hljs-attr\">checked</span>: &#123;\n      <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">Number</span>,\n      <span class=\"hljs-attr\">default</span>: <span class=\"hljs-number\">0</span>\n    &#125;\n  &#125;,\n  <span class=\"hljs-comment\">// ...</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">\"foo\"</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n<p>The above will be equivalent to:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-checkbox</span>\n  <span class=\"hljs-attr\">:checked</span>=<span class=\"hljs-string\">\"foo\"</span>\n  @<span class=\"hljs-attr\">change</span>=<span class=\"hljs-string\">\"val =&gt; &#123; foo = val &#125;\"</span>\n  <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">\"some value\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-checkbox</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"inheritAttrs\"><a href=\"#inheritAttrs\" class=\"headerlink\" title=\"inheritAttrs\"></a>inheritAttrs</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>true</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>By default, parent scope attribute bindings that are not recognized as props will “fallthrough” and be applied to the root element of the child component as normal HTML attributes. When authoring a component that wraps a target element or another component, this may not always be the desired behavior. By setting <code>inheritAttrs</code> to <code>false</code>, this default behavior can be disabled. The attributes are available via the <code>$attrs</code> instance property (also new in 2.4) and can be explicitly bound to a non-root element using <code>v-bind</code>.</p>\n<p>Note: this option does <strong>not</strong> affect <code>class</code> and <code>style</code> bindings.</p>\n</li>\n</ul>\n<h3 id=\"comments\"><a href=\"#comments\" class=\"headerlink\" title=\"comments\"></a>comments</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Default:</strong> <code>false</code></p>\n</li>\n<li><p><strong>Restrictions:</strong> This option is only available in the full build, with in-browser compilation.</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>When set to <code>true</code>, will preserve and render HTML comments found in templates. The default behavior is discarding them.</p>\n</li>\n</ul>\n<h2 id=\"Instance-Properties\"><a href=\"#Instance-Properties\" class=\"headerlink\" title=\"Instance Properties\"></a>Instance Properties</h2><h3 id=\"vm-data\"><a href=\"#vm-data\" class=\"headerlink\" title=\"vm.$data\"></a>vm.$data</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The data object that the Vue instance is observing. The Vue instance proxies access to the properties on its data object.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#data\">Options / Data - data</a></p>\n</li>\n</ul>\n<h3 id=\"vm-props\"><a href=\"#vm-props\" class=\"headerlink\" title=\"vm.$props\"></a>vm.$props</h3><blockquote>\n<p>New in 2.2.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object representing the current props a component has received. The Vue instance proxies access to the properties on its props object.</p>\n</li>\n</ul>\n<h3 id=\"vm-el\"><a href=\"#vm-el\" class=\"headerlink\" title=\"vm.$el\"></a>vm.$el</h3><ul>\n<li><p><strong>Type:</strong> <code>Element</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root DOM element that the Vue instance is managing.</p>\n</li>\n</ul>\n<h3 id=\"vm-options\"><a href=\"#vm-options\" class=\"headerlink\" title=\"vm.$options\"></a>vm.$options</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The instantiation options used for the current Vue instance. This is useful when you want to include custom properties in the options:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">customOption</span>: <span class=\"hljs-string\">'foo'</span>,\n  <span class=\"hljs-attr\">created</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.$options.customOption) <span class=\"hljs-comment\">// =&gt; 'foo'</span>\n  &#125;\n&#125;)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-parent\"><a href=\"#vm-parent\" class=\"headerlink\" title=\"vm.$parent\"></a>vm.$parent</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The parent instance, if the current instance has one.</p>\n</li>\n</ul>\n<h3 id=\"vm-root\"><a href=\"#vm-root\" class=\"headerlink\" title=\"vm.$root\"></a>vm.$root</h3><ul>\n<li><p><strong>Type:</strong> <code>Vue instance</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The root Vue instance of the current component tree. If the current instance has no parents this value will be itself.</p>\n</li>\n</ul>\n<h3 id=\"vm-children\"><a href=\"#vm-children\" class=\"headerlink\" title=\"vm.$children\"></a>vm.$children</h3><ul>\n<li><p><strong>Type:</strong> <code>Array&lt;Vue instance&gt;</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>The direct child components of the current instance. <strong>Note there’s no order guarantee for <code>$children</code>, and it is not reactive.</strong> If you find yourself trying to use <code>$children</code> for data binding, consider using an Array and <code>v-for</code> to generate child components, and use the Array as the source of truth.</p>\n</li>\n</ul>\n<h3 id=\"vm-slots\"><a href=\"#vm-slots\" class=\"headerlink\" title=\"vm.$slots\"></a>vm.$slots</h3><ul>\n<li><p><strong>Type:</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Reactive?</strong> No</p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Used to programmatically access content <a href=\"../guide/components.html#Content-Distribution-with-Slots\">distributed by slots</a>. Each <a href=\"../guide/components.html#Named-Slots\">named slot</a> has its own corresponding property (e.g. the contents of <code>v-slot:foo</code> will be found at <code>vm.$slots.foo</code>). The <code>default</code> property contains either nodes not included in a named slot or contents of <code>v-slot:default</code>.</p>\n<p>Please note that slots are <strong>not</strong> reactive. If you need a component to re-render based on changes to data passed to a slot, we suggest considering a different strategy that relies on a reactive instance option, such as <code>props</code> or <code>data</code>.</p>\n<p><strong>Note:</strong> <code>v-slot:foo</code> is supported in v2.6+. For older versions, you can use the <a href=\"../guide/components-slots.html#Deprecated-Syntax\">deprecated syntax</a>.</p>\n<p>Accessing <code>vm.$slots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">blog-post</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>About Me<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>Copyright 2016 Evan You<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>.\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">blog-post</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'blog-post'</span>, &#123;\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">createElement</span>) </span>&#123;\n    <span class=\"hljs-keyword\">var</span> header = <span class=\"hljs-keyword\">this</span>.$slots.header\n    <span class=\"hljs-keyword\">var</span> body   = <span class=\"hljs-keyword\">this</span>.$slots.default\n    <span class=\"hljs-keyword\">var</span> footer = <span class=\"hljs-keyword\">this</span>.$slots.footer\n    <span class=\"hljs-keyword\">return</span> createElement(<span class=\"hljs-string\">'div'</span>, [\n      createElement(<span class=\"hljs-string\">'header'</span>, header),\n      createElement(<span class=\"hljs-string\">'main'</span>, body),\n      createElement(<span class=\"hljs-string\">'footer'</span>, footer)\n    ])\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> Component</a></li>\n<li><a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render Functions - Slots</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-scopedSlots\"><a href=\"#vm-scopedSlots\" class=\"headerlink\" title=\"vm.$scopedSlots\"></a>vm.$scopedSlots</h3><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ [name: string]: props =&gt; Array&lt;VNode&gt; | undefined }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Used to programmatically access <a href=\"../guide/components.html#Scoped-Slots\">scoped slots</a>. For each slot, including the <code>default</code> one, the object contains a corresponding function that returns VNodes.</p>\n<p>Accessing <code>vm.$scopedSlots</code> is most useful when writing a component with a <a href=\"../guide/render-function.html\">render function</a>.</p>\n<p><strong>Note:</strong> since 2.6.0+, there are two notable changes to this property:</p>\n<ol>\n<li><p>Scoped slot functions are now guaranteed to return an array of VNodes, unless the return value is invalid, in which case the function will return <code>undefined</code>.</p>\n</li>\n<li><p>All <code>$slots</code> are now also exposed on <code>$scopedSlots</code> as functions. If you work with render functions, it is now recommended to always access slots via <code>$scopedSlots</code>, whether they currently use a scope or not. This will not only make future refactors to add a scope simpler, but also ease your eventual migration to Vue 3, where all slots will be functions.</p>\n</li>\n</ol>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#slot\"><code>&lt;slot&gt;</code> Component</a></li>\n<li><a href=\"../guide/components.html#Scoped-Slots\">Scoped Slots</a></li>\n<li><a href=\"../guide/render-function.html#Slots\">Render Functions - Slots</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-refs\"><a href=\"#vm-refs\" class=\"headerlink\" title=\"vm.$refs\"></a>vm.$refs</h3><ul>\n<li><p><strong>Type:</strong> <code>Object</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>An object of DOM elements and component instances, registered with <a href=\"#ref\"><code>ref</code> attributes</a>.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></li>\n<li><a href=\"#ref\">Special Attributes - ref</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-isServer\"><a href=\"#vm-isServer\" class=\"headerlink\" title=\"vm.$isServer\"></a>vm.$isServer</h3><ul>\n<li><p><strong>Type:</strong> <code>boolean</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Whether the current Vue instance is running on the server.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/ssr.html\">Server-Side Rendering</a></p>\n</li>\n</ul>\n<h3 id=\"vm-attrs\"><a href=\"#vm-attrs\" class=\"headerlink\" title=\"vm.$attrs\"></a>vm.$attrs</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: string }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Contains parent-scope attribute bindings (except for <code>class</code> and <code>style</code>) that are not recognized (and extracted) as props. When a component doesn’t have any declared props, this essentially contains all parent-scope bindings (except for <code>class</code> and <code>style</code>), and can be passed down to an inner component via <code>v-bind=&quot;$attrs&quot;</code> - useful when creating higher-order components.</p>\n</li>\n</ul>\n<h3 id=\"vm-listeners\"><a href=\"#vm-listeners\" class=\"headerlink\" title=\"vm.$listeners\"></a>vm.$listeners</h3><blockquote>\n<p>New in 2.4.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Type:</strong> <code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p>\n</li>\n<li><p><strong>Read only</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Contains parent-scope <code>v-on</code> event listeners (without <code>.native</code> modifiers). This can be passed down to an inner component via <code>v-on=&quot;$listeners&quot;</code> - useful when creating transparent wrapper components.</p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Data\"><a href=\"#Instance-Methods-Data\" class=\"headerlink\" title=\"Instance Methods / Data\"></a>Instance Methods / Data</h2><h3 id=\"vm-watch-expOrFn-callback-options\"><a href=\"#vm-watch-expOrFn-callback-options\" class=\"headerlink\" title=\"vm.$watch( expOrFn, callback, [options] )\"></a>vm.$watch( expOrFn, callback, [options] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Function} expOrFn</code></li>\n<li><code>{Function | Object} callback</code></li>\n<li><code>{Object} [options]</code><ul>\n<li><code>{boolean} deep</code></li>\n<li><code>{boolean} immediate</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>{Function} unwatch</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Watch an expression or a computed function on the Vue instance for changes. The callback gets called with the new value and the old value. The expression only accepts dot-delimited paths. For more complex expressions, use a function instead.</p>\n</li>\n</ul>\n<p class=\"tip\">Note: when mutating (rather than replacing) an Object or an Array, the old value will be the same as new value because they reference the same Object/Array. Vue doesn’t keep a copy of the pre-mutate value.</p>\n\n<ul>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// keypath</span>\nvm.$watch(<span class=\"hljs-string\">'a.b.c'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n  <span class=\"hljs-comment\">// do something</span>\n&#125;)\n\n<span class=\"hljs-comment\">// function</span>\nvm.$watch(\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-comment\">// every time the expression `this.a + this.b` yields a different result,</span>\n    <span class=\"hljs-comment\">// the handler will be called. It's as if we were watching a computed</span>\n    <span class=\"hljs-comment\">// property without defining the computed property itself</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.a + <span class=\"hljs-keyword\">this</span>.b\n  &#125;,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">newVal, oldVal</span>) </span>&#123;\n    <span class=\"hljs-comment\">// do something</span>\n  &#125;\n)</code></pre>\n<p><code>vm.$watch</code> returns an unwatch function that stops firing the callback:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(<span class=\"hljs-string\">'a'</span>, cb)\n<span class=\"hljs-comment\">// later, teardown the watcher</span>\nunwatch()</code></pre>\n</li>\n<li><p><strong>Option: deep</strong></p>\n<p>To also detect nested value changes inside Objects, you need to pass in <code>deep: true</code> in the options argument. Note that you don’t need to do so to listen for Array mutations.</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'someObject'</span>, callback, &#123;\n  <span class=\"hljs-attr\">deep</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\nvm.someObject.nestedValue = <span class=\"hljs-number\">123</span>\n<span class=\"hljs-comment\">// callback is fired</span></code></pre>\n</li>\n<li><p><strong>Option: immediate</strong></p>\n<p>Passing in <code>immediate: true</code> in the option will trigger the callback immediately with the current value of the expression:</p>\n<pre><code class=\"hljs js\">vm.$watch(<span class=\"hljs-string\">'a'</span>, callback, &#123;\n  <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span>\n&#125;)\n<span class=\"hljs-comment\">// `callback` is fired immediately with current value of `a`</span></code></pre>\n<p>Note that with <code>immediate</code> option you won’t be able to unwatch the given property on the first callback call.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-comment\">// This will cause an error</span>\n<span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    unwatch()\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n<p>If you still want to call an unwatch function inside the callback, you should check its availability first:</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> unwatch = vm.$watch(\n  <span class=\"hljs-string\">'value'</span>,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    doSomething()\n    <span class=\"hljs-keyword\">if</span> (unwatch) &#123;\n      unwatch()\n    &#125;\n  &#125;,\n  &#123; <span class=\"hljs-attr\">immediate</span>: <span class=\"hljs-literal\">true</span> &#125;\n)</code></pre>\n</li>\n</ul>\n<h3 id=\"vm-set-target-propertyName-index-value\"><a href=\"#vm-set-target-propertyName-index-value\" class=\"headerlink\" title=\"vm.$set( target, propertyName/index, value )\"></a>vm.$set( target, propertyName/index, value )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n<li><code>{any} value</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> the set value.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.set</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-set\">Vue.set</a></p>\n</li>\n</ul>\n<h3 id=\"vm-delete-target-propertyName-index\"><a href=\"#vm-delete-target-propertyName-index\" class=\"headerlink\" title=\"vm.$delete( target, propertyName/index )\"></a>vm.$delete( target, propertyName/index )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Object | Array} target</code></li>\n<li><code>{string | number} propertyName/index</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This is the <strong>alias</strong> of the global <code>Vue.delete</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"#Vue-delete\">Vue.delete</a></p>\n</li>\n</ul>\n<h2 id=\"Instance-Methods-Events\"><a href=\"#Instance-Methods-Events\" class=\"headerlink\" title=\"Instance Methods / Events\"></a>Instance Methods / Events</h2><h3 id=\"vm-on-event-callback\"><a href=\"#vm-on-event-callback\" class=\"headerlink\" title=\"vm.$on( event, callback )\"></a>vm.$on( event, callback )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (array only supported in 2.2.0+)</li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event on the current vm. Events can be triggered by <code>vm.$emit</code>. The callback will receive all the additional arguments passed into these event-triggering methods.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\">vm.$on(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">msg</span>) </span>&#123;\n  <span class=\"hljs-built_in\">console</span>.log(msg)\n&#125;)\nvm.$emit(<span class=\"hljs-string\">'test'</span>, <span class=\"hljs-string\">'hi'</span>)\n<span class=\"hljs-comment\">// =&gt; \"hi\"</span></code></pre>\n</li>\n</ul>\n<h3 id=\"vm-once-event-callback\"><a href=\"#vm-once-event-callback\" class=\"headerlink\" title=\"vm.$once( event, callback )\"></a>vm.$once( event, callback )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} event</code></li>\n<li><code>{Function} callback</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Listen for a custom event, but only once. The listener will be removed once it triggers for the first time.</p>\n</li>\n</ul>\n<h3 id=\"vm-off-event-callback\"><a href=\"#vm-off-event-callback\" class=\"headerlink\" title=\"vm.$off( [event, callback] )\"></a>vm.$off( [event, callback] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string | Array&lt;string&gt;} event</code> (array only supported in 2.2.2+)</li>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Remove custom event listener(s).</p>\n<ul>\n<li><p>If no arguments are provided, remove all event listeners;</p>\n</li>\n<li><p>If only the event is provided, remove all listeners for that event;</p>\n</li>\n<li><p>If both event and callback are given, remove the listener for that specific callback only.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-emit-eventName-…args\"><a href=\"#vm-emit-eventName-…args\" class=\"headerlink\" title=\"vm.$emit( eventName, […args] )\"></a>vm.$emit( eventName, […args] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{string} eventName</code></li>\n<li><code>[...args]</code></li>\n</ul>\n<p>Trigger an event on the current instance. Any additional arguments will be passed into the listener’s callback function.</p>\n</li>\n<li><p><strong>Examples:</strong></p>\n<p>Using <code>$emit</code> with only an event name:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'welcome-button'</span>, &#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"$emit('welcome')\"&gt;\n      Click me to be welcomed\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-simple\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">welcome-button</span> <span class=\"hljs-attr\">v-on:welcome</span>=<span class=\"hljs-string\">\"sayHi\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">welcome-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-simple'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">sayHi</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      alert(<span class=\"hljs-string\">'Hi!'</span>)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-simple\" class=\"demo\">\n    <welcome-button v-on:welcome=\"sayHi\"></welcome-button>\n  </div>\n  <script>\n    Vue.component('welcome-button', {\n      template: `\n        <button v-on:click=\"$emit('welcome')\">\n          Click me to be welcomed\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-simple',\n      methods: {\n        sayHi: function () {\n          alert('Hi!')\n        }\n      }\n    })\n  </script>\n  \n<p>Using <code>$emit</code> with additional arguments:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'magic-eight-ball'</span>, &#123;\n  <span class=\"hljs-attr\">data</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-keyword\">return</span> &#123;\n      <span class=\"hljs-attr\">possibleAdvice</span>: [<span class=\"hljs-string\">'Yes'</span>, <span class=\"hljs-string\">'No'</span>, <span class=\"hljs-string\">'Maybe'</span>]\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">giveAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-keyword\">var</span> randomAdviceIndex = <span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-keyword\">this</span>.possibleAdvice.length)\n      <span class=\"hljs-keyword\">this</span>.$emit(<span class=\"hljs-string\">'give-advice'</span>, <span class=\"hljs-keyword\">this</span>.possibleAdvice[randomAdviceIndex])\n    &#125;\n  &#125;,\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n    &lt;button v-on:click=\"giveAdvice\"&gt;\n      Click me for advice\n    &lt;/button&gt;\n  `</span>\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"emit-example-argument\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">magic-eight-ball</span> <span class=\"hljs-attr\">v-on:give-advice</span>=<span class=\"hljs-string\">\"showAdvice\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">magic-eight-ball</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#emit-example-argument'</span>,\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-attr\">showAdvice</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">advice</span>) </span>&#123;\n      alert(advice)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n\n  <div id=\"emit-example-argument\" class=\"demo\">\n    <magic-eight-ball v-on:give-advice=\"showAdvice\"></magic-eight-ball>\n  </div>\n  <script>\n    Vue.component('magic-eight-ball', {\n      data: function () {\n        return {\n          possibleAdvice: ['Yes', 'No', 'Maybe']\n        }\n      },\n      methods: {\n        giveAdvice: function () {\n          var randomAdviceIndex = Math.floor(Math.random() * this.possibleAdvice.length)\n          this.$emit('give-advice', this.possibleAdvice[randomAdviceIndex])\n        }\n      },\n      template: `\n        <button v-on:click=\"giveAdvice\">\n          Click me for advice\n        </button>\n      `\n    })\n    new Vue({\n      el: '#emit-example-argument',\n      methods: {\n        showAdvice: function (advice) {\n          alert(advice)\n        }\n      }\n    })\n  </script>\n  \n</li>\n</ul>\n<h2 id=\"Instance-Methods-Lifecycle\"><a href=\"#Instance-Methods-Lifecycle\" class=\"headerlink\" title=\"Instance Methods / Lifecycle\"></a>Instance Methods / Lifecycle</h2><h3 id=\"vm-mount-elementOrSelector\"><a href=\"#vm-mount-elementOrSelector\" class=\"headerlink\" title=\"vm.$mount( [elementOrSelector] )\"></a>vm.$mount( [elementOrSelector] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Element | string} [elementOrSelector]</code></li>\n<li><code>{boolean} [hydrating]</code></li>\n</ul>\n</li>\n<li><p><strong>Returns:</strong> <code>vm</code> - the instance itself</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>If a Vue instance didn’t receive the <code>el</code> option at instantiation, it will be in “unmounted” state, without an associated DOM element. <code>vm.$mount()</code> can be used to manually start the mounting of an unmounted Vue instance.</p>\n<p>If <code>elementOrSelector</code> argument is not provided, the template will be rendered as an off-document element, and you will have to use native DOM API to insert it into the document yourself.</p>\n<p>The method returns the instance itself so you can chain other instance methods after it.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> MyComponent = Vue.extend(&#123;\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;Hello!&lt;/div&gt;'</span>\n&#125;)\n\n<span class=\"hljs-comment\">// create and mount to #app (will replace #app)</span>\n<span class=\"hljs-keyword\">new</span> MyComponent().$mount(<span class=\"hljs-string\">'#app'</span>)\n\n<span class=\"hljs-comment\">// the above is the same as:</span>\n<span class=\"hljs-keyword\">new</span> MyComponent(&#123; <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">'#app'</span> &#125;)\n\n<span class=\"hljs-comment\">// or, render off-document and append afterwards:</span>\n<span class=\"hljs-keyword\">var</span> component = <span class=\"hljs-keyword\">new</span> MyComponent().$mount()\n<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">'app'</span>).appendChild(component.$el)</code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></li>\n<li><a href=\"../guide/ssr.html\">Server-Side Rendering</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-forceUpdate\"><a href=\"#vm-forceUpdate\" class=\"headerlink\" title=\"vm.$forceUpdate()\"></a>vm.$forceUpdate()</h3><ul>\n<li><p><strong>Usage:</strong></p>\n<p>Force the Vue instance to re-render. Note it does not affect all child components, only the instance itself and child components with inserted slot content.</p>\n</li>\n</ul>\n<h3 id=\"vm-nextTick-callback\"><a href=\"#vm-nextTick-callback\" class=\"headerlink\" title=\"vm.$nextTick( [callback] )\"></a>vm.$nextTick( [callback] )</h3><ul>\n<li><p><strong>Arguments:</strong></p>\n<ul>\n<li><code>{Function} [callback]</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Defer the callback to be executed after the next DOM update cycle. Use it immediately after you’ve changed some data to wait for the DOM update. This is the same as the global <code>Vue.nextTick</code>, except that the callback’s <code>this</code> context is automatically bound to the instance calling this method.</p>\n<blockquote>\n<p>New in 2.1.0+: returns a Promise if no callback is provided and Promise is supported in the execution environment. Please note that Vue does not come with a Promise polyfill, so if you target browsers that don’t support Promises natively (looking at you, IE), you will have to provide a polyfill yourself.</p>\n</blockquote>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  <span class=\"hljs-comment\">// ...</span>\n  <span class=\"hljs-attr\">methods</span>: &#123;\n    <span class=\"hljs-comment\">// ...</span>\n    <span class=\"hljs-attr\">example</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n      <span class=\"hljs-comment\">// modify data</span>\n      <span class=\"hljs-keyword\">this</span>.message = <span class=\"hljs-string\">'changed'</span>\n      <span class=\"hljs-comment\">// DOM is not updated yet</span>\n      <span class=\"hljs-keyword\">this</span>.$nextTick(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n        <span class=\"hljs-comment\">// DOM is now updated</span>\n        <span class=\"hljs-comment\">// `this` is bound to the current instance</span>\n        <span class=\"hljs-keyword\">this</span>.doSomethingElse()\n      &#125;)\n    &#125;\n  &#125;\n&#125;)</code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"#Vue-nextTick\">Vue.nextTick</a></li>\n<li><a href=\"../guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vm-destroy\"><a href=\"#vm-destroy\" class=\"headerlink\" title=\"vm.$destroy()\"></a>vm.$destroy()</h3><ul>\n<li><p><strong>Usage:</strong></p>\n<p>Completely destroy a vm. Clean up its connections with other existing vms, unbind all its directives, turn off all event listeners.</p>\n<p>Triggers the <code>beforeDestroy</code> and <code>destroyed</code> hooks.</p>\n<p class=\"tip\">In normal use cases you shouldn’t have to call this method yourself. Prefer controlling the lifecycle of child components in a data-driven fashion using <code>v-if</code> and <code>v-for</code>.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/instance.html#Lifecycle-Diagram\">Lifecycle Diagram</a></p>\n</li>\n</ul>\n<h2 id=\"Directives\"><a href=\"#Directives\" class=\"headerlink\" title=\"Directives\"></a>Directives</h2><h3 id=\"v-text\"><a href=\"#v-text\" class=\"headerlink\" title=\"v-text\"></a>v-text</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>textContent</code>. If you need to update the part of <code>textContent</code>, you should use <code>{{ Mustache }}</code> interpolations.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-text</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- same as --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Text\">Data Binding Syntax - Interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-html\"><a href=\"#v-html\" class=\"headerlink\" title=\"v-html\"></a>v-html</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Updates the element’s <code>innerHTML</code>. <strong>Note that the contents are inserted as plain HTML - they will not be compiled as Vue templates</strong>. If you find yourself trying to compose templates using <code>v-html</code>, try to rethink the solution by using components instead.</p>\n<p class=\"tip\">Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to <a href=\"https://en.wikipedia.org/wiki/Cross-site_scripting\" target=\"_blank\" rel=\"noopener\">XSS attacks</a>. Only use <code>v-html</code> on trusted content and <strong>never</strong> on user-provided content.</p>\n\n<p class=\"tip\">In <a href=\"../guide/single-file-components.html\">single-file components</a>, <code>scoped</code> styles will not apply to content inside <code>v-html</code>, because that HTML is not processed by Vue’s template compiler. If you want to target <code>v-html</code> content with scoped CSS, you can instead use <a href=\"https://vue-loader.vuejs.org/en/features/css-modules.html\" target=\"_blank\" rel=\"noopener\">CSS modules</a> or an additional, global <code>&lt;style&gt;</code> element with a manual scoping strategy such as BEM.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-html</span>=<span class=\"hljs-string\">\"html\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/syntax.html#Raw-HTML\">Data Binding Syntax - Interpolations</a></p>\n</li>\n</ul>\n<h3 id=\"v-show\"><a href=\"#v-show\" class=\"headerlink\" title=\"v-show\"></a>v-show</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Toggles the element’s <code>display</code> CSS property based on the truthy-ness of the expression value.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-show\">Conditional Rendering - v-show</a></p>\n</li>\n</ul>\n<h3 id=\"v-if\"><a href=\"#v-if\" class=\"headerlink\" title=\"v-if\"></a>v-if</h3><ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Conditionally render the element based on the truthy-ness of the expression value. The element and its contained directives / components are destroyed and re-constructed during toggles. If the element is a <code>&lt;template&gt;</code> element, its content will be extracted as the conditional block.</p>\n<p>This directive triggers transitions when its condition changes.</p>\n<p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html\">Conditional Rendering - v-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-else\"><a href=\"#v-else\" class=\"headerlink\" title=\"v-else\"></a>v-else</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else block” for <code>v-if</code> or a <code>v-if</code>/<code>v-else-if</code> chain.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"Math.random() &gt; 0.5\"</span>&gt;</span>\n  Now you see me\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Now you don't\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-else\">Conditional Rendering - v-else</a></p>\n</li>\n</ul>\n<h3 id=\"v-else-if\"><a href=\"#v-else-if\" class=\"headerlink\" title=\"v-else-if\"></a>v-else-if</h3><blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<ul>\n<li><p><strong>Expects:</strong> <code>any</code></p>\n</li>\n<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote the “else if block” for <code>v-if</code>. Can be chained.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"type === 'A'\"</span>&gt;</span>\n  A\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'B'\"</span>&gt;</span>\n  B\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else-if</span>=<span class=\"hljs-string\">\"type === 'C'\"</span>&gt;</span>\n  C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-else</span>&gt;</span>\n  Not A/B/C\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/conditional.html#v-else-if\">Conditional Rendering - v-else-if</a></p>\n</li>\n</ul>\n<h3 id=\"v-for\"><a href=\"#v-for\" class=\"headerlink\" title=\"v-for\"></a>v-for</h3><ul>\n<li><p><strong>Expects:</strong> <code>Array | Object | number | string | Iterable (since 2.6)</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Render the element or template block multiple times based on the source data. The directive’s value must use the special syntax <code>alias in expression</code> to provide an alias for the current element being iterated on:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Alternatively, you can also specify an alias for the index (or the key if used on an Object):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(item, index) in items\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, key) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"(val, name, index) in object\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The default behavior of <code>v-for</code> will try to patch the elements in-place without moving them. To force it to reorder elements, you need to provide an ordering hint with the <code>key</code> special attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n  &#123;&#123; item.text &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>In 2.6+, <code>v-for</code> can also work on values that implement the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol\" target=\"_blank\" rel=\"noopener\">Iterable Protocol</a>, including native <code>Map</code> and <code>Set</code>. However, it should be noted that Vue 2.x currently does not support reactivity on <code>Map</code> and <code>Set</code> values, so cannot automatically detect changes.</p>\n<p class=\"tip\">When used together with v-if, v-for has a higher priority than v-if. See the <a href=\"../guide/list.html#v-for-with-v-if\">list rendering guide</a> for details.</p>\n\n<p>The detailed usage for <code>v-for</code> is explained in the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/list.html\">List Rendering</a></li>\n<li><a href=\"../guide/list.html#key\">key</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-on\"><a href=\"#v-on\" class=\"headerlink\" title=\"v-on\"></a>v-on</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>@</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>Function | Inline Statement | Object</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>event</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.stop</code> - call <code>event.stopPropagation()</code>.</li>\n<li><code>.prevent</code> - call <code>event.preventDefault()</code>.</li>\n<li><code>.capture</code> - add event listener in capture mode.</li>\n<li><code>.self</code> - only trigger handler if event was dispatched from this element.</li>\n<li><code>.{keyCode | keyAlias}</code> - only trigger handler on certain keys.</li>\n<li><code>.native</code> - listen for a native event on the root element of component.</li>\n<li><code>.once</code> - trigger handler at most once.</li>\n<li><code>.left</code> - (2.2.0+) only trigger handler for left button mouse events.</li>\n<li><code>.right</code> - (2.2.0+) only trigger handler for right button mouse events.</li>\n<li><code>.middle</code> - (2.2.0+) only trigger handler for middle button mouse events.</li>\n<li><code>.passive</code> - (2.3.0+) attaches a DOM event with <code>{ passive: true }</code>.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Attaches an event listener to the element. The event type is denoted by the argument. The expression can be a method name, an inline statement, or omitted if there are modifiers present.</p>\n<p>When used on a normal element, it listens to <a href=\"https://developer.mozilla.org/en-US/docs/Web/Events\" target=\"_blank\" rel=\"noopener\"><strong>native DOM events</strong></a> only. When used on a custom element component, it listens to <strong>custom events</strong> emitted on that child component.</p>\n<p>When listening to native DOM events, the method receives the native event as the only argument. If using inline statement, the statement has access to the special <code>$event</code> property: <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>.</p>\n<p>Starting in 2.4.0+, <code>v-on</code> also supports binding to an object of event/listener pairs without an argument. Note when using the object syntax, it does not support any modifiers.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- method handler --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- dynamic event (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:</span>[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- inline statement --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click</span>=<span class=\"hljs-string\">\"doThat('hello', $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand dynamic event (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @[<span class=\"hljs-attr\">event</span>]=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- stop propagation --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prevent default --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prevent default without expression --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> @<span class=\"hljs-attr\">submit.prevent</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- chain modifiers --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click.stop.prevent</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- key modifier using keyAlias --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.enter</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- key modifier using keyCode --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> @<span class=\"hljs-attr\">keyup.13</span>=<span class=\"hljs-string\">\"onEnter\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- the click event will be triggered at most once --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on:click.once</span>=<span class=\"hljs-string\">\"doThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- object syntax (2.4.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"&#123; mousedown: doThis, mouseup: doThat &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>Listening to custom events on a child component (the handler is called when “my-event” is emitted on the child):</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- inline statement --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">my-event</span>=<span class=\"hljs-string\">\"handleThis(123, $event)\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- native event on component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> @<span class=\"hljs-attr\">click.native</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/events.html\">Event Handling</a></li>\n<li><a href=\"../guide/components.html#Custom-Events\">Components - Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-bind\"><a href=\"#v-bind\" class=\"headerlink\" title=\"v-bind\"></a>v-bind</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>:</code></p>\n</li>\n<li><p><strong>Expects:</strong> <code>any (with argument) | Object (without argument)</code></p>\n</li>\n<li><p><strong>Argument:</strong> <code>attrOrProp (optional)</code></p>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><code>.prop</code> - Bind as a DOM property instead of an attribute (<a href=\"https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028\" target=\"_blank\" rel=\"noopener\">what’s the difference?</a>). If the tag is a component then <code>.prop</code> will set the property on the component’s <code>$el</code>.</li>\n<li><code>.camel</code> - (2.1.0+) transform the kebab-case attribute name into camelCase.</li>\n<li><code>.sync</code> - (2.3.0+) a syntax sugar that expands into a <code>v-on</code> handler for updating the bound value.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Dynamically bind one or more attributes, or a component prop to an expression.</p>\n<p>When used to bind the <code>class</code> or <code>style</code> attribute, it supports additional value types such as Array or Objects. See linked guide section below for more details.</p>\n<p>When used for prop binding, the prop must be properly declared in the child component.</p>\n<p>When used without an argument, can be used to bind an object containing attribute name-value pairs. Note in this mode <code>class</code> and <code>style</code> does not support Array or Objects.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- bind an attribute --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">v-bind:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- dynamic attribute name (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">v-bind:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"imageSrc\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- shorthand dynamic attribute name (2.6.0+) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">:</span>[<span class=\"hljs-attr\">key</span>]=<span class=\"hljs-string\">\"value\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- with inline string concatenation --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">:src</span>=<span class=\"hljs-string\">\"'/path/to/images/' + fileName\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- class binding --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"&#123; red: isRed &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, classB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:class</span>=<span class=\"hljs-string\">\"[classA, &#123; classB: isB, classC: isC &#125;]\"</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- style binding --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"&#123; fontSize: size + 'px' &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">:style</span>=<span class=\"hljs-string\">\"[styleObjectA, styleObjectB]\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- binding an object of attributes --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"&#123; id: someProp, 'other-attr': otherProp &#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- DOM attribute binding with prop modifier --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-bind:text-content.prop</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- prop binding. \"prop\" must be declared in my-component. --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">:prop</span>=<span class=\"hljs-string\">\"someThing\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- pass down parent props in common with a child component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">v-bind</span>=<span class=\"hljs-string\">\"$props\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- XLink --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:xlink:special</span>=<span class=\"hljs-string\">\"foo\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svg</span> <span class=\"hljs-attr\">:view-box.camel</span>=<span class=\"hljs-string\">\"viewBox\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svg</span>&gt;</span></code></pre>\n<p><code>.camel</code> is not needed if you are using string templates, or compiling with <code>vue-loader</code>/<code>vueify</code>.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/class-and-style.html\">Class and Style Bindings</a></li>\n<li><a href=\"../guide/components.html#Props\">Components - Props</a></li>\n<li><a href=\"../guide/components.html#sync-Modifier\">Components - <code>.sync</code> Modifier</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-model\"><a href=\"#v-model\" class=\"headerlink\" title=\"v-model\"></a>v-model</h3><ul>\n<li><p><strong>Expects:</strong> varies based on value of form inputs element or output of components</p>\n</li>\n<li><p><strong>Limited to:</strong></p>\n<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li>components</li>\n</ul>\n</li>\n<li><p><strong>Modifiers:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html#lazy\"><code>.lazy</code></a> - listen to <code>change</code> events instead of <code>input</code></li>\n<li><a href=\"../guide/forms.html#number\"><code>.number</code></a> - cast valid input string to numbers</li>\n<li><a href=\"../guide/forms.html#trim\"><code>.trim</code></a> - trim input</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Create a two-way binding on a form input element or a component. For detailed usage and other notes, see the Guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/forms.html\">Form Input Bindings</a></li>\n<li><a href=\"../guide/components.html#Form-Input-Components-using-Custom-Events\">Components - Form Input Components using Custom Events</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-slot\"><a href=\"#v-slot\" class=\"headerlink\" title=\"v-slot\"></a>v-slot</h3><ul>\n<li><p><strong>Shorthand:</strong> <code>#</code></p>\n</li>\n<li><p><strong>Expects:</strong> JavaScript expression that is valid in a function argument position (supports destructuring in <a href=\"../guide/components-slots.html#Slot-Props-Destructuring\">supported environments</a>). Optional - only needed if expecting props to be passed to the slot.</p>\n</li>\n<li><p><strong>Argument:</strong> slot name (optional, defaults to <code>default</code>)</p>\n</li>\n<li><p><strong>Limited to:</strong></p>\n<ul>\n<li><code>&lt;template&gt;</code></li>\n<li><a href=\"../guide/components-slots.html#Abbreviated-Syntax-for-Lone-Default-Slots\">components</a> (for a lone default slot with props)</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Denote named slots or slots that expect to receive props.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- Named slots --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">base-layout</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:header</span>&gt;</span>\n    Header content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n  Default slot content\n\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:footer</span>&gt;</span>\n    Footer content\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">base-layout</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Named slot that receives props --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">v-slot:item</span>=<span class=\"hljs-string\">\"slotProps\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"item\"</span>&gt;</span>\n      &#123;&#123; slotProps.item.text &#125;&#125;\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">infinite-scroll</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Default slot that receive props, with destructuring --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mouse-position</span> <span class=\"hljs-attr\">v-slot</span>=<span class=\"hljs-string\">\"&#123; x, y &#125;\"</span>&gt;</span>\n  Mouse position: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mouse-position</span>&gt;</span></code></pre>\n<p>For more details, see the links below.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components-slots.html\">Components - Slots</a></li>\n<li><a href=\"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md\" target=\"_blank\" rel=\"noopener\">RFC-0001</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"v-pre\"><a href=\"#v-pre\" class=\"headerlink\" title=\"v-pre\"></a>v-pre</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Skip compilation for this element and all its children. You can use this for displaying raw mustache tags. Skipping large numbers of nodes with no directives on them can also speed up compilation.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span></code></pre>\n</li>\n</ul>\n<h3 id=\"v-cloak\"><a href=\"#v-cloak\" class=\"headerlink\" title=\"v-cloak\"></a>v-cloak</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>This directive will remain on the element until the associated Vue instance finishes compilation. Combined with CSS rules such as <code>[v-cloak] { display: none }</code>, this directive can be used to hide un-compiled mustache bindings until the Vue instance is ready.</p>\n</li>\n<li><p><strong>Example:</strong></p>\n<pre><code class=\"hljs css\"><span class=\"hljs-selector-attr\">[v-cloak]</span> &#123;\n  <span class=\"hljs-attribute\">display</span>: none;\n&#125;</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-cloak</span>&gt;</span>\n  &#123;&#123; message &#125;&#125;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>The <code>&lt;div&gt;</code> will not be visible until the compilation is done.</p>\n</li>\n</ul>\n<h3 id=\"v-once\"><a href=\"#v-once\" class=\"headerlink\" title=\"v-once\"></a>v-once</h3><ul>\n<li><p><strong>Does not expect expression</strong></p>\n</li>\n<li><p><strong>Details:</strong></p>\n<p>Render the element and component <strong>once</strong> only. On subsequent re-renders, the element/component and all its children will be treated as static content and skipped. This can be used to optimize update performance.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- single element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- the element have children --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>comment<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">v-once</span> <span class=\"hljs-attr\">:comment</span>=<span class=\"hljs-string\">\"msg\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- `v-for` directive --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"i in list\"</span> <span class=\"hljs-attr\">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/syntax.html#Text\">Data Binding Syntax - interpolations</a></li>\n<li><a href=\"../guide/components.html#Cheap-Static-Components-with-v-once\">Components - Cheap Static Components with <code>v-once</code></a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Special-Attributes\"><a href=\"#Special-Attributes\" class=\"headerlink\" title=\"Special Attributes\"></a>Special Attributes</h2><h3 id=\"key\"><a href=\"#key\" class=\"headerlink\" title=\"key\"></a>key</h3><ul>\n<li><p><strong>Expects:</strong> <code>number | string | boolean (since 2.4.2) | symbol (since 2.5.12)</code></p>\n<p>The <code>key</code> special attribute is primarily used as a hint for Vue’s virtual DOM algorithm to identify VNodes when diffing the new list of nodes against the old list. Without keys, Vue uses an algorithm that minimizes element movement and tries to patch/reuse elements of the same type in-place as much as possible. With keys, it will reorder elements based on the order change of keys, and elements with keys that are no longer present will always be removed/destroyed.</p>\n<p>Children of the same common parent must have <strong>unique keys</strong>. Duplicate keys will cause render errors.</p>\n<p>The most common use case is combined with <code>v-for</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>It can also be used to force replacement of an element/component instead of reusing it. This can be useful when you want to:</p>\n<ul>\n<li>Properly trigger lifecycle hooks of a component</li>\n<li>Trigger transitions</li>\n</ul>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"text\"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>When <code>text</code> changes, the <code>&lt;span&gt;</code> will always be replaced instead of patched, so a transition will be triggered.</p>\n</li>\n</ul>\n<h3 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h3><ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p><code>ref</code> is used to register a reference to an element or a child component. The reference will be registered under the parent component’s <code>$refs</code> object. If used on a plain DOM element, the reference will be that element; if used on a child component, the reference will be component instance:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- vm.$refs.p will be the DOM node --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"p\"</span>&gt;</span>hello<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- vm.$refs.child will be the child component instance --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child-component</span> <span class=\"hljs-attr\">ref</span>=<span class=\"hljs-string\">\"child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child-component</span>&gt;</span></code></pre>\n<p>When used on elements/components with <code>v-for</code>, the registered reference will be an Array containing DOM nodes or component instances.</p>\n<p>An important note about the ref registration timing: because the refs themselves are created as a result of the render function, you cannot access them on the initial render - they don’t exist yet! <code>$refs</code> is also non-reactive, therefore you should not attempt to use it in templates for data-binding.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Child-Component-Refs\">Child Component Refs</a></p>\n</li>\n</ul>\n<h3 id=\"is\"><a href=\"#is\" class=\"headerlink\" title=\"is\"></a>is</h3><ul>\n<li><p><strong>Expects:</strong> <code>string | Object (component’s options object)</code></p>\n<p>Used for <a href=\"../guide/components.html#Dynamic-Components\">dynamic components</a> and to work around <a href=\"../guide/components.html#DOM-Template-Parsing-Caveats\">limitations of in-DOM templates</a>.</p>\n<p>For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- component changes when currentView changes --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">v-bind:is</span>=<span class=\"hljs-string\">\"currentView\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- necessary because `&lt;my-row&gt;` would be invalid inside --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- a `&lt;table&gt;` element and so would be hoisted out      --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span> <span class=\"hljs-attr\">is</span>=<span class=\"hljs-string\">\"my-row\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span></code></pre>\n<p>For detailed usage, follow the links in the description above.</p>\n</li>\n<li><p><strong>See also:</strong></p>\n<ul>\n<li><a href=\"../guide/components.html#Dynamic-Components\">Dynamic Components</a></li>\n<li><a href=\"../guide/components.html#DOM-Template-Parsing-Caveats\">DOM Template Parsing Caveats</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"slot-deprecated\"><a href=\"#slot-deprecated\" class=\"headerlink\" title=\"slot deprecated\"></a>slot <sup style=\"color:#c92222\">deprecated</sup></h3><p><strong>Prefer <a href=\"#v-slot\">v-slot</a> in 2.6.0+.</strong></p>\n<ul>\n<li><p><strong>Expects:</strong> <code>string</code></p>\n<p>Used on content inserted into child components to indicate which named slot the content belongs to.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Named-Slots-with-slot\">Named Slots with <code>slot</code></a></p>\n</li>\n</ul>\n<h3 id=\"slot-scope-deprecated\"><a href=\"#slot-scope-deprecated\" class=\"headerlink\" title=\"slot-scope deprecated\"></a>slot-scope <sup style=\"color:#c92222\">deprecated</sup></h3><p><strong>Prefer <a href=\"#v-slot\">v-slot</a> in 2.6.0+.</strong></p>\n<ul>\n<li><p><strong>Expects:</strong> <code>function argument expression</code></p>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>Used to denote an element or component as a scoped slot. The attribute’s value should be a valid JavaScript expression that can appear in the argument position of a function signature. This means in supported environments you can also use ES2015 destructuring in the expression. Serves as a replacement for <a href=\"#scope-replaced\"><code>scope</code></a> in 2.5.0+.</p>\n<p>This attribute does not support dynamic binding.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Scoped-Slots-with-slot-scope\">Scoped Slots with <code>slot-scope</code></a></p>\n</li>\n</ul>\n<h3 id=\"scope-removed\"><a href=\"#scope-removed\" class=\"headerlink\" title=\"scope removed\"></a>scope <sup style=\"color:#c92222\">removed</sup></h3><p><strong>Replaced by <a href=\"#slot-scope\">slot-scope</a> in 2.5.0+. Prefer <a href=\"#v-slot\">v-slot</a> in 2.6.0+.</strong></p>\n<p>Used to denote a <code>&lt;template&gt;</code> element as a scoped slot.</p>\n<ul>\n<li><p><strong>Usage:</strong></p>\n<p>Same as <a href=\"#slot-scope\"><code>slot-scope</code></a> except that <code>scope</code> can only be used on <code>&lt;template&gt;</code> elements.</p>\n</li>\n</ul>\n<h2 id=\"Built-In-Components\"><a href=\"#Built-In-Components\" class=\"headerlink\" title=\"Built-In Components\"></a>Built-In Components</h2><h3 id=\"component\"><a href=\"#component\" class=\"headerlink\" title=\"component\"></a>component</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>\n<li><code>inline-template</code> - boolean</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>A “meta component” for rendering dynamic components. The actual component to render is determined by the <code>is</code> prop:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- a dynamic component controlled by --&gt;</span>\n<span class=\"hljs-comment\">&lt;!-- the `componentId` property on the vm --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"componentId\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- can also render registered component or component passed as prop --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"$options.components.child\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Dynamic-Components\">Dynamic Components</a></p>\n</li>\n</ul>\n<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used to automatically generate transition CSS class names. e.g. <code>name: &#39;fade&#39;</code> will auto expand to <code>.fade-enter</code>, <code>.fade-enter-active</code>, etc. Defaults to <code>&quot;v&quot;</code>.</li>\n<li><code>appear</code> - boolean, Whether to apply transition on initial render. Defaults to <code>false</code>.</li>\n<li><code>css</code> - boolean, Whether to apply CSS transition classes. Defaults to <code>true</code>. If set to <code>false</code>, will only trigger JavaScript hooks registered via component events.</li>\n<li><code>type</code> - string, Specifies the type of transition events to wait for to determine transition end timing. Available values are <code>&quot;transition&quot;</code> and <code>&quot;animation&quot;</code>. By default, it will automatically detect the type that has a longer duration.</li>\n<li><code>mode</code> - string, Controls the timing sequence of leaving/entering transitions. Available modes are <code>&quot;out-in&quot;</code> and <code>&quot;in-out&quot;</code>; defaults to simultaneous.</li>\n<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number }, Specifies the duration of transition. By default, Vue waits for the first <code>transitionend</code> or <code>animationend</code> event on the root transition element.</li>\n<li><code>enter-class</code> - string</li>\n<li><code>leave-class</code> - string</li>\n<li><code>appear-class</code> - string</li>\n<li><code>enter-to-class</code> - string</li>\n<li><code>leave-to-class</code> - string</li>\n<li><code>appear-to-class</code> - string</li>\n<li><code>enter-active-class</code> - string</li>\n<li><code>leave-active-class</code> - string</li>\n<li><code>appear-active-class</code> - string</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li><code>before-enter</code></li>\n<li><code>before-leave</code></li>\n<li><code>before-appear</code></li>\n<li><code>enter</code></li>\n<li><code>leave</code></li>\n<li><code>appear</code></li>\n<li><code>after-enter</code></li>\n<li><code>after-leave</code></li>\n<li><code>after-appear</code></li>\n<li><code>enter-cancelled</code></li>\n<li><code>leave-cancelled</code> (<code>v-show</code> only)</li>\n<li><code>appear-cancelled</code></li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition&gt;</code> serve as transition effects for <strong>single</strong> element/component. The <code>&lt;transition&gt;</code> only applies the transition behavior to the wrapped content inside; it doesn’t render an extra DOM element, or show up in the inspected component hierarchy.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- simple element --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- dynamic component --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"fade\"</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">\"out-in\"</span> <span class=\"hljs-attr\">appear</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- event hooking --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">\"transition-demo\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span> @<span class=\"hljs-attr\">after-enter</span>=<span class=\"hljs-string\">\"transitionComplete\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-show</span>=<span class=\"hljs-string\">\"ok\"</span>&gt;</span>toggled content<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">new</span> Vue(&#123;\n  ...\n  methods: &#123;\n    <span class=\"hljs-attr\">transitionComplete</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">el</span>) </span>&#123;\n      <span class=\"hljs-comment\">// for passed 'el' that DOM element as the argument, something ...</span>\n    &#125;\n  &#125;\n  ...\n&#125;).$mount(<span class=\"hljs-string\">'#transition-demo'</span>)</code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"transition-group\"><a href=\"#transition-group\" class=\"headerlink\" title=\"transition-group\"></a>transition-group</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>tag</code> - string, defaults to <code>span</code>.</li>\n<li><code>move-class</code> - overwrite CSS class applied during moving transition.</li>\n<li>exposes the same props as <code>&lt;transition&gt;</code> except <code>mode</code>.</li>\n</ul>\n</li>\n<li><p><strong>Events:</strong></p>\n<ul>\n<li>exposes the same events as <code>&lt;transition&gt;</code>.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;transition-group&gt;</code> serve as transition effects for <strong>multiple</strong> elements/components. The <code>&lt;transition-group&gt;</code> renders a real DOM element. By default it renders a <code>&lt;span&gt;</code>, and you can configure what element it should render via the <code>tag</code> attribute.</p>\n<p>Note that every child in a <code>&lt;transition-group&gt;</code> must be <strong>uniquely keyed</strong> for the animations to work properly.</p>\n<p><code>&lt;transition-group&gt;</code> supports moving transitions via CSS transform. When a child’s position on screen has changed after an update, it will get applied a moving CSS class (auto generated from the <code>name</code> attribute or configured with the <code>move-class</code> attribute). If the CSS <code>transform</code> property is “transition-able” when the moving class is applied, the element will be smoothly animated to its destination using the <a href=\"https://aerotwist.com/blog/flip-your-animations/\" target=\"_blank\" rel=\"noopener\">FLIP technique</a>.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition-group</span> <span class=\"hljs-attr\">tag</span>=<span class=\"hljs-string\">\"ul\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"slide\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">v-for</span>=<span class=\"hljs-string\">\"item in items\"</span> <span class=\"hljs-attr\">:key</span>=<span class=\"hljs-string\">\"item.id\"</span>&gt;</span>\n    &#123;&#123; item.text &#125;&#125;\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition-group</span>&gt;</span></code></pre>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/transitions.html\">Transitions: Entering, Leaving, and Lists</a></p>\n</li>\n</ul>\n<h3 id=\"keep-alive\"><a href=\"#keep-alive\" class=\"headerlink\" title=\"keep-alive\"></a>keep-alive</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>include</code> - string or RegExp or Array. Only components with matching names will be cached.</li>\n<li><code>exclude</code> - string or RegExp or Array. Any component with a matching name will not be cached.</li>\n<li><code>max</code> - number. The maximum number of component instances to cache.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p>When wrapped around a dynamic component, <code>&lt;keep-alive&gt;</code> caches the inactive component instances without destroying them. Similar to <code>&lt;transition&gt;</code>, <code>&lt;keep-alive&gt;</code> is an abstract component: it doesn’t render a DOM element itself, and doesn’t show up in the component parent chain.</p>\n<p>When a component is toggled inside <code>&lt;keep-alive&gt;</code>, its <code>activated</code> and <code>deactivated</code> lifecycle hooks will be invoked accordingly.</p>\n<blockquote>\n<p>In 2.2.0+ and above, <code>activated</code> and <code>deactivated</code> will fire for all nested components inside a <code>&lt;keep-alive&gt;</code> tree.</p>\n</blockquote>\n<p>Primarily used to preserve component state or avoid re-rendering.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- basic --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- multiple conditional children --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-a</span> <span class=\"hljs-attr\">v-if</span>=<span class=\"hljs-string\">\"a &gt; 1\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-a</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comp-b</span> <span class=\"hljs-attr\">v-else</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comp-b</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- used together with `&lt;transition&gt;` --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">transition</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">transition</span>&gt;</span></code></pre>\n<p>Note, <code>&lt;keep-alive&gt;</code> is designed for the case where it has one direct child component that is being toggled. It does not work if you have <code>v-for</code> inside it. When there are multiple conditional children, as above, <code>&lt;keep-alive&gt;</code> requires that only one child is rendered at a time.</p>\n</li>\n<li><p><strong><code>include</code> and <code>exclude</code></strong></p>\n<blockquote>\n<p>New in 2.1.0+</p>\n</blockquote>\n<p>The <code>include</code> and <code>exclude</code> props allow components to be conditionally cached. Both props can be a comma-delimited string, a RegExp or an Array:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- comma-delimited string --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">include</span>=<span class=\"hljs-string\">\"a,b\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- regex (use `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"/a|b/\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- Array (use `v-bind`) --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:include</span>=<span class=\"hljs-string\">\"['a', 'b']\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p>The match is first checked on the component’s own <code>name</code> option, then its local registration name (the key in the parent’s <code>components</code> option) if the <code>name</code> option is not available. Anonymous components cannot be matched against.</p>\n</li>\n<li><p><strong><code>max</code></strong></p>\n<blockquote>\n<p>New in 2.5.0+</p>\n</blockquote>\n<p>The maximum number of component instances to cache. Once this number is reached, the cached component instance that was least recently accessed will be destroyed before creating a new instance.</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span> <span class=\"hljs-attr\">:max</span>=<span class=\"hljs-string\">\"10\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">component</span> <span class=\"hljs-attr\">:is</span>=<span class=\"hljs-string\">\"view\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">component</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span></code></pre>\n<p class=\"tip\"><code>&lt;keep-alive&gt;</code> does not work with functional components because they do not have instances to be cached.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#keep-alive\">Dynamic Components - keep-alive</a></p>\n</li>\n</ul>\n<h3 id=\"slot\"><a href=\"#slot\" class=\"headerlink\" title=\"slot\"></a>slot</h3><ul>\n<li><p><strong>Props:</strong></p>\n<ul>\n<li><code>name</code> - string, Used for named slot.</li>\n</ul>\n</li>\n<li><p><strong>Usage:</strong></p>\n<p><code>&lt;slot&gt;</code> serve as content distribution outlets in component templates. <code>&lt;slot&gt;</code> itself will be replaced.</p>\n<p>For detailed usage, see the guide section linked below.</p>\n</li>\n<li><p><strong>See also:</strong> <a href=\"../guide/components.html#Content-Distribution-with-Slots\">Content Distribution with Slots</a></p>\n</li>\n</ul>\n<h2 id=\"VNode-Interface\"><a href=\"#VNode-Interface\" class=\"headerlink\" title=\"VNode Interface\"></a>VNode Interface</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js\" target=\"_blank\" rel=\"noopener\">VNode class declaration</a>.</li>\n</ul>\n<h2 id=\"Server-Side-Rendering\"><a href=\"#Server-Side-Rendering\" class=\"headerlink\" title=\"Server-Side Rendering\"></a>Server-Side Rendering</h2><ul>\n<li>Please refer to the <a href=\"https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer\" target=\"_blank\" rel=\"noopener\">vue-server-renderer package documentation</a>.</li>\n</ul>\n"},{"_content":"<!DOCTYPE html>\n<html>\n  <head>\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <div>\n        <label>Price</label>\n        <input v-model=\"price | currency\" />\n      </div>\n      <div>\n        <label>Shipping</label>\n        <input v-model=\"shipping | currency\" />\n      </div>\n      <div>\n        <label>Handling</label>\n        <input v-model=\"handling | currency\" />\n      </div>\n      <div>\n        <label>Discount</label>\n        <input v-model=\"discount | currency\" />\n      </div>\n\n      <p>Total: ${{ total }}</p>\n    </div>\n\n    <script>\n      Vue.filter(\"currency\", {\n        read: function(value) {\n          return \"$\" + value.toFixed(2);\n        },\n        write: function(value) {\n          var number = +value.replace(/[^\\d.]/g, \"\");\n          return isNaN(number) ? 0 : number;\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","source":"v2/examples/vue-10-two-way-currency-filter/index.html","raw":"<!DOCTYPE html>\n<html>\n  <head>\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <div>\n        <label>Price</label>\n        <input v-model=\"price | currency\" />\n      </div>\n      <div>\n        <label>Shipping</label>\n        <input v-model=\"shipping | currency\" />\n      </div>\n      <div>\n        <label>Handling</label>\n        <input v-model=\"handling | currency\" />\n      </div>\n      <div>\n        <label>Discount</label>\n        <input v-model=\"discount | currency\" />\n      </div>\n\n      <p>Total: ${{ total }}</p>\n    </div>\n\n    <script>\n      Vue.filter(\"currency\", {\n        read: function(value) {\n          return \"$\" + value.toFixed(2);\n        },\n        write: function(value) {\n          var number = +value.replace(/[^\\d.]/g, \"\");\n          return isNaN(number) ? 0 : number;\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","date":"2020-09-25T23:55:41.112Z","updated":"2020-09-25T23:55:41.112Z","path":"v2/examples/vue-10-two-way-currency-filter/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gys002oc2v55ihmzv2i","content":"<!DOCTYPE html>\n<html>\n  <head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <div>\n        <label>Price</label>\n        <input v-model=\"price | currency\">\n      </div>\n      <div>\n        <label>Shipping</label>\n        <input v-model=\"shipping | currency\">\n      </div>\n      <div>\n        <label>Handling</label>\n        <input v-model=\"handling | currency\">\n      </div>\n      <div>\n        <label>Discount</label>\n        <input v-model=\"discount | currency\">\n      </div>\n\n      <p>Total: $</p>\n    </div>\n\n    <script>\n      Vue.filter(\"currency\", {\n        read: function(value) {\n          return \"$\" + value.toFixed(2);\n        },\n        write: function(value) {\n          var number = +value.replace(/[^\\d.]/g, \"\");\n          return isNaN(number) ? 0 : number;\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n  <head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <div>\n        <label>Price</label>\n        <input v-model=\"price | currency\">\n      </div>\n      <div>\n        <label>Shipping</label>\n        <input v-model=\"shipping | currency\">\n      </div>\n      <div>\n        <label>Handling</label>\n        <input v-model=\"handling | currency\">\n      </div>\n      <div>\n        <label>Discount</label>\n        <input v-model=\"discount | currency\">\n      </div>\n\n      <p>Total: $</p>\n    </div>\n\n    <script>\n      Vue.filter(\"currency\", {\n        read: function(value) {\n          return \"$\" + value.toFixed(2);\n        },\n        write: function(value) {\n          var number = +value.replace(/[^\\d.]/g, \"\");\n          return isNaN(number) ? 0 : number;\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n"},{"_content":"{\n  \"name\": \"vue-10-two-way-currency-filter\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Showing how delayed state updates can cause strange behavior.\",\n  \"main\": \"index.html\",\n  \"scripts\": {\n    \"start\": \"serve\"\n  },\n  \"keywords\": [],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"serve\": \"^11.2.0\"\n  }\n}","source":"v2/examples/vue-10-two-way-currency-filter/package.json","raw":"{\n  \"name\": \"vue-10-two-way-currency-filter\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Showing how delayed state updates can cause strange behavior.\",\n  \"main\": \"index.html\",\n  \"scripts\": {\n    \"start\": \"serve\"\n  },\n  \"keywords\": [],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"serve\": \"^11.2.0\"\n  }\n}","date":"2020-09-25T23:55:41.112Z","updated":"2020-09-25T23:55:41.112Z","path":"v2/examples/vue-10-two-way-currency-filter/package.json","layout":"false","title":"","comments":1,"_id":"ckfl66gys002pc2v5z53lhjt3","content":"{\"name\":\"vue-10-two-way-currency-filter\",\"version\":\"1.0.0\",\"description\":\"Showing how delayed state updates can cause strange behavior.\",\"main\":\"index.html\",\"scripts\":{\"start\":\"serve\"},\"keywords\":[],\"license\":\"MIT\",\"devDependencies\":{\"serve\":\"^11.2.0\"}}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"vue-10-two-way-currency-filter\",\"version\":\"1.0.0\",\"description\":\"Showing how delayed state updates can cause strange behavior.\",\"main\":\"index.html\",\"scripts\":{\"start\":\"serve\"},\"keywords\":[],\"license\":\"MIT\",\"devDependencies\":{\"serve\":\"^11.2.0\"}}"},{"_content":"{\n  \"template\": \"static\"\n}\n","source":"v2/examples/vue-10-two-way-currency-filter/sandbox.config.json","raw":"{\n  \"template\": \"static\"\n}\n","date":"2020-09-25T23:55:41.113Z","updated":"2020-09-25T23:55:41.113Z","path":"v2/examples/vue-10-two-way-currency-filter/sandbox.config.json","layout":"false","title":"","comments":1,"_id":"ckfl66gys002qc2v5tg4p0akt","content":"{\"template\":\"static\"}","site":{"data":{}},"excerpt":"","more":"{\"template\":\"static\"}"},{"_content":"<!DOCTYPE html>\n<html>\n  <head>\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/accounting.js/0.4.1/accounting.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input\n        label=\"Shipping\"\n        v-bind:value.sync=\"shipping\"\n      ></currency-input>\n      <currency-input\n        label=\"Handling\"\n        v-bind:value.sync=\"handling\"\n      ></currency-input>\n      <currency-input\n        label=\"Discount\"\n        v-bind:value.sync=\"discount\"\n      ></currency-input>\n\n      <p>Total: ${{ total }}</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n            <div>\\\n              <label v-if=\"label\">{{ label }}</label>\\\n              <input\\\n                v-model=\"value | currency\"\\\n                v-on:focus=\"selectAll\"\\\n              >\\\n            </div>\\\n          ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: function(value) {\n              return \"$\" + value.toFixed(2);\n            },\n            write: function(value) {\n              var number = +value.replace(/[^\\d.]/g, \"\");\n              return isNaN(number) ? 0 : number;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","source":"v2/examples/vue-10-two-way-currency-filter-v2/index.html","raw":"<!DOCTYPE html>\n<html>\n  <head>\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/accounting.js/0.4.1/accounting.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input\n        label=\"Shipping\"\n        v-bind:value.sync=\"shipping\"\n      ></currency-input>\n      <currency-input\n        label=\"Handling\"\n        v-bind:value.sync=\"handling\"\n      ></currency-input>\n      <currency-input\n        label=\"Discount\"\n        v-bind:value.sync=\"discount\"\n      ></currency-input>\n\n      <p>Total: ${{ total }}</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n            <div>\\\n              <label v-if=\"label\">{{ label }}</label>\\\n              <input\\\n                v-model=\"value | currency\"\\\n                v-on:focus=\"selectAll\"\\\n              >\\\n            </div>\\\n          ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: function(value) {\n              return \"$\" + value.toFixed(2);\n            },\n            write: function(value) {\n              var number = +value.replace(/[^\\d.]/g, \"\");\n              return isNaN(number) ? 0 : number;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","date":"2020-09-25T23:55:41.111Z","updated":"2020-09-25T23:55:41.111Z","path":"v2/examples/vue-10-two-way-currency-filter-v2/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gyt002rc2v5yu9ik4nm","content":"<!DOCTYPE html>\n<html>\n  <head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/accounting.js/0.4.1/accounting.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input label=\"Shipping\" v-bind:value.sync=\"shipping\"></currency-input>\n      <currency-input label=\"Handling\" v-bind:value.sync=\"handling\"></currency-input>\n      <currency-input label=\"Discount\" v-bind:value.sync=\"discount\"></currency-input>\n\n      <p>Total: $</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n            <div>\\\n              <label v-if=\"label\"></label>\\\n              <input\\\n                v-model=\"value | currency\"\\\n                v-on:focus=\"selectAll\"\\\n              >\\\n            </div>\\\n          ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: function(value) {\n              return \"$\" + value.toFixed(2);\n            },\n            write: function(value) {\n              var number = +value.replace(/[^\\d.]/g, \"\");\n              return isNaN(number) ? 0 : number;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n  <head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/accounting.js/0.4.1/accounting.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input label=\"Shipping\" v-bind:value.sync=\"shipping\"></currency-input>\n      <currency-input label=\"Handling\" v-bind:value.sync=\"handling\"></currency-input>\n      <currency-input label=\"Discount\" v-bind:value.sync=\"discount\"></currency-input>\n\n      <p>Total: $</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n            <div>\\\n              <label v-if=\"label\"></label>\\\n              <input\\\n                v-model=\"value | currency\"\\\n                v-on:focus=\"selectAll\"\\\n              >\\\n            </div>\\\n          ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: function(value) {\n              return \"$\" + value.toFixed(2);\n            },\n            write: function(value) {\n              var number = +value.replace(/[^\\d.]/g, \"\");\n              return isNaN(number) ? 0 : number;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return this.price + this.shipping + this.handling - this.discount;\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n"},{"_content":"{\n  \"name\": \"vue-10-two-way-currency-filter-v2\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Showing how delayed state updates can cause strange behavior.\",\n  \"main\": \"index.html\",\n  \"scripts\": {\n    \"start\": \"serve\"\n  },\n  \"keywords\": [],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"serve\": \"^11.2.0\"\n  }\n}","source":"v2/examples/vue-10-two-way-currency-filter-v2/package.json","raw":"{\n  \"name\": \"vue-10-two-way-currency-filter-v2\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Showing how delayed state updates can cause strange behavior.\",\n  \"main\": \"index.html\",\n  \"scripts\": {\n    \"start\": \"serve\"\n  },\n  \"keywords\": [],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"serve\": \"^11.2.0\"\n  }\n}","date":"2020-09-25T23:55:41.111Z","updated":"2020-09-25T23:55:41.111Z","path":"v2/examples/vue-10-two-way-currency-filter-v2/package.json","layout":"false","title":"","comments":1,"_id":"ckfl66gyt002sc2v5xnpn7gcp","content":"{\"name\":\"vue-10-two-way-currency-filter-v2\",\"version\":\"1.0.0\",\"description\":\"Showing how delayed state updates can cause strange behavior.\",\"main\":\"index.html\",\"scripts\":{\"start\":\"serve\"},\"keywords\":[],\"license\":\"MIT\",\"devDependencies\":{\"serve\":\"^11.2.0\"}}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"vue-10-two-way-currency-filter-v2\",\"version\":\"1.0.0\",\"description\":\"Showing how delayed state updates can cause strange behavior.\",\"main\":\"index.html\",\"scripts\":{\"start\":\"serve\"},\"keywords\":[],\"license\":\"MIT\",\"devDependencies\":{\"serve\":\"^11.2.0\"}}"},{"_content":"{\n  \"template\": \"static\"\n}\n","source":"v2/examples/vue-10-two-way-currency-filter-v2/sandbox.config.json","raw":"{\n  \"template\": \"static\"\n}\n","date":"2020-09-25T23:55:41.111Z","updated":"2020-09-25T23:55:41.111Z","path":"v2/examples/vue-10-two-way-currency-filter-v2/sandbox.config.json","layout":"false","title":"","comments":1,"_id":"ckfl66gyt002tc2v5lugb5yew","content":"{\"template\":\"static\"}","site":{"data":{}},"excerpt":"","more":"{\"template\":\"static\"}"},{"_content":"var currencyValidator = {\n  format: function(number) {\n    return (Math.trunc(number * 100) / 100).toFixed(2);\n  },\n  parse: function(newString, oldNumber) {\n    var CleanParse = function(value) {\n      return { value: value };\n    };\n    var CurrencyWarning = function(warning, value) {\n      return {\n        warning: warning,\n        value: value,\n        attempt: newString\n      };\n    };\n    var NotAValidDollarAmountWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" is not a valid dollar amount\",\n        value\n      );\n    };\n    var AutomaticConversionWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" was automatically converted to \" + value,\n        value\n      );\n    };\n\n    var newNumber = Number(newString);\n    var indexOfDot = newString.indexOf(\".\");\n    var indexOfE = newString.indexOf(\"e\");\n\n    if (isNaN(newNumber)) {\n      if (\n        indexOfDot === -1 &&\n        indexOfE > 0 &&\n        indexOfE === newString.length - 1 &&\n        Number(newString.slice(0, indexOfE)) !== 0\n      ) {\n        return new CleanParse(oldNumber);\n      } else {\n        return new NotAValidDollarAmountWarning(oldNumber);\n      }\n    }\n\n    var newCurrencyString = currencyValidator.format(newNumber);\n    var newCurrencyNumber = Number(newCurrencyString);\n\n    if (newCurrencyNumber === newNumber) {\n      if (indexOfE !== -1 && indexOfE === newString.length - 2) {\n        return new AutomaticConversionWarning(newNumber);\n      } else {\n        return new CleanParse(newNumber);\n      }\n    } else {\n      return new NotAValidDollarAmountWarning(\n        newNumber > newCurrencyNumber ? newCurrencyNumber : oldNumber\n      );\n    }\n  }\n};\n","source":"v2/examples/vue-10-two-way-currency-filter-v3/currency-validator.js","raw":"var currencyValidator = {\n  format: function(number) {\n    return (Math.trunc(number * 100) / 100).toFixed(2);\n  },\n  parse: function(newString, oldNumber) {\n    var CleanParse = function(value) {\n      return { value: value };\n    };\n    var CurrencyWarning = function(warning, value) {\n      return {\n        warning: warning,\n        value: value,\n        attempt: newString\n      };\n    };\n    var NotAValidDollarAmountWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" is not a valid dollar amount\",\n        value\n      );\n    };\n    var AutomaticConversionWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" was automatically converted to \" + value,\n        value\n      );\n    };\n\n    var newNumber = Number(newString);\n    var indexOfDot = newString.indexOf(\".\");\n    var indexOfE = newString.indexOf(\"e\");\n\n    if (isNaN(newNumber)) {\n      if (\n        indexOfDot === -1 &&\n        indexOfE > 0 &&\n        indexOfE === newString.length - 1 &&\n        Number(newString.slice(0, indexOfE)) !== 0\n      ) {\n        return new CleanParse(oldNumber);\n      } else {\n        return new NotAValidDollarAmountWarning(oldNumber);\n      }\n    }\n\n    var newCurrencyString = currencyValidator.format(newNumber);\n    var newCurrencyNumber = Number(newCurrencyString);\n\n    if (newCurrencyNumber === newNumber) {\n      if (indexOfE !== -1 && indexOfE === newString.length - 2) {\n        return new AutomaticConversionWarning(newNumber);\n      } else {\n        return new CleanParse(newNumber);\n      }\n    } else {\n      return new NotAValidDollarAmountWarning(\n        newNumber > newCurrencyNumber ? newCurrencyNumber : oldNumber\n      );\n    }\n  }\n};\n","date":"2020-09-25T23:55:41.111Z","updated":"2020-09-25T23:55:41.111Z","path":"v2/examples/vue-10-two-way-currency-filter-v3/currency-validator.js","layout":"false","title":"","comments":1,"_id":"ckfl66gyv002uc2v5iiimdnqb","content":"var currencyValidator = {\n  format: function(number) {\n    return (Math.trunc(number * 100) / 100).toFixed(2);\n  },\n  parse: function(newString, oldNumber) {\n    var CleanParse = function(value) {\n      return { value: value };\n    };\n    var CurrencyWarning = function(warning, value) {\n      return {\n        warning: warning,\n        value: value,\n        attempt: newString\n      };\n    };\n    var NotAValidDollarAmountWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" is not a valid dollar amount\",\n        value\n      );\n    };\n    var AutomaticConversionWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" was automatically converted to \" + value,\n        value\n      );\n    };\n\n    var newNumber = Number(newString);\n    var indexOfDot = newString.indexOf(\".\");\n    var indexOfE = newString.indexOf(\"e\");\n\n    if (isNaN(newNumber)) {\n      if (\n        indexOfDot === -1 &&\n        indexOfE > 0 &&\n        indexOfE === newString.length - 1 &&\n        Number(newString.slice(0, indexOfE)) !== 0\n      ) {\n        return new CleanParse(oldNumber);\n      } else {\n        return new NotAValidDollarAmountWarning(oldNumber);\n      }\n    }\n\n    var newCurrencyString = currencyValidator.format(newNumber);\n    var newCurrencyNumber = Number(newCurrencyString);\n\n    if (newCurrencyNumber === newNumber) {\n      if (indexOfE !== -1 && indexOfE === newString.length - 2) {\n        return new AutomaticConversionWarning(newNumber);\n      } else {\n        return new CleanParse(newNumber);\n      }\n    } else {\n      return new NotAValidDollarAmountWarning(\n        newNumber > newCurrencyNumber ? newCurrencyNumber : oldNumber\n      );\n    }\n  }\n};\n","site":{"data":{}},"excerpt":"","more":"var currencyValidator = {\n  format: function(number) {\n    return (Math.trunc(number * 100) / 100).toFixed(2);\n  },\n  parse: function(newString, oldNumber) {\n    var CleanParse = function(value) {\n      return { value: value };\n    };\n    var CurrencyWarning = function(warning, value) {\n      return {\n        warning: warning,\n        value: value,\n        attempt: newString\n      };\n    };\n    var NotAValidDollarAmountWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" is not a valid dollar amount\",\n        value\n      );\n    };\n    var AutomaticConversionWarning = function(value) {\n      return new CurrencyWarning(\n        newString + \" was automatically converted to \" + value,\n        value\n      );\n    };\n\n    var newNumber = Number(newString);\n    var indexOfDot = newString.indexOf(\".\");\n    var indexOfE = newString.indexOf(\"e\");\n\n    if (isNaN(newNumber)) {\n      if (\n        indexOfDot === -1 &&\n        indexOfE > 0 &&\n        indexOfE === newString.length - 1 &&\n        Number(newString.slice(0, indexOfE)) !== 0\n      ) {\n        return new CleanParse(oldNumber);\n      } else {\n        return new NotAValidDollarAmountWarning(oldNumber);\n      }\n    }\n\n    var newCurrencyString = currencyValidator.format(newNumber);\n    var newCurrencyNumber = Number(newCurrencyString);\n\n    if (newCurrencyNumber === newNumber) {\n      if (indexOfE !== -1 && indexOfE === newString.length - 2) {\n        return new AutomaticConversionWarning(newNumber);\n      } else {\n        return new CleanParse(newNumber);\n      }\n    } else {\n      return new NotAValidDollarAmountWarning(\n        newNumber > newCurrencyNumber ? newCurrencyNumber : oldNumber\n      );\n    }\n  }\n};\n"},{"_content":"<!DOCTYPE html>\n<html>\n  <head>\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"currency-validator.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input\n        label=\"Shipping\"\n        v-bind:value.sync=\"shipping\"\n      ></currency-input>\n      <currency-input\n        label=\"Handling\"\n        v-bind:value.sync=\"handling\"\n      ></currency-input>\n      <currency-input\n        label=\"Discount\"\n        v-bind:value.sync=\"discount\"\n      ></currency-input>\n\n      <p>Total: ${{ total }}</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n          <div>\\\n            <label v-if=\"label\">{{ label }}</label>\\\n            $\\\n            <input\\\n              v-el:input\\\n              v-model=\"value | currency\"\\\n              v-on:focus=\"selectAll\"\\\n            >\\\n          </div>\\\n        ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: currencyValidator.format,\n            write: function(newValue, oldValue) {\n              var result = currencyValidator.parse(newValue, Number(oldValue));\n              if (result.warning) {\n                this.$els.input.value = result.value;\n              }\n              return result.value;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return (\n              (this.price * 100 +\n                this.shipping * 100 +\n                this.handling * 100 -\n                this.discount * 100) /\n              100\n            ).toFixed(2);\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","source":"v2/examples/vue-10-two-way-currency-filter-v3/index.html","raw":"<!DOCTYPE html>\n<html>\n  <head>\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"currency-validator.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input\n        label=\"Shipping\"\n        v-bind:value.sync=\"shipping\"\n      ></currency-input>\n      <currency-input\n        label=\"Handling\"\n        v-bind:value.sync=\"handling\"\n      ></currency-input>\n      <currency-input\n        label=\"Discount\"\n        v-bind:value.sync=\"discount\"\n      ></currency-input>\n\n      <p>Total: ${{ total }}</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n          <div>\\\n            <label v-if=\"label\">{{ label }}</label>\\\n            $\\\n            <input\\\n              v-el:input\\\n              v-model=\"value | currency\"\\\n              v-on:focus=\"selectAll\"\\\n            >\\\n          </div>\\\n        ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: currencyValidator.format,\n            write: function(newValue, oldValue) {\n              var result = currencyValidator.parse(newValue, Number(oldValue));\n              if (result.warning) {\n                this.$els.input.value = result.value;\n              }\n              return result.value;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return (\n              (this.price * 100 +\n                this.shipping * 100 +\n                this.handling * 100 -\n                this.discount * 100) /\n              100\n            ).toFixed(2);\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","date":"2020-09-25T23:55:41.112Z","updated":"2020-09-25T23:55:41.112Z","path":"v2/examples/vue-10-two-way-currency-filter-v3/index.html","title":"","comments":1,"layout":"page","_id":"ckfl66gyv002vc2v5rtldc8hi","content":"<!DOCTYPE html>\n<html>\n  <head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"currency-validator.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input label=\"Shipping\" v-bind:value.sync=\"shipping\"></currency-input>\n      <currency-input label=\"Handling\" v-bind:value.sync=\"handling\"></currency-input>\n      <currency-input label=\"Discount\" v-bind:value.sync=\"discount\"></currency-input>\n\n      <p>Total: $</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n          <div>\\\n            <label v-if=\"label\"></label>\\\n            $\\\n            <input\\\n              v-el:input\\\n              v-model=\"value | currency\"\\\n              v-on:focus=\"selectAll\"\\\n            >\\\n          </div>\\\n        ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: currencyValidator.format,\n            write: function(newValue, oldValue) {\n              var result = currencyValidator.parse(newValue, Number(oldValue));\n              if (result.warning) {\n                this.$els.input.value = result.value;\n              }\n              return result.value;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return (\n              (this.price * 100 +\n                this.shipping * 100 +\n                this.handling * 100 -\n                this.discount * 100) /\n              100\n            ).toFixed(2);\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n  <head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n    <title>Two-way Currency Filter</title>\n    <script src=\"https://unpkg.com/vue@1.0/dist/vue.js\"></script>\n    <script src=\"currency-validator.js\"></script>\n  </head>\n  <body>\n    <div id=\"app\">\n      <currency-input label=\"Price\" v-bind:value.sync=\"price\"></currency-input>\n      <currency-input label=\"Shipping\" v-bind:value.sync=\"shipping\"></currency-input>\n      <currency-input label=\"Handling\" v-bind:value.sync=\"handling\"></currency-input>\n      <currency-input label=\"Discount\" v-bind:value.sync=\"discount\"></currency-input>\n\n      <p>Total: $</p>\n    </div>\n\n    <script>\n      Vue.component(\"currency-input\", {\n        template:\n          '\\\n          <div>\\\n            <label v-if=\"label\"></label>\\\n            $\\\n            <input\\\n              v-el:input\\\n              v-model=\"value | currency\"\\\n              v-on:focus=\"selectAll\"\\\n            >\\\n          </div>\\\n        ',\n        props: {\n          value: {\n            type: Number,\n            default: 0,\n            twoWay: true\n          },\n          label: {\n            type: String,\n            default: \"\"\n          }\n        },\n        filters: {\n          currency: {\n            read: currencyValidator.format,\n            write: function(newValue, oldValue) {\n              var result = currencyValidator.parse(newValue, Number(oldValue));\n              if (result.warning) {\n                this.$els.input.value = result.value;\n              }\n              return result.value;\n            }\n          }\n        },\n        methods: {\n          selectAll: function(event) {\n            // Workaround for Safari bug\n            // http://stackoverflow.com/questions/1269722/selecting-text-on-focus-using-jquery-not-working-in-safari-and-chrome\n            setTimeout(function() {\n              event.target.select();\n            }, 0);\n          }\n        }\n      });\n\n      new Vue({\n        el: \"#app\",\n        data: {\n          price: 0,\n          shipping: 0,\n          handling: 0,\n          discount: 0\n        },\n        computed: {\n          total: function() {\n            return (\n              (this.price * 100 +\n                this.shipping * 100 +\n                this.handling * 100 -\n                this.discount * 100) /\n              100\n            ).toFixed(2);\n          }\n        }\n      });\n    </script>\n  </body>\n</html>\n"},{"_content":"{\n  \"name\": \"vue-10-two-way-currency-filter-v3\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Showing how delayed state updates can cause strange behavior.\",\n  \"main\": \"index.html\",\n  \"scripts\": {\n    \"start\": \"serve\"\n  },\n  \"keywords\": [],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"serve\": \"^11.2.0\"\n  }\n}","source":"v2/examples/vue-10-two-way-currency-filter-v3/package.json","raw":"{\n  \"name\": \"vue-10-two-way-currency-filter-v3\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Showing how delayed state updates can cause strange behavior.\",\n  \"main\": \"index.html\",\n  \"scripts\": {\n    \"start\": \"serve\"\n  },\n  \"keywords\": [],\n  \"license\": \"MIT\",\n  \"devDependencies\": {\n    \"serve\": \"^11.2.0\"\n  }\n}","date":"2020-09-25T23:55:41.112Z","updated":"2020-09-25T23:55:41.112Z","path":"v2/examples/vue-10-two-way-currency-filter-v3/package.json","layout":"false","title":"","comments":1,"_id":"ckfl66gyv002wc2v5yfadzzae","content":"{\"name\":\"vue-10-two-way-currency-filter-v3\",\"version\":\"1.0.0\",\"description\":\"Showing how delayed state updates can cause strange behavior.\",\"main\":\"index.html\",\"scripts\":{\"start\":\"serve\"},\"keywords\":[],\"license\":\"MIT\",\"devDependencies\":{\"serve\":\"^11.2.0\"}}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"vue-10-two-way-currency-filter-v3\",\"version\":\"1.0.0\",\"description\":\"Showing how delayed state updates can cause strange behavior.\",\"main\":\"index.html\",\"scripts\":{\"start\":\"serve\"},\"keywords\":[],\"license\":\"MIT\",\"devDependencies\":{\"serve\":\"^11.2.0\"}}"},{"_content":"{\n  \"template\": \"static\"\n}\n","source":"v2/examples/vue-10-two-way-currency-filter-v3/sandbox.config.json","raw":"{\n  \"template\": \"static\"\n}\n","date":"2020-09-25T23:55:41.112Z","updated":"2020-09-25T23:55:41.112Z","path":"v2/examples/vue-10-two-way-currency-filter-v3/sandbox.config.json","layout":"false","title":"","comments":1,"_id":"ckfl66gyv002xc2v53ajtglvy","content":"{\"template\":\"static\"}","site":{"data":{}},"excerpt":"","more":"{\"template\":\"static\"}"}],"Post":[{"title":"0.11 Component Tips","date":"2014-12-08T19:02:14.000Z","_content":"\n<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the [0.12 release notes](https://github.com/yyx990803/vue/releases) for the changes in the API.</p>\n\nThe release of 0.11 introduced [many changes](https://github.com/yyx990803/vue/blob/master/changes.md), but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.\n\n<!-- more -->\n\n### Isolated Scope and Data Passing\n\nStarting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via [Explicit Data Passing](/guide/components.html#Explicit_Data_Passing) using [`v-with`](/api/directives.html#v-with) or [`paramAttributes`](/api/options.html#paramAttributes).\n\n`paramAttributes` enables us to write Web Component style templates:\n\n``` js\nVue.component('my-component', {\n  paramAttributes: ['params'],\n  compiled: function () {\n    console.log(this.params) // passed from parent\n  }\n})\n```\n\n``` html\n<my-component params=\"{{params}}\"></my-component>\n```\n\n### Where Does It Belong?\n\nPreviously in 0.10, all directives on a component's container element are compiled in the child component's scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:\n\n``` html\n<!-- parent template -->\n<div v-component=\"child\" v-on=\"click:onParentClick\">\n  <p>{{parentMessage}}</p>\n</div>\n```\n\n``` html\n<!-- child template, with replace: true -->\n<div v-on=\"click:onChildClick\">\n  <h1>{{childMessage}}</h1>\n  <content></content>\n</div>\n```\n\nEverything in the parent template will be compiled in the parent's scope, including the content that's going to be inserted into the child component.\n\nThe only exception to the rule is `v-with` (and `paramAttributes` which compiles down to `v-with`), which works in both places - so you don't need to worry about it too much.\n\n### Cleaner Event Communication\n\nPreviously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It's also possible to trigger undesired listeners further up the chain if we do not cancel the event.\n\nThe most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, [a new directive `v-events`](/api/directives.html#v-events) has been introduced to enable exactly this behavior.\n\n0.11.4 has already been released, go try it out!\n","source":"_posts/011-component.md","raw":"---\ntitle: 0.11 Component Tips\ndate: 2014-12-08 15:02:14\ntags:\n---\n\n<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the [0.12 release notes](https://github.com/yyx990803/vue/releases) for the changes in the API.</p>\n\nThe release of 0.11 introduced [many changes](https://github.com/yyx990803/vue/blob/master/changes.md), but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.\n\n<!-- more -->\n\n### Isolated Scope and Data Passing\n\nStarting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via [Explicit Data Passing](/guide/components.html#Explicit_Data_Passing) using [`v-with`](/api/directives.html#v-with) or [`paramAttributes`](/api/options.html#paramAttributes).\n\n`paramAttributes` enables us to write Web Component style templates:\n\n``` js\nVue.component('my-component', {\n  paramAttributes: ['params'],\n  compiled: function () {\n    console.log(this.params) // passed from parent\n  }\n})\n```\n\n``` html\n<my-component params=\"{{params}}\"></my-component>\n```\n\n### Where Does It Belong?\n\nPreviously in 0.10, all directives on a component's container element are compiled in the child component's scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:\n\n``` html\n<!-- parent template -->\n<div v-component=\"child\" v-on=\"click:onParentClick\">\n  <p>{{parentMessage}}</p>\n</div>\n```\n\n``` html\n<!-- child template, with replace: true -->\n<div v-on=\"click:onChildClick\">\n  <h1>{{childMessage}}</h1>\n  <content></content>\n</div>\n```\n\nEverything in the parent template will be compiled in the parent's scope, including the content that's going to be inserted into the child component.\n\nThe only exception to the rule is `v-with` (and `paramAttributes` which compiles down to `v-with`), which works in both places - so you don't need to worry about it too much.\n\n### Cleaner Event Communication\n\nPreviously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It's also possible to trigger undesired listeners further up the chain if we do not cancel the event.\n\nThe most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, [a new directive `v-events`](/api/directives.html#v-events) has been introduced to enable exactly this behavior.\n\n0.11.4 has already been released, go try it out!\n","slug":"011-component","published":1,"updated":"2020-09-25T23:55:41.064Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwh0001c2v58ulmr9b1","content":"<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the <a href=\"https://github.com/yyx990803/vue/releases\" target=\"_blank\" rel=\"noopener\">0.12 release notes</a> for the changes in the API.</p>\n\n<p>The release of 0.11 introduced <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\" target=\"_blank\" rel=\"noopener\">many changes</a>, but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.</p>\n<a id=\"more\"></a>\n<h3 id=\"Isolated-Scope-and-Data-Passing\"><a href=\"#Isolated-Scope-and-Data-Passing\" class=\"headerlink\" title=\"Isolated Scope and Data Passing\"></a>Isolated Scope and Data Passing</h3><p>Starting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via <a href=\"/guide/components.html#Explicit_Data_Passing\">Explicit Data Passing</a> using <a href=\"/api/directives.html#v-with\"><code>v-with</code></a> or <a href=\"/api/options.html#paramAttributes\"><code>paramAttributes</code></a>.</p>\n<p><code>paramAttributes</code> enables us to write Web Component style templates:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">paramAttributes</span>: [<span class=\"hljs-string\">'params'</span>],\n  <span class=\"hljs-attr\">compiled</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.params) <span class=\"hljs-comment\">// passed from parent</span>\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">params</span>=<span class=\"hljs-string\">\"&#123;&#123;params&#125;&#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<h3 id=\"Where-Does-It-Belong\"><a href=\"#Where-Does-It-Belong\" class=\"headerlink\" title=\"Where Does It Belong?\"></a>Where Does It Belong?</h3><p>Previously in 0.10, all directives on a component’s container element are compiled in the child component’s scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- parent template --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-component</span>=<span class=\"hljs-string\">\"child\"</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"click:onParentClick\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;parentMessage&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- child template, with replace: true --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"click:onChildClick\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123;childMessage&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">content</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">content</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Everything in the parent template will be compiled in the parent’s scope, including the content that’s going to be inserted into the child component.</p>\n<p>The only exception to the rule is <code>v-with</code> (and <code>paramAttributes</code> which compiles down to <code>v-with</code>), which works in both places - so you don’t need to worry about it too much.</p>\n<h3 id=\"Cleaner-Event-Communication\"><a href=\"#Cleaner-Event-Communication\" class=\"headerlink\" title=\"Cleaner Event Communication\"></a>Cleaner Event Communication</h3><p>Previously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It’s also possible to trigger undesired listeners further up the chain if we do not cancel the event.</p>\n<p>The most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, <a href=\"/api/directives.html#v-events\">a new directive <code>v-events</code></a> has been introduced to enable exactly this behavior.</p>\n<p>0.11.4 has already been released, go try it out!</p>\n","site":{"data":{}},"excerpt":"<p class=\"tip\">Note: this post contains information for the outdated 0.11 version. Please refer to the <a href=\"https://github.com/yyx990803/vue/releases\" target=\"_blank\" rel=\"noopener\">0.12 release notes</a> for the changes in the API.</p>\n\n<p>The release of 0.11 introduced <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\" target=\"_blank\" rel=\"noopener\">many changes</a>, but the most important one is how the new component scope works. Previously in 0.10.x, components have inherited scope by default. That means in a child component template you can reference parent scope properties. This often leads to tightly-coupled components, where a child component assumes knowledge of what properties are present in the parent scope. It is also possible to accidentally refer to a parent scope property in a child component.</p>","more":"<h3 id=\"Isolated-Scope-and-Data-Passing\"><a href=\"#Isolated-Scope-and-Data-Passing\" class=\"headerlink\" title=\"Isolated Scope and Data Passing\"></a>Isolated Scope and Data Passing</h3><p>Starting in 0.11, all child components have isolated scope by default, and the recommended way to control component data access is via <a href=\"/guide/components.html#Explicit_Data_Passing\">Explicit Data Passing</a> using <a href=\"/api/directives.html#v-with\"><code>v-with</code></a> or <a href=\"/api/options.html#paramAttributes\"><code>paramAttributes</code></a>.</p>\n<p><code>paramAttributes</code> enables us to write Web Component style templates:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'my-component'</span>, &#123;\n  <span class=\"hljs-attr\">paramAttributes</span>: [<span class=\"hljs-string\">'params'</span>],\n  <span class=\"hljs-attr\">compiled</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.params) <span class=\"hljs-comment\">// passed from parent</span>\n  &#125;\n&#125;)</code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">params</span>=<span class=\"hljs-string\">\"&#123;&#123;params&#125;&#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<h3 id=\"Where-Does-It-Belong\"><a href=\"#Where-Does-It-Belong\" class=\"headerlink\" title=\"Where Does It Belong?\"></a>Where Does It Belong?</h3><p>Previously in 0.10, all directives on a component’s container element are compiled in the child component’s scope. Because it inherited parent scope, this worked in most situations. Starting in 0.11.1, we want to provide a cleaner separation between component scopes. The rule of thumbs is: if something appears in the parent template, it will be compiled in parent scope; if it appears in child template, it will be compiled in child scope. For example:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- parent template --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-component</span>=<span class=\"hljs-string\">\"child\"</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"click:onParentClick\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;parentMessage&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- child template, with replace: true --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"click:onChildClick\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>&#123;&#123;childMessage&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">content</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">content</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>Everything in the parent template will be compiled in the parent’s scope, including the content that’s going to be inserted into the child component.</p>\n<p>The only exception to the rule is <code>v-with</code> (and <code>paramAttributes</code> which compiles down to <code>v-with</code>), which works in both places - so you don’t need to worry about it too much.</p>\n<h3 id=\"Cleaner-Event-Communication\"><a href=\"#Cleaner-Event-Communication\" class=\"headerlink\" title=\"Cleaner Event Communication\"></a>Cleaner Event Communication</h3><p>Previously the standard way for a child component to communicate to its parent is via dispatching events. However, with this approach, the event listeners on the parent component are not guaranteed to be listening on the desired child component only. It’s also possible to trigger undesired listeners further up the chain if we do not cancel the event.</p>\n<p>The most common use case is for a parent to react to the events from a specific, direct child component. So in 0.11.4, <a href=\"/api/directives.html#v-events\">a new directive <code>v-events</code></a> has been introduced to enable exactly this behavior.</p>\n<p>0.11.4 has already been released, go try it out!</p>"},{"title":"Vue.js 0.12 released!","date":"2015-06-11T20:37:30.000Z","_content":"\nI'm really excited to announce that [Vue.js 0.12: Dragon Ball](https://github.com/yyx990803/vue/releases/tag/0.12.0) is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.\n\nThere's a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the [Full Release Note](https://github.com/yyx990803/vue/releases/tag/0.12.0) and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to [vuejs/Discussion](https://github.com/vuejs/Discussion/issues), or join us in the [Gitter chat channel](https://gitter.im/yyx990803/vue).\n\n<!-- more -->\n\n### More Consistent Component Syntax\n\nPreviously in 0.11 you have two ways to use a Vue.js component: using the `v-component` directive, or using custom elements. There are also two ways to pass data down to child components: using the `v-with` directive, or using the `paramAttributes` option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.\n\nIn addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.\n\nAs a result, `v-component` and `v-with` have been deprecated in 0.12. `paramAttributes` has also been renamed to `props`, which is shorter and cleaner. From now on, most Vue.js components will look like this:\n\n``` html\n<my-component prop=\"{{parentData}}\"></my-component>\n```\n\nThere are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated [Component System](/guide/components.html) section of the guide.\n\n### Filter Arguments Improvements\n\nIn 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrieve a dynamic value on the vm instead of a plain string.\n\nIn 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.\n\nThis means the usage of some existing filters will have to change:\n\n``` html\n<a v-on=\"keyup: onKeyUp | key 'enter'\"></a>\n{{ items.length | pluralize 'item' }}\n```\n\nBut it would make custom filters that rely on dynamic values much easier to write:\n\n``` html\n{{ msg | concat otherMsg }}\n```\n\nHere the first argument to the `concat` filter will be the value of `this.otherMsg`.\n\n### Asynchronous Components\n\nIt is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.\n\nWell, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn't it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.\n\nIn 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\nIt is up to you to decide how to load the component from the server, e.g. `$.getScript()` or require.js; but the recommended usage is to pair it up with Webpack's [Code Splitting feature](http://webpack.github.io/docs/code-splitting.html):\n\n``` js\nVue.component('async-webpack-example', function (resolve, reject) {\n  // In Webpack AMD like syntax indicates a code split point\n  require(['./my-async-component'], resolve)\n})\n```\n\nThat's all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example [here](https://github.com/vuejs/vue-webpack-example).\n\n### Improved Transition System\n\nVue.js' transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.\n\n`v-repeat` now also ships with built-in support for staggering transitions. It is as simple as adding `stagger=\"100\"` to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.\n\nFor full details on the new transition system, check out the [updated guide](/guide/transitions.html).\n\n### Performance Tuning\n\nVue.js' precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there's always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper `track-by` usage, [re-rendering with large, brand new dataset](http://vuejs.github.io/js-repaint-perfs/vue/) is also comparable to, or even faster than other Virtual-DOM based frameworks.\n\n### One More Thing...\n\nWith 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.\n","source":"_posts/012-release.md","raw":"---\ntitle: Vue.js 0.12 released!\ndate: 2015-06-11 17:37:30\n---\n\nI'm really excited to announce that [Vue.js 0.12: Dragon Ball](https://github.com/yyx990803/vue/releases/tag/0.12.0) is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.\n\nThere's a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the [Full Release Note](https://github.com/yyx990803/vue/releases/tag/0.12.0) and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to [vuejs/Discussion](https://github.com/vuejs/Discussion/issues), or join us in the [Gitter chat channel](https://gitter.im/yyx990803/vue).\n\n<!-- more -->\n\n### More Consistent Component Syntax\n\nPreviously in 0.11 you have two ways to use a Vue.js component: using the `v-component` directive, or using custom elements. There are also two ways to pass data down to child components: using the `v-with` directive, or using the `paramAttributes` option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.\n\nIn addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.\n\nAs a result, `v-component` and `v-with` have been deprecated in 0.12. `paramAttributes` has also been renamed to `props`, which is shorter and cleaner. From now on, most Vue.js components will look like this:\n\n``` html\n<my-component prop=\"{{parentData}}\"></my-component>\n```\n\nThere are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated [Component System](/guide/components.html) section of the guide.\n\n### Filter Arguments Improvements\n\nIn 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrieve a dynamic value on the vm instead of a plain string.\n\nIn 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.\n\nThis means the usage of some existing filters will have to change:\n\n``` html\n<a v-on=\"keyup: onKeyUp | key 'enter'\"></a>\n{{ items.length | pluralize 'item' }}\n```\n\nBut it would make custom filters that rely on dynamic values much easier to write:\n\n``` html\n{{ msg | concat otherMsg }}\n```\n\nHere the first argument to the `concat` filter will be the value of `this.otherMsg`.\n\n### Asynchronous Components\n\nIt is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.\n\nWell, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn't it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.\n\nIn 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:\n\n``` js\nVue.component('async-example', function (resolve, reject) {\n  setTimeout(function () {\n    resolve({\n      template: '<div>I am async!</div>'\n    })\n  }, 1000)\n})\n```\n\nIt is up to you to decide how to load the component from the server, e.g. `$.getScript()` or require.js; but the recommended usage is to pair it up with Webpack's [Code Splitting feature](http://webpack.github.io/docs/code-splitting.html):\n\n``` js\nVue.component('async-webpack-example', function (resolve, reject) {\n  // In Webpack AMD like syntax indicates a code split point\n  require(['./my-async-component'], resolve)\n})\n```\n\nThat's all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example [here](https://github.com/vuejs/vue-webpack-example).\n\n### Improved Transition System\n\nVue.js' transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.\n\n`v-repeat` now also ships with built-in support for staggering transitions. It is as simple as adding `stagger=\"100\"` to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.\n\nFor full details on the new transition system, check out the [updated guide](/guide/transitions.html).\n\n### Performance Tuning\n\nVue.js' precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there's always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper `track-by` usage, [re-rendering with large, brand new dataset](http://vuejs.github.io/js-repaint-perfs/vue/) is also comparable to, or even faster than other Virtual-DOM based frameworks.\n\n### One More Thing...\n\nWith 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.\n","slug":"012-release","published":1,"updated":"2020-09-25T23:55:41.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwl0003c2v5l2199222","content":"<p>I’m really excited to announce that <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\" target=\"_blank\" rel=\"noopener\">Vue.js 0.12: Dragon Ball</a> is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.</p>\n<p>There’s a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\" target=\"_blank\" rel=\"noopener\">Full Release Note</a> and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to <a href=\"https://github.com/vuejs/Discussion/issues\" target=\"_blank\" rel=\"noopener\">vuejs/Discussion</a>, or join us in the <a href=\"https://gitter.im/yyx990803/vue\" target=\"_blank\" rel=\"noopener\">Gitter chat channel</a>.</p>\n<a id=\"more\"></a>\n<h3 id=\"More-Consistent-Component-Syntax\"><a href=\"#More-Consistent-Component-Syntax\" class=\"headerlink\" title=\"More Consistent Component Syntax\"></a>More Consistent Component Syntax</h3><p>Previously in 0.11 you have two ways to use a Vue.js component: using the <code>v-component</code> directive, or using custom elements. There are also two ways to pass data down to child components: using the <code>v-with</code> directive, or using the <code>paramAttributes</code> option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.</p>\n<p>In addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.</p>\n<p>As a result, <code>v-component</code> and <code>v-with</code> have been deprecated in 0.12. <code>paramAttributes</code> has also been renamed to <code>props</code>, which is shorter and cleaner. From now on, most Vue.js components will look like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">prop</span>=<span class=\"hljs-string\">\"&#123;&#123;parentData&#125;&#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>There are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated <a href=\"/guide/components.html\">Component System</a> section of the guide.</p>\n<h3 id=\"Filter-Arguments-Improvements\"><a href=\"#Filter-Arguments-Improvements\" class=\"headerlink\" title=\"Filter Arguments Improvements\"></a>Filter Arguments Improvements</h3><p>In 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrieve a dynamic value on the vm instead of a plain string.</p>\n<p>In 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.</p>\n<p>This means the usage of some existing filters will have to change:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"keyup: onKeyUp | key 'enter'\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n&#123;&#123; items.length | pluralize 'item' &#125;&#125;</code></pre>\n<p>But it would make custom filters that rely on dynamic values much easier to write:</p>\n<pre><code class=\"hljs html\">&#123;&#123; msg | concat otherMsg &#125;&#125;</code></pre>\n<p>Here the first argument to the <code>concat</code> filter will be the value of <code>this.otherMsg</code>.</p>\n<h3 id=\"Asynchronous-Components\"><a href=\"#Asynchronous-Components\" class=\"headerlink\" title=\"Asynchronous Components\"></a>Asynchronous Components</h3><p>It is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.</p>\n<p>Well, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn’t it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.</p>\n<p>In 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    resolve(&#123;\n      <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span>\n    &#125;)\n  &#125;, <span class=\"hljs-number\">1000</span>)\n&#125;)</code></pre>\n<p>It is up to you to decide how to load the component from the server, e.g. <code>$.getScript()</code> or require.js; but the recommended usage is to pair it up with Webpack’s <a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"noopener\">Code Splitting feature</a>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-webpack-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;\n  <span class=\"hljs-comment\">// In Webpack AMD like syntax indicates a code split point</span>\n  <span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">'./my-async-component'</span>], resolve)\n&#125;)</code></pre>\n<p>That’s all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example <a href=\"https://github.com/vuejs/vue-webpack-example\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h3 id=\"Improved-Transition-System\"><a href=\"#Improved-Transition-System\" class=\"headerlink\" title=\"Improved Transition System\"></a>Improved Transition System</h3><p>Vue.js’ transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.</p>\n<p><code>v-repeat</code> now also ships with built-in support for staggering transitions. It is as simple as adding <code>stagger=&quot;100&quot;</code> to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.</p>\n<p>For full details on the new transition system, check out the <a href=\"/guide/transitions.html\">updated guide</a>.</p>\n<h3 id=\"Performance-Tuning\"><a href=\"#Performance-Tuning\" class=\"headerlink\" title=\"Performance Tuning\"></a>Performance Tuning</h3><p>Vue.js’ precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there’s always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper <code>track-by</code> usage, <a href=\"http://vuejs.github.io/js-repaint-perfs/vue/\" target=\"_blank\" rel=\"noopener\">re-rendering with large, brand new dataset</a> is also comparable to, or even faster than other Virtual-DOM based frameworks.</p>\n<h3 id=\"One-More-Thing…\"><a href=\"#One-More-Thing…\" class=\"headerlink\" title=\"One More Thing…\"></a>One More Thing…</h3><p>With 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.</p>\n","site":{"data":{}},"excerpt":"<p>I’m really excited to announce that <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\" target=\"_blank\" rel=\"noopener\">Vue.js 0.12: Dragon Ball</a> is finally here! Thanks to everyone who tried out the beta/rc versions and provided feedback / bug reports along the way.</p>\n<p>There’s a lot to cover in this release, and we will talk about a few highlights below. However, it is still recommended to carefully go through the <a href=\"https://github.com/yyx990803/vue/releases/tag/0.12.0\" target=\"_blank\" rel=\"noopener\">Full Release Note</a> and updated docs if you are upgrading from 0.11. You can report bugs on GitHub, send questions to <a href=\"https://github.com/vuejs/Discussion/issues\" target=\"_blank\" rel=\"noopener\">vuejs/Discussion</a>, or join us in the <a href=\"https://gitter.im/yyx990803/vue\" target=\"_blank\" rel=\"noopener\">Gitter chat channel</a>.</p>","more":"<h3 id=\"More-Consistent-Component-Syntax\"><a href=\"#More-Consistent-Component-Syntax\" class=\"headerlink\" title=\"More Consistent Component Syntax\"></a>More Consistent Component Syntax</h3><p>Previously in 0.11 you have two ways to use a Vue.js component: using the <code>v-component</code> directive, or using custom elements. There are also two ways to pass data down to child components: using the <code>v-with</code> directive, or using the <code>paramAttributes</code> option. Although both custom elements and param attributes get compiled down to directives eventually, it is confusing and redundant to have two sets of syntax for the same functionality.</p>\n<p>In addition, it should be noted that the component system is a first-class concept in Vue.js, even more important than directives. It defines how we encapsulate our higher-level view logic and compose our application. In the meanwhile, having a clear and declarative way to pass data into child components is also very important. Components and param attributes really deserve their own dedicated syntax to differentiate from other directives.</p>\n<p>As a result, <code>v-component</code> and <code>v-with</code> have been deprecated in 0.12. <code>paramAttributes</code> has also been renamed to <code>props</code>, which is shorter and cleaner. From now on, most Vue.js components will look like this:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">my-component</span> <span class=\"hljs-attr\">prop</span>=<span class=\"hljs-string\">\"&#123;&#123;parentData&#125;&#125;\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">my-component</span>&gt;</span></code></pre>\n<p>There are also additional props-related improvements such as explicit one-time or one-way props, expression as props, methods as prop callbacks and more. You can find out more details in the 0.12 release notes linked above and the updated <a href=\"/guide/components.html\">Component System</a> section of the guide.</p>\n<h3 id=\"Filter-Arguments-Improvements\"><a href=\"#Filter-Arguments-Improvements\" class=\"headerlink\" title=\"Filter Arguments Improvements\"></a>Filter Arguments Improvements</h3><p>In 0.11, filters always receive their arguments as plain strings. An argument can be enclosed in quotes to include whitespace, but the quotes are not automatically stripped when passed into the filter function. Some users were also confused about how to retrieve a dynamic value on the vm instead of a plain string.</p>\n<p>In 0.12, the filter argument syntax now follows a simple rule: if an argument is enclosed in quotes, it will be passed in as a plain string; otherwise, it will be evaluated against the current vm as a dynamic value.</p>\n<p>This means the usage of some existing filters will have to change:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">v-on</span>=<span class=\"hljs-string\">\"keyup: onKeyUp | key 'enter'\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n&#123;&#123; items.length | pluralize 'item' &#125;&#125;</code></pre>\n<p>But it would make custom filters that rely on dynamic values much easier to write:</p>\n<pre><code class=\"hljs html\">&#123;&#123; msg | concat otherMsg &#125;&#125;</code></pre>\n<p>Here the first argument to the <code>concat</code> filter will be the value of <code>this.otherMsg</code>.</p>\n<h3 id=\"Asynchronous-Components\"><a href=\"#Asynchronous-Components\" class=\"headerlink\" title=\"Asynchronous Components\"></a>Asynchronous Components</h3><p>It is common practice to bundle all the JavaScript into one file when building large single page applications. But when the file becomes too large, we may want to defer loading parts of our application for a faster initial load. However, this does pose some constraints on how the application architecture should be designed. It could be very tricky to figure out how to properly split up your JavaScript bundles.</p>\n<p>Well, with Vue.js we can already build our applications as decoupled components. If we can lazily load a dynamic component only when it is needed, wouldn’t it be awesome? As a matter of fact, in 0.12 this would be trivially easy with the new Asynchronous Component feature.</p>\n<p>In 0.12, you can define a component as a factory function that asynchronously resolves a component definition (can be just a plain options object). Vue.js will only trigger the factory function when the component actually needs to be rendered, and will cache the result for future re-renders:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;\n  setTimeout(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;\n    resolve(&#123;\n      <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">'&lt;div&gt;I am async!&lt;/div&gt;'</span>\n    &#125;)\n  &#125;, <span class=\"hljs-number\">1000</span>)\n&#125;)</code></pre>\n<p>It is up to you to decide how to load the component from the server, e.g. <code>$.getScript()</code> or require.js; but the recommended usage is to pair it up with Webpack’s <a href=\"http://webpack.github.io/docs/code-splitting.html\" target=\"_blank\" rel=\"noopener\">Code Splitting feature</a>:</p>\n<pre><code class=\"hljs js\">Vue.component(<span class=\"hljs-string\">'async-webpack-example'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve, reject</span>) </span>&#123;\n  <span class=\"hljs-comment\">// In Webpack AMD like syntax indicates a code split point</span>\n  <span class=\"hljs-built_in\">require</span>([<span class=\"hljs-string\">'./my-async-component'</span>], resolve)\n&#125;)</code></pre>\n<p>That’s all you need to do. You can use the component just like before, without even thinking about it being async. Webpack will automatically split your final JavaScript into separate bundles with correct dependencies, and automatically load a bundle via Ajax when it is required. You can check out a fully functional example <a href=\"https://github.com/vuejs/vue-webpack-example\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h3 id=\"Improved-Transition-System\"><a href=\"#Improved-Transition-System\" class=\"headerlink\" title=\"Improved Transition System\"></a>Improved Transition System</h3><p>Vue.js’ transition system is really easy to use, but in the past it has the limitation that you cannot mix CSS and JavaScript-based transitions together. In 0.12 that is no longer the case! The improved transition system now allows you to add JavaScript hooks to a CSS-based transition for additional control. The amount of hooks exposed have also been expanded to give you finer-grained control at every stage of the transition.</p>\n<p><code>v-repeat</code> now also ships with built-in support for staggering transitions. It is as simple as adding <code>stagger=&quot;100&quot;</code> to your repeated element. It is also possible to define separate staggering for enter and leaving, or even dynamically calculate the staggering delay in a JavaScript hook.</p>\n<p>For full details on the new transition system, check out the <a href=\"/guide/transitions.html\">updated guide</a>.</p>\n<h3 id=\"Performance-Tuning\"><a href=\"#Performance-Tuning\" class=\"headerlink\" title=\"Performance Tuning\"></a>Performance Tuning</h3><p>Vue.js’ precise dependency tracking makes it the one of the most efficient view layer for small hot updates, but there’s always room for improvement. In 0.12, internal instance creation and compilation refactors have improved first-render performance for large lists by up to 40%. With proper <code>track-by</code> usage, <a href=\"http://vuejs.github.io/js-repaint-perfs/vue/\" target=\"_blank\" rel=\"noopener\">re-rendering with large, brand new dataset</a> is also comparable to, or even faster than other Virtual-DOM based frameworks.</p>\n<h3 id=\"One-More-Thing…\"><a href=\"#One-More-Thing…\" class=\"headerlink\" title=\"One More Thing…\"></a>One More Thing…</h3><p>With 0.12 out of the door, more efforts will now be spent on the official vue-router, a dedicated routing library for Vue.js with nested view matching, full transition support, and asynchronous data hooks. I have expressed that Vue.js core intends to stay as a no-frills, drop-in view layer library, and that will not change. The vue-router will be shipped separately and is totally optional, however you can expect it to work seamlessly with Vue.js core when you need it.</p>"},{"title":"Vue.js 1.0.0 Released","date":"2015-10-26T13:00:00.000Z","_content":"\n> Hi HN! If you are not familiar with Vue.js, you might want to read this [blog post](http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/) for a higher level overview.\n\nAfter 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of [Vue.js 1.0.0 Evangelion](https://github.com/vuejs/vue/releases/tag/1.0.0)! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.\n\n<!-- more -->\n\n### Improved Template Syntax\n\nThe 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for `v-on` and `v-bind`:\n\n``` html\n<!-- short for v-bind:href -->\n<a :href=\"someURL\"></a>\n\n<!-- short for v-on:click -->\n<button @click=\"onClick\"></button>\n```\n\nWhen used on a child component, `v-on` listens for custom events and `v-bind` can be used to bind props. The shorthands using child components very succinct:\n\n``` html\n<item-list\n  :items=\"items\"\n  @ready=\"onItemsReady\"\n  @update=\"onItemsUpdate\">\n</item-list>\n```\n\n### API Cleanup\n\nThe overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.\n\nFor example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The `inherit` option is also removed, because it too often leads to tightly coupled components that are hard to refactor.\n\n### Faster Initial Rendering\n\n1.0 replaces the old `v-repeat` directive with `v-for`. In addition to providing the same functionality and more intuitive scoping, `v-for` provides up to **100%** initial render performance boost when rendering large lists and tables!\n\n### More Powerful Tooling\n\nThere are also exciting things going on outside of Vue.js core - [vue-loader](https://github.com/vuejs/vue-loader) and [vueify](https://github.com/vuejs/vueify) have received major upgrades including:\n\n- Hot component reloading. When a `*.vue` component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn't need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.\n\n- Scoped CSS. By simply adding a `scoped` attribute to your `*.vue` component style tags, the component's template and final generated CSS are magically re-written to ensure a component's styles are only applied to its own elements. Most importantly, the styles specified in a parent component **does not** leak down to child components nested within it.\n\n- ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. `vue-loader` and `vueify` now transpiles the JavaScript in your `*.vue` components out of the box, without the need for extra setup. Write future JavaScript today!\n\nCombined with [vue-router](https://github.com/vuejs/vue-router), Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.\n\n### What's Next?\n\nAs what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:\n\n1. Improving `vue-router` and make it production ready.\n\n2. Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.\n\n3. Providing more learning resources such as tutorials and examples.\n","source":"_posts/1.0.0-release.md","raw":"---\ntitle: Vue.js 1.0.0 Released\ndate: 2015-10-26 10:00:00\n---\n\n> Hi HN! If you are not familiar with Vue.js, you might want to read this [blog post](http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/) for a higher level overview.\n\nAfter 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of [Vue.js 1.0.0 Evangelion](https://github.com/vuejs/vue/releases/tag/1.0.0)! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.\n\n<!-- more -->\n\n### Improved Template Syntax\n\nThe 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for `v-on` and `v-bind`:\n\n``` html\n<!-- short for v-bind:href -->\n<a :href=\"someURL\"></a>\n\n<!-- short for v-on:click -->\n<button @click=\"onClick\"></button>\n```\n\nWhen used on a child component, `v-on` listens for custom events and `v-bind` can be used to bind props. The shorthands using child components very succinct:\n\n``` html\n<item-list\n  :items=\"items\"\n  @ready=\"onItemsReady\"\n  @update=\"onItemsUpdate\">\n</item-list>\n```\n\n### API Cleanup\n\nThe overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.\n\nFor example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The `inherit` option is also removed, because it too often leads to tightly coupled components that are hard to refactor.\n\n### Faster Initial Rendering\n\n1.0 replaces the old `v-repeat` directive with `v-for`. In addition to providing the same functionality and more intuitive scoping, `v-for` provides up to **100%** initial render performance boost when rendering large lists and tables!\n\n### More Powerful Tooling\n\nThere are also exciting things going on outside of Vue.js core - [vue-loader](https://github.com/vuejs/vue-loader) and [vueify](https://github.com/vuejs/vueify) have received major upgrades including:\n\n- Hot component reloading. When a `*.vue` component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn't need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.\n\n- Scoped CSS. By simply adding a `scoped` attribute to your `*.vue` component style tags, the component's template and final generated CSS are magically re-written to ensure a component's styles are only applied to its own elements. Most importantly, the styles specified in a parent component **does not** leak down to child components nested within it.\n\n- ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. `vue-loader` and `vueify` now transpiles the JavaScript in your `*.vue` components out of the box, without the need for extra setup. Write future JavaScript today!\n\nCombined with [vue-router](https://github.com/vuejs/vue-router), Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.\n\n### What's Next?\n\nAs what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:\n\n1. Improving `vue-router` and make it production ready.\n\n2. Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.\n\n3. Providing more learning resources such as tutorials and examples.\n","slug":"1.0.0-release","published":1,"updated":"2020-09-25T23:55:41.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwn0005c2v5mm5xaty8","content":"<blockquote>\n<p>Hi HN! If you are not familiar with Vue.js, you might want to read this <a href=\"http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/\" target=\"_blank\" rel=\"noopener\">blog post</a> for a higher level overview.</p>\n</blockquote>\n<p>After 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of <a href=\"https://github.com/vuejs/vue/releases/tag/1.0.0\" target=\"_blank\" rel=\"noopener\">Vue.js 1.0.0 Evangelion</a>! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.</p>\n<a id=\"more\"></a>\n<h3 id=\"Improved-Template-Syntax\"><a href=\"#Improved-Template-Syntax\" class=\"headerlink\" title=\"Improved Template Syntax\"></a>Improved Template Syntax</h3><p>The 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for <code>v-on</code> and <code>v-bind</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- short for v-bind:href --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:href</span>=<span class=\"hljs-string\">\"someURL\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- short for v-on:click --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>When used on a child component, <code>v-on</code> listens for custom events and <code>v-bind</code> can be used to bind props. The shorthands using child components very succinct:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item-list</span>\n  <span class=\"hljs-attr\">:items</span>=<span class=\"hljs-string\">\"items\"</span>\n  @<span class=\"hljs-attr\">ready</span>=<span class=\"hljs-string\">\"onItemsReady\"</span>\n  @<span class=\"hljs-attr\">update</span>=<span class=\"hljs-string\">\"onItemsUpdate\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item-list</span>&gt;</span></code></pre>\n<h3 id=\"API-Cleanup\"><a href=\"#API-Cleanup\" class=\"headerlink\" title=\"API Cleanup\"></a>API Cleanup</h3><p>The overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.</p>\n<p>For example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The <code>inherit</code> option is also removed, because it too often leads to tightly coupled components that are hard to refactor.</p>\n<h3 id=\"Faster-Initial-Rendering\"><a href=\"#Faster-Initial-Rendering\" class=\"headerlink\" title=\"Faster Initial Rendering\"></a>Faster Initial Rendering</h3><p>1.0 replaces the old <code>v-repeat</code> directive with <code>v-for</code>. In addition to providing the same functionality and more intuitive scoping, <code>v-for</code> provides up to <strong>100%</strong> initial render performance boost when rendering large lists and tables!</p>\n<h3 id=\"More-Powerful-Tooling\"><a href=\"#More-Powerful-Tooling\" class=\"headerlink\" title=\"More Powerful Tooling\"></a>More Powerful Tooling</h3><p>There are also exciting things going on outside of Vue.js core - <a href=\"https://github.com/vuejs/vue-loader\" target=\"_blank\" rel=\"noopener\">vue-loader</a> and <a href=\"https://github.com/vuejs/vueify\" target=\"_blank\" rel=\"noopener\">vueify</a> have received major upgrades including:</p>\n<ul>\n<li><p>Hot component reloading. When a <code>*.vue</code> component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn’t need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.</p>\n</li>\n<li><p>Scoped CSS. By simply adding a <code>scoped</code> attribute to your <code>*.vue</code> component style tags, the component’s template and final generated CSS are magically re-written to ensure a component’s styles are only applied to its own elements. Most importantly, the styles specified in a parent component <strong>does not</strong> leak down to child components nested within it.</p>\n</li>\n<li><p>ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. <code>vue-loader</code> and <code>vueify</code> now transpiles the JavaScript in your <code>*.vue</code> components out of the box, without the need for extra setup. Write future JavaScript today!</p>\n</li>\n</ul>\n<p>Combined with <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a>, Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.</p>\n<h3 id=\"What’s-Next\"><a href=\"#What’s-Next\" class=\"headerlink\" title=\"What’s Next?\"></a>What’s Next?</h3><p>As what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:</p>\n<ol>\n<li><p>Improving <code>vue-router</code> and make it production ready.</p>\n</li>\n<li><p>Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.</p>\n</li>\n<li><p>Providing more learning resources such as tutorials and examples.</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Hi HN! If you are not familiar with Vue.js, you might want to read this <a href=\"http://blog.evanyou.me/2015/10/25/vuejs-re-introduction/\" target=\"_blank\" rel=\"noopener\">blog post</a> for a higher level overview.</p>\n</blockquote>\n<p>After 300+ commits, 8 alphas, 4 betas and 2 release candidates, today I am very proud to announce the release of <a href=\"https://github.com/vuejs/vue/releases/tag/1.0.0\" target=\"_blank\" rel=\"noopener\">Vue.js 1.0.0 Evangelion</a>! Many thanks to all those who participated in the API re-design process - it would not have been possible without all the input from the community.</p>","more":"<h3 id=\"Improved-Template-Syntax\"><a href=\"#Improved-Template-Syntax\" class=\"headerlink\" title=\"Improved Template Syntax\"></a>Improved Template Syntax</h3><p>The 1.0 template syntax resolves a lot of subtle consistency issues and makes Vue templates more concise and more readable in general. The most notable new feature is the shorthand syntax for <code>v-on</code> and <code>v-bind</code>:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- short for v-bind:href --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">:href</span>=<span class=\"hljs-string\">\"someURL\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n\n<span class=\"hljs-comment\">&lt;!-- short for v-on:click --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"onClick\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>When used on a child component, <code>v-on</code> listens for custom events and <code>v-bind</code> can be used to bind props. The shorthands using child components very succinct:</p>\n<pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">item-list</span>\n  <span class=\"hljs-attr\">:items</span>=<span class=\"hljs-string\">\"items\"</span>\n  @<span class=\"hljs-attr\">ready</span>=<span class=\"hljs-string\">\"onItemsReady\"</span>\n  @<span class=\"hljs-attr\">update</span>=<span class=\"hljs-string\">\"onItemsUpdate\"</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">item-list</span>&gt;</span></code></pre>\n<h3 id=\"API-Cleanup\"><a href=\"#API-Cleanup\" class=\"headerlink\" title=\"API Cleanup\"></a>API Cleanup</h3><p>The overall goal for Vue.js 1.0 is to make it suitable for larger projects. This is why there are many API deprecations. Except for ones that are barely used, the most common reason for a deprecation is that the feature leads to patterns that damages maintainability. Specifically, we are deprecating features that make it hard to maintain and refactor a component in isolation without affecting the rest of the project.</p>\n<p>For example, the default asset resolution in 0.12 has implicit fallbacks to parents in the component tree. This makes the assets available to a component non-deterministic and subject how it is used at runtime. In 1.0, all assets are now resolved in strict mode and there are no longer implicit fallbacks to parent. The <code>inherit</code> option is also removed, because it too often leads to tightly coupled components that are hard to refactor.</p>\n<h3 id=\"Faster-Initial-Rendering\"><a href=\"#Faster-Initial-Rendering\" class=\"headerlink\" title=\"Faster Initial Rendering\"></a>Faster Initial Rendering</h3><p>1.0 replaces the old <code>v-repeat</code> directive with <code>v-for</code>. In addition to providing the same functionality and more intuitive scoping, <code>v-for</code> provides up to <strong>100%</strong> initial render performance boost when rendering large lists and tables!</p>\n<h3 id=\"More-Powerful-Tooling\"><a href=\"#More-Powerful-Tooling\" class=\"headerlink\" title=\"More Powerful Tooling\"></a>More Powerful Tooling</h3><p>There are also exciting things going on outside of Vue.js core - <a href=\"https://github.com/vuejs/vue-loader\" target=\"_blank\" rel=\"noopener\">vue-loader</a> and <a href=\"https://github.com/vuejs/vueify\" target=\"_blank\" rel=\"noopener\">vueify</a> have received major upgrades including:</p>\n<ul>\n<li><p>Hot component reloading. When a <code>*.vue</code> component is edited, all of its active instances are hot swapped without reloading the page. This means when making small changes, e.g. tweaking the styles or the template, your app doesn’t need to fully reload; the state of the app the swapped component can be preserved, drastically improving the development experience.</p>\n</li>\n<li><p>Scoped CSS. By simply adding a <code>scoped</code> attribute to your <code>*.vue</code> component style tags, the component’s template and final generated CSS are magically re-written to ensure a component’s styles are only applied to its own elements. Most importantly, the styles specified in a parent component <strong>does not</strong> leak down to child components nested within it.</p>\n</li>\n<li><p>ES2015 by default. JavaScript is evolving. You can write much cleaner and expressive code using the latest syntax. <code>vue-loader</code> and <code>vueify</code> now transpiles the JavaScript in your <code>*.vue</code> components out of the box, without the need for extra setup. Write future JavaScript today!</p>\n</li>\n</ul>\n<p>Combined with <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a>, Vue.js is now more than a library - it provides a solid foundation for building complex SPAs.</p>\n<h3 id=\"What’s-Next\"><a href=\"#What’s-Next\" class=\"headerlink\" title=\"What’s Next?\"></a>What’s Next?</h3><p>As what 1.0.0 usually suggests, the core API will stay stable for the foreseeable future and the library is ready for production use. Future development will focus on:</p>\n<ol>\n<li><p>Improving <code>vue-router</code> and make it production ready.</p>\n</li>\n<li><p>Streamlining the developer experience, e.g. a better devtool and a CLI for scaffolding Vue.js projects and components.</p>\n</li>\n<li><p>Providing more learning resources such as tutorials and examples.</p>\n</li>\n</ol>"},{"title":"Announcing Vue.js 2.0","date":"2016-04-27T16:33:00.000Z","_content":"\nToday I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let's take a peek at what's in store!\n\n<!-- more -->\n\n## Even Leaner, Even Faster\n\nVue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on [Snabbdom](https://github.com/paldepind/snabbdom)) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out [these benchmarks](https://github.com/vuejs/vue/tree/next/benchmarks)). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12KB min+gzip (as a reference, React 15 is 44KB min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17KB min+gzip, still lighter than the current 1.0 build.\n\n## Not Your Average Virtual-DOM\n\nNow, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue's reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for `shouldComponentUpdate` or immutable data structures - **it just works**.\n\nIn addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:\n\n1. It detects static class names and attributes so that they are never diffed after the initial render.\n\n2. It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.\n\nThese advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.\n\nThe new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.\n\nWith these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.\n\n## Templates, JSX, or Hyperscript?\n\nDevelopers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.\n\nBeing a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.\n\nWell, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the `template` option, just replace it with a `render` function. You can even embed render functions in your templates using the special `<render>` tag! The best of both worlds, in the same framework.\n\n## Streaming Server-side Rendering\n\nWith the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React's, is that the rendering is synchronous so it can block the server's event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.\n\n## Unlocking More Possibilities\n\nWith the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses [weex](http://alibaba.github.io/weex/) as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0's virtual-DOM to run inside ReactNative. We are excited to see how it goes!\n\n## Compatibility and What to Expect Next\n\nVue.js 2.0 is still in pre-alpha, but you can checkout the source code [here](https://github.com/vuejs/vue/tree/next/). Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out [the same official examples written in 2.0](https://github.com/vuejs/vue/tree/next/examples) - you will see that not much has changed!\n\nThe feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison [here](https://github.com/vuejs/vue/wiki/2.0-features). This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.\n\nThere is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify...). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.\n\nWe are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!\n","source":"_posts/announcing-2.0.md","raw":"---\ntitle: Announcing Vue.js 2.0\ndate: 2016-04-27 13:33:00\n---\n\nToday I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let's take a peek at what's in store!\n\n<!-- more -->\n\n## Even Leaner, Even Faster\n\nVue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on [Snabbdom](https://github.com/paldepind/snabbdom)) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out [these benchmarks](https://github.com/vuejs/vue/tree/next/benchmarks)). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12KB min+gzip (as a reference, React 15 is 44KB min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17KB min+gzip, still lighter than the current 1.0 build.\n\n## Not Your Average Virtual-DOM\n\nNow, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue's reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for `shouldComponentUpdate` or immutable data structures - **it just works**.\n\nIn addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:\n\n1. It detects static class names and attributes so that they are never diffed after the initial render.\n\n2. It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.\n\nThese advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.\n\nThe new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.\n\nWith these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.\n\n## Templates, JSX, or Hyperscript?\n\nDevelopers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.\n\nBeing a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.\n\nWell, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the `template` option, just replace it with a `render` function. You can even embed render functions in your templates using the special `<render>` tag! The best of both worlds, in the same framework.\n\n## Streaming Server-side Rendering\n\nWith the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React's, is that the rendering is synchronous so it can block the server's event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.\n\n## Unlocking More Possibilities\n\nWith the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses [weex](http://alibaba.github.io/weex/) as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0's virtual-DOM to run inside ReactNative. We are excited to see how it goes!\n\n## Compatibility and What to Expect Next\n\nVue.js 2.0 is still in pre-alpha, but you can checkout the source code [here](https://github.com/vuejs/vue/tree/next/). Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out [the same official examples written in 2.0](https://github.com/vuejs/vue/tree/next/examples) - you will see that not much has changed!\n\nThe feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison [here](https://github.com/vuejs/vue/wiki/2.0-features). This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.\n\nThere is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify...). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.\n\nWe are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!\n","slug":"announcing-2.0","published":1,"updated":"2020-09-25T23:55:41.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwp0007c2v5pkehm5f5","content":"<p>Today I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let’s take a peek at what’s in store!</p>\n<a id=\"more\"></a>\n<h2 id=\"Even-Leaner-Even-Faster\"><a href=\"#Even-Leaner-Even-Faster\" class=\"headerlink\" title=\"Even Leaner, Even Faster\"></a>Even Leaner, Even Faster</h2><p>Vue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on <a href=\"https://github.com/paldepind/snabbdom\" target=\"_blank\" rel=\"noopener\">Snabbdom</a>) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out <a href=\"https://github.com/vuejs/vue/tree/next/benchmarks\" target=\"_blank\" rel=\"noopener\">these benchmarks</a>). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12KB min+gzip (as a reference, React 15 is 44KB min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17KB min+gzip, still lighter than the current 1.0 build.</p>\n<h2 id=\"Not-Your-Average-Virtual-DOM\"><a href=\"#Not-Your-Average-Virtual-DOM\" class=\"headerlink\" title=\"Not Your Average Virtual-DOM\"></a>Not Your Average Virtual-DOM</h2><p>Now, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue’s reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for <code>shouldComponentUpdate</code> or immutable data structures - <strong>it just works</strong>.</p>\n<p>In addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:</p>\n<ol>\n<li><p>It detects static class names and attributes so that they are never diffed after the initial render.</p>\n</li>\n<li><p>It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.</p>\n</li>\n</ol>\n<p>These advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.</p>\n<p>The new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.</p>\n<p>With these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.</p>\n<h2 id=\"Templates-JSX-or-Hyperscript\"><a href=\"#Templates-JSX-or-Hyperscript\" class=\"headerlink\" title=\"Templates, JSX, or Hyperscript?\"></a>Templates, JSX, or Hyperscript?</h2><p>Developers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.</p>\n<p>Being a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.</p>\n<p>Well, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the <code>template</code> option, just replace it with a <code>render</code> function. You can even embed render functions in your templates using the special <code>&lt;render&gt;</code> tag! The best of both worlds, in the same framework.</p>\n<h2 id=\"Streaming-Server-side-Rendering\"><a href=\"#Streaming-Server-side-Rendering\" class=\"headerlink\" title=\"Streaming Server-side Rendering\"></a>Streaming Server-side Rendering</h2><p>With the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React’s, is that the rendering is synchronous so it can block the server’s event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.</p>\n<h2 id=\"Unlocking-More-Possibilities\"><a href=\"#Unlocking-More-Possibilities\" class=\"headerlink\" title=\"Unlocking More Possibilities\"></a>Unlocking More Possibilities</h2><p>With the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses <a href=\"http://alibaba.github.io/weex/\" target=\"_blank\" rel=\"noopener\">weex</a> as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0’s virtual-DOM to run inside ReactNative. We are excited to see how it goes!</p>\n<h2 id=\"Compatibility-and-What-to-Expect-Next\"><a href=\"#Compatibility-and-What-to-Expect-Next\" class=\"headerlink\" title=\"Compatibility and What to Expect Next\"></a>Compatibility and What to Expect Next</h2><p>Vue.js 2.0 is still in pre-alpha, but you can checkout the source code <a href=\"https://github.com/vuejs/vue/tree/next/\" target=\"_blank\" rel=\"noopener\">here</a>. Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out <a href=\"https://github.com/vuejs/vue/tree/next/examples\" target=\"_blank\" rel=\"noopener\">the same official examples written in 2.0</a> - you will see that not much has changed!</p>\n<p>The feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison <a href=\"https://github.com/vuejs/vue/wiki/2.0-features\" target=\"_blank\" rel=\"noopener\">here</a>. This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.</p>\n<p>There is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify…). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.</p>\n<p>We are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!</p>\n","site":{"data":{}},"excerpt":"<p>Today I am thrilled to announce the first public preview of Vue.js 2.0, which brings along many exciting improvements and new features. Let’s take a peek at what’s in store!</p>","more":"<h2 id=\"Even-Leaner-Even-Faster\"><a href=\"#Even-Leaner-Even-Faster\" class=\"headerlink\" title=\"Even Leaner, Even Faster\"></a>Even Leaner, Even Faster</h2><p>Vue.js has always focused on staying light and fast, but 2.0 pushes it even further. The rendering layer is now based on a lightweight virtual-DOM implementation (based on <a href=\"https://github.com/paldepind/snabbdom\" target=\"_blank\" rel=\"noopener\">Snabbdom</a>) that improves initial rendering speed and memory consumption by up to 2~4x in most scenarios (check out <a href=\"https://github.com/vuejs/vue/tree/next/benchmarks\" target=\"_blank\" rel=\"noopener\">these benchmarks</a>). The template-to-virtual-DOM compiler and the runtime can be separated, so you can pre-compile templates and ship your app with only the runtime, which is less than 12KB min+gzip (as a reference, React 15 is 44KB min+gzip). The compiler also works in the browser, which means you can still drop in one script tag and start hacking, just like before. Even with the compiler included, the build is sitting at 17KB min+gzip, still lighter than the current 1.0 build.</p>\n<h2 id=\"Not-Your-Average-Virtual-DOM\"><a href=\"#Not-Your-Average-Virtual-DOM\" class=\"headerlink\" title=\"Not Your Average Virtual-DOM\"></a>Not Your Average Virtual-DOM</h2><p>Now, just virtual-DOM sounds boring because there are so many implementations out there - but this one is different. Combined with Vue’s reactivity system, it provides optimized re-rendering out of the box without you having to do anything. Each component keeps track of its reactive dependencies during its render, so the system knows precisely when to re-render, and which components to re-render. No need for <code>shouldComponentUpdate</code> or immutable data structures - <strong>it just works</strong>.</p>\n<p>In addition, Vue 2.0 applies some advanced optimizations during the template-to-virtual-DOM compilation phase:</p>\n<ol>\n<li><p>It detects static class names and attributes so that they are never diffed after the initial render.</p>\n</li>\n<li><p>It detects the maximum static sub trees (sub trees with no dynamic bindings) and hoist them out of the render function. So on each re-render, it directly reuses the exact same virtual nodes and skips the diffing.</p>\n</li>\n</ol>\n<p>These advanced optimizations can usually only be achieved via Babel plugins when using JSX, but with Vue 2.0 you can get them even using the in-browser compiler.</p>\n<p>The new rendering system also allows you to disable reactive conversions by simply freezing your data and manually force updates, essentially giving you full control over the re-rendering process.</p>\n<p>With these techniques combined, Vue 2.0 ensures blazing fast performance in every possible scenario while requiring minimal optimization efforts from the developer.</p>\n<h2 id=\"Templates-JSX-or-Hyperscript\"><a href=\"#Templates-JSX-or-Hyperscript\" class=\"headerlink\" title=\"Templates, JSX, or Hyperscript?\"></a>Templates, JSX, or Hyperscript?</h2><p>Developers tend to have strong opinions on templates vs. JSX. On the one hand, templates are closer to HTML - they map better to the semantic structure of your app and make it much easier to think visually about the design, layout and styling. On the other hand, templates are limited to the DSL while the programmatic nature of JSX/hyperscript provides the full expressive power of a turing-complete language.</p>\n<p>Being a designer/developer hybrid, I prefer writing most of my interfaces in templates, but in certain cases I do miss the flexibility of JSX/hyperscript. An example would be writing a component that programmatically handles its children, something not feasible with just the template-based slot mechanism.</p>\n<p>Well, why not have both? In Vue 2.0, you can keep using the familiar template syntax, or drop down to the virtual-DOM layer whenever you feel constrained by the template DSL. Instead of the <code>template</code> option, just replace it with a <code>render</code> function. You can even embed render functions in your templates using the special <code>&lt;render&gt;</code> tag! The best of both worlds, in the same framework.</p>\n<h2 id=\"Streaming-Server-side-Rendering\"><a href=\"#Streaming-Server-side-Rendering\" class=\"headerlink\" title=\"Streaming Server-side Rendering\"></a>Streaming Server-side Rendering</h2><p>With the migration to virtual-DOM, Vue 2.0 naturally supports server-side rendering with client-side hydration. One pain point of current mainstream server rendering implementations, such as React’s, is that the rendering is synchronous so it can block the server’s event loop if the app is complex. Synchronous server-side rendering may even adversely affect time-to-content on the client. Vue 2.0 provides built-in streaming server-side rendering, so that you can render your component, get a readable stream back and directly pipe it to the HTTP response. This ensures your server is responsive, and gets the rendered content to your users faster.</p>\n<h2 id=\"Unlocking-More-Possibilities\"><a href=\"#Unlocking-More-Possibilities\" class=\"headerlink\" title=\"Unlocking More Possibilities\"></a>Unlocking More Possibilities</h2><p>With the new architecture, there are even more possibilities to explore - for example, rendering to native interfaces on mobile. Currently, we are exploring a port of Vue.js 2.0 that uses <a href=\"http://alibaba.github.io/weex/\" target=\"_blank\" rel=\"noopener\">weex</a> as a native rendering backend, a project maintained by engineers at Alibaba Group, the biggest tech enterprise of China. It is also technically feasible to adapt Vue 2.0’s virtual-DOM to run inside ReactNative. We are excited to see how it goes!</p>\n<h2 id=\"Compatibility-and-What-to-Expect-Next\"><a href=\"#Compatibility-and-What-to-Expect-Next\" class=\"headerlink\" title=\"Compatibility and What to Expect Next\"></a>Compatibility and What to Expect Next</h2><p>Vue.js 2.0 is still in pre-alpha, but you can checkout the source code <a href=\"https://github.com/vuejs/vue/tree/next/\" target=\"_blank\" rel=\"noopener\">here</a>. Despite being a full rewrite, the API is largely compatible with 1.0 with the exception of some intentional deprecations. Check out <a href=\"https://github.com/vuejs/vue/tree/next/examples\" target=\"_blank\" rel=\"noopener\">the same official examples written in 2.0</a> - you will see that not much has changed!</p>\n<p>The feature deprecations are part of our continued effort to provide the simplest API possible for maximum developer productivity. You can check out a 1.0 vs. 2.0 feature comparison <a href=\"https://github.com/vuejs/vue/wiki/2.0-features\" target=\"_blank\" rel=\"noopener\">here</a>. This does mean that it will take some effort to migrate an existing app if you happen to use some of these deprecated features heavily, but we will provide detailed upgrade guides in the future.</p>\n<p>There is still much work left to be done. We will be releasing the first alpha once we reach satisfactory test coverage, and we are aiming for beta by end of May / early June. In addition to more tests, we also need to update the supporting libraries (vue-router, Vuex, vue-loader, vueify…). Currently only Vuex works with 2.0 out of the box, but we will make sure that everything works smoothly together when 2.0 ships.</p>\n<p>We are also not forgetting about 1.x! 1.1 will be released alongside 2.0 beta, with an LTS period of 6-month critical bug fixes and 9-month security updates. It will also ship with optional deprecation warnings to get you prepared for upgrading to 2.0. Stay tuned!</p>"},{"title":"Common Beginner Gotchas","date":"2016-02-06T14:00:00.000Z","_content":"\nThere are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!\n\n<!-- more -->\n\n### Why isn't the DOM updating?\n\nMost of the time, when you change a Vue instance's data, the view updates. But there are two edge cases:\n\n1. When you are **adding a new property** that wasn't present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global [`Vue.set`](/api/#Vue-set) or [`Vue.delete`](/api/#Vue-delete) methods.\n\n2. When you modify an Array by directly setting an index (e.g. `arr[0] = val`) or modifying its `length` property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method `arr.$set(index, value)` which is syntax sugar for `arr.splice(index, 1, value)`.\n\nFurther reading: [Reactivity in Depth](/guide/reactivity.html) and [Array Change Detection](http://vuejs.org/guide/list.html#Array-Change-Detection).\n\n### When is the DOM updated?\n\nVue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use `Vue.nextTick` right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.\n\nFurther reading: [Async Update Queue](/guide/reactivity.html#Async-Update-Queue).\n\n### Why does `data` need to be a function?\n\nIn the basic examples, we declare the `data` directly as a plain object. This is because we are creating only a single instance with `new Vue()`. However, when defining a **component**, `data` must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for `data`, that same object will be **shared by reference** across all instance created! By providing a `data` function, every time a new instance is created we can call it to return a fresh copy of the initial data.\n\nFurther reading: [Component Option Caveats](/guide/components.html#Component-Option-Caveats).\n\n### HTML case insensitivity\n\nAll Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like `:myProp=\"123\"` will be matched as `:myprop=\"123\"`. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as `myProp` should be bound in templates as `:my-prop`.\n\nFurther reading: [camelCase vs. kebab-case](http://vuejs.org/guide/components.html#camelCase-vs-kebab-case).\n\nWe are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation [here](https://github.com/vuejs/vue/issues/2308).\n","source":"_posts/common-gotchas.md","raw":"---\ntitle: Common Beginner Gotchas\ndate: 2016-02-06 10:00:00\n---\n\nThere are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!\n\n<!-- more -->\n\n### Why isn't the DOM updating?\n\nMost of the time, when you change a Vue instance's data, the view updates. But there are two edge cases:\n\n1. When you are **adding a new property** that wasn't present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global [`Vue.set`](/api/#Vue-set) or [`Vue.delete`](/api/#Vue-delete) methods.\n\n2. When you modify an Array by directly setting an index (e.g. `arr[0] = val`) or modifying its `length` property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method `arr.$set(index, value)` which is syntax sugar for `arr.splice(index, 1, value)`.\n\nFurther reading: [Reactivity in Depth](/guide/reactivity.html) and [Array Change Detection](http://vuejs.org/guide/list.html#Array-Change-Detection).\n\n### When is the DOM updated?\n\nVue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use `Vue.nextTick` right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.\n\nFurther reading: [Async Update Queue](/guide/reactivity.html#Async-Update-Queue).\n\n### Why does `data` need to be a function?\n\nIn the basic examples, we declare the `data` directly as a plain object. This is because we are creating only a single instance with `new Vue()`. However, when defining a **component**, `data` must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for `data`, that same object will be **shared by reference** across all instance created! By providing a `data` function, every time a new instance is created we can call it to return a fresh copy of the initial data.\n\nFurther reading: [Component Option Caveats](/guide/components.html#Component-Option-Caveats).\n\n### HTML case insensitivity\n\nAll Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like `:myProp=\"123\"` will be matched as `:myprop=\"123\"`. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as `myProp` should be bound in templates as `:my-prop`.\n\nFurther reading: [camelCase vs. kebab-case](http://vuejs.org/guide/components.html#camelCase-vs-kebab-case).\n\nWe are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation [here](https://github.com/vuejs/vue/issues/2308).\n","slug":"common-gotchas","published":1,"updated":"2020-09-25T23:55:41.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwr0009c2v521nwppku","content":"<p>There are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!</p>\n<a id=\"more\"></a>\n<h3 id=\"Why-isn’t-the-DOM-updating\"><a href=\"#Why-isn’t-the-DOM-updating\" class=\"headerlink\" title=\"Why isn’t the DOM updating?\"></a>Why isn’t the DOM updating?</h3><p>Most of the time, when you change a Vue instance’s data, the view updates. But there are two edge cases:</p>\n<ol>\n<li><p>When you are <strong>adding a new property</strong> that wasn’t present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global <a href=\"/api/#Vue-set\"><code>Vue.set</code></a> or <a href=\"/api/#Vue-delete\"><code>Vue.delete</code></a> methods.</p>\n</li>\n<li><p>When you modify an Array by directly setting an index (e.g. <code>arr[0] = val</code>) or modifying its <code>length</code> property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method <code>arr.$set(index, value)</code> which is syntax sugar for <code>arr.splice(index, 1, value)</code>.</p>\n</li>\n</ol>\n<p>Further reading: <a href=\"/guide/reactivity.html\">Reactivity in Depth</a> and <a href=\"http://vuejs.org/guide/list.html#Array-Change-Detection\">Array Change Detection</a>.</p>\n<h3 id=\"When-is-the-DOM-updated\"><a href=\"#When-is-the-DOM-updated\" class=\"headerlink\" title=\"When is the DOM updated?\"></a>When is the DOM updated?</h3><p>Vue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use <code>Vue.nextTick</code> right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.</p>\n<p>Further reading: <a href=\"/guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a>.</p>\n<h3 id=\"Why-does-data-need-to-be-a-function\"><a href=\"#Why-does-data-need-to-be-a-function\" class=\"headerlink\" title=\"Why does data need to be a function?\"></a>Why does <code>data</code> need to be a function?</h3><p>In the basic examples, we declare the <code>data</code> directly as a plain object. This is because we are creating only a single instance with <code>new Vue()</code>. However, when defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instance created! By providing a <code>data</code> function, every time a new instance is created we can call it to return a fresh copy of the initial data.</p>\n<p>Further reading: <a href=\"/guide/components.html#Component-Option-Caveats\">Component Option Caveats</a>.</p>\n<h3 id=\"HTML-case-insensitivity\"><a href=\"#HTML-case-insensitivity\" class=\"headerlink\" title=\"HTML case insensitivity\"></a>HTML case insensitivity</h3><p>All Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like <code>:myProp=&quot;123&quot;</code> will be matched as <code>:myprop=&quot;123&quot;</code>. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as <code>myProp</code> should be bound in templates as <code>:my-prop</code>.</p>\n<p>Further reading: <a href=\"http://vuejs.org/guide/components.html#camelCase-vs-kebab-case\">camelCase vs. kebab-case</a>.</p>\n<p>We are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation <a href=\"https://github.com/vuejs/vue/issues/2308\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n","site":{"data":{}},"excerpt":"<p>There are few types of questions that we frequently see from users who are new to Vue.js. Although they are all mentioned somewhere in the guide, they are easy to miss and can be hard to find when you do get bitten by the gotchas. Therefore we are aggregating them in this post and hopefully it can save you some time!</p>","more":"<h3 id=\"Why-isn’t-the-DOM-updating\"><a href=\"#Why-isn’t-the-DOM-updating\" class=\"headerlink\" title=\"Why isn’t the DOM updating?\"></a>Why isn’t the DOM updating?</h3><p>Most of the time, when you change a Vue instance’s data, the view updates. But there are two edge cases:</p>\n<ol>\n<li><p>When you are <strong>adding a new property</strong> that wasn’t present when the data was observed. Due to the limitation of ES5 and to ensure consistent behavior across browsers, Vue.js cannot detect property addition/deletions. The best practice is to always declare properties that need to be reactive upfront. In cases where you absolutely need to add or delete properties at runtime, use the global <a href=\"/api/#Vue-set\"><code>Vue.set</code></a> or <a href=\"/api/#Vue-delete\"><code>Vue.delete</code></a> methods.</p>\n</li>\n<li><p>When you modify an Array by directly setting an index (e.g. <code>arr[0] = val</code>) or modifying its <code>length</code> property. Similarly, Vue.js cannot pickup these changes. Always modify arrays by using an Array instance method, or replacing it entirely. Vue provides a convenience method <code>arr.$set(index, value)</code> which is syntax sugar for <code>arr.splice(index, 1, value)</code>.</p>\n</li>\n</ol>\n<p>Further reading: <a href=\"/guide/reactivity.html\">Reactivity in Depth</a> and <a href=\"http://vuejs.org/guide/list.html#Array-Change-Detection\">Array Change Detection</a>.</p>\n<h3 id=\"When-is-the-DOM-updated\"><a href=\"#When-is-the-DOM-updated\" class=\"headerlink\" title=\"When is the DOM updated?\"></a>When is the DOM updated?</h3><p>Vue.js uses an asynchronous queue to batch DOM updates. This means when you modify some data, the DOM updates do not happen instantly: they are applied asynchronously when the queue is flushed. So how do you know when the DOM has been updated? Use <code>Vue.nextTick</code> right after you modify the data. The callback function you pass to it will be called once the queue has been flushed.</p>\n<p>Further reading: <a href=\"/guide/reactivity.html#Async-Update-Queue\">Async Update Queue</a>.</p>\n<h3 id=\"Why-does-data-need-to-be-a-function\"><a href=\"#Why-does-data-need-to-be-a-function\" class=\"headerlink\" title=\"Why does data need to be a function?\"></a>Why does <code>data</code> need to be a function?</h3><p>In the basic examples, we declare the <code>data</code> directly as a plain object. This is because we are creating only a single instance with <code>new Vue()</code>. However, when defining a <strong>component</strong>, <code>data</code> must be declared as a function that returns the initial data object. Why? Because there will be many instances created using the same definition. If we still use a plain object for <code>data</code>, that same object will be <strong>shared by reference</strong> across all instance created! By providing a <code>data</code> function, every time a new instance is created we can call it to return a fresh copy of the initial data.</p>\n<p>Further reading: <a href=\"/guide/components.html#Component-Option-Caveats\">Component Option Caveats</a>.</p>\n<h3 id=\"HTML-case-insensitivity\"><a href=\"#HTML-case-insensitivity\" class=\"headerlink\" title=\"HTML case insensitivity\"></a>HTML case insensitivity</h3><p>All Vue.js templates are valid, parsable HTML markup, and Vue.js relies on spec-compliant parsers to process its templates. However, as specified in the standard, HTML is case-insensitive when matching tag and attribute names. This means camelCase attributes like <code>:myProp=&quot;123&quot;</code> will be matched as <code>:myprop=&quot;123&quot;</code>. As a rule of thumb, you should use camelCase in JavaScript and kebab-case in templates. For example a prop defined in JavaScript as <code>myProp</code> should be bound in templates as <code>:my-prop</code>.</p>\n<p>Further reading: <a href=\"http://vuejs.org/guide/components.html#camelCase-vs-kebab-case\">camelCase vs. kebab-case</a>.</p>\n<p>We are also discussing the possibility of eliminating this inconsistency by resolving props and components in a case-insensitive manner. Join the conversation <a href=\"https://github.com/vuejs/vue/issues/2308\" target=\"_blank\" rel=\"noopener\">here</a>.</p>"},{"title":"March 2016 Update","date":"2016-03-14T21:45:00.000Z","_content":"\n## Growing Community\n\nVue's growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What's more exciting though, is that the community successfully organized the first [London Vue.js Meetup](http://www.meetup.com/London-Vue-js-Meetup/) and the first [Paris Vue.js Meetup](http://www.meetup.com/Vuejs-Paris/?scroll=true)! A big shoutout to the awesome organizers: [Jack](https://twitter.com/JackBarham), [James](https://twitter.com/onejamesbrowne/) and [Eduardo](https://twitter.com/posva/).\n\n<!-- more -->\n\nIf you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)\n\n## Cool Things Being Built\n\nMore and more amazing things are being built with Vue. There are products like [PageKit](https://pagekit.com/), Laravel Spark (coming soon) and [Statamic](https://v2.statamic.com/), sleek apps like [Koel](http://koel.phanan.net/) and [Gokotta](https://github.com/Zhangdroid/Gokotta), UI components like [VueStrap](http://yuche.github.io/vue-strap/) and [Vue-MDL](http://posva.net/vue-mdl/), and smooth, interactive experiences like [YouTube Adblitz](https://adblitz.withyoutube.com) and even the [Facebook NewsFeed Marketing Site](https://newsfeed.fb.com/)!\n\nThere are many other great projects - too many to be listed here - but you can check them all out in [awesome-vue](https://github.com/vuejs/awesome-vue). If you've built great things with Vue, you should also add them to the list!\n\n## A New Vision For the Project\n\nSome of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely [Vuex](https://github.com/vuejs/vuex), [vue-devtools](https://github.com/vuejs/vue-devtools) and the official [Webpack project boilerplate](https://github.com/vuejs-templates/webpack). The next step is a new release for [vue-router](https://github.com/vuejs/vue-router), and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.\n\nAll this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain \"just the view layer\" - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.\n\n## Vue.js needs your help!\n\nOpen source is awesome, and I'm proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!\n\n### Looking for collaborators\n\nThere are already users who frequently helps out in various ways, but this is an invitation to make things official. I'm looking for contributors to join the \"team\", which is currently mostly just me. If that sounds interesting to you, take a look at the application [here](https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform).\n\n### Looking for sponsors\n\nAnother way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.\n\nIf you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.\n\nIf you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)\n\nIn either case, you can provide recurring funding through Vue's [Patreon campaign](https://www.patreon.com/evanyou), or provide one-time donations via [PayPal](https://www.paypal.me/evanyou). There are many ideas for Vue that I have lined up but haven't had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!\n","source":"_posts/march-update.md","raw":"---\ntitle: March 2016 Update\ndate: 2016-03-14 18:45:00\n---\n\n## Growing Community\n\nVue's growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What's more exciting though, is that the community successfully organized the first [London Vue.js Meetup](http://www.meetup.com/London-Vue-js-Meetup/) and the first [Paris Vue.js Meetup](http://www.meetup.com/Vuejs-Paris/?scroll=true)! A big shoutout to the awesome organizers: [Jack](https://twitter.com/JackBarham), [James](https://twitter.com/onejamesbrowne/) and [Eduardo](https://twitter.com/posva/).\n\n<!-- more -->\n\nIf you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)\n\n## Cool Things Being Built\n\nMore and more amazing things are being built with Vue. There are products like [PageKit](https://pagekit.com/), Laravel Spark (coming soon) and [Statamic](https://v2.statamic.com/), sleek apps like [Koel](http://koel.phanan.net/) and [Gokotta](https://github.com/Zhangdroid/Gokotta), UI components like [VueStrap](http://yuche.github.io/vue-strap/) and [Vue-MDL](http://posva.net/vue-mdl/), and smooth, interactive experiences like [YouTube Adblitz](https://adblitz.withyoutube.com) and even the [Facebook NewsFeed Marketing Site](https://newsfeed.fb.com/)!\n\nThere are many other great projects - too many to be listed here - but you can check them all out in [awesome-vue](https://github.com/vuejs/awesome-vue). If you've built great things with Vue, you should also add them to the list!\n\n## A New Vision For the Project\n\nSome of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely [Vuex](https://github.com/vuejs/vuex), [vue-devtools](https://github.com/vuejs/vue-devtools) and the official [Webpack project boilerplate](https://github.com/vuejs-templates/webpack). The next step is a new release for [vue-router](https://github.com/vuejs/vue-router), and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.\n\nAll this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain \"just the view layer\" - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.\n\n## Vue.js needs your help!\n\nOpen source is awesome, and I'm proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!\n\n### Looking for collaborators\n\nThere are already users who frequently helps out in various ways, but this is an invitation to make things official. I'm looking for contributors to join the \"team\", which is currently mostly just me. If that sounds interesting to you, take a look at the application [here](https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform).\n\n### Looking for sponsors\n\nAnother way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.\n\nIf you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.\n\nIf you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)\n\nIn either case, you can provide recurring funding through Vue's [Patreon campaign](https://www.patreon.com/evanyou), or provide one-time donations via [PayPal](https://www.paypal.me/evanyou). There are many ideas for Vue that I have lined up but haven't had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!\n","slug":"march-update","published":1,"updated":"2020-09-25T23:55:41.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gws000ac2v53yut5l7h","content":"<h2 id=\"Growing-Community\"><a href=\"#Growing-Community\" class=\"headerlink\" title=\"Growing Community\"></a>Growing Community</h2><p>Vue’s growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What’s more exciting though, is that the community successfully organized the first <a href=\"http://www.meetup.com/London-Vue-js-Meetup/\" target=\"_blank\" rel=\"noopener\">London Vue.js Meetup</a> and the first <a href=\"http://www.meetup.com/Vuejs-Paris/?scroll=true\" target=\"_blank\" rel=\"noopener\">Paris Vue.js Meetup</a>! A big shoutout to the awesome organizers: <a href=\"https://twitter.com/JackBarham\" target=\"_blank\" rel=\"noopener\">Jack</a>, <a href=\"https://twitter.com/onejamesbrowne/\" target=\"_blank\" rel=\"noopener\">James</a> and <a href=\"https://twitter.com/posva/\" target=\"_blank\" rel=\"noopener\">Eduardo</a>.</p>\n<a id=\"more\"></a>\n<p>If you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)</p>\n<h2 id=\"Cool-Things-Being-Built\"><a href=\"#Cool-Things-Being-Built\" class=\"headerlink\" title=\"Cool Things Being Built\"></a>Cool Things Being Built</h2><p>More and more amazing things are being built with Vue. There are products like <a href=\"https://pagekit.com/\" target=\"_blank\" rel=\"noopener\">PageKit</a>, Laravel Spark (coming soon) and <a href=\"https://v2.statamic.com/\" target=\"_blank\" rel=\"noopener\">Statamic</a>, sleek apps like <a href=\"http://koel.phanan.net/\" target=\"_blank\" rel=\"noopener\">Koel</a> and <a href=\"https://github.com/Zhangdroid/Gokotta\" target=\"_blank\" rel=\"noopener\">Gokotta</a>, UI components like <a href=\"http://yuche.github.io/vue-strap/\" target=\"_blank\" rel=\"noopener\">VueStrap</a> and <a href=\"http://posva.net/vue-mdl/\" target=\"_blank\" rel=\"noopener\">Vue-MDL</a>, and smooth, interactive experiences like <a href=\"https://adblitz.withyoutube.com\" target=\"_blank\" rel=\"noopener\">YouTube Adblitz</a> and even the <a href=\"https://newsfeed.fb.com/\" target=\"_blank\" rel=\"noopener\">Facebook NewsFeed Marketing Site</a>!</p>\n<p>There are many other great projects - too many to be listed here - but you can check them all out in <a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\" rel=\"noopener\">awesome-vue</a>. If you’ve built great things with Vue, you should also add them to the list!</p>\n<h2 id=\"A-New-Vision-For-the-Project\"><a href=\"#A-New-Vision-For-the-Project\" class=\"headerlink\" title=\"A New Vision For the Project\"></a>A New Vision For the Project</h2><p>Some of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a>, <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> and the official <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">Webpack project boilerplate</a>. The next step is a new release for <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a>, and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.</p>\n<p>All this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain “just the view layer” - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.</p>\n<h2 id=\"Vue-js-needs-your-help\"><a href=\"#Vue-js-needs-your-help\" class=\"headerlink\" title=\"Vue.js needs your help!\"></a>Vue.js needs your help!</h2><p>Open source is awesome, and I’m proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!</p>\n<h3 id=\"Looking-for-collaborators\"><a href=\"#Looking-for-collaborators\" class=\"headerlink\" title=\"Looking for collaborators\"></a>Looking for collaborators</h3><p>There are already users who frequently helps out in various ways, but this is an invitation to make things official. I’m looking for contributors to join the “team”, which is currently mostly just me. If that sounds interesting to you, take a look at the application <a href=\"https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h3 id=\"Looking-for-sponsors\"><a href=\"#Looking-for-sponsors\" class=\"headerlink\" title=\"Looking for sponsors\"></a>Looking for sponsors</h3><p>Another way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.</p>\n<p>If you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.</p>\n<p>If you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)</p>\n<p>In either case, you can provide recurring funding through Vue’s <a href=\"https://www.patreon.com/evanyou\" target=\"_blank\" rel=\"noopener\">Patreon campaign</a>, or provide one-time donations via <a href=\"https://www.paypal.me/evanyou\" target=\"_blank\" rel=\"noopener\">PayPal</a>. There are many ideas for Vue that I have lined up but haven’t had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Growing-Community\"><a href=\"#Growing-Community\" class=\"headerlink\" title=\"Growing Community\"></a>Growing Community</h2><p>Vue’s growth in the past year has been nothing short of amazing. As of today we are at over 15,000 stars on GitHub, over 500k downloads from npm, and over 2,000 users in the Gitter channel. What’s more exciting though, is that the community successfully organized the first <a href=\"http://www.meetup.com/London-Vue-js-Meetup/\" target=\"_blank\" rel=\"noopener\">London Vue.js Meetup</a> and the first <a href=\"http://www.meetup.com/Vuejs-Paris/?scroll=true\" target=\"_blank\" rel=\"noopener\">Paris Vue.js Meetup</a>! A big shoutout to the awesome organizers: <a href=\"https://twitter.com/JackBarham\" target=\"_blank\" rel=\"noopener\">Jack</a>, <a href=\"https://twitter.com/onejamesbrowne/\" target=\"_blank\" rel=\"noopener\">James</a> and <a href=\"https://twitter.com/posva/\" target=\"_blank\" rel=\"noopener\">Eduardo</a>.</p>","more":"<p>If you are interested in connecting with Vue.js users near you and share your experiences in using Vue.js, joining a local Meetup is a great idea - even better, maybe you can organize one :)</p>\n<h2 id=\"Cool-Things-Being-Built\"><a href=\"#Cool-Things-Being-Built\" class=\"headerlink\" title=\"Cool Things Being Built\"></a>Cool Things Being Built</h2><p>More and more amazing things are being built with Vue. There are products like <a href=\"https://pagekit.com/\" target=\"_blank\" rel=\"noopener\">PageKit</a>, Laravel Spark (coming soon) and <a href=\"https://v2.statamic.com/\" target=\"_blank\" rel=\"noopener\">Statamic</a>, sleek apps like <a href=\"http://koel.phanan.net/\" target=\"_blank\" rel=\"noopener\">Koel</a> and <a href=\"https://github.com/Zhangdroid/Gokotta\" target=\"_blank\" rel=\"noopener\">Gokotta</a>, UI components like <a href=\"http://yuche.github.io/vue-strap/\" target=\"_blank\" rel=\"noopener\">VueStrap</a> and <a href=\"http://posva.net/vue-mdl/\" target=\"_blank\" rel=\"noopener\">Vue-MDL</a>, and smooth, interactive experiences like <a href=\"https://adblitz.withyoutube.com\" target=\"_blank\" rel=\"noopener\">YouTube Adblitz</a> and even the <a href=\"https://newsfeed.fb.com/\" target=\"_blank\" rel=\"noopener\">Facebook NewsFeed Marketing Site</a>!</p>\n<p>There are many other great projects - too many to be listed here - but you can check them all out in <a href=\"https://github.com/vuejs/awesome-vue\" target=\"_blank\" rel=\"noopener\">awesome-vue</a>. If you’ve built great things with Vue, you should also add them to the list!</p>\n<h2 id=\"A-New-Vision-For-the-Project\"><a href=\"#A-New-Vision-For-the-Project\" class=\"headerlink\" title=\"A New Vision For the Project\"></a>A New Vision For the Project</h2><p>Some of you may have noticed that the development on the Vue.js core repo has slowed down lately - in the meanwhile, a lot of efforts went into other sub projects, namely <a href=\"https://github.com/vuejs/vuex\" target=\"_blank\" rel=\"noopener\">Vuex</a>, <a href=\"https://github.com/vuejs/vue-devtools\" target=\"_blank\" rel=\"noopener\">vue-devtools</a> and the official <a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">Webpack project boilerplate</a>. The next step is a new release for <a href=\"https://github.com/vuejs/vue-router\" target=\"_blank\" rel=\"noopener\">vue-router</a>, and better documentation/examples demonstrating how Vue.js core, Vuex and vue-router work together in a large single page application.</p>\n<p>All this adds together towards a new vision for the Vue.js project: a progressive framework that can adapt to different complexity levels. Vue.js core will remain “just the view layer” - you can still drop it on whatever existing page to replace jQuery, but the Vue.js project also includes other pieces like vue-router, Vuex, vue-loader/vueify and vue-cli that works together as a more complete, opinionated framework for single page applications. More on this in a later post.</p>\n<h2 id=\"Vue-js-needs-your-help\"><a href=\"#Vue-js-needs-your-help\" class=\"headerlink\" title=\"Vue.js needs your help!\"></a>Vue.js needs your help!</h2><p>Open source is awesome, and I’m proud that Vue.js is helping people build real products all over the world. However, as the scope of the project grows, pushing new features while maintaining everything becomes a very demanding job. The good news is you can help!</p>\n<h3 id=\"Looking-for-collaborators\"><a href=\"#Looking-for-collaborators\" class=\"headerlink\" title=\"Looking for collaborators\"></a>Looking for collaborators</h3><p>There are already users who frequently helps out in various ways, but this is an invitation to make things official. I’m looking for contributors to join the “team”, which is currently mostly just me. If that sounds interesting to you, take a look at the application <a href=\"https://docs.google.com/forms/d/1SgDgKZqyivEf5xl0EOWNfs68Xy3f4oBzLXIlwlS0BIs/viewform\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<h3 id=\"Looking-for-sponsors\"><a href=\"#Looking-for-sponsors\" class=\"headerlink\" title=\"Looking for sponsors\"></a>Looking for sponsors</h3><p>Another way to help making Vue development sustainable is providing direct financial support. The more financial support I receive, the more time I get to spend on making Vue even better.</p>\n<p>If you run a business and is using Vue in a revenue-generating product, it would make business sense to sponsor Vue development: it ensures the project that your product relies on stays healthy and actively maintained. It can also help your exposure in the Vue community and makes it easier to attract Vue developers.</p>\n<p>If you are an individual user and have enjoyed the productivity of using Vue, consider donating as a sign of appreciation - like buying me coffee once in a while :)</p>\n<p>In either case, you can provide recurring funding through Vue’s <a href=\"https://www.patreon.com/evanyou\" target=\"_blank\" rel=\"noopener\">Patreon campaign</a>, or provide one-time donations via <a href=\"https://www.paypal.me/evanyou\" target=\"_blank\" rel=\"noopener\">PayPal</a>. There are many ideas for Vue that I have lined up but haven’t had the time to embark on, and I would love to be able to work on them full time - I hope you can help me make that happen!</p>"},{"title":"Vue.js 0.11 released!","date":"2014-11-09T13:23:40.000Z","_content":"\nAfter the long wait, [Vue.js 0.11 **Cowboy Bebop**](https://github.com/yyx990803/vue/releases/tag/0.11.0) is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.\n\n<!-- more -->\n\nThe 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the [0.11 Change List](https://github.com/yyx990803/vue/blob/master/changes.md) before upgrading. Aside from the API changes, 0.11 also ships with better [code quality](https://codeclimate.com/github/yyx990803/vue) and [test coverage](https://coveralls.io/r/yyx990803/vue), and is considerably more robust in almost every aspect.\n\nThis documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at [legacy.vuejs.org](http://legacy.vuejs.org).\n","source":"_posts/vue-011-release.md","raw":"---\ntitle: Vue.js 0.11 released!\ndate: 2014-11-09 09:23:40\n---\n\nAfter the long wait, [Vue.js 0.11 **Cowboy Bebop**](https://github.com/yyx990803/vue/releases/tag/0.11.0) is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.\n\n<!-- more -->\n\nThe 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the [0.11 Change List](https://github.com/yyx990803/vue/blob/master/changes.md) before upgrading. Aside from the API changes, 0.11 also ships with better [code quality](https://codeclimate.com/github/yyx990803/vue) and [test coverage](https://coveralls.io/r/yyx990803/vue), and is considerably more robust in almost every aspect.\n\nThis documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at [legacy.vuejs.org](http://legacy.vuejs.org).\n","slug":"vue-011-release","published":1,"updated":"2020-09-25T23:55:41.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gws000bc2v5nz17kgtp","content":"<p>After the long wait, <a href=\"https://github.com/yyx990803/vue/releases/tag/0.11.0\" target=\"_blank\" rel=\"noopener\">Vue.js 0.11 <strong>Cowboy Bebop</strong></a> is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.</p>\n<a id=\"more\"></a>\n<p>The 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\" target=\"_blank\" rel=\"noopener\">0.11 Change List</a> before upgrading. Aside from the API changes, 0.11 also ships with better <a href=\"https://codeclimate.com/github/yyx990803/vue\" target=\"_blank\" rel=\"noopener\">code quality</a> and <a href=\"https://coveralls.io/r/yyx990803/vue\" target=\"_blank\" rel=\"noopener\">test coverage</a>, and is considerably more robust in almost every aspect.</p>\n<p>This documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at <a href=\"http://legacy.vuejs.org\" target=\"_blank\" rel=\"noopener\">legacy.vuejs.org</a>.</p>\n","site":{"data":{}},"excerpt":"<p>After the long wait, <a href=\"https://github.com/yyx990803/vue/releases/tag/0.11.0\" target=\"_blank\" rel=\"noopener\">Vue.js 0.11 <strong>Cowboy Bebop</strong></a> is finally here! Thanks to everyone who tried out the release candidate versions and provided feedback / bug reports along the way.</p>","more":"<p>The 0.11 release introduced many new features and also a fair number of breaking changes, so please carefully read through the <a href=\"https://github.com/yyx990803/vue/blob/master/changes.md\" target=\"_blank\" rel=\"noopener\">0.11 Change List</a> before upgrading. Aside from the API changes, 0.11 also ships with better <a href=\"https://codeclimate.com/github/yyx990803/vue\" target=\"_blank\" rel=\"noopener\">code quality</a> and <a href=\"https://coveralls.io/r/yyx990803/vue\" target=\"_blank\" rel=\"noopener\">test coverage</a>, and is considerably more robust in almost every aspect.</p>\n<p>This documentation site has been fully upgraded to match the new 0.11 API. For the now legacy 0.10.6 version, you can still find documentations for it at <a href=\"http://legacy.vuejs.org\" target=\"_blank\" rel=\"noopener\">legacy.vuejs.org</a>.</p>"},{"title":"Announcing vue-cli","date":"2015-12-28T04:00:00.000Z","_content":"\nRecently there has been a lot of [discussion around the tooling hurdle](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6) when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a `<script>` tag, so we've got that part covered. However, that's not how you'd build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing [vue-cli](https://github.com/vuejs/vue-cli), a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.\n\n<!-- more -->\n\n### Just The Scaffolding\n\nThe usage looks like this:\n\n``` bash\nnpm install -g vue-cli\nvue init webpack my-project\n# answer prompts\ncd my-project\nnpm install\nnpm run dev # tada!\n```\n\nAll the CLI does is pulling down templates from the [vuejs-templates](https://github.com/vuejs-templates) organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.\n\n### Official Templates\n\nThe purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.\n\nAll official project templates are repos in the [vuejs-templates organization](https://github.com/vuejs-templates). When a new template is added to the organization, you will be able to run `vue init <template-name> <project-name>` to use that template. You can also run `vue list` to see all available official templates.\n\nCurrent available templates include:\n\n- [browserify](https://github.com/vuejs-templates/browserify) - A full-featured Browserify + vueify setup with hot-reload, linting & unit testing.\n\n- [browserify-simple](https://github.com/vuejs-templates/browserify-simple) - A simple Browserify + vueify setup for quick prototyping.\n\n- [webpack](https://github.com/vuejs-templates/webpack) - A full-featured Webpack + vue-loader setup with hot reload, linting, testing & css extraction.\n\n- [webpack-simple](https://github.com/vuejs-templates/webpack-simple) - A simple Webpack + vue-loader setup for quick prototyping.\n\n### Bring Your Own Setup\n\nIf you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via `vue-cli` too, because `vue-cli` can work directly on GitHub repos:\n\n``` bash\nvue init username/repo my-project\n```\n\n### Vue Components Everywhere\n\nThere are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support `*.vue` single file components. This means any third party Vue components written as valid `*.vue` files can be shared among projects using these setups, and simply be distributed over NPM - let's create more reusable components!\n","source":"_posts/vue-cli.md","raw":"---\ntitle: Announcing vue-cli\ndate: 2015-12-28 00:00:00\n---\n\nRecently there has been a lot of [discussion around the tooling hurdle](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6) when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a `<script>` tag, so we've got that part covered. However, that's not how you'd build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing [vue-cli](https://github.com/vuejs/vue-cli), a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.\n\n<!-- more -->\n\n### Just The Scaffolding\n\nThe usage looks like this:\n\n``` bash\nnpm install -g vue-cli\nvue init webpack my-project\n# answer prompts\ncd my-project\nnpm install\nnpm run dev # tada!\n```\n\nAll the CLI does is pulling down templates from the [vuejs-templates](https://github.com/vuejs-templates) organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.\n\n### Official Templates\n\nThe purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.\n\nAll official project templates are repos in the [vuejs-templates organization](https://github.com/vuejs-templates). When a new template is added to the organization, you will be able to run `vue init <template-name> <project-name>` to use that template. You can also run `vue list` to see all available official templates.\n\nCurrent available templates include:\n\n- [browserify](https://github.com/vuejs-templates/browserify) - A full-featured Browserify + vueify setup with hot-reload, linting & unit testing.\n\n- [browserify-simple](https://github.com/vuejs-templates/browserify-simple) - A simple Browserify + vueify setup for quick prototyping.\n\n- [webpack](https://github.com/vuejs-templates/webpack) - A full-featured Webpack + vue-loader setup with hot reload, linting, testing & css extraction.\n\n- [webpack-simple](https://github.com/vuejs-templates/webpack-simple) - A simple Webpack + vue-loader setup for quick prototyping.\n\n### Bring Your Own Setup\n\nIf you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via `vue-cli` too, because `vue-cli` can work directly on GitHub repos:\n\n``` bash\nvue init username/repo my-project\n```\n\n### Vue Components Everywhere\n\nThere are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support `*.vue` single file components. This means any third party Vue components written as valid `*.vue` files can be shared among projects using these setups, and simply be distributed over NPM - let's create more reusable components!\n","slug":"vue-cli","published":1,"updated":"2020-09-25T23:55:41.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwt000cc2v5n3ekq56y","content":"<p>Recently there has been a lot of <a href=\"https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6\" target=\"_blank\" rel=\"noopener\">discussion around the tooling hurdle</a> when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a <code>&lt;script&gt;</code> tag, so we’ve got that part covered. However, that’s not how you’d build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">vue-cli</a>, a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.</p>\n<a id=\"more\"></a>\n<h3 id=\"Just-The-Scaffolding\"><a href=\"#Just-The-Scaffolding\" class=\"headerlink\" title=\"Just The Scaffolding\"></a>Just The Scaffolding</h3><p>The usage looks like this:</p>\n<pre><code class=\"hljs bash\">npm install -g vue-cli\nvue init webpack my-project\n<span class=\"hljs-comment\"># answer prompts</span>\n<span class=\"hljs-built_in\">cd</span> my-project\nnpm install\nnpm run dev <span class=\"hljs-comment\"># tada!</span></code></pre>\n<p>All the CLI does is pulling down templates from the <a href=\"https://github.com/vuejs-templates\" target=\"_blank\" rel=\"noopener\">vuejs-templates</a> organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.</p>\n<h3 id=\"Official-Templates\"><a href=\"#Official-Templates\" class=\"headerlink\" title=\"Official Templates\"></a>Official Templates</h3><p>The purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.</p>\n<p>All official project templates are repos in the <a href=\"https://github.com/vuejs-templates\" target=\"_blank\" rel=\"noopener\">vuejs-templates organization</a>. When a new template is added to the organization, you will be able to run <code>vue init &lt;template-name&gt; &lt;project-name&gt;</code> to use that template. You can also run <code>vue list</code> to see all available official templates.</p>\n<p>Current available templates include:</p>\n<ul>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify\" target=\"_blank\" rel=\"noopener\">browserify</a> - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify-simple\" target=\"_blank\" rel=\"noopener\">browserify-simple</a> - A simple Browserify + vueify setup for quick prototyping.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">webpack</a> - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"noopener\">webpack-simple</a> - A simple Webpack + vue-loader setup for quick prototyping.</p>\n</li>\n</ul>\n<h3 id=\"Bring-Your-Own-Setup\"><a href=\"#Bring-Your-Own-Setup\" class=\"headerlink\" title=\"Bring Your Own Setup\"></a>Bring Your Own Setup</h3><p>If you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via <code>vue-cli</code> too, because <code>vue-cli</code> can work directly on GitHub repos:</p>\n<pre><code class=\"hljs bash\">vue init username/repo my-project</code></pre>\n<h3 id=\"Vue-Components-Everywhere\"><a href=\"#Vue-Components-Everywhere\" class=\"headerlink\" title=\"Vue Components Everywhere\"></a>Vue Components Everywhere</h3><p>There are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support <code>*.vue</code> single file components. This means any third party Vue components written as valid <code>*.vue</code> files can be shared among projects using these setups, and simply be distributed over NPM - let’s create more reusable components!</p>\n","site":{"data":{}},"excerpt":"<p>Recently there has been a lot of <a href=\"https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.chg95e5p6\" target=\"_blank\" rel=\"noopener\">discussion around the tooling hurdle</a> when you start a React project. Luckily for Vue.js, all you need to do to start with a quick prototype is including it from a CDN via a <code>&lt;script&gt;</code> tag, so we’ve got that part covered. However, that’s not how you’d build a real world application. In real world applications we inevitably need a certain amount of tooling to give us modularization, transpilers, pre-processors, hot-reload, linting and testing. These tools are necessary for the long-term maintainability and productivity of large projects, but the initial setup can be a big pain. This is why we are announcing <a href=\"https://github.com/vuejs/vue-cli\" target=\"_blank\" rel=\"noopener\">vue-cli</a>, a simple CLI tool to help you quickly scaffold Vue.js projects with opinionated, battery-included build setups.</p>","more":"<h3 id=\"Just-The-Scaffolding\"><a href=\"#Just-The-Scaffolding\" class=\"headerlink\" title=\"Just The Scaffolding\"></a>Just The Scaffolding</h3><p>The usage looks like this:</p>\n<pre><code class=\"hljs bash\">npm install -g vue-cli\nvue init webpack my-project\n<span class=\"hljs-comment\"># answer prompts</span>\n<span class=\"hljs-built_in\">cd</span> my-project\nnpm install\nnpm run dev <span class=\"hljs-comment\"># tada!</span></code></pre>\n<p>All the CLI does is pulling down templates from the <a href=\"https://github.com/vuejs-templates\" target=\"_blank\" rel=\"noopener\">vuejs-templates</a> organization on GitHub. Dependencies are handled via NPM, and build tasks are simply NPM scripts.</p>\n<h3 id=\"Official-Templates\"><a href=\"#Official-Templates\" class=\"headerlink\" title=\"Official Templates\"></a>Official Templates</h3><p>The purpose of official Vue project templates is providing opinionated, battery-included development tooling setups so that users can get started with actual app code as fast as possible. However, these templates are un-opinionated in terms of how you structure your app code and what libraries you use in addition to Vue.js.</p>\n<p>All official project templates are repos in the <a href=\"https://github.com/vuejs-templates\" target=\"_blank\" rel=\"noopener\">vuejs-templates organization</a>. When a new template is added to the organization, you will be able to run <code>vue init &lt;template-name&gt; &lt;project-name&gt;</code> to use that template. You can also run <code>vue list</code> to see all available official templates.</p>\n<p>Current available templates include:</p>\n<ul>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify\" target=\"_blank\" rel=\"noopener\">browserify</a> - A full-featured Browserify + vueify setup with hot-reload, linting &amp; unit testing.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/browserify-simple\" target=\"_blank\" rel=\"noopener\">browserify-simple</a> - A simple Browserify + vueify setup for quick prototyping.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack\" target=\"_blank\" rel=\"noopener\">webpack</a> - A full-featured Webpack + vue-loader setup with hot reload, linting, testing &amp; css extraction.</p>\n</li>\n<li><p><a href=\"https://github.com/vuejs-templates/webpack-simple\" target=\"_blank\" rel=\"noopener\">webpack-simple</a> - A simple Webpack + vue-loader setup for quick prototyping.</p>\n</li>\n</ul>\n<h3 id=\"Bring-Your-Own-Setup\"><a href=\"#Bring-Your-Own-Setup\" class=\"headerlink\" title=\"Bring Your Own Setup\"></a>Bring Your Own Setup</h3><p>If you are not happy with the official templates, you can fork these templates, modify them to fit your specific needs (or even create your own from scratch), and use them via <code>vue-cli</code> too, because <code>vue-cli</code> can work directly on GitHub repos:</p>\n<pre><code class=\"hljs bash\">vue init username/repo my-project</code></pre>\n<h3 id=\"Vue-Components-Everywhere\"><a href=\"#Vue-Components-Everywhere\" class=\"headerlink\" title=\"Vue Components Everywhere\"></a>Vue Components Everywhere</h3><p>There are different templates for different purposes: simple setups for quick prototyping, and full-featured setups for ambitious applications. A common feature among these templates though, is that they all support <code>*.vue</code> single file components. This means any third party Vue components written as valid <code>*.vue</code> files can be shared among projects using these setups, and simply be distributed over NPM - let’s create more reusable components!</p>"},{"title":"Vue.js 0.10.6, and what's next","date":"2014-07-29T03:04:55.000Z","_content":"\n## 0.10.6\n\nVue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintenance version before the next major release.\n\n<!-- more -->\n\n- fix `v-style` error when value is falsy or a number. ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix the built-in `currency` filter error when value is a string ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix `Vue.require` for building with Component v1.0+ ( thanks to [@kewah](https://github.com/kewah) )\n- Allow template nodes to be passed as a template option ( thanks to [@jordangarcia](https://github.com/jordangarcia) )\n- `vm.$destroy()` now accepts an optional argument `noRemove`. When passed in as `true` it will leave the vm's DOM node intact after the vm is destroyed.\n\n## Vue-next\n\nSome of you might have noticed there is a [next](https://github.com/yyx990803/vue/tree/next) branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:\n\n- Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.\n- Improve general code quality (in particular, `compiler.js` as of now is a big pile of mess, and comments are not consistent across the codebase.)\n\nTake note that the `next` branch is still in **very** early stage. The internals will change a lot, and when it comes out it **will** break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in [`changes.md`](https://github.com/yyx990803/vue/blob/next/changes.md). The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I'd appreciate your feedback on any of the topics.\n\nShare your thoughts at [vuejs/Discussion](https://github.com/vuejs/Discussion/issues).\n","source":"_posts/vue-next.md","raw":"---\ntitle: Vue.js 0.10.6, and what's next\ndate: 2014-07-29 00:04:55\n---\n\n## 0.10.6\n\nVue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintenance version before the next major release.\n\n<!-- more -->\n\n- fix `v-style` error when value is falsy or a number. ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix the built-in `currency` filter error when value is a string ( thanks to [@dmfilipenko](https://github.com/dmfilipenko) )\n- fix `Vue.require` for building with Component v1.0+ ( thanks to [@kewah](https://github.com/kewah) )\n- Allow template nodes to be passed as a template option ( thanks to [@jordangarcia](https://github.com/jordangarcia) )\n- `vm.$destroy()` now accepts an optional argument `noRemove`. When passed in as `true` it will leave the vm's DOM node intact after the vm is destroyed.\n\n## Vue-next\n\nSome of you might have noticed there is a [next](https://github.com/yyx990803/vue/tree/next) branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:\n\n- Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.\n- Improve general code quality (in particular, `compiler.js` as of now is a big pile of mess, and comments are not consistent across the codebase.)\n\nTake note that the `next` branch is still in **very** early stage. The internals will change a lot, and when it comes out it **will** break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in [`changes.md`](https://github.com/yyx990803/vue/blob/next/changes.md). The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I'd appreciate your feedback on any of the topics.\n\nShare your thoughts at [vuejs/Discussion](https://github.com/vuejs/Discussion/issues).\n","slug":"vue-next","published":1,"updated":"2020-09-25T23:55:41.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwu000dc2v53h27p3s7","content":"<h2 id=\"0-10-6\"><a href=\"#0-10-6\" class=\"headerlink\" title=\"0.10.6\"></a>0.10.6</h2><p>Vue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintenance version before the next major release.</p>\n<a id=\"more\"></a>\n<ul>\n<li>fix <code>v-style</code> error when value is falsy or a number. ( thanks to <a href=\"https://github.com/dmfilipenko\" target=\"_blank\" rel=\"noopener\">@dmfilipenko</a> )</li>\n<li>fix the built-in <code>currency</code> filter error when value is a string ( thanks to <a href=\"https://github.com/dmfilipenko\" target=\"_blank\" rel=\"noopener\">@dmfilipenko</a> )</li>\n<li>fix <code>Vue.require</code> for building with Component v1.0+ ( thanks to <a href=\"https://github.com/kewah\" target=\"_blank\" rel=\"noopener\">@kewah</a> )</li>\n<li>Allow template nodes to be passed as a template option ( thanks to <a href=\"https://github.com/jordangarcia\" target=\"_blank\" rel=\"noopener\">@jordangarcia</a> )</li>\n<li><code>vm.$destroy()</code> now accepts an optional argument <code>noRemove</code>. When passed in as <code>true</code> it will leave the vm’s DOM node intact after the vm is destroyed.</li>\n</ul>\n<h2 id=\"Vue-next\"><a href=\"#Vue-next\" class=\"headerlink\" title=\"Vue-next\"></a>Vue-next</h2><p>Some of you might have noticed there is a <a href=\"https://github.com/yyx990803/vue/tree/next\" target=\"_blank\" rel=\"noopener\">next</a> branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:</p>\n<ul>\n<li>Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.</li>\n<li>Improve general code quality (in particular, <code>compiler.js</code> as of now is a big pile of mess, and comments are not consistent across the codebase.)</li>\n</ul>\n<p>Take note that the <code>next</code> branch is still in <strong>very</strong> early stage. The internals will change a lot, and when it comes out it <strong>will</strong> break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in <a href=\"https://github.com/yyx990803/vue/blob/next/changes.md\" target=\"_blank\" rel=\"noopener\"><code>changes.md</code></a>. The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I’d appreciate your feedback on any of the topics.</p>\n<p>Share your thoughts at <a href=\"https://github.com/vuejs/Discussion/issues\" target=\"_blank\" rel=\"noopener\">vuejs/Discussion</a>.</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"0-10-6\"><a href=\"#0-10-6\" class=\"headerlink\" title=\"0.10.6\"></a>0.10.6</h2><p>Vue.js 0.10.6 has been released! This is another small bug-fix release and will be the last maintenance version before the next major release.</p>","more":"<ul>\n<li>fix <code>v-style</code> error when value is falsy or a number. ( thanks to <a href=\"https://github.com/dmfilipenko\" target=\"_blank\" rel=\"noopener\">@dmfilipenko</a> )</li>\n<li>fix the built-in <code>currency</code> filter error when value is a string ( thanks to <a href=\"https://github.com/dmfilipenko\" target=\"_blank\" rel=\"noopener\">@dmfilipenko</a> )</li>\n<li>fix <code>Vue.require</code> for building with Component v1.0+ ( thanks to <a href=\"https://github.com/kewah\" target=\"_blank\" rel=\"noopener\">@kewah</a> )</li>\n<li>Allow template nodes to be passed as a template option ( thanks to <a href=\"https://github.com/jordangarcia\" target=\"_blank\" rel=\"noopener\">@jordangarcia</a> )</li>\n<li><code>vm.$destroy()</code> now accepts an optional argument <code>noRemove</code>. When passed in as <code>true</code> it will leave the vm’s DOM node intact after the vm is destroyed.</li>\n</ul>\n<h2 id=\"Vue-next\"><a href=\"#Vue-next\" class=\"headerlink\" title=\"Vue-next\"></a>Vue-next</h2><p>Some of you might have noticed there is a <a href=\"https://github.com/yyx990803/vue/tree/next\" target=\"_blank\" rel=\"noopener\">next</a> branch in the repo. And yes, I am re-writing Vue.js from scratch. There are two main reasons:</p>\n<ul>\n<li>Fix some issues that are caused by design flaws in the current version. Because these changes affect the design of some core modules, it is actually easier to rewrite than to apply on the current codebase.</li>\n<li>Improve general code quality (in particular, <code>compiler.js</code> as of now is a big pile of mess, and comments are not consistent across the codebase.)</li>\n</ul>\n<p>Take note that the <code>next</code> branch is still in <strong>very</strong> early stage. The internals will change a lot, and when it comes out it <strong>will</strong> break current applications. Despite that I will try to keep the API changes to a minimum. Major differences with current 0.10 branch are documented in <a href=\"https://github.com/yyx990803/vue/blob/next/changes.md\" target=\"_blank\" rel=\"noopener\"><code>changes.md</code></a>. The list is obviously incomplete and subject to change, some of them are simply ideas, but it at least gives you a taste of what to expect, and I’d appreciate your feedback on any of the topics.</p>\n<p>Share your thoughts at <a href=\"https://github.com/vuejs/Discussion/issues\" target=\"_blank\" rel=\"noopener\">vuejs/Discussion</a>.</p>"},{"title":"Why Vue.js doesn't support templateURL","date":"2015-10-28T13:56:00.000Z","_content":"\nA very common question from new Vue users, especially those who used Angular before, is \"can I have `templateURL`?\". I have answered this so many times and I figure it's better to write something about it.\n\n<!-- more -->\n\nIn Angular, `templateURL` or `ng-include` allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let's rethink what problem it solves.\n\nFirst, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it's in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there's no point in splitting them further apart.\n\nSecond, because `templateURL` loads the template via Ajax at runtime, you don't need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app's initial load performance. Now imagine you use `templateURL` for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don't know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app's initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in `$templateCache` - but that shows us a build step is, in fact, inevitable for any serious frontend development.\n\nSo, without `templateURL`, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with `<script type=\"x/template\">` also feels like a hack. Well, maybe it's time to up the game a bit and use a proper module bundler like [Webpack](http://webpack.github.io/) or [Browserify](http://browserify.org/). It might seem daunting if you've never dealt with them before, but trust me it's worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your [Vue components in a single file](http://vuejs.org/guide/single-file-components.html), with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.\n\nFinally, Vue does allow you to [lazy load your components](http://vuejs.org/guide/components.html#Async-Components), and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.\n\nThink in components, not templates.\n","source":"_posts/why-no-template-url.md","raw":"---\ntitle: \"Why Vue.js doesn't support templateURL\"\ndate: 2015-10-28 10:56:00\n---\n\nA very common question from new Vue users, especially those who used Angular before, is \"can I have `templateURL`?\". I have answered this so many times and I figure it's better to write something about it.\n\n<!-- more -->\n\nIn Angular, `templateURL` or `ng-include` allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let's rethink what problem it solves.\n\nFirst, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it's in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there's no point in splitting them further apart.\n\nSecond, because `templateURL` loads the template via Ajax at runtime, you don't need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app's initial load performance. Now imagine you use `templateURL` for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don't know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app's initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in `$templateCache` - but that shows us a build step is, in fact, inevitable for any serious frontend development.\n\nSo, without `templateURL`, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with `<script type=\"x/template\">` also feels like a hack. Well, maybe it's time to up the game a bit and use a proper module bundler like [Webpack](http://webpack.github.io/) or [Browserify](http://browserify.org/). It might seem daunting if you've never dealt with them before, but trust me it's worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your [Vue components in a single file](http://vuejs.org/guide/single-file-components.html), with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.\n\nFinally, Vue does allow you to [lazy load your components](http://vuejs.org/guide/components.html#Async-Components), and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.\n\nThink in components, not templates.\n","slug":"why-no-template-url","published":1,"updated":"2020-09-25T23:55:41.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwv000ec2v5rzmbipj9","content":"<p>A very common question from new Vue users, especially those who used Angular before, is “can I have <code>templateURL</code>?”. I have answered this so many times and I figure it’s better to write something about it.</p>\n<a id=\"more\"></a>\n<p>In Angular, <code>templateURL</code> or <code>ng-include</code> allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let’s rethink what problem it solves.</p>\n<p>First, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it’s in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there’s no point in splitting them further apart.</p>\n<p>Second, because <code>templateURL</code> loads the template via Ajax at runtime, you don’t need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app’s initial load performance. Now imagine you use <code>templateURL</code> for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don’t know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app’s initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in <code>$templateCache</code> - but that shows us a build step is, in fact, inevitable for any serious frontend development.</p>\n<p>So, without <code>templateURL</code>, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with <code>&lt;script type=&quot;x/template&quot;&gt;</code> also feels like a hack. Well, maybe it’s time to up the game a bit and use a proper module bundler like <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"noopener\">Webpack</a> or <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>. It might seem daunting if you’ve never dealt with them before, but trust me it’s worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your <a href=\"http://vuejs.org/guide/single-file-components.html\">Vue components in a single file</a>, with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.</p>\n<p>Finally, Vue does allow you to <a href=\"http://vuejs.org/guide/components.html#Async-Components\">lazy load your components</a>, and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.</p>\n<p>Think in components, not templates.</p>\n","site":{"data":{}},"excerpt":"<p>A very common question from new Vue users, especially those who used Angular before, is “can I have <code>templateURL</code>?”. I have answered this so many times and I figure it’s better to write something about it.</p>","more":"<p>In Angular, <code>templateURL</code> or <code>ng-include</code> allows the user to dynamically load a remote template file at runtime. This seems pretty convenient as a built-in feature, but let’s rethink what problem it solves.</p>\n<p>First, it allows us to write our template in a separate HTML file. This gives us proper syntax highlighting in editors, which is probably why many prefer to do so. But is splitting your JavaScript code and the template really the best way? For a Vue.js component, its template and its JavaScript is tightly coupled by nature - it’s in fact much simpler if things are just in the same file. The context switching of jumping back and forth between two files actually makes the development experience much worse. Conceptually, components are the basic building block of a Vue.js app, not templates. Every Vue.js template is coupled to an accompanying JavaScript context - there’s no point in splitting them further apart.</p>\n<p>Second, because <code>templateURL</code> loads the template via Ajax at runtime, you don’t need a build step in order to split up your files. This is convenient during development, but comes at a serious cost when you want to deploy it to production. Before HTTP/2 is universally supported, the number of HTTP requests is still probably the most critical factor in your app’s initial load performance. Now imagine you use <code>templateURL</code> for every component in your app - the browser needs to perform dozens of HTTP requests before even being able to display anything! In case you don’t know, most browsers limit the number of parallel requests it can perform to a single server. When you exceed that limit, your app’s initial rendering will suffer for every extra round trip the browser has to wait for. Sure, there are build tools that can help you pre-register all those templates in <code>$templateCache</code> - but that shows us a build step is, in fact, inevitable for any serious frontend development.</p>\n<p>So, without <code>templateURL</code>, how do we deal with the development experience problem? Writing templates as inline JavaScript strings is terrible, faking templates with <code>&lt;script type=&quot;x/template&quot;&gt;</code> also feels like a hack. Well, maybe it’s time to up the game a bit and use a proper module bundler like <a href=\"http://webpack.github.io/\" target=\"_blank\" rel=\"noopener\">Webpack</a> or <a href=\"http://browserify.org/\" target=\"_blank\" rel=\"noopener\">Browserify</a>. It might seem daunting if you’ve never dealt with them before, but trust me it’s worth it to take the leap. Proper modularization is a necessity if you want to build anything large and maintainable. More importantly, you get to write your <a href=\"http://vuejs.org/guide/single-file-components.html\">Vue components in a single file</a>, with proper syntax highlighting and the extra benefits of custom pre-processors, hot-reloading, ES2015 by default, autoprefixing and scoped CSS, which makes the development experience 10 times better.</p>\n<p>Finally, Vue does allow you to <a href=\"http://vuejs.org/guide/components.html#Async-Components\">lazy load your components</a>, and with Webpack it is trivially easy. Although this is only a concern when your initial bundle is so large that you are better off splitting it apart.</p>\n<p>Think in components, not templates.</p>"},{"title":"Vue.js 0.10 is here!","date":"2014-03-22T22:00:13.000Z","type":"{{type}}","yield":"{{>yield}}","_content":"\nVue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new `v-view` directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js [even faster](http://vuejs.org/perf/).\n\n<!-- more -->\n\nSee the [Installation](/guide/installation.html) page for the latest builds.\n\n### New\n\n- Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with `v-component=\"{{type}}\"`. [Doc](/guide/directives.html#Literal_Directives).\n- Attributes listed in the `paramAttributes` option now accept mustache interpolations too. They will also only be evaluated once.\n- `v-repeat` now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. [Doc](/guide/list.html#Using_an_Identifier).\n- Added `v-view` directive which binds to a string value and dynamically instantiate different components using that string as the component ID. [Doc](/api/directives.html#v-view).\n- Added `filterBy` and `orderBy` filters for `v-repeat`. [Doc](/api/filters.html#filterBy).\n- Custom filters that access properties on its `this` context will be considered **computed filters**. [Doc](/guide/custom-filter.html#Filter_Context).\n- You can now access the event in `v-on` handler expressions as `$event`. Example: `<a v-on=\"click:handle('hello', $event)\">Hello</a>`\n- Interpolation delimiters can now be customized via the `delimiters` global config option. Example: `Vue.config({ delimiters: [\"[\", \"]\"] })` will change the matched interpolation tags to `[[ ]]` for text bindings and `[[[ ]]]` for html bindings.\n\n### Changed\n\n- `{{yield}}` syntax has been deprecated. A Web Components spec compatible content insertion mechanism using `<content>` elements has been introduced. [Doc](/guide/components.html#Content_Insertion).\n- To use a component as a custom element, the component ID must now contain a hyphen (`-`). This is consistent with the current custom element spec draft.\n- `v-repeat` Arrays' augmented methods have been renamed from `set` to `$set(index, value)` and `remove` to `$remove(index | value)`. The prefix better differentiates them from native methods. The `replace` method has been removed.\n- When iterating over an Object with `v-repeat`, the object no longer gets a `$repeater` array. Instead, the object is now augmented with two methods: `$add(key, value)` and `$delete(key)`, which will trigger corresponding view updates.\n- `v-if` now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with `v-repeat`. Use `v-show` or the new built-in array filters instead.\n- `v-with` can no longer be used alone. It now must be used with either `v-component` or `v-view`. `v-component` can also be used as an empty directive just to create a child VM using the default `Vue` constructor.\n- Production build now strips all warnings and debug logs. To leverage `debug: true`, use the development version. The development version now has more detailed warning messages.\n\n### Fixed\n\n- `event.stopPropagation()` and `event.preventDefault()` inside `v-on` handlers now work as expected.\n- `parent` option now works properly when used in `Vue.extend`\n- Mustache bindings inside `<textarea>` are now properly interpolated before being set as value.\n\n### Internal\n\n- `v-component`, `v-with` and `v-if` have been re-written for a cleaner compile flow.\n- `v-repeat` has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.\n- `template` option now directly clones native `<template>`'s content when available.\n- Overall performance improvements for both initialization and rendering.\n","source":"_posts/vuejs-010-release.md","raw":"---\ntitle: Vue.js 0.10 is here!\ndate: 2014-03-22 19:00:13\ntype: '{{type}}'\nyield: '{{>yield}}'\n---\n\nVue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new `v-view` directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js [even faster](http://vuejs.org/perf/).\n\n<!-- more -->\n\nSee the [Installation](/guide/installation.html) page for the latest builds.\n\n### New\n\n- Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with `v-component=\"{{type}}\"`. [Doc](/guide/directives.html#Literal_Directives).\n- Attributes listed in the `paramAttributes` option now accept mustache interpolations too. They will also only be evaluated once.\n- `v-repeat` now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. [Doc](/guide/list.html#Using_an_Identifier).\n- Added `v-view` directive which binds to a string value and dynamically instantiate different components using that string as the component ID. [Doc](/api/directives.html#v-view).\n- Added `filterBy` and `orderBy` filters for `v-repeat`. [Doc](/api/filters.html#filterBy).\n- Custom filters that access properties on its `this` context will be considered **computed filters**. [Doc](/guide/custom-filter.html#Filter_Context).\n- You can now access the event in `v-on` handler expressions as `$event`. Example: `<a v-on=\"click:handle('hello', $event)\">Hello</a>`\n- Interpolation delimiters can now be customized via the `delimiters` global config option. Example: `Vue.config({ delimiters: [\"[\", \"]\"] })` will change the matched interpolation tags to `[[ ]]` for text bindings and `[[[ ]]]` for html bindings.\n\n### Changed\n\n- `{{yield}}` syntax has been deprecated. A Web Components spec compatible content insertion mechanism using `<content>` elements has been introduced. [Doc](/guide/components.html#Content_Insertion).\n- To use a component as a custom element, the component ID must now contain a hyphen (`-`). This is consistent with the current custom element spec draft.\n- `v-repeat` Arrays' augmented methods have been renamed from `set` to `$set(index, value)` and `remove` to `$remove(index | value)`. The prefix better differentiates them from native methods. The `replace` method has been removed.\n- When iterating over an Object with `v-repeat`, the object no longer gets a `$repeater` array. Instead, the object is now augmented with two methods: `$add(key, value)` and `$delete(key)`, which will trigger corresponding view updates.\n- `v-if` now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with `v-repeat`. Use `v-show` or the new built-in array filters instead.\n- `v-with` can no longer be used alone. It now must be used with either `v-component` or `v-view`. `v-component` can also be used as an empty directive just to create a child VM using the default `Vue` constructor.\n- Production build now strips all warnings and debug logs. To leverage `debug: true`, use the development version. The development version now has more detailed warning messages.\n\n### Fixed\n\n- `event.stopPropagation()` and `event.preventDefault()` inside `v-on` handlers now work as expected.\n- `parent` option now works properly when used in `Vue.extend`\n- Mustache bindings inside `<textarea>` are now properly interpolated before being set as value.\n\n### Internal\n\n- `v-component`, `v-with` and `v-if` have been re-written for a cleaner compile flow.\n- `v-repeat` has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.\n- `template` option now directly clones native `<template>`'s content when available.\n- Overall performance improvements for both initialization and rendering.\n","slug":"vuejs-010-release","published":1,"updated":"2020-09-25T23:55:41.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckfl66gwv000fc2v5129d0867","content":"<p>Vue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new <code>v-view</code> directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js <a href=\"http://vuejs.org/perf/\">even faster</a>.</p>\n<a id=\"more\"></a>\n<p>See the <a href=\"/guide/installation.html\">Installation</a> page for the latest builds.</p>\n<h3 id=\"New\"><a href=\"#New\" class=\"headerlink\" title=\"New\"></a>New</h3><ul>\n<li>Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with <code>v-component=&quot;{{type}}&quot;</code>. <a href=\"/guide/directives.html#Literal_Directives\">Doc</a>.</li>\n<li>Attributes listed in the <code>paramAttributes</code> option now accept mustache interpolations too. They will also only be evaluated once.</li>\n<li><code>v-repeat</code> now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. <a href=\"/guide/list.html#Using_an_Identifier\">Doc</a>.</li>\n<li>Added <code>v-view</code> directive which binds to a string value and dynamically instantiate different components using that string as the component ID. <a href=\"/api/directives.html#v-view\">Doc</a>.</li>\n<li>Added <code>filterBy</code> and <code>orderBy</code> filters for <code>v-repeat</code>. <a href=\"/api/filters.html#filterBy\">Doc</a>.</li>\n<li>Custom filters that access properties on its <code>this</code> context will be considered <strong>computed filters</strong>. <a href=\"/guide/custom-filter.html#Filter_Context\">Doc</a>.</li>\n<li>You can now access the event in <code>v-on</code> handler expressions as <code>$event</code>. Example: <code>&lt;a v-on=&quot;click:handle(&#39;hello&#39;, $event)&quot;&gt;Hello&lt;/a&gt;</code></li>\n<li>Interpolation delimiters can now be customized via the <code>delimiters</code> global config option. Example: <code>Vue.config({ delimiters: [&quot;[&quot;, &quot;]&quot;] })</code> will change the matched interpolation tags to <code>[[ ]]</code> for text bindings and <code>[[[ ]]]</code> for html bindings.</li>\n</ul>\n<h3 id=\"Changed\"><a href=\"#Changed\" class=\"headerlink\" title=\"Changed\"></a>Changed</h3><ul>\n<li><code>{{>yield}}</code> syntax has been deprecated. A Web Components spec compatible content insertion mechanism using <code>&lt;content&gt;</code> elements has been introduced. <a href=\"/guide/components.html#Content_Insertion\">Doc</a>.</li>\n<li>To use a component as a custom element, the component ID must now contain a hyphen (<code>-</code>). This is consistent with the current custom element spec draft.</li>\n<li><code>v-repeat</code> Arrays’ augmented methods have been renamed from <code>set</code> to <code>$set(index, value)</code> and <code>remove</code> to <code>$remove(index | value)</code>. The prefix better differentiates them from native methods. The <code>replace</code> method has been removed.</li>\n<li>When iterating over an Object with <code>v-repeat</code>, the object no longer gets a <code>$repeater</code> array. Instead, the object is now augmented with two methods: <code>$add(key, value)</code> and <code>$delete(key)</code>, which will trigger corresponding view updates.</li>\n<li><code>v-if</code> now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with <code>v-repeat</code>. Use <code>v-show</code> or the new built-in array filters instead.</li>\n<li><code>v-with</code> can no longer be used alone. It now must be used with either <code>v-component</code> or <code>v-view</code>. <code>v-component</code> can also be used as an empty directive just to create a child VM using the default <code>Vue</code> constructor.</li>\n<li>Production build now strips all warnings and debug logs. To leverage <code>debug: true</code>, use the development version. The development version now has more detailed warning messages.</li>\n</ul>\n<h3 id=\"Fixed\"><a href=\"#Fixed\" class=\"headerlink\" title=\"Fixed\"></a>Fixed</h3><ul>\n<li><code>event.stopPropagation()</code> and <code>event.preventDefault()</code> inside <code>v-on</code> handlers now work as expected.</li>\n<li><code>parent</code> option now works properly when used in <code>Vue.extend</code></li>\n<li>Mustache bindings inside <code>&lt;textarea&gt;</code> are now properly interpolated before being set as value.</li>\n</ul>\n<h3 id=\"Internal\"><a href=\"#Internal\" class=\"headerlink\" title=\"Internal\"></a>Internal</h3><ul>\n<li><code>v-component</code>, <code>v-with</code> and <code>v-if</code> have been re-written for a cleaner compile flow.</li>\n<li><code>v-repeat</code> has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.</li>\n<li><code>template</code> option now directly clones native <code>&lt;template&gt;</code>‘s content when available.</li>\n<li>Overall performance improvements for both initialization and rendering.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>Vue.js 0.10.0 (Blade Runner) has been released! This release comes with many useful additions based on the suggestions from the users, notably interpolation in literal directives, dynamic components with the new <code>v-view</code> directive, array filters, and the option to configure interpolation delimiters. Internally, the codebase has received many refactoring and improvements which makes Vue.js <a href=\"http://vuejs.org/perf/\">even faster</a>.</p>","more":"<p>See the <a href=\"/guide/installation.html\">Installation</a> page for the latest builds.</p>\n<h3 id=\"New\"><a href=\"#New\" class=\"headerlink\" title=\"New\"></a>New</h3><ul>\n<li>Literal directives can now contain interpolation tags. These tags will be evaluated only once at compile time. An example usage is conditionally decide which component to instantiate with <code>v-component=&quot;{{type}}&quot;</code>. <a href=\"/guide/directives.html#Literal_Directives\">Doc</a>.</li>\n<li>Attributes listed in the <code>paramAttributes</code> option now accept mustache interpolations too. They will also only be evaluated once.</li>\n<li><code>v-repeat</code> now accepts an argument which will be used as the identifier for the wrapped object. This allows more explicit property access in repeaters. <a href=\"/guide/list.html#Using_an_Identifier\">Doc</a>.</li>\n<li>Added <code>v-view</code> directive which binds to a string value and dynamically instantiate different components using that string as the component ID. <a href=\"/api/directives.html#v-view\">Doc</a>.</li>\n<li>Added <code>filterBy</code> and <code>orderBy</code> filters for <code>v-repeat</code>. <a href=\"/api/filters.html#filterBy\">Doc</a>.</li>\n<li>Custom filters that access properties on its <code>this</code> context will be considered <strong>computed filters</strong>. <a href=\"/guide/custom-filter.html#Filter_Context\">Doc</a>.</li>\n<li>You can now access the event in <code>v-on</code> handler expressions as <code>$event</code>. Example: <code>&lt;a v-on=&quot;click:handle(&#39;hello&#39;, $event)&quot;&gt;Hello&lt;/a&gt;</code></li>\n<li>Interpolation delimiters can now be customized via the <code>delimiters</code> global config option. Example: <code>Vue.config({ delimiters: [&quot;[&quot;, &quot;]&quot;] })</code> will change the matched interpolation tags to <code>[[ ]]</code> for text bindings and <code>[[[ ]]]</code> for html bindings.</li>\n</ul>\n<h3 id=\"Changed\"><a href=\"#Changed\" class=\"headerlink\" title=\"Changed\"></a>Changed</h3><ul>\n<li><code>{{>yield}}</code> syntax has been deprecated. A Web Components spec compatible content insertion mechanism using <code>&lt;content&gt;</code> elements has been introduced. <a href=\"/guide/components.html#Content_Insertion\">Doc</a>.</li>\n<li>To use a component as a custom element, the component ID must now contain a hyphen (<code>-</code>). This is consistent with the current custom element spec draft.</li>\n<li><code>v-repeat</code> Arrays’ augmented methods have been renamed from <code>set</code> to <code>$set(index, value)</code> and <code>remove</code> to <code>$remove(index | value)</code>. The prefix better differentiates them from native methods. The <code>replace</code> method has been removed.</li>\n<li>When iterating over an Object with <code>v-repeat</code>, the object no longer gets a <code>$repeater</code> array. Instead, the object is now augmented with two methods: <code>$add(key, value)</code> and <code>$delete(key)</code>, which will trigger corresponding view updates.</li>\n<li><code>v-if</code> now creates and destroys a child ViewModel instance when the binding value changes, instead of simply removing/inserting the DOM node. In addition, it can no longer be used with <code>v-repeat</code>. Use <code>v-show</code> or the new built-in array filters instead.</li>\n<li><code>v-with</code> can no longer be used alone. It now must be used with either <code>v-component</code> or <code>v-view</code>. <code>v-component</code> can also be used as an empty directive just to create a child VM using the default <code>Vue</code> constructor.</li>\n<li>Production build now strips all warnings and debug logs. To leverage <code>debug: true</code>, use the development version. The development version now has more detailed warning messages.</li>\n</ul>\n<h3 id=\"Fixed\"><a href=\"#Fixed\" class=\"headerlink\" title=\"Fixed\"></a>Fixed</h3><ul>\n<li><code>event.stopPropagation()</code> and <code>event.preventDefault()</code> inside <code>v-on</code> handlers now work as expected.</li>\n<li><code>parent</code> option now works properly when used in <code>Vue.extend</code></li>\n<li>Mustache bindings inside <code>&lt;textarea&gt;</code> are now properly interpolated before being set as value.</li>\n</ul>\n<h3 id=\"Internal\"><a href=\"#Internal\" class=\"headerlink\" title=\"Internal\"></a>Internal</h3><ul>\n<li><code>v-component</code>, <code>v-with</code> and <code>v-if</code> have been re-written for a cleaner compile flow.</li>\n<li><code>v-repeat</code> has been re-written to use refined diff algorithm which triggers minimum DOM manipulations when the array is set to a different instance containing overlapping elements. This makes it efficient to pipe an Array through filters.</li>\n<li><code>template</code> option now directly clones native <code>&lt;template&gt;</code>‘s content when available.</li>\n<li>Overall performance improvements for both initialization and rendering.</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}